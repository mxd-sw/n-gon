<!DOCTYPE html>
<html lang="en">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Browser-based side scrolling video game with the matter.js physics engine.">
    <meta name="author" content="Ross Landgreen">
    <meta property="og:description" content="Browser-based side scrolling video game with the matter.js physics engine.">
    <meta property="og:title" content="n-gon">
    <meta name="twitter:title" content="n-gon">
    <meta name="twitter:description" content="Browser-based side scrolling video game with the matter.js physics engine.">
    <!-- <meta http-equiv="refresh" content="0; url=https://landgreen.github.io/n-gon/"> -->
    <title>n-gon</title>
    <style>
        :root {
    --build-bg-color: #aeb6c2;
    --card-color: #fafcfd;
    --hover-card-color: #e5e5ed;
}

body {
    font-family: "Helvetica", "Arial", sans-serif;
    margin: 0;
    overflow: hidden;
    cursor: auto;
    background-color: #f00;
    /* filter: grayscale(1); */
    /* transition: background-color 0.2s ease-in-out; */
}

canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 0;
    user-select: none;
}

select {
    font-size: 0.8em;
    border: 1px #333 solid;
    border-radius: 6px;
}

select option {
    background-color: #fff;
}

input {
    padding: 0px 4px;
    font-size: 0.8em;
    border: 1px #333 solid;
    border-radius: 4px;
}

a {
    text-decoration: none;
    color: #08c;
}

em {
    opacity: 0.7;
}

#splash {
    user-select: none;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
    transition: opacity 5s ease-in;
}

*:focus {
    outline: none;
}

table {
    border-collapse: collapse;
    width: 360px;
}

tr {
    padding: 10px;
    text-align: left;
}

td {
    padding-left: 10px;
}

.key-input-train {
    padding: 0px 5px;
    border: 2px solid #444;
    color: #444;
    border-radius: 4px;
    background-color: #d0d0d0;
    text-align: center;
    font-weight: 400;
}

.key-input {
    padding: 3px 8px;
    border: 2px solid #333;
    background-color: #fff;
    text-align: center;
}

.pause-table {
    width: auto;
}

.key-input-pause {
    width: 15px;
    padding: 0px 2px;
    border: 2px solid #333;
    background-color: #fff;
    text-align: center;
}

.key-used {
    color: #777;
    font-size: 80%;
}

summary {
    font-size: 1.2em;
}

.SVG-button {
    border: 1.5px #333 solid;
    border-radius: 8px;
    background-color: #fff;
}

.SVG-button:hover {
    background-color: #eee;
}

.SVG-button-splash {
    border: 2px #333 solid;
    border-radius: 8px;
    background-color: #fff;
    transition: opacity 5s ease-in;
}

.SVG-button-splash:hover {
    background-color: #eee;
}

#start-button {
    position: absolute;
    bottom: 108px;
    right: 4px;
    z-index: 12;
    /* top-left | top-right | bottom-right | bottom-left */
    /* border-radius: 8px 8px 0 0; */
}

#training-button {
    position: absolute;
    bottom: 56px;
    right: 4px;
    z-index: 12;
    /* border-radius: 8px 0px 0 0; */
}

#experiment-button {
    position: absolute;
    bottom: 4px;
    right: 4px;
    z-index: 12;
    /* border-radius: 8px 0 8px 8px; */
}





#construct {
    display: none;
    position: absolute;
    bottom: 0%;
    right: 0%;
    z-index: 1;
    width: 250px;
    height: 200px;
    background-color: #fff;
    color: #000;
    font-size: 0.9em;
    white-space: pre;
    padding: 3px;
    border: 1px #333 solid;
}

#flex-center {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
}

.choose-grid {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 10px 1px;
    margin: 0px;
    border: 0px;
    z-index: 12;
    max-height: 99vh;
    font-size: 1.3em;
    display: grid;
    grid-template-columns: repeat(3, 384px);
    align-items: stretch;
    visibility: hidden;
    opacity: 0;
    transition: opacity 0.25s linear;
    overflow: auto;
    -ms-overflow-style: none;
    scrollbar-width: none;
}

.choose-grid-no-images {
    border-radius: 8px;
    border: 10px solid #444;
    gap: 10px;
    background-color: #444;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    margin: 0px;
    z-index: 12;
    max-height: 99vh;
    font-size: 1.3em;
    display: grid;
    grid-template-columns: 384px;
    align-items: stretch;
    visibility: hidden;
    opacity: 0;
    transition: opacity 0.25s linear;
    overflow: auto;
    -ms-overflow-style: none;
    scrollbar-width: none;
    /* box-shadow: 7px 7px 6px rgba(0, 0, 0, 0.13); */
}


#choose-grid::-webkit-scrollbar {
    display: none;
}

.choose-grid-module {
    line-height: 160%;
    background-color: var(--card-color);
    font-size: 0.75em;
}

.choose-grid-module:hover {
    background-color: var(--hover-card-color);
}

.choose-grid-module:hover .card-text {
    background-color: var(--hover-card-color);
}

.research-select {
    float: right;
    margin-right: 10px;
}

.pause-grid {
    padding: 2px;
    margin: 0px;
    display: none;
    grid-template-columns: 384px;
    grid-auto-rows: minmax(auto, auto);
    align-content: start;
    align-items: start;
    z-index: 2;
    font-size: 1.3em;
}

#pause-grid-right {
    position: absolute;
    top: -2px;
    right: -4px;
    overflow: auto;
    max-height: 100vh;
    -ms-overflow-style: none;
    scrollbar-width: none;
    padding: 1px;
}

#pause-grid-right::-webkit-scrollbar {
    display: none;
}

#pause-grid-left {
    position: absolute;
    top: -2px;
    left: -4px;
    overflow: auto;
    max-height: 100vh;
    -ms-overflow-style: none;
    scrollbar-width: none;
}

#pause-grid-left::-webkit-scrollbar {
    display: none;
}

.pause-grid-module {
    line-height: 160%;
    background-color: var(--card-color);
    font-size: 0.75em;
}

.sort {
    padding: 0.1em 0.3em;
    border: 1px solid #444;
    /* min-height: 88px; */
    line-height: 100%;
    background-color: var(--card-color);
}

.sort-button {
    border: 1px #333 solid;
    border-radius: 0.4em;
    background-color: #fff;
    font-size: 0.5em;
    /* padding: 0.3em; */

}

.sort-button:hover {
    background-color: #eee;
}

.pause-eject .card-text {
    animation: techColorCycle 1s linear infinite alternate;
}

#experiment-grid {
    display: flex;
    justify-content: center;
    padding: 0px;
    margin: 0px;
    border: 0px;
    background-color: var(--build-bg-color);
    display: none;
    grid-template-columns: repeat(auto-fit, 384px);
    grid-auto-flow: row;
    /* grid-auto-rows: minmax(auto, auto); */
    position: relative;
    /* bottom: 0px; */
    z-index: 10;
    font-size: 1.3em;
    -ms-overflow-style: none;
    /* IE and Edge */
    scrollbar-width: none;
    /* Firefox */
}

#experiment-grid::-webkit-scrollbar {
    display: none;
}

.experiment-grid-module {
    line-height: 160%;
    background-color: var(--card-color);
    font-size: 0.75em;
}

.experiment-grid-hide {
    display: none;
}

.grid-title {
    padding-bottom: 6px;
    padding-top: 4px;
    font-size: 1.4em;
    font-weight: 600;
}

.experiment-grid-module:hover:not(.build-tech-selected, .build-field-selected, .build-gun-selected) {
    background-color: var(--card-color);
}

.experiment-start-box {
    background-color: var(--card-color);
    position: sticky;
    top: 0;
    z-index: 10;
    align-self: start;
    width: 276px;
    line-height: 200%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border: 2px #333 solid;
    border-top: 0px;
    border-radius: 10px;
    border-top-left-radius: 0px;
    /* border-bottom-left-radius: 0px; */
    border-top-right-radius: 0px;
    padding: 0.2em 0px;
    /* height: 210px; */
    box-shadow: 8px 8px 6px rgba(0, 0, 50, 0.15);
    /* opacity: 0.1; */
}

.card-background {
    height: 340px;
    background-size: contain;
    background-repeat: no-repeat;
    display: flex;
    justify-content: flex-end;
    flex-direction: column;
}

.card-text {
    background-color: var(--card-color);
    padding: 0.5em 1em;
    border: 1px solid #444;
    margin-top: -1px;
    margin-right: -1px;
    font-size: 0.92em;
    min-height: 88px;
    /* border-radius: 5px; */
}

.cancel-card {
    text-align: center;
    font-size: 1.1em;
    font-weight: 100;
    justify-self: end;
    border: 1px solid #444;
    margin-top: -1px;
    margin-right: -1px;
    padding: 1px;
    line-height: 160%;
    background-color: var(--card-color);
}

.cancel-card:hover {
    background-color: var(--hover-card-color);
}

.research-card {
    font-size: 1.1em;
    font-weight: 100;
    border: 1px solid #444;
    margin-top: -1px;
    margin-right: -1px;
    padding: 1px 0px 1px 10px;
    line-height: 160%;
    background-color: var(--card-color);
}

.research-card:hover {
    background-color: var(--hover-card-color);
}

.research-cancel {
    display: flex;
    gap: 10px;
    line-height: 160%;
    /* background-color: var(--card-color); */
    font-size: 1em;
    position: sticky;
    top: 0px;
    z-index: 10;
}

.sticky {
    position: sticky;
    top: 0px;
    z-index: 10;
}

/* keeps 5 columns at 1440px */
@media (min-width: 1710px) and (max-width: 1950px) {

    .experiment-grid-module,
    .choose-grid-module,
    .pause-grid-module,
    .research-cancel {
        line-height: 143%;
        font-size: 0.68em;
    }

    .research-cancel {
        font-size: 0.9em;
    }

    #experiment-grid,
    .choose-grid,
    .pause-grid {
        grid-template-columns: repeat(auto-fit, 340px);
    }

    .card-background {
        height: 290px;
    }

    .card-text {
        min-height: 75px;
    }
}

/* (min-width: 30em) and (max-width: 80em) */
@media (max-width: 1709px) {

    .experiment-grid-module,
    .choose-grid-module,
    .pause-grid-module {
        line-height: 139%;
        font-size: 0.58em;
    }

    .research-cancel {
        font-size: 0.8em;
    }

    #experiment-grid,
    .choose-grid,
    .pause-grid {
        grid-template-columns: repeat(auto-fit, 285px);
    }

    .card-background {
        height: 240px;
    }

    .card-text {
        min-height: 64px;
    }
}

/* .card-text */
.choose-grid-no-images .card-text,
.choose-grid-no-images .research-card,
.choose-grid-no-images .cancel-card {
    border-radius: 5px;
}

.experiment-grid-module:hover .card-text {
    background-color: var(--hover-card-color);
}

.build-tech-selected .card-text {
    background-color: hsl(253, 100%, 84%);
}

.build-tech-selected.experiment-grid-module:hover .card-text {
    background-color: hsl(253, 100%, 81%);
}

.build-gun-selected .card-text {
    background-color: hsl(218, 100%, 81%);
}

.build-gun-selected.experiment-grid-module:hover .card-text {
    background-color: hsl(218, 100%, 76%);
}

.build-field-selected .card-text {
    background-color: hsl(193, 100%, 75%);
}

.build-field-selected.experiment-grid-module:hover .card-text {
    background-color: hsl(193, 100%, 68%);
}

.experiment-grid-disabled {
    /* background-color: var(--build-bg-color); */
    /* color: #000; */
    opacity: 0.35;
}

.experiment-grid-disabled[data-descr] {
    position: relative;
}

.experiment-grid-disabled[data-descr]:hover::after {
    content: '\a \00a0 \00a0 \00a0 REQUIRES:\a \00a0 \00a0 \00a0 ' attr(data-descr);
    white-space: pre-wrap;
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: var(--build-bg-color);
    z-index: 1;
    opacity: 1;
    transition: opacity 0.5s ease;
}

#info {
    position: absolute;
    bottom: 3px;
    left: 3px;
    z-index: 10;
    font-size: 1.5em;
    transition: opacity 5s ease-in;
    width: 100%;

    /* border: 1.5px #333 solid; */
    /* border-radius: 8px; */
    /* background-color: #fff; */
}

.details-div {
    padding: 10px;
    border-radius: 8px;
    border: 2px #333 solid;
    background-color: var(--card-color);
}


#dmg {
    position: absolute;
    z-index: 2;
    width: 100%;
    height: 100%;
    display: none;
    /* background-color also set in mass-energy tech */
    background-color: #f67;
    opacity: 0;
    transition: opacity 1s;
}

#damage-bar {
    position: absolute;
    /* top: 1px;
    left: 15px;
    height: 7px;
    width: 0px;
    transition: width 0.3s linear; */
    top: 16px;
    right: 4px;
    height: 0px;
    width: 7px;
    transition: height 0.25s linear;
    opacity: 1;
    z-index: 2;
    pointer-events: none;
    background-color: rgb(255, 55, 95);
    /* border-bottom: 1.5px solid #701; */
    /* border-right: 1.5px solid #701; */
    display: none;
}

#defense-bar {
    position: absolute;
    top: 8px;
    left: 15px;
    height: 7px;
    width: 0px;
    transition: width 0.25s linear;
    opacity: 1;
    z-index: 2;
    pointer-events: none;
    background-color: #fff;
    border-right: 1.5px solid #777;
    display: none;
}

#health {
    position: absolute;
    top: 15px;
    left: 15px;
    height: 20px;
    width: 0px;
    transition: width 1s ease-out;
    z-index: 2;
    pointer-events: none;
    background-color: rgb(9, 245, 166);
    border-right: 2px solid rgb(51, 162, 125);
    display: none;
}

#health-bg {
    position: absolute;
    top: 15px;
    left: 15px;
    height: 20px;
    width: 0px;
    transition: width 1s ease-out;
    background-color: #032;
    opacity: 0.1;
    z-index: 1;
    pointer-events: none;
    display: none;
}

/* background on title page */
#fade-out {
    position: absolute;
    z-index: 2;
    width: 100%;
    height: 100%;
    background-color: #e2e9ec;
    opacity: 1;
    transition: opacity 3s;
    pointer-events: none;
}

#guns {
    position: absolute;
    top: 82px;
    left: 15px;
    z-index: 2;
    font-size: 23px;
    color: #222;
    background-color: rgba(255, 255, 255, 0.2);
    line-height: 120%;
    user-select: none;
    pointer-events: none;
    padding: 0px 5px 0px 5px;
    border-radius: 5px;
}

#field {
    position: absolute;
    top: 45px;
    left: 15px;
    z-index: 2;
    font-size: 23px;
    color: #000;
    text-align: right;
    opacity: 0.7;
    background-color: rgba(190, 210, 245, 0.25);
    user-select: none;
    pointer-events: none;
    padding: 0px 5px 0px 5px;
    border-radius: 5px;
}

#right-HUD {
    position: absolute;
    top: 15px;
    right: 15px;
    z-index: 2;
    font-size: 20px;
    text-align: right;
    line-height: 120%;
    user-select: none;
    pointer-events: none;
    /*border: 2px solid rgba(0, 0, 0, 0.4);*/
    color: #222;
    padding: 0px 5px 0px 5px;
    border-radius: 5px;
    opacity: 0.35;
    background-color: rgba(255, 255, 255, 0.4);
}

.constraint-module {
    line-height: 160%;
    padding: 20px;
    border-radius: 5px;
    font-size: 1.2em;
    font-family: monospace;
    font-weight: 800;
    text-align: center;
    color: #624;
    background-color: rgba(255, 240, 250, 1);
}

#right-HUD-constraint {
    position: absolute;
    top: 12px;
    right: 15px;
    z-index: 2;
    font-size: 20px;
    text-align: right;
    line-height: 120%;
    user-select: none;
    pointer-events: none;
    padding: 5px 10px 5px 10px;
    border-radius: 8px;
    color: #624;
    opacity: 0.35;
    background-color: rgba(255, 215, 241, 0.4);
    /* color: rgb(141, 23, 88);
    opacity: 0.35;
    background-color: rgba(141, 23, 88, 0.1); */
    /* font-weight: 400; */
    transition: all 0.5s linear;
}

.constraint {
    color: rgb(141, 23, 88);
}

.metallic-sparkle {
    background: linear-gradient(90deg,
            #c38aa6,
            #e6c0d9,
            #dca4c6,
            #c38aa6,
            #e6c0d9,
            #dca4c6,
            #c38aa6);
    background-size: 200% 100%;
    background-clip: text;
    color: transparent;
    animation: shimmer 4s infinite linear;
}

@keyframes shimmer {
    0% {
        background-position: 0% 50%;
    }

    50% {
        background-position: 100% 50%;
    }

    100% {
        background-position: 0% 50%;
    }
}

#text-log {
    z-index: 2;
    position: absolute;
    bottom: 10px;
    left: 10px;
    padding: 10px;
    border-radius: 4px;
    line-height: 140%;
    font-size: 1.15em;
    color: #555;
    background-color: rgba(255, 255, 255, 0.5);
    pointer-events: none;
    user-select: none;
}

.color-text {
    color: #000;
}

.color-var {
    color: hsl(253, 100%, 58%);
}

.color-symbol {
    color: hsl(290, 100%, 40%);
}

.color-gun {
    color: hsl(218, 100%, 58%);
}

.highlight {
    border-radius: 6px;
    background-color: #ff0;
    padding: 3px;
}

.color-f {
    color: #0ad;
    letter-spacing: 1px;
}

.color-s {
    color: #04f;
    letter-spacing: 1px;
}

.color-d {
    color: #f03;
    letter-spacing: 1px;
}

.color-p {
    color: #067;
    letter-spacing: 1px;
}

.color-h {
    color: #0b7;
    letter-spacing: 1px;
}

.color-e {
    color: #d60;
    letter-spacing: 1px;
}

.color-m {
    color: hsl(253, 100%, 50%);
    letter-spacing: 1px;
}

.color-g {
    color: hsl(218, 80%, 40%);
    letter-spacing: 1px;
}

.color-ammo {
    color: #356;
}

.color-tier {
    color: #006aff;
}

.color-choice {
    display: inline-block;
}

.color-choice span {
    display: inline-block;
    animation: bounce 3s infinite;
    transform-origin: bottom;
    color: #555;
}

.color-choice span:nth-child(1) {
    animation-delay: 0s;
}

.color-choice span:nth-child(2) {
    animation-delay: 1s;
}

.color-choice span:nth-child(3) {
    animation-delay: 2s;
}

@keyframes bounce {
    0% {
        transform: translateY(0);
    }

    15% {
        transform: translateY(-2px);
        color: #aaa;
    }

    30% {
        transform: translateY(0);
    }

    100% {
        transform: translateY(0);
    }
}

.color-invulnerable {
    color: #fff;
    text-shadow: 0px 0px 7px #000;
}

.color-dark-matter {
    color: #246;
    text-shadow: 0px 0px 7px #246;
}

.color-tokamak {
    color: #5c3ab8;
    font-weight: 100;
    text-shadow: 0px -5px 9px rgb(255, 0, 204);
}



.color-dup {
    font-variant: small-caps;
    letter-spacing: 1px;
    text-shadow: 1.5px -1.5px hsla(243, 100%, 38%, 0.2);
}

.color-remove {
    text-decoration: line-through;
    /* letter-spacing: 2px; */
    border-radius: 3px;
    padding: 0px 3px;
    background-color: hsl(255, 40%, 71%);
    color: #fff;
}

.color-cloaked {
    letter-spacing: 2px;
    animation: cloak 6s linear infinite alternate;
    color: rgba(0, 0, 0, 0);
}

@keyframes cloak {
    0% {
        text-shadow: 0px 0px 0px #000;
        opacity: 1;
    }

    50% {
        text-shadow: 0px 0px 0px #000;
        opacity: 1;
    }

    100% {
        text-shadow: 0px 0px 15px #000;
        opacity: 0;
    }
}

.color-laser {
    color: #f02;
    font-weight: 100;
    letter-spacing: -0.8px;
}

.color-plasma {
    color: #c0e;
    letter-spacing: 1px;
    background-color: rgba(132, 0, 255, 0.06);
    padding: 2px;
    border-radius: 9px;
    letter-spacing: 1px;
}

.color-worm {
    color: #fff;
    text-shadow: 1px 0px 2px #234;
}

.color-print {
    color: #567;
    font-family: 'Courier New', Courier, monospace;
}

.color-defense {
    background-color: hsla(227, 9%, 71%, 0.279);
    padding: 2px;
    border-radius: 4px;
    letter-spacing: 1px;
    font-weight: 100;
}

.color-bot {
    font-variant: small-caps;
    background-color: rgba(75, 125, 150, 0.06);
    border: 0.1em solid #146;
    color: #146;
    padding: 0em 0.3em 0.08em 0.3em;
    font-weight: 400;
}

.no-box {
    border: none;
    background-color: transparent;
    padding: 0;
}

.color-block {
    background-color: rgba(0, 0, 0, 0.1);
    border: 0.1em solid #333;
    padding: 0.5px;
    font-weight: 100;
}

.color-cancel {
    background-color: var(--card-color);
    border: 0.15em #444 solid;
    padding: 0.2em;
    border-radius: 0.2em;
    font-weight: 800;
    font-size: 1em;
}

.color-junk {
    letter-spacing: 1px;
    font-family: Lucida Console, Courier, monospace;
}

.color-r {
    color: #f7b;
    letter-spacing: 1px;
}

.color-flop {
    text-decoration: underline;
    font-weight: 100;
    letter-spacing: -1px;
}

.color-alt {
    text-decoration: underline;
    font-weight: 100;
    letter-spacing: -1px;
}

.faded {
    opacity: 0.7;
    font-size: 90%;
}

.circle-grid {
    width: 1.32em;
    height: 1.32em;
    border-radius: 50%;
    display: inline-block;
    margin-bottom: -0.3em;
}

.circle-grid-instant {
    width: 1.1em;
    height: 1.1em;
    border-radius: 50%;
    border: 0.15em solid hsl(255, 100%, 71%);
    display: inline-block;
    margin-bottom: -0.35em;
}

.circle-grid-skin {
    width: 1.25em;
    height: 1.25em;
    border-radius: 50%;
    display: inline-block;
    background-color: #fff;
    opacity: 0.8;
    border: 0.08em solid #222;
    position: absolute;
    top: -0.05em;
    left: 0em;
}

.circle-grid-skin-eye {
    width: 0.18em;
    height: 0.18em;
    border-radius: 50%;
    display: inline-block;
    background-color: #fff;
    border: 0.08em solid #222;
    position: absolute;
    top: 0.45em;
    left: 0.9em;
}

.junk {
    background-color: hsl(254, 44%, 75%);
    border-radius: 25%;
}

.research-circle {
    width: 0.9em;
    height: 0.9em;
    border-radius: 50%;
    display: inline-block;
    background-color: #f7b;
    border: 0.065em #fff solid;
    opacity: 0.85;
    margin-bottom: -0.1em;
}

.ammo-circle {
    width: 0.75em;
    height: 0.75em;
    border-radius: 50%;
    display: inline-block;
    background-color: #467;
    border: 0.05em #fff solid;
    opacity: 0.95;
    margin-bottom: -1.5px;
}

.heal-circle {
    width: 0.95em;
    height: 0.95em;
    border-radius: 50%;
    display: inline-block;
    background-color: #0d9;
    border: 0.05em #fff solid;
    opacity: 0.85;
    margin-bottom: -2px;
}

.heal-circle-energy {
    width: 0.95em;
    height: 0.95em;
    border-radius: 50%;
    display: inline-block;
    background-color: #ff0;
    border: 0.05em #000 solid;
    opacity: 0.85;
    margin-bottom: -2px;
}

.coupling-circle {
    width: 0.7em;
    height: 0.7em;
    border-radius: 50%;
    display: inline-block;
    background-color: #0ae;
    border: 0.05em #fff solid;
    margin-bottom: -0.5px;
}

.boost-circle {
    width: 0.7em;
    height: 0.7em;
    border-radius: 50%;
    display: inline-block;
    background-color: #f03;
    border: 0.05em #fff solid;
    opacity: 0.9;
    margin-bottom: -0.5px;
}

@keyframes pulse {
    0% {
        border-radius: 0%;
    }

    100% {
        border-radius: 50%;
    }
}

.field {
    background-color: #0cf;
}

.tech {
    background-color: hsl(255, 100%, 71%);
}

.gun {
    background-color: rgb(0, 80, 218);
}

.heal {
    background-color: #0d9;
}

.research {
    background-color: #f7b;
}

.color-speed {
    display: inline-block;
    transform: skew(-27deg);
    /* font-weight: 400; */
    color: #038;
}

.color-randomize {
    display: inline-block;
    animation: randomize 4s linear infinite alternate;
    transform-origin: bottom;
    color: #555;
}

@keyframes randomize {

    0%,
    100% {
        font-family: Arial;
    }

    20% {
        font-family: Times New Roman;
    }

    40% {
        font-family: Verdana;
    }

    60% {
        font-family: Georgia;
    }

    80% {
        font-family: Courier New;
    }
}

.alt {
    animation: alt 8s linear infinite alternate;
    font-weight: 400;
    letter-spacing: 1px;
}

@keyframes alt {
    0% {
        text-shadow: 3px 0px 0px;
    }

    100% {
        text-shadow: -3px 0px 0px;
    }

}

.flicker {
    animation: flicker 4s linear infinite;
}

@keyframes flicker {
    0% {
        opacity: 1;
    }

    80% {
        opacity: 1;
    }

    90% {
        opacity: 0;
    }

    100% {
        opacity: 1;
    }
}

.color-coupling {
    text-shadow: 0px 0px 1.5px #0cf;
    letter-spacing: 1px;
    font-weight: 100;
}

.box {
    padding: 3px 8px 3px 8px;
    border: 2px solid #444;
    border-radius: 4px;
    background-color: rgba(255, 255, 255, 0.5);
}

.wrapper {
    display: grid;
    grid-template-columns: 360px 10px;
    align-self: center;
    justify-content: center;
}

.grid-box {
    align-self: center;
    justify-self: center;
}

.right {
    text-align: right;
}

.lore {
    animation: bgColor 3.5s linear infinite;
}

.lore-text {
    animation: textColor 3s linear infinite;
}

.entanglement {
    font-size: 1.1em;
    font-weight: 100;
    text-align: center;
    letter-spacing: 10px;
    border: none;
    background-color: var(--card-color);
}

.flipX {
    animation: 14s anim-flipX linear infinite;
}

@keyframes anim-flipX {
    0% {
        transform: rotateX(0.5turn);
    }

    50% {
        transform: rotateX(1turn);
    }

    100% {
        transform: rotateX(0.5turn);
    }
}

@keyframes fieldColorCycle {
    0% {
        background-color: rgb(255, 255, 255)
    }

    100% {
        background-color: rgb(0, 204, 255)
    }
}

@keyframes techColorCycle {
    0% {
        background-color: hsl(253, 100%, 100%)
    }

    100% {
        background-color: hsl(253, 100%, 90%)
    }
}

@keyframes bgColor {
    0% {
        background-color: rgb(63, 218, 216)
    }

    10% {
        background-color: rgb(47, 201, 226)
    }

    20% {
        background-color: rgb(28, 127, 238)
    }

    30% {
        background-color: rgb(95, 21, 242)
    }

    40% {
        background-color: rgb(186, 12, 248)
    }

    50% {
        background-color: rgb(251, 7, 217)
    }

    60% {
        background-color: rgba(255, 0, 0)
    }

    70% {
        background-color: rgb(255, 0, 0)
    }

    80% {
        background-color: rgb(255, 154, 0)
    }

    90% {
        background-color: rgb(208, 222, 33)
    }

    100% {
        background-color: rgb(79, 220, 74)
    }
}

@keyframes textColor {
    0% {
        color: rgb(63, 218, 216)
    }

    10% {
        color: rgb(47, 201, 226)
    }

    20% {
        color: rgb(28, 127, 238)
    }

    30% {
        color: rgb(95, 21, 242)
    }

    40% {
        color: rgb(186, 12, 248)
    }

    50% {
        color: rgb(251, 7, 217)
    }

    60% {
        color: rgba(255, 0, 0)
    }

    70% {
        color: rgb(255, 0, 0)
    }

    80% {
        color: rgb(255, 154, 0)
    }

    90% {
        color: rgb(208, 222, 33)
    }

    100% {
        color: rgb(79, 220, 74)
    }
}

.link {
    color: #000;
}

.link:hover {
    text-decoration: underline;
}

/* 
.fade-ins {
    animation: 1.5s linear 1s fadeins;
}

@keyframes fadeins {
    0% {
        opacity: 0;
    }

    100% {
        opacity: 1;
    }
} */
.blurry-text {
    color: transparent;
    text-shadow: 0 0 10px rgba(0, 0, 0, 0.6);
}

.unblur {
    color: transparent;
    text-shadow: 0 0 7px rgba(0, 0, 0, 0.5);
    animation: 2.5s ease 0.5s normal forwards 1 unblur;
}

@keyframes unblur {
    0% {
        color: transparent;
        text-shadow: 0 0 7px rgba(0, 0, 0, 0.5);
    }

    100% {
        /* font-weight: 800; */
        color: #000;
        text-shadow: 0 0 0px rgba(0, 0, 0, 0.5);
    }
}

.fade-in {
    opacity: 0;
    animation: 2s ease 1.5s normal forwards 1 fadein;
}

.fade-in-fast {
    opacity: 0;
    animation: 1.5s ease 1s normal forwards 1 fadein;
}

.fade-in-faster {
    opacity: 0;
    animation: 2s ease 0.5s normal forwards 1 fadein;
}

@keyframes fadein {
    0% {
        opacity: 0;
    }

    100% {
        opacity: 1;
    }
}

@keyframes dash {
    to {
        stroke-dashoffset: 0;
    }
}

.draw-lines {
    stroke-dasharray: 20;
    stroke-dashoffset: 20;
    animation: dash 2.4s ease-in forwards;
}

.draw-lines-dash {
    stroke-dasharray: 4;
    stroke-dashoffset: 4;
    animation: dash 2.4s ease-in forwards;
}

.draw-lines-o {
    stroke-dasharray: 11;
    stroke-dashoffset: 11;
    animation: dash 2.4s ease-in forwards;
}

.draw-lines-g {
    stroke-dasharray: 17;
    stroke-dashoffset: 17;
    animation: dash 2.4s ease-in forwards;
}

.draw-lines-box-1 {
    stroke-dasharray: 1000;
    stroke-dashoffset: 1000;
    animation: dash 5s ease-in forwards;
    animation-delay: 0s;
}

.draw-lines-box-2 {
    stroke-dasharray: 1000;
    stroke-dashoffset: 1000;
    animation: dash 2.6s ease-in forwards;
    animation-delay: 1s;
}

.draw-lines-box-3 {
    stroke-dasharray: 1000;
    stroke-dashoffset: 1000;
    animation: dash 1.15s ease-in forwards;
    animation-delay: 1.55s;
}

.draw-lines3 {
    stroke-dasharray: 3000;
    stroke-dashoffset: 3000;
    animation: dash 3.1s ease-in forwards;
}

.draw-lines4 {
    stroke-dasharray: 500;
    stroke-dashoffset: 500;
    animation: dash 3.5s ease-in forwards;
}



.grid-container {
    display: grid;
    grid-template-columns: 0fr 5fr 0fr;
    line-height: 150%;
    background-color: #fff;
    padding: 15px 0 14px 0;
    border-radius: 5px;
}

.far-right-column {
    display: grid;
    grid-template-rows: repeat(7, 1fr);
    font-size: 2rem;
    font-family: monospace;
    align-self: center;
    justify-self: center;
    width: 22px;
    /* padding: 0rem; */
}

.far-right-column>div {
    padding-top: 50px;
}

#difficulty-slider {
    margin-top: 2.3rem;
    /* height: 26.3rem; */
    height: 31.4rem;
    width: 2rem;
    writing-mode: vertical-lr;
    direction: ltr;
}

.left-column {
    grid-row: 1 / span 7
}

.right-column {
    display: grid;
    grid-template-rows: repeat(7, 1fr);
    /* to adjust the width of this column edit the "gridTemplateColumns" in the difficulty power up js code*/
}

.row {
    transition: opacity 0.5s ease-out;
    /* border: 2px #444 solid; */
    /* margin-top: -2px; */
    font-size: 1.2rem;
    padding: 10px;
}

.pause-difficulty-row {
    line-height: 130%;
    font-size: 1em;
    padding: 7px 0px 7px 0px;
    /* top | right | bottom | left */
    margin: -5px 0;
}

#constraint-1 {
    background-color: hsl(240, 18%, 95%);
    border-radius: 7px 7px 0 0;
}

#constraint-2 {
    background-color: hsl(240, 18%, 93%);
}

#constraint-3 {
    background-color: hsl(240, 18%, 89%);
}

#constraint-4 {
    background-color: hsl(240, 18%, 85%);
}

#constraint-5 {
    background-color: hsl(240, 18%, 81%);
}

#constraint-6 {
    background-color: hsl(240, 18%, 77%);
}

#constraint-7 {
    background-color: hsl(240, 18%, 73%);
    border-radius: 0 0 7px 7px;
}

#constraint-1:hover {
    background-color: hsl(240, 18%, 93%);
    border: 1px #444 solid;
    padding: 9px;
}

#constraint-2:hover {
    background-color: hsl(240, 18%, 91%);
    border: 1px #444 solid;
    padding: 9px;
}

#constraint-3:hover {
    background-color: hsl(240, 18%, 87%);
    border: 1px #444 solid;
    padding: 9px;
}

#constraint-4:hover {
    background-color: hsl(240, 18%, 83%);
    border: 1px #444 solid;
    padding: 9px;
}

#constraint-5:hover {
    background-color: hsl(240, 18%, 79%);
    border: 1px #444 solid;
    padding: 9px;
}

#constraint-6:hover {
    background-color: hsl(240, 18%, 75%);
    border: 1px #444 solid;
    padding: 9px;
}

#constraint-7:hover {
    background-color: hsl(240, 18%, 71%);
    border: 1px #444 solid;
    padding: 9px;
}

#choose-difficulty {
    text-align: center;
    font-size: 1.1em;
    padding: 5px;
    margin-top: 10px;
    color: #333;
    border-radius: 5px;
}

.pause-details {
    background-color: #e2e9ec;
    border: 1px solid #333;
    border-radius: 5px;
    padding: 7px;
    margin-bottom: 10px;
    /* box-shadow: 4px 4px 4px hsla(240, 0%, 17%, 0.14); */
}

.tooltip {}

.tooltip .tooltiptext {
    visibility: hidden;
    background-color: #fff;
    border-radius: 0.3em;
    padding: 0.2em 0.3em;
    border: solid #000 1px;

    position: relative;
    z-index: 1;
    bottom: 100%;
    left: 0%;
    margin-left: -50%;
}

.tooltip:hover .tooltiptext {
    visibility: visible;
}
    </style>
    <link rel='shortcut icon' href='favicon.ico' type='image/x-icon' />
</head>

<body>
    <div id='guns'></div>
    <div id='field'></div>
    <div id='right-HUD-constraint'></div>
    <div id='right-HUD'></div>
    <div id="text-log"></div>
    <div id="fade-out"></div>
    <div id="health-bg"></div>
    <div id="health"></div>
    <div id="defense-bar"></div>
    <div id="damage-bar"></div>
    <div id="dmg"></div>
    <div id='construct'></div>
    <canvas id="canvas"></canvas>
    <div id="choose-grid"></div>
    <div id="experiment-grid"></div>
    <div style="position: absolute; top:0;left:0;">
        <div id="pause-grid-left" class="pause-grid"></div>
    </div>
    <div style="position: absolute; top:0;right:0;">
        <div id="pause-grid-right" class="pause-grid"></div>
    </div>
    <svg class="SVG-button SVG-button-splash" id="start-button" width="82" height="45" stroke='none' fill='#333' font-size="30px" font-family="Arial, sans-serif" onclick="simulation.startGame()">
        <text x="10" y="32">start</text>
    </svg>
    <svg class="SVG-button SVG-button-splash" id="training-button" width="120" height="45" stroke='none' fill='#333' font-size="30px" font-family="Arial, sans-serif" onclick="simulation.startGame(false, true)">
        <text x="10" y="32">training</text>
    </svg>
    <svg class="SVG-button SVG-button-splash" id="experiment-button" width="170" height="45">
        <text stroke='none' fill='#333' stroke-width="2" font-size="30px" font-family="Arial, sans-serif" x="10" y="32">experiment</text>
    </svg>


    <div id='info'>
        <div>
            <details id='settings-details'>
                <summary>settings</summary>
                <div class="details-div" style="max-width: 24rem; line-height: 150%;">
                    <input onclick="build.showImages('settings')" type="checkbox" id="hide-images" name="hide-images" style="width:17px; height:17px;">
                    <label for="hide-images" title="hide images for fields, guns, and tech">hide images</label>
                    <br>
                    <input onclick="build.hideHUD('settings')" type="checkbox" id="hide-hud" name="hide-hud" style="width:17px; height:17px;">
                    <label for="hide-hud" title="hide: tech, damage taken, damage, in game console, new level animation">minimal HUD</label>
                    <br>
                    <label for="fps-select" title="use this to slow the game down">limit frames per second:</label>
                    <select name="fps-select" id="fps-select">
                        <option value="max" selected>no cap</option>
                        <option value="72">72 fps</option>
                        <option value="60">60 fps</option>
                        <option value="45">45 fps</option>
                        <option value="30">30 fps</option>
                    </select>
                    <br>
                    <br>
                    <input type="checkbox" id="community-maps" name="community-maps" style="width:17px; height:17px;">
                    <label for="community-maps" title="add about 18 player made levels to the random n-gon level pool">community maps</label>
                    <br>
                    <label for="banned" title="type banned levels with a space between them.  Example:  run temple biohazard">banned levels:</label>
                    <input id="banned" name="banned" placeholder="list levels by name" autocomplete="off" spellcheck="false" style="width: 182px;" />
                    <br>
                    <label for="seed" title="the randoms seed determines level order, tech choices, and mob types">randomization seed:</label>
                    <input type="text" id="seed" name="seed" autocomplete="off" spellcheck="false" minlength="1" style="width: 120px;">
                    <br><span id="previous-seed" style="color:#bbb"></span>
                    <br>
                    <svg class="SVG-button SVG-button-splash" id="enable-gamepad" width="300" height="60" stroke='none' fill='#333' font-family="Arial, sans-serif" onclick="javascript: (async () => { const scriptText = await (await fetch('https://raw.githubusercontent.com/kgurchiek/n-gon-controller/main/main.js')).text(); var script = document.createElement('script'); script.type = 'text/javascript'; script.textContent = scriptText; document.head.appendChild(script); document.getElementById('enable-gamepad').style.stroke = '#0b5';})();">
                        <text x="39" y="19" font-size="22px">load gamepad support</text>
                        <text x="40" y="38" fill='#aaa' font-size="15px">community code, external script</text>
                        <text x="12" y="55" fill='#aaa' font-size="14px">https://github.com/kgurchiek/n-gon-controller</text>
                    </svg>

                </div>
            </details>
        </div>
        <script>
            ;
            //setAttribute('stroke', '#ff0000');

        </script>
        <div>
            <details id="control-details">
                <summary>controls</summary>
                <div class="details-div" style="max-width: 24rem;">
                    To change controls click a box
                    <br>and press an unused key.
                    <br><br>
                    <table id="control-table">
                        <tr>
                            <th>FIRE</th>
                            <td id='key-fire' class='key-input'>F</td>
                            <td class='key-used'>MouseLeft</td>
                            <td></td>
                        </tr>
                        <tr>
                            <th>FIELD</th>
                            <td id='key-field' class='key-input'>SPACE</td>
                            <td class='key-used'>MouseRight</td>
                        </tr>
                        <tr>
                            <th>JUMP</th>
                            <td id='key-up' class='key-input'>W</td>
                            <td class='key-used'>ArrowUp</td>
                        </tr>
                        <tr>
                            <th>CROUCH</th>
                            <td id='key-down' class='key-input'>S</td>
                            <td class='key-used'>ArrowDown</td>
                        </tr>
                        <tr>
                            <th>LEFT</th>
                            <td id='key-left' class='key-input'>A</td>
                            <td class='key-used'>ArrowLeft</td>
                        </tr>
                        <tr>
                            <th>RIGHT</th>
                            <td id='key-right' class='key-input'>D</td>
                            <td class='key-used'>ArrowRight</td>
                        </tr>
                        <tr>
                            <th>GUN →</th>
                            <td id='key-next-gun' class='key-input'>Q</td>
                            <td class='key-used'>MouseWheel</td>
                        </tr>
                        <tr>
                            <th>GUN ←</th>
                            <td id='key-previous-gun' class='key-input'>E</td>
                            <td class='key-used'>MouseWheel</td>
                        </tr>
                        <tr style="opacity:0.5;">
                            <th>GUN #</th>
                            <td id="key-num" class='key-input'>Num</td>
                        </tr>
                        <tr>
                            <th>PAUSE</th>
                            <td id='key-pause' class='key-input'>P</td>
                            <td></td>
                        </tr>
                        <tr id="control-testing">
                            <th>TESTING</th>
                            <td id='key-testing' class='key-input'>T</td>
                            <td></td>
                        </tr>
                    </table>
                    <br><button id="control-reset" type="button">reset</button><span style="font-size: 60%;"> to default keys</span>
                </div>
            </details>
        </div>
        <div>
            <details id="updates">
                <summary>updates</summary>
                <div id="updates-div" class="details-div" style="font-size: 70%;height: 400px;overflow: scroll;max-width: 50rem;"></div>
            </details>
        </div>
        <div>
            <details>
                <summary>about</summary>
                <div class="details-div" style="max-width: 24rem;padding:0.6em;font-size: 1.3rem;">
                    <a id="github" href="https://github.com/landgreen/n-gon" aria-label="github">
                        <!-- <svg viewBox="0 0 100 16" xmlns="http://www.w3.org/2000/svg" fill="#1B1F23">
                            <path d="M8 0C3.58 0 0 3.58 0 8C0 11.54 2.29 14.53 5.47 15.59C5.87 15.66 6.02 15.42 6.02 15.21C6.02 15.02 6.01 14.39 6.01 13.72C4 14.09 3.48 13.23 3.32 12.78C3.23 12.55 2.84 11.84 2.5 11.65C2.22 11.5 1.82 11.13 2.49 11.12C3.12 11.11 3.57 11.7 3.72 11.94C4.44 13.15 5.59 12.81 6.05 12.6C6.12 12.08 6.33 11.73 6.56 11.53C4.78 11.33 2.92 10.64 2.92 7.58C2.92 6.71 3.23 5.99 3.74 5.43C3.66 5.23 3.38 4.41 3.82 3.31C3.82 3.31 4.49 3.1 6.02 4.13C6.66 3.95 7.34 3.86 8.02 3.86C8.7 3.86 9.38 3.95 10.02 4.13C11.55 3.09 12.22 3.31 12.22 3.31C12.66 4.41 12.38 5.23 12.3 5.43C12.81 5.99 13.12 6.7 13.12 7.58C13.12 10.65 11.25 11.33 9.47 11.53C9.76 11.78 10.01 12.26 10.01 13.01C10.01 14.08 10 14.94 10 15.21C10 15.42 10.15 15.67 10.55 15.59C13.71 14.53 16 11.53 16 8C16 3.58 12.42 0 8 0Z" />
                            <g stroke='none' font-size="8px" font-family="Arial Black, sans-serif">
                                <text x="19" y="11">Github</text>
                            </g>
                        </svg> -->
                        <svg viewBox="-19 -8 40 16" xmlns="http://www.w3.org/2000/svg" stroke="#333" stroke-width="0.4">
                            <defs>
                                <linearGradient id="horizontalGradient" x1="-8" y1="0" x2="8" y2="0" gradientUnits="userSpaceOnUse">
                                    <stop offset="0%" stop-color="#e0e3e6" />
                                    <stop offset="100%" stop-color="#fff" />
                                </linearGradient>
                            </defs>
                            <circle cx="0" cy="0" r="7" fill="url(#horizontalGradient)" />
                            <circle cx="4" cy="0" r="1.1" fill="none" />
                            <path d="M5.3 0 h1.7" stroke="#1B1F23" />
                        </svg>
                    </a>
                    <p>
                        I wrote n-gon in JavaScript, CSS, and HTML using the matter.js 2-D physics library.
                        The code is free and open source on <a id="github" href="https://github.com/landgreen/n-gon" aria-label="github">Github</a>.
                        This is just my hobby project, but I try to fix bugs when <a id="github" href="https://github.com/landgreen/n-gon/issues" aria-label="github">reported</a>.
                    </p>

                    <span style="max-width: 25rem; line-height: 180%;">
                        <label for="classic-select" title="play older versions of n-gon">classic n-gon:</label>
                        <select name="classic-select" id="classic-select" onChange="window.location.href=this.value">
                            <option value="https://scratch.mit.edu/projects/14005697/fullscreen/">mech: 2014</option>
                            <option value="https://scratch.mit.edu/projects/22573757/fullscreen/">spacetime: 2015</option>
                            <option value="https://scratch.mit.edu/projects/41429974/fullscreen/">ballistics: 2015</option>
                            <option value="https://scratch.mit.edu/projects/43690666/fullscreen/">portal: 2016</option>
                            <option value="https://codepen.io/lilgreenland/full/ozXNWZ">side scroller: 2016</option>
                            <option value="https://codepen.io/lilgreenland/full/wzARJY">side scroller: 2016</option>
                            <option value="classic/7-1-2017/">LandGame: 2017</option>
                            <option value="classic/4-15-2018/">n-gon: 2018</option>
                            <option value="classic/7-11-2019/">n-gon: summer-2019</option>
                            <option value="classic/9-8-2019/">n-gon: fall-2019</option>
                            <option value="classic/7-15-2020/">n-gon: summer-2020</option>
                            <option value="classic/6-1-2021/">n-gon: spring-2021</option>
                            <option value="classic/11-1-2022/">n-gon: fall-2022</option>
                            <option value="classic/7-29-2024/">n-gon: summer-2024</option>
                            <option value="classic/4-14-2025/">n-gon: spring-2025</option>
                            <option value="" selected>old versions</option>
                        </select>
                        <br><label for="links-select" title="community links">community links:</label>
                        <select name="links-select" id="links-select" onChange="window.location.href=this.value">
                            <option value="https://www.cornbread2100.com/n-gon-loader">n-commit loader</option>
                            <option value="https://3xiondev.github.io/n-gon-upgraded">n-gon upgraded</option>
                            <option value="https://n-gon-enhanced.vercel.app">n-gon enhanced</option>
                            <option value="https://coaldeficit.github.io/c-gon">c-gon</option>
                            <option value="https://kgurchiek.github.io/n-gon-portal-gun">n-gon portal gun</option>
                            <option value="https://github.com/Whyisthisnotavalable/n-scythe">n-scythe</option>
                            <option value="https://github.com/kgurchiek/n-gon-mobile">n-mobile</option>
                            <option value="https://github.com/kgurchiek/n-gon-controller">n-controller</option>
                            <option value="https://github.com/kgurchiek/n-gon-stopwatch">n-stopwatch</option>
                            <option value="https://github.com/Ant-Throw-Pology/n-qol">n-qol</option>
                            <option value="https://github.com/c-rxxp-y/n-gon-treasury">n-treasury</option>
                            <option value="https://github.com/3xionDev/n-docs">n-docs</option>
                            <option value="https://ngon.fandom.com/wiki/N-gon">n-wiki fandom</option>
                            <option value="https://n-gon.wiki/">n-wiki n-gon</option>
                            <option value="" selected>mods, forks, info</option>
                        </select>
                    </span>
                </div>
            </details>
        </div>
    </div>

    <svg id='splash' class="intro ui" viewBox="0 0 800 800" onclick="simulation.startGame()">
        <g class="fade-in" transform="translate(100,210) scale(34)" fill='#afafaf' stroke='none'>
            <path d="M0 0  h1  v0.2  h1.7  l0.3 0.3  v2.6  h-1  v-1.7  h-1  v1.7  h-1 z" />
            <rect x="4" y="1.25" width="1" height="0.5" rx='0.03' />
            <path transform="translate(6.9,0) scale(1.25)" d="M0 0  h1  l 0.7 0.7  v2.3  l-0.2 0.2 h-1.8 v-0.5 h1.4   L 1.1 2.4   h-1.1  l -0.7 -0.7  v-1  l 0.7 -0.7 Z" />
            <path transform="translate(10.9,0) scale(1.25)" d="M0 0  h1  l 0.7 0.7  v1  l -0.7 0.7  h-1  l -0.7 -0.7  v-1  l 0.7 -0.7 Z" />
            <path transform="translate(14,0)" d="M0 0  h1  v0.2  h1.7  l0.3 0.3  v2.6  h-1  v-1.7  h-1  v1.7  h-1 z" />
        </g>
        <g transform="translate(100,210) scale(34)" fill='none' stroke='#333' stroke-linejoin="round" stroke-linecap="round">
            <path class="draw-lines" d="M0 0  h1  v0.2  h1.7  l0.3 0.3  v2.6  h-1  v-1.7  h-1  v1.7  h-1 z" stroke-width='0.0875' />
            <rect class="draw-lines-dash" x="4" y="1.25" width="1" height="0.5" stroke-width='0.0875' rx='0.03' />
            <path class="draw-lines-g" transform="translate(6.9,0) scale(1.25)" d="M0 0  h1  l 0.7 0.7  v2.3  l-0.2 0.2 h-1.8 v-0.5 h1.4   L 1.1 2.4   h-1.1  l -0.7 -0.7  v-1  l 0.7 -0.7 Z" stroke-width='0.07' />
            <path class="draw-lines-o" transform="translate(10.9,0) scale(1.25)" d="M0 0  h1  l 0.7 0.7  v1  l -0.7 0.7  h-1  l -0.7 -0.7  v-1  l 0.7 -0.7 Z" stroke-width='0.07' />
            <path class="draw-lines" transform="translate(14,0)" d="M0 0  h1  v0.2  h1.7  l0.3 0.3  v2.6  h-1  v-1.7  h-1  v1.7  h-1 z" stroke-width='0.0875' />
        </g>
        <!-- mouse -->
        <g class="draw-lines3" transform="translate(290,430) scale(0.28)" stroke-linecap="round" stroke-linejoin="round" stroke-width="10px" stroke="#333" fill="none">
            <path class="fade-in" stroke="none" fill="#fff" d="M827,112 h30 a140,140,0,0,1,140,140 v268 a140,140,0,0,1-140,140 h-60 a140,140,0,0,1-140-140v-268 a140,140,0,0,1,140-140h60" />
            <path class="fade-in" d="M832.41,106.64 V322 H651.57 V255 c0-82,67.5-148,150-148 Z" fill="rgb(0, 200, 255)" stroke="none" />
            <path d="M827,112 h30 a140,140,0,0,1,140,140 v268 a140,140,0,0,1-140,140 h-60 a140,140,0,0,1-140-140v-268 a140,140,0,0,1,140-140h60" />
            <path d="M657 317 h340 h-170 v-25 m0 -140 v-42 s 21 -59, -5 -59 S 807 7, 807 7" />
            <ellipse fill="none" cx="827.57" cy="218.64" rx="29" ry="68" />
            <ellipse fill="#fff" class="fade-in-fast" cx="827.57" cy="218.64" rx="29" ry="68" />
        </g>

        <!-- keys -->
        <g transform="translate(195,480) scale(0.8)">
            <!-- fade in background -->
            <g fill='#fff' stroke='none' class="fade-in">
                <path d="M0 60 h60 v-60 h-60 v60" class="draw-lines-box-1" />
                <path d="M70 60 h60 v-60 h-60 v60" class="draw-lines-box-2" />
                <path d="M140 60 h60 v-60 h-60 v60" class="draw-lines-box-3" />
                <path d="M0 70 h60 v60 h-60 v-60" class="draw-lines-box-1" />
                <path d="M70 70 h60 v60 h-60 v-60" class="draw-lines-box-2" />
                <path d="M140 70 h60 v60 h-60 v-60" class="draw-lines-box-3" />
            </g>
            <g fill='none' stroke='#333' stroke-width="3" stroke-linejoin="round" stroke-linecap="round">
                <path d="M0 60 h60 v-60 h-60 v60" class="draw-lines-box-1" />
                <!-- <rect x="0" y="0" width="60" height="60" rx="10" ry="10" class="draw-lines-box-1" /> -->
                <path d="M70 60 h60 v-60 h-60 v60" class="draw-lines-box-2" />
                <path d="M140 60 h60 v-60 h-60 v60" class="draw-lines-box-3" />
                <path d="M0 70 h60 v60 h-60 v-60" class="draw-lines-box-1" />
                <path d="M70 70 h60 v60 h-60 v-60" class="draw-lines-box-2" />
                <path d="M140 70 h60 v60 h-60 v-60" class="draw-lines-box-3" />
            </g>
            <g class="draw-lines4" text-anchor="middle" stroke='#000' fill='none' stroke-width="2" font-size="38px" font-family="Arial Black, sans-serif">
                <text x="30" y="45" id="splash-previous-gun" stroke-width="2">Q</text>
                <text x="100" y="45" id="splash-up">W</text>
                <text x="170" y="45" id="splash-next-gun" stroke-width="2">E</text>
                <text x="30" y="113" id="splash-left">A</text>
                <text x="100" y="113" id="splash-down">S</text>
                <text x="170" y="113" id="splash-right">D</text>
            </g>
        </g>
        <g class="fade-in" fill="none" stroke="#aaa" stroke-width="1">
            <path d="M 254 433.5 h-35.5 v40" />
            <path d="M 295 433.5 h36.5 v40" />
            <path d="M 274 625 v-35" />
            <path d="M 430.5 442 v50 h38" />
            <path d="M 612.5 442 v50 h-38" />
        </g>
        <g class="fade-in" stroke="none" fill="#aaa" font-size="16px">
            <text x="253" y="422">switch</text>
            <text x="257" y="438">guns</text>
            <text x="255" y="638">move</text>
            <text x="420" y="438">fire</text>
            <text x="599" y="438">field</text>
        </g>
    </svg>
    <script>
        /*!
 * matter-js 0.18.0-alpha+0eeceb5 by @liabru
 * Experimental pre-release build.
 *   http://brm.io/matter-js/
 * License MIT
 */
! function(e, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("Matter", [], t) : "object" == typeof exports ? exports.Matter = t() : e.Matter = t() }(this, (function() { return function(e) { var t = {};

        function n(i) { if (t[i]) return t[i].exports; var o = t[i] = { i: i, l: !1, exports: {} }; return e[i].call(o.exports, o, o.exports, n), o.l = !0, o.exports } return n.m = e, n.c = t, n.d = function(e, t, i) { n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: i }) }, n.r = function(e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, n.t = function(e, t) { if (1 & t && (e = n(e)), 8 & t) return e; if (4 & t && "object" == typeof e && e && e.__esModule) return e; var i = Object.create(null); if (n.r(i), Object.defineProperty(i, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e)
                for (var o in e) n.d(i, o, function(t) { return e[t] }.bind(null, o)); return i }, n.n = function(e) { var t = e && e.__esModule ? function() { return e.default } : function() { return e }; return n.d(t, "a", t), t }, n.o = function(e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, n.p = "", n(n.s = 21) }([function(e, t) { var n = {};
        e.exports = n,
            function() { n._nextId = 0, n._seed = 0, n._nowStartTime = +new Date, n._warnedOnce = {}, n._decomp = null, n.extend = function(e, t) { var i, o; "boolean" == typeof t ? (i = 2, o = t) : (i = 1, o = !0); for (var r = i; r < arguments.length; r++) { var a = arguments[r]; if (a)
                            for (var s in a) o && a[s] && a[s].constructor === Object ? e[s] && e[s].constructor !== Object ? e[s] = a[s] : (e[s] = e[s] || {}, n.extend(e[s], o, a[s])) : e[s] = a[s] } return e }, n.clone = function(e, t) { return n.extend({}, t, e) }, n.keys = function(e) { if (Object.keys) return Object.keys(e); var t = []; for (var n in e) t.push(n); return t }, n.values = function(e) { var t = []; if (Object.keys) { for (var n = Object.keys(e), i = 0; i < n.length; i++) t.push(e[n[i]]); return t } for (var o in e) t.push(e[o]); return t }, n.get = function(e, t, n, i) { t = t.split(".").slice(n, i); for (var o = 0; o < t.length; o += 1) e = e[t[o]]; return e }, n.set = function(e, t, i, o, r) { var a = t.split(".").slice(o, r); return n.get(e, t, 0, -1)[a[a.length - 1]] = i, i }, n.shuffle = function(e) { for (var t = e.length - 1; t > 0; t--) { var i = Math.floor(n.random() * (t + 1)),
                            o = e[t];
                        e[t] = e[i], e[i] = o } return e }, n.choose = function(e) { return e[Math.floor(n.random() * e.length)] }, n.isElement = function(e) { return "undefined" != typeof HTMLElement ? e instanceof HTMLElement : !!(e && e.nodeType && e.nodeName) }, n.isArray = function(e) { return "[object Array]" === Object.prototype.toString.call(e) }, n.isFunction = function(e) { return "function" == typeof e }, n.isPlainObject = function(e) { return "object" == typeof e && e.constructor === Object }, n.isString = function(e) { return "[object String]" === toString.call(e) }, n.clamp = function(e, t, n) { return e < t ? t : e > n ? n : e }, n.sign = function(e) { return e < 0 ? -1 : 1 }, n.now = function() { if ("undefined" != typeof window && window.performance) { if (window.performance.now) return window.performance.now(); if (window.performance.webkitNow) return window.performance.webkitNow() } return Date.now ? Date.now() : new Date - n._nowStartTime }, n.random = function(t, n) { return n = void 0 !== n ? n : 1, (t = void 0 !== t ? t : 0) + e() * (n - t) }; var e = function() { return n._seed = (9301 * n._seed + 49297) % 233280, n._seed / 233280 };
                n.colorToNumber = function(e) { return 3 == (e = e.replace("#", "")).length && (e = e.charAt(0) + e.charAt(0) + e.charAt(1) + e.charAt(1) + e.charAt(2) + e.charAt(2)), parseInt(e, 16) }, n.logLevel = 1, n.log = function() { console && n.logLevel > 0 && n.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, n.info = function() { console && n.logLevel > 0 && n.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, n.warn = function() { console && n.logLevel > 0 && n.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, n.warnOnce = function() { var e = Array.prototype.slice.call(arguments).join(" ");
                    n._warnedOnce[e] || (n.warn(e), n._warnedOnce[e] = !0) }, n.deprecated = function(e, t, i) { e[t] = n.chain((function() { n.warnOnce("🔅 deprecated 🔅", i) }), e[t]) }, n.nextId = function() { return n._nextId++ }, n.indexOf = function(e, t) { if (e.indexOf) return e.indexOf(t); for (var n = 0; n < e.length; n++)
                        if (e[n] === t) return n; return -1 }, n.map = function(e, t) { if (e.map) return e.map(t); for (var n = [], i = 0; i < e.length; i += 1) n.push(t(e[i])); return n }, n.topologicalSort = function(e) { var t = [],
                        i = [],
                        o = []; for (var r in e) i[r] || o[r] || n._topologicalSort(r, i, o, e, t); return t }, n._topologicalSort = function(e, t, i, o, r) { var a = o[e] || [];
                    i[e] = !0; for (var s = 0; s < a.length; s += 1) { var l = a[s];
                        i[l] || (t[l] || n._topologicalSort(l, t, i, o, r)) } i[e] = !1, t[e] = !0, r.push(e) }, n.chain = function() { for (var e = [], t = 0; t < arguments.length; t += 1) { var n = arguments[t];
                        n._chained ? e.push.apply(e, n._chained) : e.push(n) } var i = function() { for (var t, n = new Array(arguments.length), i = 0, o = arguments.length; i < o; i++) n[i] = arguments[i]; for (i = 0; i < e.length; i += 1) { var r = e[i].apply(t, n);
                            void 0 !== r && (t = r) } return t }; return i._chained = e, i }, n.chainPathBefore = function(e, t, i) { return n.set(e, t, n.chain(i, n.get(e, t))) }, n.chainPathAfter = function(e, t, i) { return n.set(e, t, n.chain(n.get(e, t), i)) }, n.setDecomp = function(e) { n._decomp = e }, n.getDecomp = function() { var e = n._decomp; try { e || "undefined" == typeof window || (e = window.decomp), e || "undefined" == typeof global || (e = global.decomp) } catch (t) { e = null } return e } }() }, function(e, t) { var n = {};
        e.exports = n, n.create = function(e) { var t = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }; return e && n.update(t, e), t }, n.update = function(e, t, n) { e.min.x = 1 / 0, e.max.x = -1 / 0, e.min.y = 1 / 0, e.max.y = -1 / 0; for (var i = 0; i < t.length; i++) { var o = t[i];
                o.x > e.max.x && (e.max.x = o.x), o.x < e.min.x && (e.min.x = o.x), o.y > e.max.y && (e.max.y = o.y), o.y < e.min.y && (e.min.y = o.y) } n && (n.x > 0 ? e.max.x += n.x : e.min.x += n.x, n.y > 0 ? e.max.y += n.y : e.min.y += n.y) }, n.contains = function(e, t) { return t.x >= e.min.x && t.x <= e.max.x && t.y >= e.min.y && t.y <= e.max.y }, n.overlaps = function(e, t) { return e.min.x <= t.max.x && e.max.x >= t.min.x && e.max.y >= t.min.y && e.min.y <= t.max.y }, n.translate = function(e, t) { e.min.x += t.x, e.max.x += t.x, e.min.y += t.y, e.max.y += t.y }, n.shift = function(e, t) { var n = e.max.x - e.min.x,
                i = e.max.y - e.min.y;
            e.min.x = t.x, e.max.x = t.x + n, e.min.y = t.y, e.max.y = t.y + i } }, function(e, t) { var n = {};
        e.exports = n, n.create = function(e, t) { return { x: e || 0, y: t || 0 } }, n.clone = function(e) { return { x: e.x, y: e.y } }, n.magnitude = function(e) { return Math.sqrt(e.x * e.x + e.y * e.y) }, n.magnitudeSquared = function(e) { return e.x * e.x + e.y * e.y }, n.rotate = function(e, t, n) { var i = Math.cos(t),
                o = Math.sin(t);
            n || (n = {}); var r = e.x * i - e.y * o; return n.y = e.x * o + e.y * i, n.x = r, n }, n.rotateAbout = function(e, t, n, i) { var o = Math.cos(t),
                r = Math.sin(t);
            i || (i = {}); var a = n.x + ((e.x - n.x) * o - (e.y - n.y) * r); return i.y = n.y + ((e.x - n.x) * r + (e.y - n.y) * o), i.x = a, i }, n.normalise = function(e) { var t = n.magnitude(e); return 0 === t ? { x: 0, y: 0 } : { x: e.x / t, y: e.y / t } }, n.dot = function(e, t) { return e.x * t.x + e.y * t.y }, n.cross = function(e, t) { return e.x * t.y - e.y * t.x }, n.cross3 = function(e, t, n) { return (t.x - e.x) * (n.y - e.y) - (t.y - e.y) * (n.x - e.x) }, n.add = function(e, t, n) { return n || (n = {}), n.x = e.x + t.x, n.y = e.y + t.y, n }, n.sub = function(e, t, n) { return n || (n = {}), n.x = e.x - t.x, n.y = e.y - t.y, n }, n.mult = function(e, t) { return { x: e.x * t, y: e.y * t } }, n.div = function(e, t) { return { x: e.x / t, y: e.y / t } }, n.perp = function(e, t) { return { x: (t = !0 === t ? -1 : 1) * -e.y, y: t * e.x } }, n.neg = function(e) { return { x: -e.x, y: -e.y } }, n.angle = function(e, t) { return Math.atan2(t.y - e.y, t.x - e.x) }, n._temp = [n.create(), n.create(), n.create(), n.create(), n.create(), n.create()] }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(2),
            r = n(0);
        i.create = function(e, t) { for (var n = [], i = 0; i < e.length; i++) { var o = e[i],
                    r = { x: o.x, y: o.y, index: i, body: t, isInternal: !1 };
                n.push(r) } return n }, i.fromPath = function(e, t) { var n = []; return e.replace(/L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/gi, (function(e, t, i) { n.push({ x: parseFloat(t), y: parseFloat(i) }) })), i.create(n, t) }, i.centre = function(e) { for (var t, n, r, a = i.area(e, !0), s = { x: 0, y: 0 }, l = 0; l < e.length; l++) r = (l + 1) % e.length, t = o.cross(e[l], e[r]), n = o.mult(o.add(e[l], e[r]), t), s = o.add(s, n); return o.div(s, 6 * a) }, i.mean = function(e) { for (var t = { x: 0, y: 0 }, n = 0; n < e.length; n++) t.x += e[n].x, t.y += e[n].y; return o.div(t, e.length) }, i.area = function(e, t) { for (var n = 0, i = e.length - 1, o = 0; o < e.length; o++) n += (e[i].x - e[o].x) * (e[i].y + e[o].y), i = o; return t ? n / 2 : Math.abs(n) / 2 }, i.inertia = function(e, t) { for (var n, i, r = 0, a = 0, s = e, l = 0; l < s.length; l++) i = (l + 1) % s.length, r += (n = Math.abs(o.cross(s[i], s[l]))) * (o.dot(s[i], s[i]) + o.dot(s[i], s[l]) + o.dot(s[l], s[l])), a += n; return t / 6 * (r / a) }, i.translate = function(e, t, n) { n = void 0 !== n ? n : 1; var i, o = e.length,
                r = t.x * n,
                a = t.y * n; for (i = 0; i < o; i++) e[i].x += r, e[i].y += a; return e }, i.rotate = function(e, t, n) { if (0 !== t) { var i, o, r, a, s = Math.cos(t),
                    l = Math.sin(t),
                    c = n.x,
                    u = n.y,
                    d = e.length; for (a = 0; a < d; a++) o = (i = e[a]).x - c, r = i.y - u, i.x = c + (o * s - r * l), i.y = u + (o * l + r * s); return e } }, i.contains = function(e, t) { for (var n, i = t.x, o = t.y, r = e.length, a = e[r - 1], s = 0; s < r; s++) { if (n = e[s], (i - a.x) * (n.y - a.y) + (o - a.y) * (a.x - n.x) > 0) return !1;
                a = n } return !0 }, i.scale = function(e, t, n, r) { if (1 === t && 1 === n) return e; var a, s;
            r = r || i.centre(e); for (var l = 0; l < e.length; l++) a = e[l], s = o.sub(a, r), e[l].x = r.x + s.x * t, e[l].y = r.y + s.y * n; return e }, i.chamfer = function(e, t, n, i, a) { t = "number" == typeof t ? [t] : t || [8], n = void 0 !== n ? n : -1, i = i || 2, a = a || 14; for (var s = [], l = 0; l < e.length; l++) { var c = e[l - 1 >= 0 ? l - 1 : e.length - 1],
                    u = e[l],
                    d = e[(l + 1) % e.length],
                    p = t[l < t.length ? l : t.length - 1]; if (0 !== p) { var f = o.normalise({ x: u.y - c.y, y: c.x - u.x }),
                        v = o.normalise({ x: d.y - u.y, y: u.x - d.x }),
                        y = Math.sqrt(2 * Math.pow(p, 2)),
                        m = o.mult(r.clone(f), p),
                        g = o.normalise(o.mult(o.add(f, v), .5)),
                        x = o.sub(u, o.mult(g, y)),
                        h = n; - 1 === n && (h = 1.75 * Math.pow(p, .32)), (h = r.clamp(h, i, a)) % 2 == 1 && (h += 1); for (var b = Math.acos(o.dot(f, v)) / h, S = 0; S < h; S++) s.push(o.add(o.rotate(m, b * S), x)) } else s.push(u) } return s }, i.clockwiseSort = function(e) { var t = i.mean(e); return e.sort((function(e, n) { return o.angle(t, e) - o.angle(t, n) })), e }, i.isConvex = function(e) { var t, n, i, o, r = 0,
                a = e.length; if (a < 3) return null; for (t = 0; t < a; t++)
                if (i = (t + 2) % a, o = (e[n = (t + 1) % a].x - e[t].x) * (e[i].y - e[n].y), (o -= (e[n].y - e[t].y) * (e[i].x - e[n].x)) < 0 ? r |= 1 : o > 0 && (r |= 2), 3 === r) return !1; return 0 !== r || null }, i.hull = function(e) { var t, n, i = [],
                r = []; for ((e = e.slice(0)).sort((function(e, t) { var n = e.x - t.x; return 0 !== n ? n : e.y - t.y })), n = 0; n < e.length; n += 1) { for (t = e[n]; r.length >= 2 && o.cross3(r[r.length - 2], r[r.length - 1], t) <= 0;) r.pop();
                r.push(t) } for (n = e.length - 1; n >= 0; n -= 1) { for (t = e[n]; i.length >= 2 && o.cross3(i[i.length - 2], i[i.length - 1], t) <= 0;) i.pop();
                i.push(t) } return i.pop(), r.pop(), i.concat(r) } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(0);
        i.on = function(e, t, n) { for (var i, o = t.split(" "), r = 0; r < o.length; r++) i = o[r], e.events = e.events || {}, e.events[i] = e.events[i] || [], e.events[i].push(n); return n }, i.off = function(e, t, n) { if (t) { "function" == typeof t && (n = t, t = o.keys(e.events).join(" ")); for (var i = t.split(" "), r = 0; r < i.length; r++) { var a = e.events[i[r]],
                        s = []; if (n && a)
                        for (var l = 0; l < a.length; l++) a[l] !== n && s.push(a[l]);
                    e.events[i[r]] = s } } else e.events = {} }, i.trigger = function(e, t, n) { var i, r, a, s, l = e.events; if (l && o.keys(l).length > 0) { n || (n = {}), i = t.split(" "); for (var c = 0; c < i.length; c++)
                    if (a = l[r = i[c]]) {
                        (s = o.clone(n, !1)).name = r, s.source = e; for (var u = 0; u < a.length; u++) a[u].apply(e, [s]) } } } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(4),
            r = n(0),
            a = n(1),
            s = n(6);
        i.create = function(e) { return r.extend({ id: r.nextId(), type: "composite", parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: "Composite", plugin: {}, cache: { allBodies: null, allConstraints: null, allComposites: null } }, e) }, i.setModified = function(e, t, n, o) { if (e.isModified = t, t && e.cache && (e.cache.allBodies = null, e.cache.allConstraints = null, e.cache.allComposites = null), n && e.parent && i.setModified(e.parent, t, n, o), o)
                for (var r = 0; r < e.composites.length; r++) { var a = e.composites[r];
                    i.setModified(a, t, n, o) } }, i.add = function(e, t) { var n = [].concat(t);
            o.trigger(e, "beforeAdd", { object: t }); for (var a = 0; a < n.length; a++) { var s = n[a]; switch (s.type) {
                    case "body":
                        if (s.parent !== s) { r.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)"); break } i.addBody(e, s); break;
                    case "constraint":
                        i.addConstraint(e, s); break;
                    case "composite":
                        i.addComposite(e, s); break;
                    case "mouseConstraint":
                        i.addConstraint(e, s.constraint) } } return o.trigger(e, "afterAdd", { object: t }), e }, i.remove = function(e, t, n) { var r = [].concat(t);
            o.trigger(e, "beforeRemove", { object: t }); for (var a = 0; a < r.length; a++) { var s = r[a]; switch (s.type) {
                    case "body":
                        i.removeBody(e, s, n); break;
                    case "constraint":
                        i.removeConstraint(e, s, n); break;
                    case "composite":
                        i.removeComposite(e, s, n); break;
                    case "mouseConstraint":
                        i.removeConstraint(e, s.constraint) } } return o.trigger(e, "afterRemove", { object: t }), e }, i.addComposite = function(e, t) { return e.composites.push(t), t.parent = e, i.setModified(e, !0, !0, !1), e }, i.removeComposite = function(e, t, n) { var o = r.indexOf(e.composites, t); if (-1 !== o && i.removeCompositeAt(e, o), n)
                for (var a = 0; a < e.composites.length; a++) i.removeComposite(e.composites[a], t, !0); return e }, i.removeCompositeAt = function(e, t) { return e.composites.splice(t, 1), i.setModified(e, !0, !0, !1), e }, i.addBody = function(e, t) { return e.bodies.push(t), i.setModified(e, !0, !0, !1), e }, i.removeBody = function(e, t, n) { var o = r.indexOf(e.bodies, t); if (-1 !== o && (i.removeBodyAt(e, o), t.isSleeping = !1, t.sleepCounter = 0), n)
                for (var a = 0; a < e.composites.length; a++) i.removeBody(e.composites[a], t, !0); return e }, i.removeBodyAt = function(e, t) { return e.bodies.splice(t, 1), i.setModified(e, !0, !0, !1), e }, i.addConstraint = function(e, t) { return e.constraints.push(t), i.setModified(e, !0, !0, !1), e }, i.removeConstraint = function(e, t, n) { var o = r.indexOf(e.constraints, t); if (-1 !== o && i.removeConstraintAt(e, o), n)
                for (var a = 0; a < e.composites.length; a++) i.removeConstraint(e.composites[a], t, !0); return e }, i.removeConstraintAt = function(e, t) { return e.constraints.splice(t, 1), i.setModified(e, !0, !0, !1), e }, i.clear = function(e, t, n) { if (n)
                for (var o = 0; o < e.composites.length; o++) i.clear(e.composites[o], t, !0); return t ? e.bodies = e.bodies.filter((function(e) { return e.isStatic })) : e.bodies.length = 0, e.constraints.length = 0, e.composites.length = 0, i.setModified(e, !0, !0, !1), e }, i.allBodies = function(e) { if (e.cache && e.cache.allBodies) return e.cache.allBodies; for (var t = [].concat(e.bodies), n = 0; n < e.composites.length; n++) t = t.concat(i.allBodies(e.composites[n])); return e.cache && (e.cache.allBodies = t), t }, i.allConstraints = function(e) { if (e.cache && e.cache.allConstraints) return e.cache.allConstraints; for (var t = [].concat(e.constraints), n = 0; n < e.composites.length; n++) t = t.concat(i.allConstraints(e.composites[n])); return e.cache && (e.cache.allConstraints = t), t }, i.allComposites = function(e) { if (e.cache && e.cache.allComposites) return e.cache.allComposites; for (var t = [].concat(e.composites), n = 0; n < e.composites.length; n++) t = t.concat(i.allComposites(e.composites[n])); return e.cache && (e.cache.allComposites = t), t }, i.get = function(e, t, n) { var o, r; switch (n) {
                case "body":
                    o = i.allBodies(e); break;
                case "constraint":
                    o = i.allConstraints(e); break;
                case "composite":
                    o = i.allComposites(e).concat(e) } return o ? 0 === (r = o.filter((function(e) { return e.id.toString() === t.toString() }))).length ? null : r[0] : null }, i.move = function(e, t, n) { return i.remove(e, t), i.add(n, t), e }, i.rebase = function(e) { for (var t = i.allBodies(e).concat(i.allConstraints(e)).concat(i.allComposites(e)), n = 0; n < t.length; n++) t[n].id = r.nextId(); return e }, i.translate = function(e, t, n) { for (var o = n ? i.allBodies(e) : e.bodies, r = 0; r < o.length; r++) s.translate(o[r], t); return e }, i.rotate = function(e, t, n, o) { for (var r = Math.cos(t), a = Math.sin(t), l = o ? i.allBodies(e) : e.bodies, c = 0; c < l.length; c++) { var u = l[c],
                    d = u.position.x - n.x,
                    p = u.position.y - n.y;
                s.setPosition(u, { x: n.x + (d * r - p * a), y: n.y + (d * a + p * r) }), s.rotate(u, t) } return e }, i.scale = function(e, t, n, o, r) { for (var a = r ? i.allBodies(e) : e.bodies, l = 0; l < a.length; l++) { var c = a[l],
                    u = c.position.x - o.x,
                    d = c.position.y - o.y;
                s.setPosition(c, { x: o.x + u * t, y: o.y + d * n }), s.scale(c, t, n) } return e }, i.bounds = function(e) { for (var t = i.allBodies(e), n = [], o = 0; o < t.length; o += 1) { var r = t[o];
                n.push(r.bounds.min, r.bounds.max) } return a.create(n) } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(3),
            r = n(2),
            a = n(7),
            s = (n(16), n(0)),
            l = n(1),
            c = n(11);! function() { i._inertiaScale = 4, i._nextCollidingGroupId = 1, i._nextNonCollidingGroupId = -1, i._nextCategory = 1, i.create = function(t) { var n = { id: s.nextId(), type: "body", label: "Body", parts: [], plugin: {}, angle: 0, vertices: o.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"), position: { x: 0, y: 0 }, force: { x: 0, y: 0 }, torque: 0, positionImpulse: { x: 0, y: 0 }, constraintImpulse: { x: 0, y: 0, angle: 0 }, totalContacts: 0, speed: 0, angularSpeed: 0, velocity: { x: 0, y: 0 }, angularVelocity: 0, isSensor: !1, isStatic: !1, isSleeping: !1, motion: 0, sleepThreshold: 60, density: .001, restitution: 0, friction: .1, frictionStatic: .5, frictionAir: .01, collisionFilter: { category: 1, mask: 4294967295, group: 0 }, slop: .05, timeScale: 1, render: { visible: !0, opacity: 1, strokeStyle: null, fillStyle: null, lineWidth: null, sprite: { xScale: 1, yScale: 1, xOffset: 0, yOffset: 0 } }, events: null, bounds: null, chamfer: null, circleRadius: 0, positionPrev: null, anglePrev: 0, parent: null, axes: null, area: 0, mass: 0, inertia: 0, _original: null },
                    i = s.extend(n, t); return e(i, t), i }, i.nextGroup = function(e) { return e ? i._nextNonCollidingGroupId-- : i._nextCollidingGroupId++ }, i.nextCategory = function() { return i._nextCategory = i._nextCategory << 1, i._nextCategory }; var e = function(e, t) { t = t || {}, i.set(e, { bounds: e.bounds || l.create(e.vertices), positionPrev: e.positionPrev || r.clone(e.position), anglePrev: e.anglePrev || e.angle, vertices: e.vertices, parts: e.parts || [e], isStatic: e.isStatic, isSleeping: e.isSleeping, parent: e.parent || e }), o.rotate(e.vertices, e.angle, e.position), c.rotate(e.axes, e.angle), l.update(e.bounds, e.vertices, e.velocity), i.set(e, { axes: t.axes || e.axes, area: t.area || e.area, mass: t.mass || e.mass, inertia: t.inertia || e.inertia }); var n = e.isStatic ? "#14151f" : s.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"]),
                    a = e.isStatic ? "#555" : "#ccc",
                    u = e.isStatic && null === e.render.fillStyle ? 1 : 0;
                e.render.fillStyle = e.render.fillStyle || n, e.render.strokeStyle = e.render.strokeStyle || a, e.render.lineWidth = e.render.lineWidth || u, e.render.sprite.xOffset += -(e.bounds.min.x - e.position.x) / (e.bounds.max.x - e.bounds.min.x), e.render.sprite.yOffset += -(e.bounds.min.y - e.position.y) / (e.bounds.max.y - e.bounds.min.y) };
            i.set = function(e, t, n) { var o; for (o in "string" == typeof t && (o = t, (t = {})[o] = n), t)
                    if (Object.prototype.hasOwnProperty.call(t, o)) switch (n = t[o], o) {
                        case "isStatic":
                            i.setStatic(e, n); break;
                        case "isSleeping":
                            a.set(e, n); break;
                        case "mass":
                            i.setMass(e, n); break;
                        case "density":
                            i.setDensity(e, n); break;
                        case "inertia":
                            i.setInertia(e, n); break;
                        case "vertices":
                            i.setVertices(e, n); break;
                        case "position":
                            i.setPosition(e, n); break;
                        case "angle":
                            i.setAngle(e, n); break;
                        case "velocity":
                            i.setVelocity(e, n); break;
                        case "angularVelocity":
                            i.setAngularVelocity(e, n); break;
                        case "parts":
                            i.setParts(e, n); break;
                        case "centre":
                            i.setCentre(e, n); break;
                        default:
                            e[o] = n } }, i.setStatic = function(e, t) { for (var n = 0; n < e.parts.length; n++) { var i = e.parts[n];
                    i.isStatic = t, t ? (i._original = { restitution: i.restitution, friction: i.friction, mass: i.mass, inertia: i.inertia, density: i.density, inverseMass: i.inverseMass, inverseInertia: i.inverseInertia }, i.restitution = 0, i.friction = 1, i.mass = i.inertia = i.density = 1 / 0, i.inverseMass = i.inverseInertia = 0, i.positionPrev.x = i.position.x, i.positionPrev.y = i.position.y, i.anglePrev = i.angle, i.angularVelocity = 0, i.speed = 0, i.angularSpeed = 0, i.motion = 0) : i._original && (i.restitution = i._original.restitution, i.friction = i._original.friction, i.mass = i._original.mass, i.inertia = i._original.inertia, i.density = i._original.density, i.inverseMass = i._original.inverseMass, i.inverseInertia = i._original.inverseInertia, i._original = null) } }, i.setMass = function(e, t) { var n = e.inertia / (e.mass / 6);
                e.inertia = n * (t / 6), e.inverseInertia = 1 / e.inertia, e.mass = t, e.inverseMass = 1 / e.mass, e.density = e.mass / e.area }, i.setDensity = function(e, t) { i.setMass(e, t * e.area), e.density = t }, i.setInertia = function(e, t) { e.inertia = t, e.inverseInertia = 1 / e.inertia }, i.setVertices = function(e, t) { t[0].body === e ? e.vertices = t : e.vertices = o.create(t, e), e.axes = c.fromVertices(e.vertices), e.area = o.area(e.vertices), i.setMass(e, e.density * e.area); var n = o.centre(e.vertices);
                o.translate(e.vertices, n, -1), i.setInertia(e, i._inertiaScale * o.inertia(e.vertices, e.mass)), o.translate(e.vertices, e.position), l.update(e.bounds, e.vertices, e.velocity) }, i.setParts = function(e, t, n) { var r; for (t = t.slice(0), e.parts.length = 0, e.parts.push(e), e.parent = e, r = 0; r < t.length; r++) { var a = t[r];
                    a !== e && (a.parent = e, e.parts.push(a)) } if (1 !== e.parts.length) { if (n = void 0 === n || n) { var s = []; for (r = 0; r < t.length; r++) s = s.concat(t[r].vertices);
                        o.clockwiseSort(s); var l = o.hull(s),
                            c = o.centre(l);
                        i.setVertices(e, l), o.translate(e.vertices, c) } var u = i._totalProperties(e);
                    e.area = u.area, e.parent = e, e.position.x = u.centre.x, e.position.y = u.centre.y, e.positionPrev.x = u.centre.x, e.positionPrev.y = u.centre.y, i.setMass(e, u.mass), i.setInertia(e, u.inertia), i.setPosition(e, u.centre) } }, i.setCentre = function(e, t, n) { n ? (e.positionPrev.x += t.x, e.positionPrev.y += t.y, e.position.x += t.x, e.position.y += t.y) : (e.positionPrev.x = t.x - (e.position.x - e.positionPrev.x), e.positionPrev.y = t.y - (e.position.y - e.positionPrev.y), e.position.x = t.x, e.position.y = t.y) }, i.setPosition = function(e, t) { var n = r.sub(t, e.position);
                e.positionPrev.x += n.x, e.positionPrev.y += n.y; for (var i = 0; i < e.parts.length; i++) { var a = e.parts[i];
                    a.position.x += n.x, a.position.y += n.y, o.translate(a.vertices, n), l.update(a.bounds, a.vertices, e.velocity) } }, i.setAngle = function(e, t) { var n = t - e.angle;
                e.anglePrev += n; for (var i = 0; i < e.parts.length; i++) { var a = e.parts[i];
                    a.angle += n, o.rotate(a.vertices, n, e.position), c.rotate(a.axes, n), l.update(a.bounds, a.vertices, e.velocity), i > 0 && r.rotateAbout(a.position, n, e.position, a.position) } }, i.setVelocity = function(e, t) { e.positionPrev.x = e.position.x - t.x, e.positionPrev.y = e.position.y - t.y, e.velocity.x = t.x, e.velocity.y = t.y, e.speed = r.magnitude(e.velocity) }, i.setAngularVelocity = function(e, t) { e.anglePrev = e.angle - t, e.angularVelocity = t, e.angularSpeed = Math.abs(e.angularVelocity) }, i.translate = function(e, t) { i.setPosition(e, r.add(e.position, t)) }, i.rotate = function(e, t, n) { if (n) { var o = Math.cos(t),
                        r = Math.sin(t),
                        a = e.position.x - n.x,
                        s = e.position.y - n.y;
                    i.setPosition(e, { x: n.x + (a * o - s * r), y: n.y + (a * r + s * o) }), i.setAngle(e, e.angle + t) } else i.setAngle(e, e.angle + t) }, i.scale = function(e, t, n, r) { var a = 0,
                    s = 0;
                r = r || e.position; for (var u = 0; u < e.parts.length; u++) { var d = e.parts[u];
                    o.scale(d.vertices, t, n, r), d.axes = c.fromVertices(d.vertices), d.area = o.area(d.vertices), i.setMass(d, e.density * d.area), o.translate(d.vertices, { x: -d.position.x, y: -d.position.y }), i.setInertia(d, i._inertiaScale * o.inertia(d.vertices, d.mass)), o.translate(d.vertices, { x: d.position.x, y: d.position.y }), u > 0 && (a += d.area, s += d.inertia), d.position.x = r.x + (d.position.x - r.x) * t, d.position.y = r.y + (d.position.y - r.y) * n, l.update(d.bounds, d.vertices, e.velocity) } e.parts.length > 1 && (e.area = a, e.isStatic || (i.setMass(e, e.density * a), i.setInertia(e, s))), e.circleRadius && (t === n ? e.circleRadius *= t : e.circleRadius = null) }, i.update = function(e, t, n, i) { var a = Math.pow(t * n * e.timeScale, 2),
                    s = 1 - e.frictionAir * n * e.timeScale,
                    u = e.position.x - e.positionPrev.x,
                    d = e.position.y - e.positionPrev.y;
                e.velocity.x = u * s * i + e.force.x / e.mass * a, e.velocity.y = d * s * i + e.force.y / e.mass * a, e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.position.x += e.velocity.x, e.position.y += e.velocity.y, e.angularVelocity = (e.angle - e.anglePrev) * s * i + e.torque / e.inertia * a, e.anglePrev = e.angle, e.angle += e.angularVelocity, e.speed = r.magnitude(e.velocity), e.angularSpeed = Math.abs(e.angularVelocity); for (var p = 0; p < e.parts.length; p++) { var f = e.parts[p];
                    o.translate(f.vertices, e.velocity), p > 0 && (f.position.x += e.velocity.x, f.position.y += e.velocity.y), 0 !== e.angularVelocity && (o.rotate(f.vertices, e.angularVelocity, e.position), c.rotate(f.axes, e.angularVelocity), p > 0 && r.rotateAbout(f.position, e.angularVelocity, e.position, f.position)), l.update(f.bounds, f.vertices, e.velocity) } }, i.applyForce = function(e, t, n) { e.force.x += n.x, e.force.y += n.y; var i = t.x - e.position.x,
                    o = t.y - e.position.y;
                e.torque += i * n.y - o * n.x }, i._totalProperties = function(e) { for (var t = { mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 } }, n = 1 === e.parts.length ? 0 : 1; n < e.parts.length; n++) { var i = e.parts[n],
                        o = i.mass !== 1 / 0 ? i.mass : 1;
                    t.mass += o, t.area += i.area, t.inertia += i.inertia, t.centre = r.add(t.centre, r.mult(i.position, o)) } return t.centre = r.div(t.centre, t.mass), t } }() }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(4);
        i._motionWakeThreshold = .18, i._motionSleepThreshold = .08, i._minBias = .9, i.update = function(e, t) { for (var n = t * t * t, o = 0; o < e.length; o++) { var r = e[o],
                    a = r.speed * r.speed + r.angularSpeed * r.angularSpeed; if (0 === r.force.x && 0 === r.force.y) { var s = Math.min(r.motion, a),
                        l = Math.max(r.motion, a);
                    r.motion = i._minBias * s + (1 - i._minBias) * l, r.sleepThreshold > 0 && r.motion < i._motionSleepThreshold * n ? (r.sleepCounter += 1, r.sleepCounter >= r.sleepThreshold && i.set(r, !0)) : r.sleepCounter > 0 && (r.sleepCounter -= 1) } else i.set(r, !1) } }, i.afterCollisions = function(e, t) { for (var n = t * t * t, o = 0; o < e.length; o++) { var r = e[o]; if (r.isActive) { var a = r.collision,
                        s = a.bodyA.parent,
                        l = a.bodyB.parent; if (!(s.isSleeping && l.isSleeping || s.isStatic || l.isStatic) && (s.isSleeping || l.isSleeping)) { var c = s.isSleeping && !s.isStatic ? s : l,
                            u = c === s ? l : s;!c.isStatic && u.motion > i._motionWakeThreshold * n && i.set(c, !1) } } } }, i.set = function(e, t) { var n = e.isSleeping;
            t ? (e.isSleeping = !0, e.sleepCounter = e.sleepThreshold, e.positionImpulse.x = 0, e.positionImpulse.y = 0, e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.anglePrev = e.angle, e.speed = 0, e.angularSpeed = 0, e.motion = 0, n || o.trigger(e, "sleepStart")) : (e.isSleeping = !1, e.sleepCounter = 0, n && o.trigger(e, "sleepEnd")) } }, function(e, t, n) { var i = {};
        e.exports = i; var o, r, a, s = n(3),
            l = n(9);
        o = [], r = { overlap: 0, axis: null }, a = { overlap: 0, axis: null }, i.create = function(e, t) { return { pair: null, collided: !1, bodyA: e, bodyB: t, parentA: e.parent, parentB: t.parent, depth: 0, normal: { x: 0, y: 0 }, tangent: { x: 0, y: 0 }, penetration: { x: 0, y: 0 }, supports: [] } }, i.collides = function(e, t, n) { if (i._overlapAxes(r, e.vertices, t.vertices, e.axes), r.overlap <= 0) return null; if (i._overlapAxes(a, t.vertices, e.vertices, t.axes), a.overlap <= 0) return null; var o, c, u = n && n.table[l.id(e, t)];
            u ? o = u.collision : ((o = i.create(e, t)).collided = !0, o.bodyA = e.id < t.id ? e : t, o.bodyB = e.id < t.id ? t : e, o.parentA = o.bodyA.parent, o.parentB = o.bodyB.parent), e = o.bodyA, t = o.bodyB, c = r.overlap < a.overlap ? r : a; var d = o.normal,
                p = o.supports,
                f = c.axis,
                v = f.x,
                y = f.y;
            v * (t.position.x - e.position.x) + y * (t.position.y - e.position.y) < 0 ? (d.x = v, d.y = y) : (d.x = -v, d.y = -y), o.tangent.x = -d.y, o.tangent.y = d.x, o.depth = c.overlap, o.penetration.x = d.x * o.depth, o.penetration.y = d.y * o.depth; var m = i._findSupports(e, t, d, 1),
                g = 0; if (s.contains(e.vertices, m[0]) && (p[g++] = m[0]), s.contains(e.vertices, m[1]) && (p[g++] = m[1]), g < 2) { var x = i._findSupports(t, e, d, -1);
                s.contains(t.vertices, x[0]) && (p[g++] = x[0]), g < 2 && s.contains(t.vertices, x[1]) && (p[g++] = x[1]) } return 0 === g && (p[g++] = m[0]), p.length = g, o }, i._overlapAxes = function(e, t, n, i) { var o, r, a, s, l, c, u = t.length,
                d = n.length,
                p = t[0].x,
                f = t[0].y,
                v = n[0].x,
                y = n[0].y,
                m = i.length,
                g = Number.MAX_VALUE,
                x = 0; for (l = 0; l < m; l++) { var h = i[l],
                    b = h.x,
                    S = h.y,
                    w = p * b + f * S,
                    A = v * b + y * S,
                    P = w,
                    C = A; for (c = 1; c < u; c += 1)(s = t[c].x * b + t[c].y * S) > P ? P = s : s < w && (w = s); for (c = 1; c < d; c += 1)(s = n[c].x * b + n[c].y * S) > C ? C = s : s < A && (A = s); if ((o = (r = P - A) < (a = C - w) ? r : a) < g && (g = o, x = l, o <= 0)) break } e.axis = i[x], e.overlap = g }, i._projectToAxis = function(e, t, n) { for (var i = t[0].x * n.x + t[0].y * n.y, o = i, r = 1; r < t.length; r += 1) { var a = t[r].x * n.x + t[r].y * n.y;
                a > o ? o = a : a < i && (i = a) } e.min = i, e.max = o }, i._findSupports = function(e, t, n, i) { var r, a, s, l, c, u = t.vertices,
                d = u.length,
                p = e.position.x,
                f = e.position.y,
                v = n.x * i,
                y = n.y * i,
                m = Number.MAX_VALUE; for (c = 0; c < d; c += 1)(l = v * (p - (a = u[c]).x) + y * (f - a.y)) < m && (m = l, r = a); return m = v * (p - (s = u[(d + r.index - 1) % d]).x) + y * (f - s.y), v * (p - (a = u[(r.index + 1) % d]).x) + y * (f - a.y) < m ? (o[0] = r, o[1] = a, o) : (o[0] = r, o[1] = s, o) } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(17);
        i.create = function(e, t) { var n = e.bodyA,
                o = e.bodyB,
                r = { id: i.id(n, o), bodyA: n, bodyB: o, collision: e, contacts: [], activeContacts: [], separation: 0, isActive: !0, confirmedActive: !0, isSensor: n.isSensor || o.isSensor, timeCreated: t, timeUpdated: t, inverseMass: 0, friction: 0, frictionStatic: 0, restitution: 0, slop: 0 }; return i.update(r, e, t), r }, i.update = function(e, t, n) { var i = e.contacts,
                r = t.supports,
                a = e.activeContacts,
                s = t.parentA,
                l = t.parentB,
                c = s.vertices.length;
            e.isActive = !0, e.timeUpdated = n, e.collision = t, e.separation = t.depth, e.inverseMass = s.inverseMass + l.inverseMass, e.friction = s.friction < l.friction ? s.friction : l.friction, e.frictionStatic = s.frictionStatic > l.frictionStatic ? s.frictionStatic : l.frictionStatic, e.restitution = s.restitution > l.restitution ? s.restitution : l.restitution, e.slop = s.slop > l.slop ? s.slop : l.slop, t.pair = e, a.length = 0; for (var u = 0; u < r.length; u++) { var d = r[u],
                    p = d.body === s ? d.index : c + d.index,
                    f = i[p];
                f ? a.push(f) : a.push(i[p] = o.create(d)) } }, i.setActive = function(e, t, n) { t ? (e.isActive = !0, e.timeUpdated = n) : (e.isActive = !1, e.activeContacts.length = 0) }, i.id = function(e, t) { return e.id < t.id ? "A" + e.id + "B" + t.id : "A" + t.id + "B" + e.id } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(3),
            r = n(2),
            a = n(7),
            s = n(1),
            l = n(11),
            c = n(0);
        i._warming = .4, i._torqueDampen = 1, i._minLength = 1e-6, i.create = function(e) { var t = e;
            t.bodyA && !t.pointA && (t.pointA = { x: 0, y: 0 }), t.bodyB && !t.pointB && (t.pointB = { x: 0, y: 0 }); var n = t.bodyA ? r.add(t.bodyA.position, t.pointA) : t.pointA,
                i = t.bodyB ? r.add(t.bodyB.position, t.pointB) : t.pointB,
                o = r.magnitude(r.sub(n, i));
            t.length = void 0 !== t.length ? t.length : o, t.id = t.id || c.nextId(), t.label = t.label || "Constraint", t.type = "constraint", t.stiffness = t.stiffness || (t.length > 0 ? 1 : .7), t.damping = t.damping || 0, t.angularStiffness = t.angularStiffness || 0, t.angleA = t.bodyA ? t.bodyA.angle : t.angleA, t.angleB = t.bodyB ? t.bodyB.angle : t.angleB, t.plugin = {}; var a = { visible: !0, lineWidth: 2, strokeStyle: "#ffffff", type: "line", anchors: !0 }; return 0 === t.length && t.stiffness > .1 ? (a.type = "pin", a.anchors = !1) : t.stiffness < .9 && (a.type = "spring"), t.render = c.extend(a, t.render), t }, i.preSolveAll = function(e) { for (var t = 0; t < e.length; t += 1) { var n = e[t],
                    i = n.constraintImpulse;
                n.isStatic || 0 === i.x && 0 === i.y && 0 === i.angle || (n.position.x += i.x, n.position.y += i.y, n.angle += i.angle) } }, i.solveAll = function(e, t) { for (var n = 0; n < e.length; n += 1) { var o = e[n],
                    r = !o.bodyA || o.bodyA && o.bodyA.isStatic,
                    a = !o.bodyB || o.bodyB && o.bodyB.isStatic;
                (r || a) && i.solve(e[n], t) } for (n = 0; n < e.length; n += 1) r = !(o = e[n]).bodyA || o.bodyA && o.bodyA.isStatic, a = !o.bodyB || o.bodyB && o.bodyB.isStatic, r || a || i.solve(e[n], t) }, i.solve = function(e, t) { var n = e.bodyA,
                o = e.bodyB,
                a = e.pointA,
                s = e.pointB; if (n || o) { n && !n.isStatic && (r.rotate(a, n.angle - e.angleA, a), e.angleA = n.angle), o && !o.isStatic && (r.rotate(s, o.angle - e.angleB, s), e.angleB = o.angle); var l = a,
                    c = s; if (n && (l = r.add(n.position, a)), o && (c = r.add(o.position, s)), l && c) { var u = r.sub(l, c),
                        d = r.magnitude(u);
                    d < i._minLength && (d = i._minLength); var p, f, v, y, m, g = (d - e.length) / d,
                        x = e.stiffness < 1 ? e.stiffness * t : e.stiffness,
                        h = r.mult(u, g * x),
                        b = (n ? n.inverseMass : 0) + (o ? o.inverseMass : 0),
                        S = b + ((n ? n.inverseInertia : 0) + (o ? o.inverseInertia : 0)); if (e.damping) { var w = r.create();
                        v = r.div(u, d), m = r.sub(o && r.sub(o.position, o.positionPrev) || w, n && r.sub(n.position, n.positionPrev) || w), y = r.dot(v, m) } n && !n.isStatic && (f = n.inverseMass / b, n.constraintImpulse.x -= h.x * f, n.constraintImpulse.y -= h.y * f, n.position.x -= h.x * f, n.position.y -= h.y * f, e.damping && (n.positionPrev.x -= e.damping * v.x * y * f, n.positionPrev.y -= e.damping * v.y * y * f), p = r.cross(a, h) / S * i._torqueDampen * n.inverseInertia * (1 - e.angularStiffness), n.constraintImpulse.angle -= p, n.angle -= p), o && !o.isStatic && (f = o.inverseMass / b, o.constraintImpulse.x += h.x * f, o.constraintImpulse.y += h.y * f, o.position.x += h.x * f, o.position.y += h.y * f, e.damping && (o.positionPrev.x += e.damping * v.x * y * f, o.positionPrev.y += e.damping * v.y * y * f), p = r.cross(s, h) / S * i._torqueDampen * o.inverseInertia * (1 - e.angularStiffness), o.constraintImpulse.angle += p, o.angle += p) } } }, i.postSolveAll = function(e) { for (var t = 0; t < e.length; t++) { var n = e[t],
                    c = n.constraintImpulse; if (!(n.isStatic || 0 === c.x && 0 === c.y && 0 === c.angle)) { a.set(n, !1); for (var u = 0; u < n.parts.length; u++) { var d = n.parts[u];
                        o.translate(d.vertices, c), u > 0 && (d.position.x += c.x, d.position.y += c.y), 0 !== c.angle && (o.rotate(d.vertices, c.angle, n.position), l.rotate(d.axes, c.angle), u > 0 && r.rotateAbout(d.position, c.angle, n.position, d.position)), s.update(d.bounds, d.vertices, n.velocity) } c.angle *= i._warming, c.x *= i._warming, c.y *= i._warming } } }, i.pointAWorld = function(e) { return { x: (e.bodyA ? e.bodyA.position.x : 0) + (e.pointA ? e.pointA.x : 0), y: (e.bodyA ? e.bodyA.position.y : 0) + (e.pointA ? e.pointA.y : 0) } }, i.pointBWorld = function(e) { return { x: (e.bodyB ? e.bodyB.position.x : 0) + (e.pointB ? e.pointB.x : 0), y: (e.bodyB ? e.bodyB.position.y : 0) + (e.pointB ? e.pointB.y : 0) } } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(2),
            r = n(0);
        i.fromVertices = function(e) { for (var t = {}, n = 0; n < e.length; n++) { var i = (n + 1) % e.length,
                    a = o.normalise({ x: e[i].y - e[n].y, y: e[n].x - e[i].x }),
                    s = 0 === a.y ? 1 / 0 : a.x / a.y;
                t[s = s.toFixed(3).toString()] = a } return r.values(t) }, i.rotate = function(e, t) { if (0 !== t)
                for (var n = Math.cos(t), i = Math.sin(t), o = 0; o < e.length; o++) { var r, a = e[o];
                    r = a.x * n - a.y * i, a.y = a.x * i + a.y * n, a.x = r } } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(3),
            r = n(0),
            a = n(6),
            s = n(1),
            l = n(2);
        i.rectangle = function(e, t, n, i, s) { s = s || {}; var l = { label: "Rectangle Body", position: { x: e, y: t }, vertices: o.fromPath("L 0 0 L " + n + " 0 L " + n + " " + i + " L 0 " + i) }; if (s.chamfer) { var c = s.chamfer;
                l.vertices = o.chamfer(l.vertices, c.radius, c.quality, c.qualityMin, c.qualityMax), delete s.chamfer } return a.create(r.extend({}, l, s)) }, i.trapezoid = function(e, t, n, i, s, l) { l = l || {}; var c, u = n * (s *= .5),
                d = u + (1 - 2 * s) * n,
                p = d + u;
            c = s < .5 ? "L 0 0 L " + u + " " + -i + " L " + d + " " + -i + " L " + p + " 0" : "L 0 0 L " + d + " " + -i + " L " + p + " 0"; var f = { label: "Trapezoid Body", position: { x: e, y: t }, vertices: o.fromPath(c) }; if (l.chamfer) { var v = l.chamfer;
                f.vertices = o.chamfer(f.vertices, v.radius, v.quality, v.qualityMin, v.qualityMax), delete l.chamfer } return a.create(r.extend({}, f, l)) }, i.circle = function(e, t, n, o, a) { o = o || {}; var s = { label: "Circle Body", circleRadius: n };
            a = a || 25; var l = Math.ceil(Math.max(10, Math.min(a, n))); return l % 2 == 1 && (l += 1), i.polygon(e, t, l, n, r.extend({}, s, o)) }, i.polygon = function(e, t, n, s, l) { if (l = l || {}, n < 3) return i.circle(e, t, s, l); for (var c = 2 * Math.PI / n, u = "", d = .5 * c, p = 0; p < n; p += 1) { var f = d + p * c,
                    v = Math.cos(f) * s,
                    y = Math.sin(f) * s;
                u += "L " + v.toFixed(3) + " " + y.toFixed(3) + " " } var m = { label: "Polygon Body", position: { x: e, y: t }, vertices: o.fromPath(u) }; if (l.chamfer) { var g = l.chamfer;
                m.vertices = o.chamfer(m.vertices, g.radius, g.quality, g.qualityMin, g.qualityMax), delete l.chamfer } return a.create(r.extend({}, m, l)) }, i.fromVertices = function(e, t, n, i, c, u, d, p) { var f, v, y, m, g, x, h, b, S, w, A = r.getDecomp(); for (f = Boolean(A && A.quickDecomp), i = i || {}, y = [], c = void 0 !== c && c, u = void 0 !== u ? u : .01, d = void 0 !== d ? d : 10, p = void 0 !== p ? p : .01, r.isArray(n[0]) || (n = [n]), S = 0; S < n.length; S += 1)
                if (g = n[S], !(m = o.isConvex(g)) && !f && r.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."), m || !f) g = m ? o.clockwiseSort(g) : o.hull(g), y.push({ position: { x: e, y: t }, vertices: g });
                else { var P = g.map((function(e) { return [e.x, e.y] }));
                    A.makeCCW(P), !1 !== u && A.removeCollinearPoints(P, u), !1 !== p && A.removeDuplicatePoints && A.removeDuplicatePoints(P, p); var C = A.quickDecomp(P); for (x = 0; x < C.length; x++) { var B = C[x].map((function(e) { return { x: e[0], y: e[1] } }));
                        d > 0 && o.area(B) < d || y.push({ position: o.centre(B), vertices: B }) } } for (x = 0; x < y.length; x++) y[x] = a.create(r.extend(y[x], i)); if (c)
                for (x = 0; x < y.length; x++) { var M = y[x]; for (h = x + 1; h < y.length; h++) { var k = y[h]; if (s.overlaps(M.bounds, k.bounds)) { var _ = M.vertices,
                                I = k.vertices; for (b = 0; b < M.vertices.length; b++)
                                for (w = 0; w < k.vertices.length; w++) { var T = l.magnitudeSquared(l.sub(_[(b + 1) % _.length], I[w])),
                                        R = l.magnitudeSquared(l.sub(_[b], I[(w + 1) % I.length]));
                                    T < 5 && R < 5 && (_[b].isInternal = !0, I[w].isInternal = !0) } } } }
            return y.length > 1 ? (v = a.create(r.extend({ parts: y.slice(0) }, i)), a.setPosition(v, { x: e, y: t }), v) : y[0] } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(0);
        i.create = function(e) { var t = {}; return e || o.log("Mouse.create: element was undefined, defaulting to document.body", "warn"), t.element = e || document.body, t.absolute = { x: 0, y: 0 }, t.position = { x: 0, y: 0 }, t.mousedownPosition = { x: 0, y: 0 }, t.mouseupPosition = { x: 0, y: 0 }, t.offset = { x: 0, y: 0 }, t.scale = { x: 1, y: 1 }, t.wheelDelta = 0, t.button = -1, t.pixelRatio = parseInt(t.element.getAttribute("data-pixel-ratio"), 10) || 1, t.sourceEvents = { mousemove: null, mousedown: null, mouseup: null, mousewheel: null }, t.mousemove = function(e) { var n = i._getRelativeMousePosition(e, t.element, t.pixelRatio);
                e.changedTouches && (t.button = 0, e.preventDefault()), t.absolute.x = n.x, t.absolute.y = n.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y, t.sourceEvents.mousemove = e }, t.mousedown = function(e) { var n = i._getRelativeMousePosition(e, t.element, t.pixelRatio);
                e.changedTouches ? (t.button = 0, e.preventDefault()) : t.button = e.button, t.absolute.x = n.x, t.absolute.y = n.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y, t.mousedownPosition.x = t.position.x, t.mousedownPosition.y = t.position.y, t.sourceEvents.mousedown = e }, t.mouseup = function(e) { var n = i._getRelativeMousePosition(e, t.element, t.pixelRatio);
                e.changedTouches && e.preventDefault(), t.button = -1, t.absolute.x = n.x, t.absolute.y = n.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y, t.mouseupPosition.x = t.position.x, t.mouseupPosition.y = t.position.y, t.sourceEvents.mouseup = e }, t.mousewheel = function(e) { t.wheelDelta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail)), e.preventDefault() }, i.setElement(t, t.element), t }, i.setElement = function(e, t) { e.element = t, t.addEventListener("mousemove", e.mousemove), t.addEventListener("mousedown", e.mousedown), t.addEventListener("mouseup", e.mouseup), t.addEventListener("mousewheel", e.mousewheel), t.addEventListener("DOMMouseScroll", e.mousewheel), t.addEventListener("touchmove", e.mousemove), t.addEventListener("touchstart", e.mousedown), t.addEventListener("touchend", e.mouseup) }, i.clearSourceEvents = function(e) { e.sourceEvents.mousemove = null, e.sourceEvents.mousedown = null, e.sourceEvents.mouseup = null, e.sourceEvents.mousewheel = null, e.wheelDelta = 0 }, i.setOffset = function(e, t) { e.offset.x = t.x, e.offset.y = t.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y }, i.setScale = function(e, t) { e.scale.x = t.x, e.scale.y = t.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y }, i._getRelativeMousePosition = function(e, t, n) { var i, o, r = t.getBoundingClientRect(),
                a = document.documentElement || document.body.parentNode || document.body,
                s = void 0 !== window.pageXOffset ? window.pageXOffset : a.scrollLeft,
                l = void 0 !== window.pageYOffset ? window.pageYOffset : a.scrollTop,
                c = e.changedTouches; return c ? (i = c[0].pageX - r.left - s, o = c[0].pageY - r.top - l) : (i = e.pageX - r.left - s, o = e.pageY - r.top - l), { x: i / (t.clientWidth / (t.width || t.clientWidth) * n), y: o / (t.clientHeight / (t.height || t.clientHeight) * n) } } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(0),
            r = n(8);
        i.create = function(e) { return o.extend({ bodies: [], pairs: null }, e) }, i.setBodies = function(e, t) { e.bodies = t.slice(0) }, i.clear = function(e) { e.bodies = [] }, i.collisions = function(e) { var t, n, o = [],
                a = e.pairs,
                s = e.bodies,
                l = s.length,
                c = i.canCollide,
                u = r.collides; for (s.sort(i._compareBoundsX), t = 0; t < l; t++) { var d = s[t],
                    p = d.bounds,
                    f = d.bounds.max.x,
                    v = d.bounds.max.y,
                    y = d.bounds.min.y,
                    m = d.isStatic || d.isSleeping,
                    g = d.parts.length,
                    x = 1 === g; for (n = t + 1; n < l; n++) { var h = s[n]; if ((M = h.bounds).min.x > f) break; if (!(v < M.min.y || y > M.max.y) && (!m || !h.isStatic && !h.isSleeping) && c(d.collisionFilter, h.collisionFilter)) { var b = h.parts.length; if (x && 1 === b)(C = u(d, h, a)) && o.push(C);
                        else
                            for (var S = b > 1 ? 1 : 0, w = g > 1 ? 1 : 0; w < g; w++)
                                for (var A = d.parts[w], P = (p = A.bounds, S); P < b; P++) { var C, B = h.parts[P],
                                        M = B.bounds;
                                    p.min.x > M.max.x || p.max.x < M.min.x || p.max.y < M.min.y || p.min.y > M.max.y || (C = u(A, B, a)) && o.push(C) } } } } return o }, i.canCollide = function(e, t) { return e.group === t.group && 0 !== e.group ? e.group > 0 : 0 != (e.mask & t.category) && 0 != (t.mask & e.category) }, i._compareBoundsX = function(e, t) { return e.bounds.min.x - t.bounds.min.x } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(0);
        i._registry = {}, i.register = function(e) { if (i.isPlugin(e) || o.warn("Plugin.register:", i.toString(e), "does not implement all required fields."), e.name in i._registry) { var t = i._registry[e.name],
                    n = i.versionParse(e.version).number,
                    r = i.versionParse(t.version).number;
                n > r ? (o.warn("Plugin.register:", i.toString(t), "was upgraded to", i.toString(e)), i._registry[e.name] = e) : n < r ? o.warn("Plugin.register:", i.toString(t), "can not be downgraded to", i.toString(e)) : e !== t && o.warn("Plugin.register:", i.toString(e), "is already registered to different plugin object") } else i._registry[e.name] = e; return e }, i.resolve = function(e) { return i._registry[i.dependencyParse(e).name] }, i.toString = function(e) { return "string" == typeof e ? e : (e.name || "anonymous") + "@" + (e.version || e.range || "0.0.0") }, i.isPlugin = function(e) { return e && e.name && e.version && e.install }, i.isUsed = function(e, t) { return e.used.indexOf(t) > -1 }, i.isFor = function(e, t) { var n = e.for && i.dependencyParse(e.for); return !e.for || t.name === n.name && i.versionSatisfies(t.version, n.range) }, i.use = function(e, t) { if (e.uses = (e.uses || []).concat(t || []), 0 !== e.uses.length) { for (var n = i.dependencies(e), r = o.topologicalSort(n), a = [], s = 0; s < r.length; s += 1)
                    if (r[s] !== e.name) { var l = i.resolve(r[s]);
                        l ? i.isUsed(e, l.name) || (i.isFor(l, e) || (o.warn("Plugin.use:", i.toString(l), "is for", l.for, "but installed on", i.toString(e) + "."), l._warned = !0), l.install ? l.install(e) : (o.warn("Plugin.use:", i.toString(l), "does not specify an install function."), l._warned = !0), l._warned ? (a.push("🔶 " + i.toString(l)), delete l._warned) : a.push("✅ " + i.toString(l)), e.used.push(l.name)) : a.push("❌ " + r[s]) } a.length > 0 && o.info(a.join("  ")) } else o.warn("Plugin.use:", i.toString(e), "does not specify any dependencies to install.") }, i.dependencies = function(e, t) { var n = i.dependencyParse(e),
                r = n.name; if (!(r in (t = t || {}))) { e = i.resolve(e) || e, t[r] = o.map(e.uses || [], (function(t) { i.isPlugin(t) && i.register(t); var r = i.dependencyParse(t),
                        a = i.resolve(t); return a && !i.versionSatisfies(a.version, r.range) ? (o.warn("Plugin.dependencies:", i.toString(a), "does not satisfy", i.toString(r), "used by", i.toString(n) + "."), a._warned = !0, e._warned = !0) : a || (o.warn("Plugin.dependencies:", i.toString(t), "used by", i.toString(n), "could not be resolved."), e._warned = !0), r.name })); for (var a = 0; a < t[r].length; a += 1) i.dependencies(t[r][a], t); return t } }, i.dependencyParse = function(e) { return o.isString(e) ? (/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/.test(e) || o.warn("Plugin.dependencyParse:", e, "is not a valid dependency string."), { name: e.split("@")[0], range: e.split("@")[1] || "*" }) : { name: e.name, range: e.range || e.version } }, i.versionParse = function(e) { var t = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/;
            t.test(e) || o.warn("Plugin.versionParse:", e, "is not a valid version or range."); var n = t.exec(e),
                i = Number(n[4]),
                r = Number(n[5]),
                a = Number(n[6]); return { isRange: Boolean(n[1] || n[2]), version: n[3], range: e, operator: n[1] || n[2] || "", major: i, minor: r, patch: a, parts: [i, r, a], prerelease: n[7], number: 1e8 * i + 1e4 * r + a } }, i.versionSatisfies = function(e, t) { t = t || "*"; var n = i.versionParse(t),
                o = i.versionParse(e); if (n.isRange) { if ("*" === n.operator || "*" === e) return !0; if (">" === n.operator) return o.number > n.number; if (">=" === n.operator) return o.number >= n.number; if ("~" === n.operator) return o.major === n.major && o.minor === n.minor && o.patch >= n.patch; if ("^" === n.operator) return n.major > 0 ? o.major === n.major && o.number >= n.number : n.minor > 0 ? o.minor === n.minor && o.patch >= n.patch : o.patch === n.patch } return e === t || "*" === e } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(0),
            r = n(5),
            a = n(1),
            s = n(4),
            l = n(2),
            c = n(13);! function() { var e, t; "undefined" != typeof window && (e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(e) { window.setTimeout((function() { e(o.now()) }), 1e3 / 60) }, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), i._goodFps = 30, i._goodDelta = 1e3 / 60, i.create = function(e) { var t = { engine: null, element: null, canvas: null, mouse: null, frameRequestId: null, timing: { historySize: 60, delta: 0, deltaHistory: [], lastTime: 0, lastTimestamp: 0, lastElapsed: 0, timestampElapsed: 0, timestampElapsedHistory: [], engineDeltaHistory: [], engineElapsedHistory: [], elapsedHistory: [] }, options: { width: 800, height: 600, pixelRatio: 1, background: "#14151f", wireframeBackground: "#14151f", hasBounds: !!e.bounds, enabled: !0, wireframes: !0, showSleeping: !0, showDebug: !1, showStats: !1, showPerformance: !1, showBounds: !1, showVelocity: !1, showCollisions: !1, showSeparations: !1, showAxes: !1, showPositions: !1, showAngleIndicator: !1, showIds: !1, showVertexNumbers: !1, showConvexHulls: !1, showInternalEdges: !1, showMousePosition: !1 } },
                    n = o.extend(t, e); return n.canvas && (n.canvas.width = n.options.width || n.canvas.width, n.canvas.height = n.options.height || n.canvas.height), n.mouse = e.mouse, n.engine = e.engine, n.canvas = n.canvas || d(n.options.width, n.options.height), n.context = n.canvas.getContext("2d"), n.textures = {}, n.bounds = n.bounds || { min: { x: 0, y: 0 }, max: { x: n.canvas.width, y: n.canvas.height } }, n.controller = i, n.options.showBroadphase = !1, 1 !== n.options.pixelRatio && i.setPixelRatio(n, n.options.pixelRatio), o.isElement(n.element) && n.element.appendChild(n.canvas), n }, i.run = function(t) {! function o(r) { t.frameRequestId = e(o), n(t, r), i.world(t, r), (t.options.showStats || t.options.showDebug) && i.stats(t, t.context, r), (t.options.showPerformance || t.options.showDebug) && i.performance(t, t.context, r) }() }, i.stop = function(e) { t(e.frameRequestId) }, i.setPixelRatio = function(e, t) { var n = e.options,
                    i = e.canvas; "auto" === t && (t = p(i)), n.pixelRatio = t, i.setAttribute("data-pixel-ratio", t), i.width = n.width * t, i.height = n.height * t, i.style.width = n.width + "px", i.style.height = n.height + "px" }, i.lookAt = function(e, t, n, i) { i = void 0 === i || i, t = o.isArray(t) ? t : [t], n = n || { x: 0, y: 0 }; for (var r = { min: { x: 1 / 0, y: 1 / 0 }, max: { x: -1 / 0, y: -1 / 0 } }, a = 0; a < t.length; a += 1) { var s = t[a],
                        l = s.bounds ? s.bounds.min : s.min || s.position || s,
                        u = s.bounds ? s.bounds.max : s.max || s.position || s;
                    l && u && (l.x < r.min.x && (r.min.x = l.x), u.x > r.max.x && (r.max.x = u.x), l.y < r.min.y && (r.min.y = l.y), u.y > r.max.y && (r.max.y = u.y)) } var d = r.max.x - r.min.x + 2 * n.x,
                    p = r.max.y - r.min.y + 2 * n.y,
                    f = e.canvas.height,
                    v = e.canvas.width / f,
                    y = d / p,
                    m = 1,
                    g = 1;
                y > v ? g = y / v : m = v / y, e.options.hasBounds = !0, e.bounds.min.x = r.min.x, e.bounds.max.x = r.min.x + d * m, e.bounds.min.y = r.min.y, e.bounds.max.y = r.min.y + p * g, i && (e.bounds.min.x += .5 * d - d * m * .5, e.bounds.max.x += .5 * d - d * m * .5, e.bounds.min.y += .5 * p - p * g * .5, e.bounds.max.y += .5 * p - p * g * .5), e.bounds.min.x -= n.x, e.bounds.max.x -= n.x, e.bounds.min.y -= n.y, e.bounds.max.y -= n.y, e.mouse && (c.setScale(e.mouse, { x: (e.bounds.max.x - e.bounds.min.x) / e.canvas.width, y: (e.bounds.max.y - e.bounds.min.y) / e.canvas.height }), c.setOffset(e.mouse, e.bounds.min)) }, i.startViewTransform = function(e) { var t = e.bounds.max.x - e.bounds.min.x,
                    n = e.bounds.max.y - e.bounds.min.y,
                    i = t / e.options.width,
                    o = n / e.options.height;
                e.context.setTransform(e.options.pixelRatio / i, 0, 0, e.options.pixelRatio / o, 0, 0), e.context.translate(-e.bounds.min.x, -e.bounds.min.y) }, i.endViewTransform = function(e) { e.context.setTransform(e.options.pixelRatio, 0, 0, e.options.pixelRatio, 0, 0) }, i.world = function(e, t) { var n, u = o.now(),
                    d = e.engine,
                    p = d.world,
                    f = e.canvas,
                    y = e.context,
                    m = e.options,
                    g = e.timing,
                    x = r.allBodies(p),
                    h = r.allConstraints(p),
                    b = m.wireframes ? m.wireframeBackground : m.background,
                    S = [],
                    w = [],
                    A = { timestamp: d.timing.timestamp }; if (s.trigger(e, "beforeRender", A), e.currentBackground !== b && v(e, b), y.globalCompositeOperation = "source-in", y.fillStyle = "transparent", y.fillRect(0, 0, f.width, f.height), y.globalCompositeOperation = "source-over", m.hasBounds) { for (n = 0; n < x.length; n++) { var P = x[n];
                        a.overlaps(P.bounds, e.bounds) && S.push(P) } for (n = 0; n < h.length; n++) { var C = h[n],
                            B = C.bodyA,
                            M = C.bodyB,
                            k = C.pointA,
                            _ = C.pointB;
                        B && (k = l.add(B.position, C.pointA)), M && (_ = l.add(M.position, C.pointB)), k && _ && ((a.contains(e.bounds, k) || a.contains(e.bounds, _)) && w.push(C)) } i.startViewTransform(e), e.mouse && (c.setScale(e.mouse, { x: (e.bounds.max.x - e.bounds.min.x) / e.options.width, y: (e.bounds.max.y - e.bounds.min.y) / e.options.height }), c.setOffset(e.mouse, e.bounds.min)) } else w = h, S = x, 1 !== e.options.pixelRatio && e.context.setTransform(e.options.pixelRatio, 0, 0, e.options.pixelRatio, 0, 0);!m.wireframes || d.enableSleeping && m.showSleeping ? i.bodies(e, S, y) : (m.showConvexHulls && i.bodyConvexHulls(e, S, y), i.bodyWireframes(e, S, y)), m.showBounds && i.bodyBounds(e, S, y), (m.showAxes || m.showAngleIndicator) && i.bodyAxes(e, S, y), m.showPositions && i.bodyPositions(e, S, y), m.showVelocity && i.bodyVelocity(e, S, y), m.showIds && i.bodyIds(e, S, y), m.showSeparations && i.separations(e, d.pairs.list, y), m.showCollisions && i.collisions(e, d.pairs.list, y), m.showVertexNumbers && i.vertexNumbers(e, S, y), m.showMousePosition && i.mousePosition(e, e.mouse, y), i.constraints(w, y), m.hasBounds && i.endViewTransform(e), s.trigger(e, "afterRender", A), g.lastElapsed = o.now() - u }, i.stats = function(e, t, n) { for (var i = e.engine, o = i.world, a = r.allBodies(o), s = 0, l = 0, c = 0; c < a.length; c += 1) s += a[c].parts.length; var u = { Part: s, Body: a.length, Cons: r.allConstraints(o).length, Comp: r.allComposites(o).length, Pair: i.pairs.list.length }; for (var d in t.fillStyle = "#0e0f19", t.fillRect(l, 0, 302.5, 44), t.font = "12px Arial", t.textBaseline = "top", t.textAlign = "right", u) { var p = u[d];
                    t.fillStyle = "#aaa", t.fillText(d, l + 55, 8), t.fillStyle = "#eee", t.fillText(p, l + 55, 26), l += 55 } }, i.performance = function(e, t) { var n = e.engine,
                    o = e.timing,
                    r = o.deltaHistory,
                    a = o.elapsedHistory,
                    s = o.timestampElapsedHistory,
                    l = o.engineDeltaHistory,
                    c = o.engineElapsedHistory,
                    d = n.timing.lastDelta,
                    p = u(r),
                    f = u(a),
                    v = u(l),
                    y = u(c),
                    m = u(s) / p || 0,
                    g = 1e3 / p || 0;
                t.fillStyle = "#0e0f19", t.fillRect(0, 50, 370, 34), i.status(t, 10, 69, 60, 4, r.length, Math.round(g) + " fps", g / i._goodFps, (function(e) { return r[e] / p - 1 })), i.status(t, 82, 69, 60, 4, l.length, d.toFixed(2) + " dt", i._goodDelta / d, (function(e) { return l[e] / v - 1 })), i.status(t, 154, 69, 60, 4, c.length, y.toFixed(2) + " ut", 1 - y / i._goodFps, (function(e) { return c[e] / y - 1 })), i.status(t, 226, 69, 60, 4, a.length, f.toFixed(2) + " rt", 1 - f / i._goodFps, (function(e) { return a[e] / f - 1 })), i.status(t, 298, 69, 60, 4, s.length, m.toFixed(2) + " x", m * m * m, (function(e) { return (s[e] / r[e] / m || 0) - 1 })) }, i.status = function(e, t, n, i, r, a, s, l, c) { e.strokeStyle = "#888", e.fillStyle = "#444", e.lineWidth = 1, e.fillRect(t, n + 7, i, 1), e.beginPath(), e.moveTo(t, n + 7 - r * o.clamp(.4 * c(0), -2, 2)); for (var u = 0; u < i; u += 1) e.lineTo(t + u, n + 7 - (u < a ? r * o.clamp(.4 * c(u), -2, 2) : 0));
                e.stroke(), e.fillStyle = "hsl(" + o.clamp(25 + 95 * l, 0, 120) + ",100%,60%)", e.fillRect(t, n - 7, 4, 4), e.font = "12px Arial", e.textBaseline = "middle", e.textAlign = "right", e.fillStyle = "#eee", e.fillText(s, t + i, n - 5) }, i.constraints = function(e, t) { for (var n = t, i = 0; i < e.length; i++) { var r = e[i]; if (r.render.visible && r.pointA && r.pointB) { var a, s, c = r.bodyA,
                            u = r.bodyB; if (a = c ? l.add(c.position, r.pointA) : r.pointA, "pin" === r.render.type) n.beginPath(), n.arc(a.x, a.y, 3, 0, 2 * Math.PI), n.closePath();
                        else { if (s = u ? l.add(u.position, r.pointB) : r.pointB, n.beginPath(), n.moveTo(a.x, a.y), "spring" === r.render.type)
                                for (var d, p = l.sub(s, a), f = l.perp(l.normalise(p)), v = Math.ceil(o.clamp(r.length / 5, 12, 20)), y = 1; y < v; y += 1) d = y % 2 == 0 ? 1 : -1, n.lineTo(a.x + p.x * (y / v) + f.x * d * 4, a.y + p.y * (y / v) + f.y * d * 4);
                            n.lineTo(s.x, s.y) } r.render.lineWidth && (n.lineWidth = r.render.lineWidth, n.strokeStyle = r.render.strokeStyle, n.stroke()), r.render.anchors && (n.fillStyle = r.render.strokeStyle, n.beginPath(), n.arc(a.x, a.y, 3, 0, 2 * Math.PI), n.arc(s.x, s.y, 3, 0, 2 * Math.PI), n.closePath(), n.fill()) } } }, i.bodies = function(e, t, n) { var i, o, r, a, s = n,
                    l = (e.engine, e.options),
                    c = l.showInternalEdges || !l.wireframes; for (r = 0; r < t.length; r++)
                    if ((i = t[r]).render.visible)
                        for (a = i.parts.length > 1 ? 1 : 0; a < i.parts.length; a++)
                            if ((o = i.parts[a]).render.visible) { if (l.showSleeping && i.isSleeping ? s.globalAlpha = .5 * o.render.opacity : 1 !== o.render.opacity && (s.globalAlpha = o.render.opacity), o.render.sprite && o.render.sprite.texture && !l.wireframes) { var u = o.render.sprite,
                                        d = f(e, u.texture);
                                    s.translate(o.position.x, o.position.y), s.rotate(o.angle), s.drawImage(d, d.width * -u.xOffset * u.xScale, d.height * -u.yOffset * u.yScale, d.width * u.xScale, d.height * u.yScale), s.rotate(-o.angle), s.translate(-o.position.x, -o.position.y) } else { if (o.circleRadius) s.beginPath(), s.arc(o.position.x, o.position.y, o.circleRadius, 0, 2 * Math.PI);
                                    else { s.beginPath(), s.moveTo(o.vertices[0].x, o.vertices[0].y); for (var p = 1; p < o.vertices.length; p++) !o.vertices[p - 1].isInternal || c ? s.lineTo(o.vertices[p].x, o.vertices[p].y) : s.moveTo(o.vertices[p].x, o.vertices[p].y), o.vertices[p].isInternal && !c && s.moveTo(o.vertices[(p + 1) % o.vertices.length].x, o.vertices[(p + 1) % o.vertices.length].y);
                                        s.lineTo(o.vertices[0].x, o.vertices[0].y), s.closePath() } l.wireframes ? (s.lineWidth = 1, s.strokeStyle = "#bbb", s.stroke()) : (s.fillStyle = o.render.fillStyle, o.render.lineWidth && (s.lineWidth = o.render.lineWidth, s.strokeStyle = o.render.strokeStyle, s.stroke()), s.fill()) } s.globalAlpha = 1 } }, i.bodyWireframes = function(e, t, n) { var i, o, r, a, s, l = n,
                    c = e.options.showInternalEdges; for (l.beginPath(), r = 0; r < t.length; r++)
                    if ((i = t[r]).render.visible)
                        for (s = i.parts.length > 1 ? 1 : 0; s < i.parts.length; s++) { for (o = i.parts[s], l.moveTo(o.vertices[0].x, o.vertices[0].y), a = 1; a < o.vertices.length; a++) !o.vertices[a - 1].isInternal || c ? l.lineTo(o.vertices[a].x, o.vertices[a].y) : l.moveTo(o.vertices[a].x, o.vertices[a].y), o.vertices[a].isInternal && !c && l.moveTo(o.vertices[(a + 1) % o.vertices.length].x, o.vertices[(a + 1) % o.vertices.length].y);
                            l.lineTo(o.vertices[0].x, o.vertices[0].y) } l.lineWidth = 1, l.strokeStyle = "#bbb", l.stroke() }, i.bodyConvexHulls = function(e, t, n) { var i, o, r, a = n; for (a.beginPath(), o = 0; o < t.length; o++)
                    if ((i = t[o]).render.visible && 1 !== i.parts.length) { for (a.moveTo(i.vertices[0].x, i.vertices[0].y), r = 1; r < i.vertices.length; r++) a.lineTo(i.vertices[r].x, i.vertices[r].y);
                        a.lineTo(i.vertices[0].x, i.vertices[0].y) } a.lineWidth = 1, a.strokeStyle = "rgba(255,255,255,0.2)", a.stroke() }, i.vertexNumbers = function(e, t, n) { var i, o, r, a = n; for (i = 0; i < t.length; i++) { var s = t[i].parts; for (r = s.length > 1 ? 1 : 0; r < s.length; r++) { var l = s[r]; for (o = 0; o < l.vertices.length; o++) a.fillStyle = "rgba(255,255,255,0.2)", a.fillText(i + "_" + o, l.position.x + .8 * (l.vertices[o].x - l.position.x), l.position.y + .8 * (l.vertices[o].y - l.position.y)) } } }, i.mousePosition = function(e, t, n) { var i = n;
                i.fillStyle = "rgba(255,255,255,0.8)", i.fillText(t.position.x + "  " + t.position.y, t.position.x + 5, t.position.y - 5) }, i.bodyBounds = function(e, t, n) { var i = n,
                    o = (e.engine, e.options);
                i.beginPath(); for (var r = 0; r < t.length; r++) { if (t[r].render.visible)
                        for (var a = t[r].parts, s = a.length > 1 ? 1 : 0; s < a.length; s++) { var l = a[s];
                            i.rect(l.bounds.min.x, l.bounds.min.y, l.bounds.max.x - l.bounds.min.x, l.bounds.max.y - l.bounds.min.y) } } o.wireframes ? i.strokeStyle = "rgba(255,255,255,0.08)" : i.strokeStyle = "rgba(0,0,0,0.1)", i.lineWidth = 1, i.stroke() }, i.bodyAxes = function(e, t, n) { var i, o, r, a, s = n,
                    l = (e.engine, e.options); for (s.beginPath(), o = 0; o < t.length; o++) { var c = t[o],
                        u = c.parts; if (c.render.visible)
                        if (l.showAxes)
                            for (r = u.length > 1 ? 1 : 0; r < u.length; r++)
                                for (i = u[r], a = 0; a < i.axes.length; a++) { var d = i.axes[a];
                                    s.moveTo(i.position.x, i.position.y), s.lineTo(i.position.x + 20 * d.x, i.position.y + 20 * d.y) } else
                                    for (r = u.length > 1 ? 1 : 0; r < u.length; r++)
                                        for (i = u[r], a = 0; a < i.axes.length; a++) s.moveTo(i.position.x, i.position.y), s.lineTo((i.vertices[0].x + i.vertices[i.vertices.length - 1].x) / 2, (i.vertices[0].y + i.vertices[i.vertices.length - 1].y) / 2) } l.wireframes ? (s.strokeStyle = "indianred", s.lineWidth = 1) : (s.strokeStyle = "rgba(255, 255, 255, 0.4)", s.globalCompositeOperation = "overlay", s.lineWidth = 2), s.stroke(), s.globalCompositeOperation = "source-over" }, i.bodyPositions = function(e, t, n) { var i, o, r, a, s = n,
                    l = (e.engine, e.options); for (s.beginPath(), r = 0; r < t.length; r++)
                    if ((i = t[r]).render.visible)
                        for (a = 0; a < i.parts.length; a++) o = i.parts[a], s.arc(o.position.x, o.position.y, 3, 0, 2 * Math.PI, !1), s.closePath(); for (l.wireframes ? s.fillStyle = "indianred" : s.fillStyle = "rgba(0,0,0,0.5)", s.fill(), s.beginPath(), r = 0; r < t.length; r++)(i = t[r]).render.visible && (s.arc(i.positionPrev.x, i.positionPrev.y, 2, 0, 2 * Math.PI, !1), s.closePath());
                s.fillStyle = "rgba(255,165,0,0.8)", s.fill() }, i.bodyVelocity = function(e, t, n) { var i = n;
                i.beginPath(); for (var o = 0; o < t.length; o++) { var r = t[o];
                    r.render.visible && (i.moveTo(r.position.x, r.position.y), i.lineTo(r.position.x + 2 * (r.position.x - r.positionPrev.x), r.position.y + 2 * (r.position.y - r.positionPrev.y))) } i.lineWidth = 3, i.strokeStyle = "cornflowerblue", i.stroke() }, i.bodyIds = function(e, t, n) { var i, o, r = n; for (i = 0; i < t.length; i++)
                    if (t[i].render.visible) { var a = t[i].parts; for (o = a.length > 1 ? 1 : 0; o < a.length; o++) { var s = a[o];
                            r.font = "12px Arial", r.fillStyle = "rgba(255,255,255,0.5)", r.fillText(s.id, s.position.x + 10, s.position.y - 10) } } }, i.collisions = function(e, t, n) { var i, o, r, a, s = n,
                    l = e.options; for (s.beginPath(), r = 0; r < t.length; r++)
                    if ((i = t[r]).isActive)
                        for (o = i.collision, a = 0; a < i.activeContacts.length; a++) { var c = i.activeContacts[a].vertex;
                            s.rect(c.x - 1.5, c.y - 1.5, 3.5, 3.5) }
                for (l.wireframes ? s.fillStyle = "rgba(255,255,255,0.7)" : s.fillStyle = "orange", s.fill(), s.beginPath(), r = 0; r < t.length; r++)
                    if ((i = t[r]).isActive && (o = i.collision, i.activeContacts.length > 0)) { var u = i.activeContacts[0].vertex.x,
                            d = i.activeContacts[0].vertex.y;
                        2 === i.activeContacts.length && (u = (i.activeContacts[0].vertex.x + i.activeContacts[1].vertex.x) / 2, d = (i.activeContacts[0].vertex.y + i.activeContacts[1].vertex.y) / 2), o.bodyB === o.supports[0].body || !0 === o.bodyA.isStatic ? s.moveTo(u - 8 * o.normal.x, d - 8 * o.normal.y) : s.moveTo(u + 8 * o.normal.x, d + 8 * o.normal.y), s.lineTo(u, d) } l.wireframes ? s.strokeStyle = "rgba(255,165,0,0.7)" : s.strokeStyle = "orange", s.lineWidth = 1, s.stroke() }, i.separations = function(e, t, n) { var i, o, r, a, s, l = n,
                    c = e.options; for (l.beginPath(), s = 0; s < t.length; s++)
                    if ((i = t[s]).isActive) { r = (o = i.collision).bodyA; var u = 1;
                        (a = o.bodyB).isStatic || r.isStatic || (u = .5), a.isStatic && (u = 0), l.moveTo(a.position.x, a.position.y), l.lineTo(a.position.x - o.penetration.x * u, a.position.y - o.penetration.y * u), u = 1, a.isStatic || r.isStatic || (u = .5), r.isStatic && (u = 0), l.moveTo(r.position.x, r.position.y), l.lineTo(r.position.x + o.penetration.x * u, r.position.y + o.penetration.y * u) } c.wireframes ? l.strokeStyle = "rgba(255,165,0,0.5)" : l.strokeStyle = "orange", l.stroke() }, i.inspector = function(e, t) { e.engine; var n, i = e.selected,
                    o = e.render,
                    r = o.options; if (r.hasBounds) { var a = o.bounds.max.x - o.bounds.min.x,
                        s = o.bounds.max.y - o.bounds.min.y,
                        l = a / o.options.width,
                        c = s / o.options.height;
                    t.scale(1 / l, 1 / c), t.translate(-o.bounds.min.x, -o.bounds.min.y) } for (var u = 0; u < i.length; u++) { var d = i[u].data; switch (t.translate(.5, .5), t.lineWidth = 1, t.strokeStyle = "rgba(255,165,0,0.9)", t.setLineDash([1, 2]), d.type) {
                        case "body":
                            n = d.bounds, t.beginPath(), t.rect(Math.floor(n.min.x - 3), Math.floor(n.min.y - 3), Math.floor(n.max.x - n.min.x + 6), Math.floor(n.max.y - n.min.y + 6)), t.closePath(), t.stroke(); break;
                        case "constraint":
                            var p = d.pointA;
                            d.bodyA && (p = d.pointB), t.beginPath(), t.arc(p.x, p.y, 10, 0, 2 * Math.PI), t.closePath(), t.stroke() } t.setLineDash([]), t.translate(-.5, -.5) } null !== e.selectStart && (t.translate(.5, .5), t.lineWidth = 1, t.strokeStyle = "rgba(255,165,0,0.6)", t.fillStyle = "rgba(255,165,0,0.1)", n = e.selectBounds, t.beginPath(), t.rect(Math.floor(n.min.x), Math.floor(n.min.y), Math.floor(n.max.x - n.min.x), Math.floor(n.max.y - n.min.y)), t.closePath(), t.stroke(), t.fill(), t.translate(-.5, -.5)), r.hasBounds && t.setTransform(1, 0, 0, 1, 0, 0) }; var n = function(e, t) { var n = e.engine,
                        o = e.timing,
                        r = o.historySize,
                        a = n.timing.timestamp;
                    o.delta = t - o.lastTime || i._goodDelta, o.lastTime = t, o.timestampElapsed = a - o.lastTimestamp || 0, o.lastTimestamp = a, o.deltaHistory.unshift(o.delta), o.deltaHistory.length = Math.min(o.deltaHistory.length, r), o.engineDeltaHistory.unshift(n.timing.lastDelta), o.engineDeltaHistory.length = Math.min(o.engineDeltaHistory.length, r), o.timestampElapsedHistory.unshift(o.timestampElapsed), o.timestampElapsedHistory.length = Math.min(o.timestampElapsedHistory.length, r), o.engineElapsedHistory.unshift(n.timing.lastElapsed), o.engineElapsedHistory.length = Math.min(o.engineElapsedHistory.length, r), o.elapsedHistory.unshift(o.lastElapsed), o.elapsedHistory.length = Math.min(o.elapsedHistory.length, r) },
                u = function(e) { for (var t = 0, n = 0; n < e.length; n += 1) t += e[n]; return t / e.length || 0 },
                d = function(e, t) { var n = document.createElement("canvas"); return n.width = e, n.height = t, n.oncontextmenu = function() { return !1 }, n.onselectstart = function() { return !1 }, n },
                p = function(e) { var t = e.getContext("2d"); return (window.devicePixelRatio || 1) / (t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1) },
                f = function(e, t) { var n = e.textures[t]; return n || ((n = e.textures[t] = new Image).src = t, n) },
                v = function(e, t) { var n = t; /(jpg|gif|png)$/.test(t) && (n = "url(" + t + ")"), e.canvas.style.background = n, e.canvas.style.backgroundSize = "contain", e.currentBackground = t } }() }, function(e, t) { var n = {};
        e.exports = n, n.create = function(e) { return { vertex: e, normalImpulse: 0, tangentImpulse: 0 } } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(7),
            r = n(19),
            a = n(14),
            s = n(20),
            l = n(4),
            c = n(5),
            u = n(10),
            d = n(0),
            p = n(6);
        i.create = function(e) { e = e || {}; var t = d.extend({ positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], plugin: {}, gravity: { x: 0, y: 1, scale: .001 }, timing: { timestamp: 0, timeScale: 1, lastDelta: 0, lastElapsed: 0 } }, e); return t.world = e.world || c.create({ label: "World" }), t.pairs = e.pairs || s.create(), t.detector = e.detector || a.create(), t.grid = { buckets: [] }, t.world.gravity = t.gravity, t.broadphase = t.grid, t.metrics = {}, t }, i.update = function(e, t, n) { var p = d.now();
            t = t || 1e3 / 60, n = n || 1; var f, v = e.world,
                y = e.detector,
                m = e.pairs,
                g = e.timing,
                x = g.timestamp;
            g.timestamp += t * g.timeScale, g.lastDelta = t * g.timeScale; var h = { timestamp: g.timestamp };
            l.trigger(e, "beforeUpdate", h); var b = c.allBodies(v),
                S = c.allConstraints(v); for (v.isModified && a.setBodies(y, b), v.isModified && c.setModified(v, !1, !1, !0), e.enableSleeping && o.update(b, g.timeScale), i._bodiesApplyGravity(b, e.gravity), i._bodiesUpdate(b, t, g.timeScale, n, v.bounds), u.preSolveAll(b), f = 0; f < e.constraintIterations; f++) u.solveAll(S, g.timeScale);
            u.postSolveAll(b), y.pairs = e.pairs; var w = a.collisions(y); for (s.update(m, w, x), e.enableSleeping && o.afterCollisions(m.list, g.timeScale), m.collisionStart.length > 0 && l.trigger(e, "collisionStart", { pairs: m.collisionStart }), r.preSolvePosition(m.list), f = 0; f < e.positionIterations; f++) r.solvePosition(m.list, g.timeScale); for (r.postSolvePosition(b), u.preSolveAll(b), f = 0; f < e.constraintIterations; f++) u.solveAll(S, g.timeScale); for (u.postSolveAll(b), r.preSolveVelocity(m.list), f = 0; f < e.velocityIterations; f++) r.solveVelocity(m.list, g.timeScale); return m.collisionActive.length > 0 && l.trigger(e, "collisionActive", { pairs: m.collisionActive }), m.collisionEnd.length > 0 && l.trigger(e, "collisionEnd", { pairs: m.collisionEnd }), i._bodiesClearForces(b), l.trigger(e, "afterUpdate", h), e.timing.lastElapsed = d.now() - p, e }, i.merge = function(e, t) { if (d.extend(e, t), t.world) { e.world = t.world, i.clear(e); for (var n = c.allBodies(e.world), r = 0; r < n.length; r++) { var a = n[r];
                    o.set(a, !1), a.id = d.nextId() } } }, i.clear = function(e) { s.clear(e.pairs), a.clear(e.detector) }, i._bodiesClearForces = function(e) { for (var t = 0; t < e.length; t++) { var n = e[t];
                n.force.x = 0, n.force.y = 0, n.torque = 0 } }, i._bodiesApplyGravity = function(e, t) { var n = void 0 !== t.scale ? t.scale : .001; if ((0 !== t.x || 0 !== t.y) && 0 !== n)
                for (var i = 0; i < e.length; i++) { var o = e[i];
                    o.isStatic || o.isSleeping || (o.force.y += o.mass * t.y * n, o.force.x += o.mass * t.x * n) } }, i._bodiesUpdate = function(e, t, n, i, o) { for (var r = 0; r < e.length; r++) { var a = e[r];
                a.isStatic || a.isSleeping || p.update(a, t, n, i) } } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(3),
            r = n(1);
        i._restingThresh = 4, i._restingThreshTangent = 6, i._positionDampen = .9, i._positionWarming = .8, i._frictionNormalMultiplier = 5, i.preSolvePosition = function(e) { var t, n, i, o = e.length; for (t = 0; t < o; t++)(n = e[t]).isActive && (i = n.activeContacts.length, n.collision.parentA.totalContacts += i, n.collision.parentB.totalContacts += i) }, i.solvePosition = function(e, t) { var n, o, r, a, s, l, c, u, d = i._positionDampen,
                p = e.length; for (n = 0; n < p; n++)(o = e[n]).isActive && !o.isSensor && (a = (r = o.collision).parentA, s = r.parentB, l = r.normal, o.separation = l.x * (s.positionImpulse.x + r.penetration.x - a.positionImpulse.x) + l.y * (s.positionImpulse.y + r.penetration.y - a.positionImpulse.y)); for (n = 0; n < p; n++)(o = e[n]).isActive && !o.isSensor && (a = (r = o.collision).parentA, s = r.parentB, l = r.normal, u = (o.separation - o.slop) * t, (a.isStatic || s.isStatic) && (u *= 2), a.isStatic || a.isSleeping || (c = d / a.totalContacts, a.positionImpulse.x += l.x * u * c, a.positionImpulse.y += l.y * u * c), s.isStatic || s.isSleeping || (c = d / s.totalContacts, s.positionImpulse.x -= l.x * u * c, s.positionImpulse.y -= l.y * u * c)) }, i.postSolvePosition = function(e) { for (var t = i._positionWarming, n = e.length, a = o.translate, s = r.update, l = 0; l < n; l++) { var c = e[l],
                    u = c.positionImpulse,
                    d = u.x,
                    p = u.y,
                    f = c.velocity; if (c.totalContacts = 0, 0 !== d || 0 !== p) { for (var v = 0; v < c.parts.length; v++) { var y = c.parts[v];
                        a(y.vertices, u), s(y.bounds, y.vertices, f), y.position.x += d, y.position.y += p } c.positionPrev.x += d, c.positionPrev.y += p, d * f.x + p * f.y < 0 ? (u.x = 0, u.y = 0) : (u.x *= t, u.y *= t) } } }, i.preSolveVelocity = function(e) { var t, n, i = e.length; for (t = 0; t < i; t++) { var o = e[t]; if (o.isActive && !o.isSensor) { var r = o.activeContacts,
                        a = r.length,
                        s = o.collision,
                        l = s.parentA,
                        c = s.parentB,
                        u = s.normal,
                        d = s.tangent; for (n = 0; n < a; n++) { var p = r[n],
                            f = p.vertex,
                            v = p.normalImpulse,
                            y = p.tangentImpulse; if (0 !== v || 0 !== y) { var m = u.x * v + d.x * y,
                                g = u.y * v + d.y * y;
                            l.isStatic || l.isSleeping || (l.positionPrev.x += m * l.inverseMass, l.positionPrev.y += g * l.inverseMass, l.anglePrev += l.inverseInertia * ((f.x - l.position.x) * g - (f.y - l.position.y) * m)), c.isStatic || c.isSleeping || (c.positionPrev.x -= m * c.inverseMass, c.positionPrev.y -= g * c.inverseMass, c.anglePrev -= c.inverseInertia * ((f.x - c.position.x) * g - (f.y - c.position.y) * m)) } } } } }, i.solveVelocity = function(e, t) { var n, o, r, a, s = t * t,
                l = i._restingThresh * s,
                c = i._frictionNormalMultiplier,
                u = i._restingThreshTangent * s,
                d = Number.MAX_VALUE,
                p = e.length; for (r = 0; r < p; r++) { var f = e[r]; if (f.isActive && !f.isSensor) { var v = f.collision,
                        y = v.parentA,
                        m = v.parentB,
                        g = y.velocity,
                        x = m.velocity,
                        h = v.normal.x,
                        b = v.normal.y,
                        S = v.tangent.x,
                        w = v.tangent.y,
                        A = f.activeContacts,
                        P = A.length,
                        C = 1 / P,
                        B = y.inverseMass + m.inverseMass,
                        M = f.friction * f.frictionStatic * c * s; for (g.x = y.position.x - y.positionPrev.x, g.y = y.position.y - y.positionPrev.y, x.x = m.position.x - m.positionPrev.x, x.y = m.position.y - m.positionPrev.y, y.angularVelocity = y.angle - y.anglePrev, m.angularVelocity = m.angle - m.anglePrev, a = 0; a < P; a++) { var k = A[a],
                            _ = k.vertex,
                            I = _.x - y.position.x,
                            T = _.y - y.position.y,
                            R = _.x - m.position.x,
                            E = _.y - m.position.y,
                            V = g.x - T * y.angularVelocity,
                            L = g.y + I * y.angularVelocity,
                            O = V - (x.x - E * m.angularVelocity),
                            D = L - (x.y + R * m.angularVelocity),
                            F = h * O + b * D,
                            H = S * O + w * D,
                            j = f.separation + F,
                            q = Math.min(j, 1),
                            W = (q = j < 0 ? 0 : q) * M;
                        H > W || -H > W ? (o = H > 0 ? H : -H, (n = f.friction * (H > 0 ? 1 : -1) * s) < -o ? n = -o : n > o && (n = o)) : (n = H, o = d); var G = I * b - T * h,
                            N = R * b - E * h,
                            U = C / (B + y.inverseInertia * G * G + m.inverseInertia * N * N),
                            z = (1 + f.restitution) * F * U; if (n *= U, F * F > l && F < 0) k.normalImpulse = 0;
                        else { var X = k.normalImpulse;
                            k.normalImpulse += z, k.normalImpulse = Math.min(k.normalImpulse, 0), z = k.normalImpulse - X } if (H * H > u) k.tangentImpulse = 0;
                        else { var Q = k.tangentImpulse;
                            k.tangentImpulse += n, k.tangentImpulse < -o && (k.tangentImpulse = -o), k.tangentImpulse > o && (k.tangentImpulse = o), n = k.tangentImpulse - Q } var Y = h * z + S * n,
                            Z = b * z + w * n;
                        y.isStatic || y.isSleeping || (y.positionPrev.x += Y * y.inverseMass, y.positionPrev.y += Z * y.inverseMass, y.anglePrev += (I * Z - T * Y) * y.inverseInertia), m.isStatic || m.isSleeping || (m.positionPrev.x -= Y * m.inverseMass, m.positionPrev.y -= Z * m.inverseMass, m.anglePrev -= (R * Z - E * Y) * m.inverseInertia) } } } } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(9),
            r = n(0);
        i.create = function(e) { return r.extend({ table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [] }, e) }, i.update = function(e, t, n) { var i, r, a, s, l, c, u = e.list,
                d = u.length,
                p = e.table,
                f = t.length,
                v = e.collisionStart,
                y = e.collisionEnd,
                m = e.collisionActive; for (v.length = 0, y.length = 0, m.length = 0, c = 0; c < d; c++) u[c].confirmedActive = !1; for (c = 0; c < f; c++)(l = (i = t[c]).pair) ? (l.isActive ? m.push(l) : v.push(l), o.update(l, i, n), l.confirmedActive = !0) : (p[(l = o.create(i, n)).id] = l, v.push(l), u.push(l)); var g = []; for (d = u.length, c = 0; c < d; c++)(l = u[c]).confirmedActive || (r = l.collision.bodyA, a = l.collision.bodyB, (!r.isSleeping && !r.isStatic || !a.isSleeping && !a.isStatic || r.isStatic && a.isStatic) && (o.setActive(l, !1, n), y.push(l), g.push(c))); for (c = 0; c < g.length; c++) l = u[s = g[c] - c], u.splice(s, 1), delete p[l.id] }, i.clear = function(e) { return e.table = {}, e.list.length = 0, e.collisionStart.length = 0, e.collisionActive.length = 0, e.collisionEnd.length = 0, e } }, function(e, t, n) { var i = e.exports = n(22);
        i.Axes = n(11), i.Bodies = n(12), i.Body = n(6), i.Bounds = n(1), i.Collision = n(8), i.Common = n(0), i.Composite = n(5), i.Composites = n(23), i.Constraint = n(10), i.Contact = n(17), i.Detector = n(14), i.Engine = n(18), i.Events = n(4), i.Grid = n(24), i.Mouse = n(13), i.MouseConstraint = n(25), i.Pair = n(9), i.Pairs = n(20), i.Plugin = n(15), i.Query = n(26), i.Render = n(16), i.Resolver = n(19), i.Runner = n(27), i.SAT = n(28), i.Sleeping = n(7), i.Svg = n(29), i.Vector = n(2), i.Vertices = n(3), i.World = n(30), i.Engine.run = i.Runner.run, i.Common.deprecated(i.Engine, "run", "Engine.run ➤ use Matter.Runner.run(engine) instead") }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(15),
            r = n(0);
        i.name = "matter-js", i.version = "0.18.0-alpha+0eeceb5", i.uses = [], i.used = [], i.use = function() { o.use(i, Array.prototype.slice.call(arguments)) }, i.before = function(e, t) { return e = e.replace(/^Matter./, ""), r.chainPathBefore(i, e, t) }, i.after = function(e, t) { return e = e.replace(/^Matter./, ""), r.chainPathAfter(i, e, t) } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(5),
            r = n(10),
            a = n(0),
            s = n(6),
            l = n(12),
            c = a.deprecated;
        i.stack = function(e, t, n, i, r, a, l) { for (var c, u = o.create({ label: "Stack" }), d = e, p = t, f = 0, v = 0; v < i; v++) { for (var y = 0, m = 0; m < n; m++) { var g = l(d, p, m, v, c, f); if (g) { var x = g.bounds.max.y - g.bounds.min.y,
                            h = g.bounds.max.x - g.bounds.min.x;
                        x > y && (y = x), s.translate(g, { x: .5 * h, y: .5 * x }), d = g.bounds.max.x + r, o.addBody(u, g), c = g, f += 1 } else d += r } p += y + a, d = e } return u }, i.chain = function(e, t, n, i, s, l) { for (var c = e.bodies, u = 1; u < c.length; u++) { var d = c[u - 1],
                    p = c[u],
                    f = d.bounds.max.y - d.bounds.min.y,
                    v = d.bounds.max.x - d.bounds.min.x,
                    y = p.bounds.max.y - p.bounds.min.y,
                    m = { bodyA: d, pointA: { x: v * t, y: f * n }, bodyB: p, pointB: { x: (p.bounds.max.x - p.bounds.min.x) * i, y: y * s } },
                    g = a.extend(m, l);
                o.addConstraint(e, r.create(g)) } return e.label += " Chain", e }, i.mesh = function(e, t, n, i, s) { var l, c, u, d, p, f = e.bodies; for (l = 0; l < n; l++) { for (c = 1; c < t; c++) u = f[c - 1 + l * t], d = f[c + l * t], o.addConstraint(e, r.create(a.extend({ bodyA: u, bodyB: d }, s))); if (l > 0)
                    for (c = 0; c < t; c++) u = f[c + (l - 1) * t], d = f[c + l * t], o.addConstraint(e, r.create(a.extend({ bodyA: u, bodyB: d }, s))), i && c > 0 && (p = f[c - 1 + (l - 1) * t], o.addConstraint(e, r.create(a.extend({ bodyA: p, bodyB: d }, s)))), i && c < t - 1 && (p = f[c + 1 + (l - 1) * t], o.addConstraint(e, r.create(a.extend({ bodyA: p, bodyB: d }, s)))) } return e.label += " Mesh", e }, i.pyramid = function(e, t, n, o, r, a, l) { return i.stack(e, t, n, o, r, a, (function(t, i, a, c, u, d) { var p = Math.min(o, Math.ceil(n / 2)),
                    f = u ? u.bounds.max.x - u.bounds.min.x : 0; if (!(c > p || a < (c = p - c) || a > n - 1 - c)) return 1 === d && s.translate(u, { x: (a + (n % 2 == 1 ? 1 : -1)) * f, y: 0 }), l(e + (u ? a * f : 0) + a * r, i, a, c, u, d) })) }, i.newtonsCradle = function(e, t, n, i, a) { for (var s = o.create({ label: "Newtons Cradle" }), c = 0; c < n; c++) { var u = l.circle(e + c * (1.9 * i), t + a, i, { inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }),
                    d = r.create({ pointA: { x: e + c * (1.9 * i), y: t }, bodyB: u });
                o.addBody(s, u), o.addConstraint(s, d) } return s }, c(i, "newtonsCradle", "Composites.newtonsCradle ➤ moved to newtonsCradle example"), i.car = function(e, t, n, i, a) { var c = s.nextGroup(!0),
                u = .5 * -n + 20,
                d = .5 * n - 20,
                p = o.create({ label: "Car" }),
                f = l.rectangle(e, t, n, i, { collisionFilter: { group: c }, chamfer: { radius: .5 * i }, density: 2e-4 }),
                v = l.circle(e + u, t + 0, a, { collisionFilter: { group: c }, friction: .8 }),
                y = l.circle(e + d, t + 0, a, { collisionFilter: { group: c }, friction: .8 }),
                m = r.create({ bodyB: f, pointB: { x: u, y: 0 }, bodyA: v, stiffness: 1, length: 0 }),
                g = r.create({ bodyB: f, pointB: { x: d, y: 0 }, bodyA: y, stiffness: 1, length: 0 }); return o.addBody(p, f), o.addBody(p, v), o.addBody(p, y), o.addConstraint(p, m), o.addConstraint(p, g), p }, c(i, "car", "Composites.car ➤ moved to car example"), i.softBody = function(e, t, n, o, r, s, c, u, d, p) { d = a.extend({ inertia: 1 / 0 }, d), p = a.extend({ stiffness: .2, render: { type: "line", anchors: !1 } }, p); var f = i.stack(e, t, n, o, r, s, (function(e, t) { return l.circle(e, t, u, d) })); return i.mesh(f, n, o, c, p), f.label = "Soft Body", f }, c(i, "softBody", "Composites.softBody ➤ moved to softBody and cloth examples") }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(9),
            r = n(0),
            a = r.deprecated;
        i.create = function(e) { return r.extend({ buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48 }, e) }, i.update = function(e, t, n, o) { var r, a, s, l, c, u = n.world,
                d = e.buckets,
                p = !1; for (r = 0; r < t.length; r++) { var f = t[r]; if ((!f.isSleeping || o) && (!u.bounds || !(f.bounds.max.x < u.bounds.min.x || f.bounds.min.x > u.bounds.max.x || f.bounds.max.y < u.bounds.min.y || f.bounds.min.y > u.bounds.max.y))) { var v = i._getRegion(e, f); if (!f.region || v.id !== f.region.id || o) { f.region && !o || (f.region = v); var y = i._regionUnion(v, f.region); for (a = y.startCol; a <= y.endCol; a++)
                            for (s = y.startRow; s <= y.endRow; s++) { l = d[c = i._getBucketId(a, s)]; var m = a >= v.startCol && a <= v.endCol && s >= v.startRow && s <= v.endRow,
                                    g = a >= f.region.startCol && a <= f.region.endCol && s >= f.region.startRow && s <= f.region.endRow;!m && g && g && l && i._bucketRemoveBody(e, l, f), (f.region === v || m && !g || o) && (l || (l = i._createBucket(d, c)), i._bucketAddBody(e, l, f)) } f.region = v, p = !0 } } } p && (e.pairsList = i._createActivePairsList(e)) }, a(i, "update", "Grid.update ➤ replaced by Matter.Detector"), i.clear = function(e) { e.buckets = {}, e.pairs = {}, e.pairsList = [] }, a(i, "clear", "Grid.clear ➤ replaced by Matter.Detector"), i._regionUnion = function(e, t) { var n = Math.min(e.startCol, t.startCol),
                o = Math.max(e.endCol, t.endCol),
                r = Math.min(e.startRow, t.startRow),
                a = Math.max(e.endRow, t.endRow); return i._createRegion(n, o, r, a) }, i._getRegion = function(e, t) { var n = t.bounds,
                o = Math.floor(n.min.x / e.bucketWidth),
                r = Math.floor(n.max.x / e.bucketWidth),
                a = Math.floor(n.min.y / e.bucketHeight),
                s = Math.floor(n.max.y / e.bucketHeight); return i._createRegion(o, r, a, s) }, i._createRegion = function(e, t, n, i) { return { id: e + "," + t + "," + n + "," + i, startCol: e, endCol: t, startRow: n, endRow: i } }, i._getBucketId = function(e, t) { return "C" + e + "R" + t }, i._createBucket = function(e, t) { return e[t] = [] }, i._bucketAddBody = function(e, t, n) { var i, r = e.pairs,
                a = o.id,
                s = t.length; for (i = 0; i < s; i++) { var l = t[i]; if (!(n.id === l.id || n.isStatic && l.isStatic)) { var c = a(n, l),
                        u = r[c];
                    u ? u[2] += 1 : r[c] = [n, l, 1] } } t.push(n) }, i._bucketRemoveBody = function(e, t, n) { var i, a = e.pairs,
                s = o.id;
            t.splice(r.indexOf(t, n), 1); var l = t.length; for (i = 0; i < l; i++) { var c = a[s(n, t[i])];
                c && (c[2] -= 1) } }, i._createActivePairsList = function(e) { var t, n, i = e.pairs,
                o = r.keys(i),
                a = o.length,
                s = []; for (n = 0; n < a; n++)(t = i[o[n]])[2] > 0 ? s.push(t) : delete i[o[n]]; return s } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(3),
            r = n(7),
            a = n(13),
            s = n(4),
            l = n(14),
            c = n(10),
            u = n(5),
            d = n(0),
            p = n(1);
        i.create = function(e, t) { var n = (e ? e.mouse : null) || (t ? t.mouse : null);
            n || (e && e.render && e.render.canvas ? n = a.create(e.render.canvas) : t && t.element ? n = a.create(t.element) : (n = a.create(), d.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected"))); var o = { type: "mouseConstraint", mouse: n, element: null, body: null, constraint: c.create({ label: "Mouse Constraint", pointA: n.position, pointB: { x: 0, y: 0 }, length: .01, stiffness: .1, angularStiffness: 1, render: { strokeStyle: "#90EE90", lineWidth: 3 } }), collisionFilter: { category: 1, mask: 4294967295, group: 0 } },
                r = d.extend(o, t); return s.on(e, "beforeUpdate", (function() { var t = u.allBodies(e.world);
                i.update(r, t), i._triggerEvents(r) })), r }, i.update = function(e, t) { var n = e.mouse,
                i = e.constraint,
                a = e.body; if (0 === n.button) { if (i.bodyB) r.set(i.bodyB, !1), i.pointA = n.position;
                else
                    for (var c = 0; c < t.length; c++)
                        if (a = t[c], p.contains(a.bounds, n.position) && l.canCollide(a.collisionFilter, e.collisionFilter))
                            for (var u = a.parts.length > 1 ? 1 : 0; u < a.parts.length; u++) { var d = a.parts[u]; if (o.contains(d.vertices, n.position)) { i.pointA = n.position, i.bodyB = e.body = a, i.pointB = { x: n.position.x - a.position.x, y: n.position.y - a.position.y }, i.angleB = a.angle, r.set(a, !1), s.trigger(e, "startdrag", { mouse: n, body: a }); break } } } else i.bodyB = e.body = null, i.pointB = null, a && s.trigger(e, "enddrag", { mouse: n, body: a }) }, i._triggerEvents = function(e) { var t = e.mouse,
                n = t.sourceEvents;
            n.mousemove && s.trigger(e, "mousemove", { mouse: t }), n.mousedown && s.trigger(e, "mousedown", { mouse: t }), n.mouseup && s.trigger(e, "mouseup", { mouse: t }), a.clearSourceEvents(t) } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(2),
            r = n(8),
            a = n(1),
            s = n(12),
            l = n(3);
        i.collides = function(e, t) { for (var n = [], i = t.length, o = e.bounds, s = r.collides, l = a.overlaps, c = 0; c < i; c++) { var u = t[c],
                    d = u.parts.length,
                    p = 1 === d ? 0 : 1; if (l(u.bounds, o))
                    for (var f = p; f < d; f++) { var v = u.parts[f]; if (l(v.bounds, o)) { var y = s(v, e); if (y) { n.push(y); break } } } } return n }, i.ray = function(e, t, n, r) { r = r || 1e-100; for (var a = o.angle(t, n), l = o.magnitude(o.sub(t, n)), c = .5 * (n.x + t.x), u = .5 * (n.y + t.y), d = s.rectangle(c, u, l, r, { angle: a }), p = i.collides(d, e), f = 0; f < p.length; f += 1) { var v = p[f];
                v.body = v.bodyB = v.bodyA } return p }, i.region = function(e, t, n) { for (var i = [], o = 0; o < e.length; o++) { var r = e[o],
                    s = a.overlaps(r.bounds, t);
                (s && !n || !s && n) && i.push(r) } return i }, i.point = function(e, t) { for (var n = [], i = 0; i < e.length; i++) { var o = e[i]; if (a.contains(o.bounds, t))
                    for (var r = 1 === o.parts.length ? 0 : 1; r < o.parts.length; r++) { var s = o.parts[r]; if (a.contains(s.bounds, t) && l.contains(s.vertices, t)) { n.push(o); break } } } return n } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(4),
            r = n(18),
            a = n(0);! function() { var e, t, n;
            ("undefined" != typeof window && (e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), e) || (e = function(e) { n = setTimeout((function() { e(a.now()) }), 1e3 / 60) }, t = function() { clearTimeout(n) });
            i.create = function(e) { var t = a.extend({ fps: 60, correction: 1, deltaSampleSize: 60, counterTimestamp: 0, frameCounter: 0, deltaHistory: [], timePrev: null, timeScalePrev: 1, frameRequestId: null, isFixed: !1, enabled: !0 }, e); return t.delta = t.delta || 1e3 / t.fps, t.deltaMin = t.deltaMin || 1e3 / t.fps, t.deltaMax = t.deltaMax || 1e3 / (.5 * t.fps), t.fps = 1e3 / t.delta, t }, i.run = function(t, n) { return void 0 !== t.positionIterations && (n = t, t = i.create()),
                    function o(r) { t.frameRequestId = e(o), r && t.enabled && i.tick(t, n, r) }(), t }, i.tick = function(e, t, n) { var i, a = t.timing,
                    s = 1,
                    l = { timestamp: a.timestamp };
                o.trigger(e, "beforeTick", l), e.isFixed ? i = e.delta : (i = n - e.timePrev || e.delta, e.timePrev = n, e.deltaHistory.push(i), e.deltaHistory = e.deltaHistory.slice(-e.deltaSampleSize), s = (i = (i = (i = Math.min.apply(null, e.deltaHistory)) < e.deltaMin ? e.deltaMin : i) > e.deltaMax ? e.deltaMax : i) / e.delta, e.delta = i), 0 !== e.timeScalePrev && (s *= a.timeScale / e.timeScalePrev), 0 === a.timeScale && (s = 0), e.timeScalePrev = a.timeScale, e.correction = s, e.frameCounter += 1, n - e.counterTimestamp >= 1e3 && (e.fps = e.frameCounter * ((n - e.counterTimestamp) / 1e3), e.counterTimestamp = n, e.frameCounter = 0), o.trigger(e, "tick", l), o.trigger(e, "beforeUpdate", l), r.update(t, i, s), o.trigger(e, "afterUpdate", l), o.trigger(e, "afterTick", l) }, i.stop = function(e) { t(e.frameRequestId) }, i.start = function(e, t) { i.run(e, t) } }() }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(8),
            r = n(0).deprecated;
        i.collides = function(e, t) { return o.collides(e, t) }, r(i, "collides", "SAT.collides ➤ replaced by Collision.collides") }, function(e, t, n) { var i = {};
        e.exports = i;
        n(1); var o = n(0);
        i.pathToVertices = function(e, t) { "undefined" == typeof window || "SVGPathSeg" in window || o.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required."); var n, r, a, s, l, c, u, d, p, f, v, y = [],
                m = 0,
                g = 0,
                x = 0;
            t = t || 15; var h = function(e, t, n) { var i = n % 2 == 1 && n > 1; if (!p || e != p.x || t != p.y) { p && i ? (f = p.x, v = p.y) : (f = 0, v = 0); var o = { x: f + e, y: v + t };!i && p || (p = o), y.push(o), g = f + e, x = v + t } },
                b = function(e) { var t = e.pathSegTypeAsLetter.toUpperCase(); if ("Z" !== t) { switch (t) {
                            case "M":
                            case "L":
                            case "T":
                            case "C":
                            case "S":
                            case "Q":
                                g = e.x, x = e.y; break;
                            case "H":
                                g = e.x; break;
                            case "V":
                                x = e.y } h(g, x, e.pathSegType) } }; for (i._svgPathToAbsolute(e), a = e.getTotalLength(), c = [], n = 0; n < e.pathSegList.numberOfItems; n += 1) c.push(e.pathSegList.getItem(n)); for (u = c.concat(); m < a;) { if ((l = c[e.getPathSegAtLength(m)]) != d) { for (; u.length && u[0] != l;) b(u.shift());
                    d = l } switch (l.pathSegTypeAsLetter.toUpperCase()) {
                    case "C":
                    case "T":
                    case "S":
                    case "Q":
                    case "A":
                        s = e.getPointAtLength(m), h(s.x, s.y, 0) } m += t } for (n = 0, r = u.length; n < r; ++n) b(u[n]); return y }, i._svgPathToAbsolute = function(e) { for (var t, n, i, o, r, a, s = e.pathSegList, l = 0, c = 0, u = s.numberOfItems, d = 0; d < u; ++d) { var p = s.getItem(d),
                    f = p.pathSegTypeAsLetter; if (/[MLHVCSQTA]/.test(f)) "x" in p && (l = p.x), "y" in p && (c = p.y);
                else switch ("x1" in p && (i = l + p.x1), "x2" in p && (r = l + p.x2), "y1" in p && (o = c + p.y1), "y2" in p && (a = c + p.y2), "x" in p && (l += p.x), "y" in p && (c += p.y), f) {
                    case "m":
                        s.replaceItem(e.createSVGPathSegMovetoAbs(l, c), d); break;
                    case "l":
                        s.replaceItem(e.createSVGPathSegLinetoAbs(l, c), d); break;
                    case "h":
                        s.replaceItem(e.createSVGPathSegLinetoHorizontalAbs(l), d); break;
                    case "v":
                        s.replaceItem(e.createSVGPathSegLinetoVerticalAbs(c), d); break;
                    case "c":
                        s.replaceItem(e.createSVGPathSegCurvetoCubicAbs(l, c, i, o, r, a), d); break;
                    case "s":
                        s.replaceItem(e.createSVGPathSegCurvetoCubicSmoothAbs(l, c, r, a), d); break;
                    case "q":
                        s.replaceItem(e.createSVGPathSegCurvetoQuadraticAbs(l, c, i, o), d); break;
                    case "t":
                        s.replaceItem(e.createSVGPathSegCurvetoQuadraticSmoothAbs(l, c), d); break;
                    case "a":
                        s.replaceItem(e.createSVGPathSegArcAbs(l, c, p.r1, p.r2, p.angle, p.largeArcFlag, p.sweepFlag), d); break;
                    case "z":
                    case "Z":
                        l = t, c = n }
                "M" != f && "m" != f || (t = l, n = c) } } }, function(e, t, n) { var i = {};
        e.exports = i; var o = n(5);
        n(0);
        i.create = o.create, i.add = o.add, i.remove = o.remove, i.clear = o.clear, i.addComposite = o.addComposite, i.addBody = o.addBody, i.addConstraint = o.addConstraint }]) }));
    </script>
    <!-- <script src='lib/decomp.min.js'></script> -->
    <script>
        // game Object ********************************************************
//*********************************************************************
const simulation = {
    loop() { }, //main game loop, gets set to normal or testing loop
    // normalLoop() {
    //     try {
    //         simulation.gravity();
    //         Engine.update(engine, simulation.delta);
    //         simulation.wipe();
    //         simulation.textLog();
    //         if (m.onGround) {
    //             m.groundControl()
    //         } else {
    //             m.airControl()
    //         }
    //         m.move();
    //         m.look();
    //         simulation.camera();
    //         level.custom();
    //         powerUps.do();
    //         mobs.draw();
    //         simulation.draw.cons();
    //         simulation.draw.body();
    //         if (!m.isTimeDilated) mobs.loop();
    //         mobs.healthBar();
    //         m.draw();
    //         m.hold();
    //         level.customTopLayer();
    //         simulation.draw.drawMapPath();
    //         b.fire();
    //         b.bulletRemove();
    //         b.bulletDraw();
    //         if (!m.isTimeDilated) b.bulletDo();
    //         simulation.drawCircle();
    //         simulation.runEphemera();
    //         ctx.restore();
    //     } catch (error) {
    //         simulation.inGameConsole(`<strong style='color:red;'>ERROR:</strong> ${(error.stack && error.stack.replace(/\n/g, "<br>")) || (error.message + ` <u>${error.filename}:${error.lineno}</u>`)}`);
    //     } finally {
    //         simulation.drawCursor();
    //     }
    // },
    // testingLoop() {
    //     try {
    //         simulation.gravity();
    //         Engine.update(engine, simulation.delta);
    //         simulation.wipe();
    //         simulation.textLog();
    //         if (m.onGround) {
    //             m.groundControl()
    //         } else {
    //             m.airControl()
    //         }
    //         m.move();
    //         m.look();
    //         simulation.camera();
    //         level.custom();
    //         m.draw();
    //         m.hold();
    //         level.customTopLayer();
    //         simulation.draw.wireFrame();
    //         if (input.fire && m.fireCDcycle < m.cycle) {
    //             m.fireCDcycle = m.cycle + 15; //fire cooldown       
    //             for (let i = 0, len = mob.length; i < len; i++) {
    //                 if (Vector.magnitudeSquared(Vector.sub(mob[i].position, simulation.mouseInGame)) < mob[i].radius * mob[i].radius) {
    //                     console.log(mob[i])
    //                 }
    //             }
    //         }
    //         simulation.draw.cons();
    //         simulation.draw.testing();
    //         simulation.drawCircle();
    //         simulation.runEphemera();
    //         simulation.constructCycle()
    //     } catch (error) {
    //         simulation.inGameConsole(`<strong style='color:red;'>ERROR:</strong> ${(error.stack && error.stack.replace(/\n/g, "<br>")) || (error.message + ` <u>${error.filename}:${error.lineno}</u>`)}`);
    //     } finally {
    //         ctx.restore();
    //         simulation.testingOutput();
    //         simulation.drawCursor();
    //     }
    // },
    normalLoop() {
        simulation.gravity();
        Engine.update(engine, simulation.delta);
        simulation.wipe();
        simulation.textLog();
        if (m.onGround) {
            m.groundControl()
        } else {
            m.airControl()
        }
        m.move();
        m.look();
        simulation.camera();
        level.custom();
        powerUps.do();
        mobs.draw();
        simulation.draw.cons();
        simulation.draw.body();
        if (!m.isTimeDilated) mobs.loop();
        mobs.healthBar();
        m.draw();
        m.hold();
        level.customTopLayer();
        simulation.draw.drawMapPath();
        b.fire();
        b.bulletRemove();
        b.bulletDraw();
        if (!m.isTimeDilated) b.bulletDo();
        simulation.drawCircle();
        simulation.runEphemera();
        ctx.restore();
        simulation.drawCursor();
    },
    testingLoop() {
        simulation.gravity();
        Engine.update(engine, simulation.delta);
        simulation.wipe();
        simulation.textLog();
        if (m.onGround) {
            m.groundControl()
        } else {
            m.airControl()
        }
        m.move();
        m.look();
        simulation.camera();
        level.custom();
        m.draw();
        m.hold();
        level.customTopLayer();
        simulation.draw.wireFrame();
        if (input.fire && m.fireCDcycle < m.cycle) {
            m.fireCDcycle = m.cycle + 15; //fire cooldown       
            for (let i = 0, len = mob.length; i < len; i++) {
                if (Vector.magnitudeSquared(Vector.sub(mob[i].position, simulation.mouseInGame)) < mob[i].radius * mob[i].radius) {
                    console.log(mob[i])
                }
            }
        }
        simulation.draw.cons();
        simulation.draw.testing();
        simulation.drawCircle();
        simulation.runEphemera();
        simulation.constructCycle()
        ctx.restore();
        simulation.testingOutput();
        simulation.drawCursor();
    },
    isTimeSkipping: false,
    timeSkip(cycles = 60) {
        simulation.isTimeSkipping = true;
        for (let i = 0; i < cycles; i++) {
            simulation.cycle++;
            m.cycle++;
            simulation.gravity();
            Engine.update(engine, simulation.delta);
            if (m.onGround) {
                m.groundControl()
            } else {
                m.airControl()
            }
            m.move();
            level.custom();
            mobs.loop();
            m.walk_cycle += m.flipLegs * m.Vx;
            m.hold();
            level.customTopLayer();
            b.fire();
            b.bulletRemove();
            b.bulletDo();
            simulation.runEphemera();
        }
        simulation.isTimeSkipping = false;
    },
    timePlayerSkip(cycles = 60) {
        simulation.isTimeSkipping = true;
        for (let i = 0; i < cycles; i++) {
            simulation.cycle++;
            // m.walk_cycle += (m.flipLegs * m.Vx) * 0.5; //makes the legs look like they are moving fast this is just gonna run for each method call since it needs some tweaking
            simulation.gravity();
            Engine.update(engine, simulation.delta);
            // level.custom();
            // level.customTopLayer();
            if (!m.isTimeDilated) mobs.loop();
            if (m.fieldMode !== 7) m.hold();
            b.bulletRemove();
            if (!m.isTimeDilated) b.bulletDo();
            simulation.runEphemera();
        }
        simulation.isTimeSkipping = false;
    },
    ephemera: [], //array that is used to store ephemera objects
    removeEphemera: function (name) {
        for (let i = 0, len = simulation.ephemera.length; i < len; i++) {
            if (simulation.ephemera[i].name === name) {
                simulation.ephemera.splice(i, 1);
                break;
            }
        }
    },
    runEphemera() {
        for (let i = 0; i < simulation.ephemera.length; i++) {
            simulation.ephemera[i].do();
        }
    },
    // timeMobSkip() {
    //     simulation.gravity();
    //     Engine.update(engine, simulation.delta);
    //     simulation.wipe();
    //     simulation.textLog();
    //     if (m.onGround) {
    //         m.groundControl()
    //     } else {
    //         m.airControl()
    //     }
    //     m.move();
    //     m.look();
    //     simulation.camera();
    //     level.custom();
    //     powerUps.do();
    //     mobs.draw();
    //     simulation.draw.cons();
    //     simulation.draw.body();
    //     if (!m.isTimeDilated) {
    //         // mobs.loop();
    //     }
    //     mobs.healthBar();
    //     m.draw();
    //     m.hold();
    //     // v.draw(); //working on visibility work in progress
    //     level.customTopLayer();
    //     simulation.draw.drawMapPath();
    //     b.fire();
    //     b.bulletRemove();
    //     b.bulletDraw();
    //     if (!m.isTimeDilated) b.bulletDo();
    //     simulation.drawCircle();
    //     // simulation.clip();
    //     ctx.restore();
    //     simulation.drawCursor();
    //     // simulation.pixelGraphics();
    // },
    mouse: {
        x: canvas.width / 2,
        y: canvas.height / 2
    },
    mouseInGame: {
        x: 0,
        y: 0
    },
    g: 0.0024, // applies to player, bodies, and power ups  (not mobs)
    onTitlePage: true,
    isCheating: false,
    isTraining: false,
    paused: false,
    isChoosing: false,
    testing: false, //testing mode: shows wire frame and some variables
    cycle: 0, //total cycles, 60 per second
    fpsCap: null, //limits frames per second to 144/2=72,  on most monitors the fps is capped at 60fps by the hardware
    fpsCapDefault: 72, //use to change fpsCap back to normal after a hit from a mob
    isCommunityMaps: false,
    cyclePaused: 0,
    fallHeight: 6000, //below this y position the player will teleport to start, take damage, or teleport to the sky based on the value of  level.fallMode
    lastTimeStamp: 0, //tracks time stamps for measuring delta
    delta: 1000 / 60, //speed of game engine //looks like it has to be 16.6666 to match player input
    buttonCD: 0,
    isHorizontalFlipped: false, //makes some maps flipped horizontally
    levelsCleared: 0,
    difficultyMode: 2, //normal difficulty is 2
    difficulty: 0,
    constraint: 0,
    healScale: 1,
    accelScale: null,
    CDScale: null,
    molecularMode: Math.floor(4 * Math.random()), //0 spores, 1 missile, 2 ice IX, 3 drones //randomize molecular assembler field type
    // dropFPS(cap = 40, time = 15) {
    //   simulation.fpsCap = cap
    //   simulation.fpsInterval = 1000 / simulation.fpsCap;
    //   simulation.defaultFPSCycle = simulation.cycle + time
    //   const normalFPS = function () {
    //     if (simulation.defaultFPSCycle < simulation.cycle) {
    //       simulation.fpsCap = 72
    //       simulation.fpsInterval = 1000 / simulation.fpsCap;
    //     } else {
    //       requestAnimationFrame(normalFPS);
    //     }
    //   };
    //   requestAnimationFrame(normalFPS);
    // },
    // clip() {

    // },
    pixelGraphics() {
        //copy current canvas pixel data
        let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        let data = imgData.data;
        //change pixel data


        // const off = 4 * Math.floor(x) + 4 * canvas.width * Math.floor(y);
        // multiple windows
        for (let i = data.length / 2; i < data.length; i += 4) {
            index = i % (canvas.width * canvas.height * 2) // + canvas.width*4*canvas.height

            data[i + 0] = data[index + 0]; // red
            data[i + 1] = data[index + 1]; // red
            data[i + 2] = data[index + 2]; // red
            data[i + 3] = data[index + 3]; // red
        }

        for (let x = 0; x < len; x++) {

        }



        // const startX = 2 * canvas.width + 2 * canvas.width * canvas.height
        // const endX = 4 * canvas.width + 4 * canvas.width * canvas.height
        // const startY = 2 * canvas.width + 2 * canvas.width * canvas.height
        // const endY = 4 * canvas.width + 4 * canvas.width * canvas.height
        // for (let x = startX; x < endX; x++) {
        //   for (let y = startY; y < endY; y++) {

        //   }
        // }




        //strange draw offset
        // const off = canvas.height * canvas.width * 4 / 2
        // for (let index = 0; index < data.length; index += 4) {
        //   data[index + 0] = data[index + 0 + off]; // red
        //   data[index + 1] = data[index + 1 + off]; // red
        //   data[index + 2] = data[index + 2 + off]; // red
        //   data[index + 3] = data[index + 3 + off]; // red
        // }

        //change all pixels
        // for (let index = 0; index < data.length; index += 4) {
        // data[index + 0] = 255; // red
        // data[index + 1] = 255; // green
        // data[index + 2] = 255; // blue
        // data[index + 3] = 255; // alpha 
        // }

        //change random pixels
        // for (let i = 0, len = Math.floor(data.length / 10); i < len; ++i) {
        //   const index = Math.floor((Math.random() * data.length) / 4) * 4;
        //   data[index + 0] = 255; // red
        //   data[index + 1] = 0; // green
        //   data[index + 2] = 0; // blue
        //   data[index + 3] = 255 //Math.floor(Math.random() * Math.random() * 255); // alpha
        // }

        // //change random pixels
        // for (let i = 0, len = Math.floor(data.length / 1000); i < len; ++i) {
        //   const index = Math.floor((Math.random() * data.length) / 4) * 4;
        //   // data[index] = data[index] ^ 255; // Invert Red
        //   // data[index + 1] = data[index + 1] ^ 255; // Invert Green
        //   // data[index + 2] = data[index + 2] ^ 255; // Invert Blue
        //   data[index + 0] = 0; // red
        //   data[index + 1] = 0; // green
        //   data[index + 2] = 0; // blue
        //   // data[index + 3] = 255 //Math.floor(Math.random() * Math.random() * 255); // alpha
        // }

        //draw new pixel data to canvas
        ctx.putImageData(imgData, 0, 0);
    },
    drawCursor() {
        const size = 10;
        ctx.beginPath();
        ctx.moveTo(simulation.mouse.x - size, simulation.mouse.y);
        ctx.lineTo(simulation.mouse.x + size, simulation.mouse.y);
        ctx.moveTo(simulation.mouse.x, simulation.mouse.y - size);
        ctx.lineTo(simulation.mouse.x, simulation.mouse.y + size);
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#000"; //'rgba(0,0,0,0.4)'
        ctx.stroke(); // Draw it
    },
    drawCursorBasic() {
        const size = 10;
        ctx.beginPath();
        ctx.moveTo(simulation.mouse.x - size, simulation.mouse.y);
        ctx.lineTo(simulation.mouse.x + size, simulation.mouse.y);
        ctx.moveTo(simulation.mouse.x, simulation.mouse.y - size);
        ctx.lineTo(simulation.mouse.x, simulation.mouse.y + size);
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#000"; //'rgba(0,0,0,0.4)'
        ctx.stroke(); // Draw it
    },
    drawCursorCoolDown() {
        const size = 10;
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#000"; //'rgba(0,0,0,0.4)'
        ctx.beginPath();
        if (m.fireCDcycle > m.cycle) {
            ctx.strokeStyle = "#000"; //'rgba(0,0,0,0.4)'
            ctx.arc(simulation.mouse.x, simulation.mouse.y, size + 1, 0, 2 * Math.PI);
        } else {
            ctx.strokeStyle = "#000"; //'rgba(0,0,0,0.4)'
        }
        ctx.moveTo(simulation.mouse.x - size, simulation.mouse.y);
        ctx.lineTo(simulation.mouse.x + size, simulation.mouse.y);
        ctx.moveTo(simulation.mouse.x, simulation.mouse.y - size);
        ctx.lineTo(simulation.mouse.x, simulation.mouse.y + size);
        ctx.stroke(); // Draw it
    },
    drawList: [], //so you can draw a first frame of explosions.. I know this is bad
    drawTime: 8, //how long circles are drawn.  use to push into drawlist.time
    mobDmgColor: "rgba(255,0,0,0.7)", //color when a mob damages the player  // set by mass-energy tech
    playerDmgColor: "rgba(0,0,0,0.7)", //color when the player damages a mob
    drawCircle() {
        //draws a circle for two cycles, used for showing damage mostly
        let i = simulation.drawList.length;
        while (i--) {
            ctx.beginPath(); //draw circle
            ctx.arc(simulation.drawList[i].x, simulation.drawList[i].y, simulation.drawList[i].radius, 0, 2 * Math.PI);
            ctx.fillStyle = simulation.drawList[i].color;
            ctx.fill();
            if (simulation.drawList[i].time) {
                simulation.drawList[i].time--;
            } else {
                if (!m.isTimeDilated) simulation.drawList.splice(i, 1); //remove when timer runs out
            }
        }
    },
    circleFlare(dup, loops = 100) {
        boltNum = dup * 300
        const bolts = []
        colors = [powerUps.research.color, powerUps.ammo.color, powerUps.heal.color, powerUps.tech.color, powerUps.field.color, powerUps.gun.color]
        for (let i = 0; i < boltNum; ++i) {
            const mag = 6 + 20 * Math.random()
            const angle = 2 * Math.PI * Math.random()
            bolts.push({
                x: m.pos.x,
                y: m.pos.y,
                Vx: mag * Math.cos(angle),
                Vy: mag * Math.sin(angle),
                color: colors[Math.floor(Math.random() * colors.length)]
            })
        }
        let count = 0
        loop = () => { //draw electricity
            if (count++ < loops) requestAnimationFrame(loop)
            for (let i = 0, len = bolts.length; i < len; ++i) {
                bolts[i].x += bolts[i].Vx
                bolts[i].y += bolts[i].Vy
                if (Math.random() < 0.2) {
                    simulation.drawList.push({
                        x: bolts[i].x,
                        y: bolts[i].y,
                        radius: 1.5 + 5 * Math.random(),
                        // color: "rgba(0,155,155,0.7)",
                        color: bolts[i].color,
                        time: Math.floor(9 + 25 * Math.random() * Math.random())
                    });
                }
            }
        }
        requestAnimationFrame(loop)
    },
    boldActiveGunHUD() {
        if (b.inventory.length > 0) {
            for (let i = 0, len = b.inventory.length; i < len; ++i) {
                if (b.inventory[i] === b.activeGun && document.getElementById(b.activeGun)) {
                    document.getElementById(b.inventory[i]).style.opacity = "1";
                } else {
                    document.getElementById(b.inventory[i]).style.opacity = "0.3";
                }
            }
        }
    },
    updateGunHUD() {
        for (let i = 0, len = b.inventory.length; i < len; ++i) {
            document.getElementById(b.inventory[i]).innerHTML = `${b.guns[b.inventory[i]].name} - ${b.guns[b.inventory[i]].ammo}`
        }
    },
    makeGunHUD() {
        //remove all nodes
        const myNode = document.getElementById("guns");
        while (myNode.firstChild) {
            myNode.removeChild(myNode.firstChild);
        }
        //add nodes
        for (let i = 0, len = b.inventory.length; i < len; ++i) {
            const node = document.createElement("div");
            node.setAttribute("id", b.inventory[i]);
            const textNode = document.createTextNode(`${b.guns[b.inventory[i]].name} - ${b.guns[b.inventory[i]].ammo}`); //b.guns[b.inventory[i]].name + " - " + b.guns[b.inventory[i]].ammo);
            node.appendChild(textNode);
            document.getElementById("guns").appendChild(node);
        }
        simulation.boldActiveGunHUD();
    },
    // updateTechHUD() {
    //     let text = ""
    //     for (let i = 0, len = tech.tech.length; i < len; i++) { //add tech
    //         if (tech.tech[i].isLost) {
    //             if (text) text += "<br>" //add a new line, but not on the first line
    //             text += `<span style="text-decoration: line-through;">${tech.tech[i].name}</span>`
    //         } else if (tech.tech[i].count > 0 && !tech.tech[i].isInstant) {
    //             if (text) text += "<br>" //add a new line, but not on the first line
    //             text += `<span id = "${tech.tech[i].name}">${tech.tech[i].name}${tech.tech[i].count > 1 ? ` (${tech.tech[i].count}x)` : ""}</span>`

    //             // document.getElementById(tech.tech[i].name).style.fontWeight = 'bold';
    //             // simulation.ephemera.push({
    //             //     name: "bold",
    //             //     count: 180,
    //             //     do() {
    //             //         this.count--
    //             //         if (this.count < 0) {
    //             //             simulation.removeEphemera(this.name)
    //             //             if (document.getElementById(tech.tech[i].name)) document.getElementById(tech.tech[i].name).style.fontWeight = 'normal';
    //             //         }
    //             //     }
    //             // })
    //         }
    //     }
    //     document.getElementById("right-HUD").innerHTML = text
    // },
    updateTechHUD() {
        let text = ""
        for (let i = 0, len = tech.tech.length; i < len; i++) { //add tech
            if (tech.tech[i].isLost) {
                if (text) text += "<br>" //add a new line, but not on the first line
                text += `<span style="text-decoration: line-through;">${tech.tech[i].name}</span>`
            } else if (tech.tech[i].count > 0 && !tech.tech[i].isInstant) {
                if (text) text += "<br>" //add a new line, but not on the first line
                text += tech.tech[i].name
                if (tech.tech[i].count > 1) text += ` (${tech.tech[i].count}x)`
            }
        }
        document.getElementById("right-HUD").innerHTML = text
    },
    lastLogTime: 0,
    isTextLogOpen: true,
    inGameConsole(text, time = 240) {
        if (!localSettings.isHideHUD && simulation.isTextLogOpen && !build.isExperimentSelection) {
            if (simulation.lastLogTime > m.cycle) { //if there is an older message
                document.getElementById("text-log").innerHTML = document.getElementById("text-log").innerHTML + '<br>' + text;
                simulation.lastLogTime = m.cycle + time;
            } else {
                document.getElementById("text-log").innerHTML = text;
                document.getElementById("text-log").style.display = "inline";
                simulation.lastLogTime = m.cycle + time;
            }
        }
    },
    textLog() {
        if (simulation.lastLogTime && simulation.lastLogTime < m.cycle) {
            simulation.lastLogTime = 0;
            // document.getElementById("text-log").innerHTML = " ";
            document.getElementById("text-log").style.display = "none";
        }
    },
    nextGun() {
        if (b.inventory.length > 1 && !(tech.isGunCycle || tech.isGunChoice)) {
            b.inventoryGun++;
            if (b.inventoryGun > b.inventory.length - 1) b.inventoryGun = 0;
            simulation.switchGun();
        }
    },
    previousGun() {
        if (b.inventory.length > 1 && !(tech.isGunCycle || tech.isGunChoice)) {
            b.inventoryGun--;
            if (b.inventoryGun < 0) b.inventoryGun = b.inventory.length - 1;
            simulation.switchGun();
        }
    },
    switchToGunInInventory(num) {
        if (b.inventory[num] !== undefined && b.inventoryGun !== num) {
            b.inventoryGun = num
            simulation.switchGun();
        }
    },
    switchGun() {
        if (tech.isLongitudinal && b.activeGun === 3) b.guns[3].waves = []; //empty array of wave bullets
        if (tech.crouchAmmoCount) tech.crouchAmmoCount = 1 //this prevents hacking the tech by switching guns
        if (b.inventory.length > 0) b.activeGun = b.inventory[b.inventoryGun];
        b.guns[8].charge = 0; // foam charge to 0
        simulation.updateGunHUD();
        simulation.boldActiveGunHUD();
        //set crosshairs
        if (b.activeGun === 1) {
            simulation.drawCursor = simulation.drawCursorCoolDown
        } else {
            simulation.drawCursor = simulation.drawCursorBasic
        }
    },
    zoom: null,
    zoomScale: 1000,
    isAutoZoom: true,
    setZoom(zoomScale = simulation.zoomScale) { //use in window resize in index.js
        simulation.zoomScale = zoomScale
        simulation.zoom = canvas.height / zoomScale; //sets starting zoom scale
    },
    zoomTransition(newZoomScale, step = 2) {
        //old version
        // if (simulation.isAutoZoom) {
        //     const isBigger = (newZoomScale - simulation.zoomScale > 0) ? true : false;
        //     requestAnimationFrame(zLoop);
        //     const currentLevel = level.onLevel

        //     function zLoop() {
        //         if (currentLevel !== level.onLevel || simulation.isAutoZoom === false) return //stop the zoom if player goes to a new level

        //         if (isBigger) {
        //             simulation.zoomScale += step
        //             if (simulation.zoomScale >= newZoomScale) {
        //                 simulation.setZoom(newZoomScale);
        //                 return
        //             }
        //         } else {
        //             simulation.zoomScale -= step
        //             if (simulation.zoomScale <= newZoomScale) {
        //                 simulation.setZoom(newZoomScale);
        //                 return
        //             }
        //         }

        //         simulation.setZoom();
        //         requestAnimationFrame(zLoop);
        //     }
        // }


        //rewrite using the ephemera system
        if (simulation.isAutoZoom) {
            simulation.ephemera.push({
                name: "zoom",
                count: simulation.testing ? 0 : 120, //cycles before it self removes
                currentLevel: level.onLevel,
                do() {
                    this.count--
                    const step = (newZoomScale - simulation.zoomScale) / this.count
                    simulation.zoomScale += step
                    if (this.count < 1 && this.currentLevel === level.onLevel && simulation.isAutoZoom) {
                        simulation.zoomScale = newZoomScale
                        simulation.removeEphemera(this.name)
                    }
                    simulation.setZoom(simulation.zoomScale);
                },
            })
        }
    },
    isInvertedVertical: false,
    flipCameraVertical(frames = 1, passFunction = () => { }) {
        if (!simulation.isInvertedVertical) {
            if (frames > 0) {
                let count = 0
                const loop = () => {
                    if (m.alive) {
                        if (simulation.paused) {
                            requestAnimationFrame(loop);
                        } else {
                            count++
                            ctx.setTransform(1, 0, 0, 1, 0, 0); ///reset to avoid build up of transformations
                            if (count === frames) {
                                // Flip the canvas vertically
                                ctx.translate(0, canvas.height); // Move the origin down to the bottom
                                ctx.scale(1, -1); // Flip vertically
                                simulation.isInvertedVertical = true
                                //flip mouse Y again to make sure it caught
                                mouseMove = function (e) {
                                    simulation.mouse.x = e.clientX;
                                    simulation.mouse.y = window.innerHeight - e.clientY;
                                }
                            } else {
                                requestAnimationFrame(loop);
                                ctx.translate(0, canvas.height * count / frames);
                                ctx.scale(1, 1 - 2 * count / frames);
                            }
                            if (count === Math.floor(frames / 2)) {
                                //flip mouse Y at the 1/2 way point
                                mouseMove = function (e) {
                                    simulation.mouse.x = e.clientX;
                                    simulation.mouse.y = window.innerHeight - e.clientY;
                                }
                                //passFunction probably flips the map elements 
                                passFunction()
                            }
                        }
                    }
                }
                requestAnimationFrame(loop);
            } else {
                // Flip the canvas vertically
                ctx.translate(0, canvas.height); // Move the origin down to the bottom
                ctx.scale(1, -1); // Flip vertically
                //flip mouse Y
                simulation.isInvertedVertical = true
                mouseMove = function (e) {
                    simulation.mouse.x = e.clientX;
                    simulation.mouse.y = window.innerHeight - e.clientY;
                }
            }
        }
    },
    unFlipCameraVertical(frames = 0, passFunction = () => { }) {
        if (frames) {
            let count = 0
            const loop = () => {
                if (m.alive) {
                    if (simulation.paused) {
                        requestAnimationFrame(loop);
                    } else {
                        count++
                        ctx.setTransform(1, 0, 0, 1, 0, 0); ///reset to avoid build up of transformations
                        if (count === frames) {
                            // requestAnimationFrame(() => { ctx.reset(); });
                            // ctx.translate(0, 0);
                            // ctx.scale(1, 1);
                            simulation.isInvertedVertical = false
                            //flip mouse Y again to make sure it caught
                            mouseMove = mouseMoveDefault

                        } else {
                            requestAnimationFrame(loop);
                            ctx.translate(0, canvas.height - canvas.height * count / frames);
                            ctx.scale(1, -1 + 2 * count / frames);
                        }
                        if (count === Math.floor(frames / 2)) {
                            mouseMove = mouseMoveDefault//flip mouse Y at the 1/2 way point
                            passFunction()//passFunction probably draws new map elements 
                        }
                    }
                }
            }
            requestAnimationFrame(loop);
        } else {
            ctx.reset();
            ctx.font = "25px Arial";
            simulation.isInvertedVertical = false
            mouseMove = mouseMoveDefault
        }
    },
    translatePlayerAndCamera(where, isTranslateBots = true) {
        //infinite falling.  teleport to sky after falling
        const before = { x: player.position.x, y: player.position.y, }
        Matter.Body.setPosition(player, { x: where.x, y: where.y });
        const change = { x: before.x - player.position.x, y: before.y - player.position.y }
        // translate camera to preserve illusion to endless fall
        m.transX += change.x
        m.transY += change.y
        simulation.mouseInGame.x = (simulation.mouse.x - canvas.width2) / simulation.zoom * simulation.edgeZoomOutSmooth + canvas.width2 - m.transX;
        simulation.mouseInGame.y = (simulation.mouse.y - canvas.height2) / simulation.zoom * simulation.edgeZoomOutSmooth + canvas.height2 - m.transY;

        m.angle = Math.atan2(simulation.mouseInGame.y - m.pos.y, simulation.mouseInGame.x - m.pos.x);

        //is there a reason to update m.pos here?
        // m.pos.x = player.position.x;
        // m.pos.y = playerBody.position.y - m.yOff;
        if (isTranslateBots) {
            for (let i = 0; i < bullet.length; i++) {
                if (bullet[i].botType) {
                    if (Vector.magnitudeSquared(Vector.sub(bullet[i].position, player.position)) > 1000000) { //far away bots teleport to player
                        Matter.Body.setPosition(bullet[i], Vector.add(player.position, { x: 250 * (Math.random() - 0.5), y: 250 * (Math.random() - 0.5) }));
                        Matter.Body.setVelocity(bullet[i], { x: 0, y: 0 });
                    } else { //close bots maintain relative distance to player on teleport
                        Matter.Body.setPosition(bullet[i], Vector.sub(bullet[i].position, change));
                    }
                }
            }
        }
    },
    setupCamera() { //makes the camera not scroll after changing locations
        // only works if velocity is zero
        m.pos.x = player.position.x;
        m.pos.y = playerBody.position.y - m.yOff;
        const scale = 0.8;
        m.transSmoothX = canvas.width2 - m.pos.x - (simulation.mouse.x - canvas.width2) * scale;
        m.transSmoothY = canvas.height2 - m.pos.y - (simulation.mouse.y - canvas.height2) * scale;
        m.transX += (m.transSmoothX - m.transX);
        m.transY += (m.transSmoothY - m.transY);
    },
    edgeZoomOutSmooth: 1,
    camera() {
        //zoom out when mouse gets near the edge of the window
        const dx = simulation.mouse.x / window.innerWidth - 0.5 //x distance from mouse to window center scaled by window width
        const dy = simulation.mouse.y / window.innerHeight - 0.5 //y distance from mouse to window center scaled by window height
        const d = Math.max(dx * dx, dy * dy)
        simulation.edgeZoomOutSmooth = (1 + 4 * d * d) * 0.04 + simulation.edgeZoomOutSmooth * 0.96

        ctx.save();
        ctx.translate(canvas.width2, canvas.height2); //center
        ctx.scale(simulation.zoom / simulation.edgeZoomOutSmooth, simulation.zoom / simulation.edgeZoomOutSmooth); //zoom in once centered
        ctx.translate(-canvas.width2 + m.transX, -canvas.height2 + m.transY); //translate
        // ctx.translate(-canvas.width2 + m.transX - player.velocity.x, -canvas.height2 + m.transY + player.velocity.y); //translate
        //calculate in game mouse position by undoing the zoom and translations
        simulation.mouseInGame.x = (simulation.mouse.x - canvas.width2) / simulation.zoom * simulation.edgeZoomOutSmooth + canvas.width2 - m.transX;
        simulation.mouseInGame.y = (simulation.mouse.y - canvas.height2) / simulation.zoom * simulation.edgeZoomOutSmooth + canvas.height2 - m.transY;
    },
    //for moving camera away from player
    setCameraPosition(x, y, zoom = 1) {
        ctx.restore();
        ctx.save();
        ctx.translate(canvas.width2, canvas.height2); //center
        ctx.scale(zoom, zoom); //zoom in once centered
        ctx.translate(- x, - y); //center

        // ctx.scale(simulation.zoom / simulation.edgeZoomOutSmooth, simulation.zoom / simulation.edgeZoomOutSmooth); //zoom in once centered
        // ctx.translate(-canvas.width2, -canvas.height2); //translate
        //calculate in game mouse position by undoing the zoom and translations
        simulation.mouseInGame.x = (simulation.mouse.x - canvas.width2) / simulation.zoom * simulation.edgeZoomOutSmooth + canvas.width2 - m.transX;
        simulation.mouseInGame.y = (simulation.mouse.y - canvas.height2) / simulation.zoom * simulation.edgeZoomOutSmooth + canvas.height2 - m.transY;
    },
    cameraNoLook() {
        ctx.save();
        ctx.translate(canvas.width2, canvas.height2); //center
        // ctx.scale(simulation.zoom / simulation.edgeZoomOutSmooth, simulation.zoom / simulation.edgeZoomOutSmooth); //zoom in once centered
        ctx.translate(-canvas.width2 + m.transX, -canvas.height2 + m.transY); //translate
        //calculate in game mouse position by undoing the zoom and translations
        simulation.mouseInGame.x = (simulation.mouse.x - canvas.width2) / simulation.zoom * simulation.edgeZoomOutSmooth + canvas.width2 - m.transX;
        simulation.mouseInGame.y = (simulation.mouse.y - canvas.height2) / simulation.zoom * simulation.edgeZoomOutSmooth + canvas.height2 - m.transY;
    },
    restoreCamera() {
        ctx.restore();
    },
    trails(swapPeriod = 150) {
        // const swapPeriod = 150
        const len = 30
        for (let i = 0; i < len; i++) {
            setTimeout(function () {
                simulation.wipe = function () { //set wipe to have trails
                    ctx.fillStyle = `rgba(221,221,221,${i * i * 0.0005 + 0.0025})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }, (i) * swapPeriod);
        }

        setTimeout(function () {
            simulation.wipe = function () { //set wipe to normal
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }, len * swapPeriod);
    },
    // warp(translation = 5, skew = 0.05, scale = 0.05) {
    // if (simulation.cycle % 2) { //have to alternate frames or else successive rumbles over write the effects of the previous rumble
    // requestAnimationFrame(() => { ctx.setTransform(1, 0, 0, 1, 0, 0); }) //reset
    // requestAnimationFrame(() => {
    //     if (!simulation.paused && m.alive) {
    //         ctx.transform(1 - scale * (Math.random() - 0.5), skew * (Math.random() - 0.5), skew * (Math.random() - 0.5), 1 - scale * (Math.random() - 0.5), translation * (Math.random() - 0.5), translation * (Math.random() - 0.5)); //ctx.transform(Horizontal scaling. A value of 1 results in no scaling,  Vertical skewing,   Horizontal skewing,   Vertical scaling. A value of 1 results in no scaling,   Horizontal translation (moving),   Vertical translation (moving)) //https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setTransform
    //     }
    // })

    //reset
    // ctx.transform(1, 0, 0, 1, 0, 0); //ctx.transform(Horizontal scaling. A value of 1 results in no scaling,  Vertical skewing,   Horizontal skewing,   Vertical scaling. A value of 1 results in no scaling,   Horizontal translation (moving),   Vertical translation (moving)) //https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setTransform

    // }
    // const loop = () => {
    //     if (!simulation.paused && m.alive) {
    //         ctx.save();
    //         ctx.transform(1 - scale * (Math.random() - 0.5), skew * (Math.random() - 0.5), skew * (Math.random() - 0.5), 1 - scale * (Math.random() - 0.5), translation * (Math.random() - 0.5), translation * (Math.random() - 0.5)); //ctx.transform(Horizontal scaling. A value of 1 results in no scaling,  Vertical skewing,   Horizontal skewing,   Vertical scaling. A value of 1 results in no scaling,   Horizontal translation (moving),   Vertical translation (moving))
    //         requestAnimationFrame(() => { ctx.restore(); })
    //     }
    // }
    // requestAnimationFrame(loop);

    // function loop() {
    //     if (!simulation.paused && m.alive) {
    //         ctx.save();
    //         ctx.transform(1 - scale * (Math.random() - 0.5), skew * (Math.random() - 0.5), skew * (Math.random() - 0.5), 1 - scale * (Math.random() - 0.5), translation * (Math.random() - 0.5), translation * (Math.random() - 0.5)); //ctx.transform(Horizontal scaling. A value of 1 results in no scaling,  Vertical skewing,   Horizontal skewing,   Vertical scaling. A value of 1 results in no scaling,   Horizontal translation (moving),   Vertical translation (moving))
    //         requestAnimationFrame(() => { ctx.restore(); })
    //     }
    //     requestAnimationFrame(loop);
    // }
    // requestAnimationFrame(loop);
    // },
    wipe() { }, //set in simulation.startGame
    gravity() {
        function addGravity(bodies, magnitude) {
            for (var i = 0; i < bodies.length; i++) {
                bodies[i].force.y += bodies[i].mass * magnitude;
            }
        }
        if (!m.isTimeDilated) {
            addGravity(powerUp, simulation.g);
            addGravity(body, simulation.g);
        }
        player.force.y += player.mass * simulation.g;
    },
    firstRun: true,
    splashReturn() {
        document.getElementById("previous-seed").innerHTML = `previous seed: <span style="font-size:80%;">${Math.initialSeed}</span><br>`
        document.getElementById("seed").value = Math.initialSeed = Math.seed //randomize initial seed

        //String(document.getElementById("seed").value)
        // Math.seed = Math.abs(Math.hash(Math.initialSeed)) //update randomizer seed in case the player changed it


        simulation.clearTimeouts();
        simulation.onTitlePage = true;
        document.getElementById("splash").onclick = function () {
            simulation.startGame();
        };
        document.getElementById("choose-grid").style.visibility = "hidden"
        document.getElementById("choose-grid").style.opacity = "0"
        document.getElementById("info").style.display = "inline";
        document.getElementById("info").style.opacity = "0";
        document.getElementById("experiment-button").style.display = "inline"
        document.getElementById("experiment-button").style.opacity = "0";
        document.getElementById("training-button").style.display = "inline"
        document.getElementById("training-button").style.opacity = "0";
        document.getElementById("start-button").style.display = "inline"
        document.getElementById("start-button").style.opacity = "0";
        document.getElementById("experiment-grid").style.display = "none"
        document.getElementById("pause-grid-left").style.display = "none"
        document.getElementById("pause-grid-right").style.display = "none"
        document.getElementById("splash").style.display = "inline";
        document.getElementById("splash").style.opacity = "0";
        document.getElementById("dmg").style.display = "none";
        document.getElementById("health-bg").style.display = "none";
        document.getElementById("defense-bar").style.display = "none"
        document.getElementById("damage-bar").style.display = "none"
        document.body.style.cursor = "auto";
        setTimeout(() => {
            document.getElementById("experiment-button").style.opacity = "1";
            document.getElementById("training-button").style.opacity = "1";
            document.getElementById("start-button").style.opacity = "1";
            document.getElementById("info").style.opacity = "1";
            document.getElementById("splash").style.opacity = "1";
        }, 200);
    },
    fpsInterval: 0, //set in startGame
    then: null,
    startGame(isBuildRun = false, isTrainingRun = false) {
        simulation.isTextLogOpen = true
        simulation.clearMap()
        if (!isBuildRun) { //if a build run logic flow returns to "experiment-button").addEventListener
            document.body.style.cursor = "none";
            document.body.style.overflow = "hidden"
        }
        if (isTrainingRun) {
            simulation.isTraining = true
        } else {
            simulation.isTraining = false
        }
        simulation.onTitlePage = false;
        // document.getElementById("choose-grid").style.display = "none"
        document.getElementById("choose-grid").style.visibility = "hidden"
        document.getElementById("choose-grid").style.opacity = "0"
        document.getElementById("experiment-grid").style.display = "none"
        document.getElementById("info").style.display = "none";
        document.getElementById("experiment-button").style.display = "none";
        document.getElementById("training-button").style.display = "none";
        document.getElementById("start-button").style.display = "none";
        // document.getElementById("experiment-button").style.opacity = "0";
        document.getElementById("splash").onclick = null; //removes the onclick effect so the function only runs once
        document.getElementById("splash").style.display = "none"; //hides the element that spawned the function
        document.getElementById("dmg").style.display = "inline";
        document.getElementById("health").style.display = "inline"
        document.getElementById("health-bg").style.display = "inline";
        if (!localSettings.isHideHUD) {
            document.getElementById("right-HUD").style.display = "inline"
            document.getElementById("defense-bar").style.display = "inline"
            document.getElementById("damage-bar").style.display = "inline"
        } else {
            document.getElementById("right-HUD").style.display = "none"
            document.getElementById("defense-bar").style.display = "none"
            document.getElementById("damage-bar").style.display = "none"
        }
        document.getElementById("guns").style.display = "inline"
        document.getElementById("field").style.display = "inline"

        // document.body.style.overflow = "hidden"
        document.getElementById("pause-grid-left").style.display = "none"
        document.getElementById("pause-grid-right").style.display = "none"
        document.getElementById("pause-grid-right").style.opacity = "1"
        document.getElementById("pause-grid-left").style.opacity = "1"
        ctx.globalCompositeOperation = "source-over"
        ctx.shadowBlur = 0;

        mouseMove = mouseMoveDefault
        requestAnimationFrame(() => {
            ctx.setTransform(1, 0, 0, 1, 0, 0); //reset warp effect
            ctx.setLineDash([]) //reset stroke dash effect
        })
        // ctx.shadowColor = '#000';
        if (!m.isShipMode) {
            m.resetSkin() //set the play draw to normal, undoing some junk tech
            m.spawn(); //spawns the player
            m.look = m.lookDefault
        } else {
            Composite.add(engine.world, [player])
        }
        seededShuffle(level.constraint)
        level.populateLevels()
        input.endKeySensing();
        simulation.ephemera = []
        powerUps.powerUpStorage = []
        tech.resetAllTech(); //sets tech to default values
        b.resetAllGuns();
        for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
            if (b.guns[i].name === "laser") b.guns[i].chooseFireMethod()
            if (b.guns[i].name === "nail gun") b.guns[i].chooseFireMethod()
            if (b.guns[i].name === "super balls") b.guns[i].chooseFireMethod()
            if (b.guns[i].name === "harpoon") b.guns[i].chooseFireMethod()
            if (b.guns[i].name === "foam") b.guns[i].chooseFireMethod()
        }
        b.zeroBotCount()

        m.isSwitchingWorlds = false
        simulation.isChoosing = false;
        b.setFireMethod()
        b.setFireCD();
        for (let i = 0; i < b.guns.length; i++) b.guns[i].isRecentlyShown = false //reset recently shown back to zero
        for (let i = 0; i < m.fieldUpgrades.length; i++) m.fieldUpgrades[i].isRecentlyShown = false //reset recently shown back to zero
        for (let i = 0; i < tech.tech.length; i++) tech.tech[i].isRecentlyShown = false //reset recently shown back to zero

        powerUps.tech.choiceLog = [];
        powerUps.gun.choiceLog = [];
        powerUps.field.choiceLog = [];
        powerUps.totalPowerUps = 0;
        powerUps.research.count = 0;
        powerUps.boost.endCycle = 0
        powerUps.isFieldSpawned = false
        m.setFillColors();
        input.isPauseKeyReady = true
        simulation.wipe = function () { //set wipe to normal
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        m.lastHit = 0
        m.hole.isOn = false
        simulation.paused = false;
        engine.timing.timeScale = 1;
        simulation.fpsCap = simulation.fpsCapDefault;
        simulation.isAutoZoom = true;
        simulation.makeGunHUD();
        simulation.lastLogTime = 0;
        mobs.mobDeaths = 0
        level.isFlipped = false
        level.onLevel = 0;
        level.levelsCleared = 0;
        level.updateDifficulty()
        // level.setConstraints()

        simulation.clearNow = true;
        document.getElementById("text-log").style.display = "none"
        document.getElementById("fade-out").style.opacity = 0;
        document.title = "n-gon";
        simulation.inGameConsole(`Math.seed <span class='color-symbol'>=</span> ${Math.initialSeed}`);
        simulation.inGameConsole(`<span class='color-var'>const</span> engine <span class='color-symbol'>=</span> Engine.create(); <em>//simulation begin</em>`);
        simulation.inGameConsole(`engine.timing.timeScale <span class='color-symbol'>=</span> 1`);
        m.alive = true;
        m.definePlayerMass();
        m.onGround = false
        m.lastOnGroundCycle = 0
        m.health = 0;
        level.isLowHeal = false
        m.addHealth(0.25)
        m.drop();
        m.holdingTarget = null

        //set to default field
        tech.healMaxEnergyBonus = 0
        m.energy = 0
        m.immuneCycle = 0;
        m.coupling = 0
        m.setField(0) //this calls m.couplingChange(), which sets max health and max energy
        //exit testing
        if (simulation.testing) {
            simulation.testing = false;
            simulation.loop = simulation.normalLoop
            if (simulation.isConstructionMode) document.getElementById("construct").style.display = 'none'
        }
        simulation.isCheating = false
        simulation.firstRun = false;
        build.hasExperimentalMode = false
        build.isExperimentSelection = false;
        build.isExperimentRun = false;


        //setup checks
        if (!localSettings.isHideHUD) {
            simulation.ephemera.push({
                name: "dmgDefBars", count: 0, do() {
                    if (!(m.cycle % 15)) { //4 times a second
                        const defense = m.defense() //update defense bar
                        if (m.lastCalculatedDefense !== defense) {
                            document.getElementById("defense-bar").style.width = Math.floor(300 * m.maxHealth * (1 - defense)) + "px";
                            m.lastCalculatedDefense = defense
                        }
                        const damage = tech.damageAdjustments() //update damage bar
                        if (m.lastCalculatedDamage !== damage) {
                            document.getElementById("damage-bar").style.height = Math.floor((Math.atan(0.25 * damage - 0.25) + 0.25) * 0.63 * canvas.height) + "px";
                            m.lastCalculatedDamage = damage
                        }
                    }
                },
            })
        }
        simulation.ephemera.push({
            name: "uniqueName", count: 0, do() {
                if (!(m.cycle % 60)) { //once a second
                    //energy overfill 
                    if (m.energy > m.maxEnergy) {
                        m.energy = m.maxEnergy + (m.energy - m.maxEnergy) * tech.overfillDrain //every second energy above max energy loses 25%
                        if (m.energy > 1000000) m.energy = 1000000
                    }
                    if (m.pos.y > simulation.fallHeight) { // if 4000px deep
                        if (level.fallMode === "start") {
                            //infinite falling.  teleport to sky after falling

                            simulation.ephemera.push({
                                name: "slow player",
                                count: 160, //cycles before it self removes
                                do() {
                                    this.count--
                                    if (this.count < 0 || m.onGround) simulation.removeEphemera(this.name)
                                    if (player.velocity.y > 70) Matter.Body.setVelocity(player, { x: player.velocity.x * 0.99, y: player.velocity.y * 0.99 });
                                    if (player.velocity.y > 90) Matter.Body.setVelocity(player, { x: player.velocity.x * 0.99, y: player.velocity.y * 0.99 });
                                },
                            })

                            const before = { x: player.position.x, y: player.position.y, }
                            Matter.Body.setPosition(player, { x: level.enter.x, y: level.enter.y - 3000 });
                            // Matter.Body.setPosition(player, level.fallPosition);

                            const change = { x: before.x - player.position.x, y: before.y - player.position.y }
                            // translate camera smoothly to preserve illusion to endless fall
                            m.transX += change.x
                            m.transY += change.y
                            simulation.mouseInGame.x = (simulation.mouse.x - canvas.width2) / simulation.zoom * simulation.edgeZoomOutSmooth + canvas.width2 - m.transX;
                            simulation.mouseInGame.y = (simulation.mouse.y - canvas.height2) / simulation.zoom * simulation.edgeZoomOutSmooth + canvas.height2 - m.transY;
                            m.angle = Math.atan2(simulation.mouseInGame.y - m.pos.y, simulation.mouseInGame.x - m.pos.x);
                            // move bots
                            for (let i = 0; i < bullet.length; i++) {
                                if (bullet[i].botType) Matter.Body.setPosition(bullet[i], Vector.sub(bullet[i].position, change));
                            }
                        } else if (level.fallMode === "position") { //fall and stay in the same horizontal position
                            simulation.ephemera.push({
                                name: "slow player",
                                count: 180, //cycles before it self removes
                                do() {
                                    this.count--
                                    if (this.count < 0 || m.onGround) simulation.removeEphemera(this.name)
                                    if (player.velocity.y > 70) Matter.Body.setVelocity(player, { x: player.velocity.x * 0.99, y: player.velocity.y * 0.99 });
                                    if (player.velocity.y > 90) Matter.Body.setVelocity(player, { x: player.velocity.x * 0.99, y: player.velocity.y * 0.99 });
                                },
                            })
                            const before = { x: player.position.x, y: player.position.y, }
                            const posXClamped = Math.min(Math.max(level.fallModeBounds.left, player.position.x), level.fallModeBounds.right)
                            Matter.Body.setPosition(player, { x: posXClamped, y: level.enter.y - 4000 });

                            // translate camera smoothly to preserve illusion to endless fall
                            const change = { x: before.x - posXClamped, y: before.y - player.position.y }
                            m.transX += change.x
                            m.transY += change.y
                            simulation.mouseInGame.x = (simulation.mouse.x - canvas.width2) / simulation.zoom * simulation.edgeZoomOutSmooth + canvas.width2 - m.transX;
                            simulation.mouseInGame.y = (simulation.mouse.y - canvas.height2) / simulation.zoom * simulation.edgeZoomOutSmooth + canvas.height2 - m.transY;
                            m.angle = Math.atan2(simulation.mouseInGame.y - m.pos.y, simulation.mouseInGame.x - m.pos.x);

                            // move bots
                            for (let i = 0; i < bullet.length; i++) {
                                if (bullet[i].botType) Matter.Body.setPosition(bullet[i], Vector.sub(bullet[i].position, change));
                            }
                        } else { //get hurt and go to start
                            Matter.Body.setVelocity(player, { x: 0, y: 0 });
                            Matter.Body.setPosition(player, { x: level.enter.x + 50, y: level.enter.y - 20 });
                            // move bots
                            for (let i = 0; i < bullet.length; i++) {
                                if (bullet[i].botType) {
                                    Matter.Body.setPosition(bullet[i], Vector.add(player.position, { x: 250 * (Math.random() - 0.5), y: 250 * (Math.random() - 0.5) }));
                                    Matter.Body.setVelocity(bullet[i], { x: 0, y: 0 });
                                }
                            }
                        }





                    }
                    if (isNaN(player.position.x)) m.death();
                    if (m.lastKillCycle + 300 > m.cycle) { //effects active for 5 seconds after killing a mob
                        if (tech.isEnergyRecovery && m.immuneCycle < m.cycle) {
                            m.energy += m.maxEnergy * 0.05 * level.isReducedRegen
                            simulation.drawList.push({ //add dmg to draw queue
                                x: m.pos.x,
                                y: m.pos.y - 45,
                                radius: Math.sqrt(m.maxEnergy * 0.05) * 60,
                                color: "rgba(0, 204, 255,0.4)", //#0cf
                                time: 4
                            });
                        }
                        if (tech.isHealthRecovery) {
                            if (tech.isEnergyHealth) {
                                if (m.immuneCycle < m.cycle) {
                                    m.energy += m.maxEnergy * 0.005 * level.isReducedRegen
                                    simulation.drawList.push({ //add dmg to draw queue
                                        x: m.pos.x,
                                        y: m.pos.y,
                                        radius: Math.sqrt(m.maxEnergy * 0.02) * 60,
                                        color: "rgba(0, 204, 255,0.4)", //#0cf
                                        time: 4
                                    });
                                }
                            } else {
                                const heal = 0.005 * m.maxHealth
                                m.addHealth(heal)
                                simulation.drawList.push({ //add dmg to draw queue
                                    x: m.pos.x,
                                    y: m.pos.y,
                                    radius: Math.sqrt(heal) * 150,
                                    color: "rgba(0,255,200,0.5)",
                                    time: 4
                                });
                            }
                        }
                    }

                    if (!(m.cycle % 420)) { //once every 7 seconds
                        //check if player is inside the map
                        if (Matter.Query.point(map, m.pos).length > 0 || Matter.Query.point(map, player.position).length > 0) {
                            //check for the next few seconds to see if being stuck continues
                            simulation.ephemera.push({
                                name: "stuck",
                                count: 240, //cycles before it self removes
                                do() {
                                    if (Matter.Query.point(map, m.pos).length > 0 || Matter.Query.point(map, player.position).length > 0) {
                                        this.count--

                                        if (this.count < 0) {
                                            simulation.removeEphemera(this.name)
                                            Matter.Body.setVelocity(player, { x: 0, y: 0 });
                                            Matter.Body.setPosition(player, { x: level.enter.x + 50, y: level.enter.y - 20 });
                                        }
                                    } else {
                                        simulation.removeEphemera(this.name)
                                    }
                                },
                            })
                        }
                        if (tech.isZeno) {
                            if (tech.isEnergyHealth) {
                                m.energy *= 0.95
                            } else {
                                m.health *= 0.95 //remove 5%
                                m.displayHealth();
                            }
                            simulation.drawList.push({ //add dmg to draw queue
                                x: m.pos.x,
                                y: m.pos.y,
                                radius: 5,
                                color: "rgb(255, 0, 195)",
                                time: 4
                            });
                        }
                        if (tech.cyclicImmunity && m.immuneCycle < m.cycle + tech.cyclicImmunity) m.immuneCycle = m.cycle + tech.cyclicImmunity; //player is immune to damage for 60 cycles



                        let i = body.length;
                        while (i--) {
                            if (body[i].position.y > simulation.fallHeight) {
                                Matter.Composite.remove(engine.world, body[i]);
                                body.splice(i, 1);
                            }
                        }
                        i = powerUp.length
                        while (i--) {
                            if (powerUp[i].position.y > simulation.fallHeight) {
                                Matter.Body.setVelocity(powerUp[i], { x: 0, y: 0 });
                                if (level.fallMode === "position") {
                                    const posXClamped = Math.min(Math.max(level.fallModeBounds.left, powerUp[i].position.x), level.fallModeBounds.right)
                                    Matter.Body.setPosition(powerUp[i], { x: posXClamped, y: level.enter.y - 3000 });
                                } else {
                                    Matter.Body.setPosition(powerUp[i], {
                                        x: level.exit.x + 30 * (Math.random() - 0.5),
                                        y: level.exit.y + 30 * (Math.random() - 0.5)
                                    });
                                }
                            }
                        }
                        i = mob.length;
                        while (i--) {
                            if (mob[i].position.y > simulation.fallHeight) {
                                if (mob[i].isBoss && level.fallMode === "position") {
                                    Matter.Body.setVelocity(mob[i], { x: 0, y: 0 });
                                    const posXClamped = Math.min(Math.max(level.fallModeBounds.left, mob[i].position.x), level.fallModeBounds.right)
                                    Matter.Body.setPosition(mob[i], { x: posXClamped, y: level.enter.y - 3000 });
                                } else {
                                    mob[i].death();
                                }
                            }
                        }

                    }
                }
            },
        })

        //setup FPS cap
        simulation.fpsInterval = 1000 / simulation.fpsCap;
        simulation.then = Date.now();
        requestAnimationFrame(cycle); //starts game loop
    },
    clearTimeouts() {
        let id = window.setTimeout(function () { }, 0);
        while (id--) {
            window.clearTimeout(id); // will do nothing if no timeout with id is present
        }
    },
    clearNow: false,
    clearMap() {
        level.isVerticalFLipLevel = false
        level.isProcedural = false;
        level.fallMode = "";
        simulation.unFlipCameraVertical()
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (m.alive) {
            if (tech.isLongitudinal) b.guns[3].waves = []; //empty array of wave bullets
            if (b.guns[10].have) { //do you have mines as a gun
                let count = 0;
                for (i = 0, len = bullet.length; i < len; i++) { //count mines left on map
                    if (
                        (bullet[i].bulletType === "mine" && (!tech.isMineSentry || bullet[i].shots === undefined)) ||
                        bullet[i].bulletType === "laser mine") {
                        count++
                    }
                }
                if (tech.crouchAmmoCount) count = Math.ceil(count / 2)
                b.guns[10].ammo += count
                if (tech.ammoCap) b.guns[10].ammo = Math.min(tech.ammoCap, b.guns[10].ammo)
                simulation.updateGunHUD();
            }

            if (tech.isMutualism && !tech.isEnergyHealth) {
                for (let i = 0; i < bullet.length; i++) {
                    if (bullet[i].isMutualismActive) {
                        m.health += 0.01 + 0.01 * ((bullet[i].isSpore || bullet[i].isFlea) ? 0 : 1)
                        if (m.health > m.maxHealth) m.health = m.maxHealth;
                        m.displayHealth();
                    }
                }
            }
            if (tech.isEndLevelPowerUp) {
                for (let i = 0; i < powerUp.length; i++) {
                    if (powerUp[i].name === "tech") {
                        tech.giveTech()
                    } else if (powerUp[i].name === "gun") {
                        if (!tech.isOneGun) b.giveGuns("random")
                    } else if (powerUp[i].name === "field") {
                        if (m.fieldMode === 0) m.setField(Math.ceil(Math.random() * (m.fieldUpgrades.length - 1))) //pick a random field, but not field 0
                    } else {
                        powerUp[i].effect();
                    }
                }
            }
        }
        simulation.lastLogTime = 0; //clear previous messages
        spawn.allowShields = true;
        powerUps.totalPowerUps = powerUp.length
        let holdTarget = (m.holdingTarget) ? m.holdingTarget : undefined //if player is holding something this remembers it before it gets deleted
        tech.deathSpawnsFromBoss = 0;
        simulation.fallHeight = 3000;
        document.body.style.backgroundColor = "#eee" //"#d8dadf";
        // color.map = "#444";
        // color.bullet = "#FFFFFF";
        color = { //light
            // background: "#ddd", // used instead:  document.body.style.backgroundColor
            block: "rgba(140,140,140,0.85)",
            blockS: "#222",
            map: "#444",
            bullet: "#000"
        }
        simulation.draw.drawMapPath = simulation.draw.drawMapPathDefault
        m.fireCDcycle = 0
        m.drop();
        m.hole.isOn = false;
        simulation.drawList = [];
        mobs.maxMobBody = 40

        if (tech.isHealAttract && m.alive) { //send health power ups to the next level
            let healCount = 0
            for (let i = 0, len = powerUp.length; i < len; i++) {
                if (powerUp[i].name === "heal" && Vector.magnitudeSquared(Vector.sub(powerUp[i].position, m.pos)) < 1000000) healCount++
            }
            //respawn health in animation frame
            let respawnHeal = () => {
                if (healCount > 0) {
                    requestAnimationFrame(respawnHeal);
                    if (!simulation.paused && !simulation.isChoosing) {
                        healCount--
                        powerUps.directSpawn(level.enter.x + 50 + 100 * (Math.random() - 0.5), level.enter.y - 60 + 100 * (Math.random() - 0.5), "heal");
                    }
                }
            }
            requestAnimationFrame(respawnHeal);
        }
        if (tech.isDronesTravel && m.alive) {
            //count drones
            let droneCount = 0
            let sporeCount = 0
            let wormCount = 0
            let fleaCount = 0
            let deliveryCount = 0
            for (let i = 0; i < bullet.length; ++i) {
                if (bullet[i].isDrone) {
                    droneCount++
                    if (bullet[i].isImproved) deliveryCount++
                } else if (bullet[i].isSpore) {
                    sporeCount++
                } else if (bullet[i].wormSize) {
                    wormCount++
                } else if (bullet[i].isFlea) {
                    fleaCount++
                }
            }

            //respawn drones in animation frame
            requestAnimationFrame(() => { b.delayDrones({ x: level.enter.x + 50, y: level.enter.y - 60 }, droneCount, deliveryCount) });

            //respawn spores in animation frame
            let respawnSpores = () => {
                if (sporeCount > 0) {
                    requestAnimationFrame(respawnSpores);
                    if (!simulation.paused && !simulation.isChoosing) {
                        sporeCount--
                        const where = {
                            x: level.enter.x + 50,
                            y: level.enter.y - 60
                        }
                        b.spore({
                            x: where.x + 100 * (Math.random() - 0.5),
                            y: where.y + 120 * (Math.random() - 0.5)
                        })
                    }
                }
            }
            requestAnimationFrame(respawnSpores);

            //respawn worms in animation frame
            let respawnWorms = () => {
                if (wormCount > 0) {
                    requestAnimationFrame(respawnWorms);
                    if (!simulation.paused && !simulation.isChoosing) {
                        wormCount--
                        const where = {
                            x: level.enter.x + 50,
                            y: level.enter.y - 60
                        }
                        b.worm({
                            x: where.x + 100 * (Math.random() - 0.5),
                            y: where.y + 120 * (Math.random() - 0.5)
                        })
                    }
                }
            }
            requestAnimationFrame(respawnWorms);

            //respawn fleas in animation frame
            let respawnFleas = () => {
                if (fleaCount > 0) {
                    requestAnimationFrame(respawnFleas);
                    if (!simulation.paused && !simulation.isChoosing) {
                        fleaCount--
                        const where = {
                            x: level.enter.x + 50,
                            y: level.enter.y - 60
                        }
                        const speed = 6 + 3 * Math.random()
                        const angle = 2 * Math.PI * Math.random()
                        b.flea({
                            x: where.x + 100 * (Math.random() - 0.5),
                            y: where.y + 120 * (Math.random() - 0.5)
                        }, {
                            x: speed * Math.cos(angle),
                            y: speed * Math.sin(angle)
                        })
                    }
                }
            }
            requestAnimationFrame(respawnFleas);
        }
        if (tech.isQuantumEraser && m.alive) {
            let count = 0
            for (let i = 0, len = mob.length; i < len; i++) {
                if (mob[i].isDropPowerUp && mob[i].alive) count++
            }
            count *= 0.4 //to fake the 25% chance, this makes it not random, and more predictable
            let cycle = () => { //run after waiting a cycle for the map to be cleared
                const types = ["heal", "ammo", "heal", "ammo", "research", "coupling", "boost", "tech", "gun", "field"]
                for (let i = 0; i < count; i++) powerUps.spawnDelay(types[Math.floor(Math.random() * types.length)], 1)
            }
            requestAnimationFrame(cycle);
        }

        function removeAll(array) {
            // for (let i = 0; i < array.length; ++i) Matter.Composite.remove(engine.world, array[i]);
            for (let i = 0; i < array.length; ++i) Matter.Composite.remove(engine.world, array[i]);
        }
        removeAll(map);
        map = [];
        removeAll(body);
        body = [];
        removeAll(mob);
        mob = [];
        removeAll(powerUp);
        powerUp = [];
        removeAll(cons);
        cons = [];
        removeAll(consBB);
        consBB = [];
        removeAll(bullet);
        bullet = [];
        removeAll(composite);
        composite = [];
        // if player was holding something this makes a new copy to hold
        if (holdTarget && m.alive) {
            len = body.length;
            body[len] = Matter.Bodies.fromVertices(0, 0, holdTarget.vertices, {
                friction: holdTarget.friction,
                frictionAir: holdTarget.frictionAir,
                frictionStatic: holdTarget.frictionStatic
            });
            Matter.Body.setPosition(body[len], m.pos);
            m.isHolding = true
            m.holdingTarget = body[len];
            m.holdingTarget.collisionFilter.category = 0;
            m.holdingTarget.collisionFilter.mask = 0;
            m.definePlayerMass(m.defaultMass + m.holdingTarget.mass * m.holdingMassScale)
            Composite.add(engine.world, m.holdingTarget); //add to world
            m.holdingTarget.classType = "body"
        }
        //set fps back to default
        simulation.fpsCap = simulation.fpsCapDefault
        simulation.fpsInterval = 1000 / simulation.fpsCap;
    },
    // getCoords: {
    //   //used when building maps, outputs a draw rect command to console, only works in testing mode
    //   pos1: {
    //     x: 0,
    //     y: 0
    //   },
    //   pos2: {
    //     x: 0,
    //     y: 0
    //   },
    //   out() {
    //     if (keys[49]) {
    //       simulation.getCoords.pos1.x = Math.round(simulation.mouseInGame.x / 25) * 25;
    //       simulation.getCoords.pos1.y = Math.round(simulation.mouseInGame.y / 25) * 25;
    //     }
    //     if (keys[50]) {
    //       //press 1 in the top left; press 2 in the bottom right;copy command from console
    //       simulation.getCoords.pos2.x = Math.round(simulation.mouseInGame.x / 25) * 25;
    //       simulation.getCoords.pos2.y = Math.round(simulation.mouseInGame.y / 25) * 25;
    //       window.getSelection().removeAllRanges();
    //       var range = document.createRange();
    //       range.selectNode(document.getElementById("test"));
    //       window.getSelection().addRange(range);
    //       document.execCommand("copy");
    //       window.getSelection().removeAllRanges();
    //     }
    //   }
    // },
    testingOutput() {
        ctx.fillStyle = "#000";
        ctx.textAlign = "center";
        ctx.fillText(`(${simulation.mouseInGame.x.toFixed(1)}, ${simulation.mouseInGame.y.toFixed(1)})`, simulation.mouse.x, simulation.mouse.y - 20);
    },
    sight: { //credit to Cornbread2100 for adding this algorithm to n-gon
        // square: 0,
        intersectMap: [], //this is precalculated in simulation.draw.lineOfSightPrecalculation()
        getIntersection(v1, v1End, domain) {
            const intersections = simulation.sight.getIntersections(v1, v1End, domain);
            var best = { x: v1End.x, y: v1End.y, dist: (v1End.x - v1.x) ** 2 + (v1End.y - v1.y) ** 2 }
            for (const intersection of intersections) {
                const dist = (intersection.x - v1.x) ** 2 + (intersection.y - v1.y) ** 2;
                if (dist < best.dist) best = { x: intersection.x, y: intersection.y, dist: dist }
            }
            best.dist = Math.sqrt(best.dist)
            return best;
        },
        getIntersections(v1, v1End, domain) {
            const intersections = [];
            for (const obj of domain) {
                for (var i = 0; i < obj.vertices.length - 1; i++) {
                    results = simulation.checkLineIntersection(v1, v1End, obj.vertices[i], obj.vertices[i + 1]);
                    if (results.onLine1 && results.onLine2) intersections.push({ x: results.x, y: results.y });
                }
                results = simulation.checkLineIntersection(v1, v1End, obj.vertices[obj.vertices.length - 1], obj.vertices[0]);
                if (results.onLine1 && results.onLine2) intersections.push({ x: results.x, y: results.y });
            }
            return intersections;
        },
        circleLoS(pos, radius) {
            function allCircleLineCollisions(c, radius, domain) {
                var lines = [];
                for (const obj of domain) {
                    for (var i = 0; i < obj.vertices.length - 1; i++) lines.push(circleLineCollisions(obj.vertices[i], obj.vertices[i + 1], c, radius));
                    lines.push(circleLineCollisions(obj.vertices[obj.vertices.length - 1], obj.vertices[0], c, radius));
                }
                const collisionLines = [];
                for (const line of lines) {
                    if (line.length == 2) {
                        // const distance1 = Math.sqrt((line[0].x - c.x) ** 2 + (line[0].y - c.y) ** 2)
                        // const angle1 = Math.atan2(line[0].y - c.y, line[0].x - c.x);
                        // const queryPoint1 = {
                        //     x: Math.cos(angle1) * (distance1 - 1) + c.x,
                        //     y: Math.sin(angle1) * (distance1 - 1) + c.y
                        // }
                        // const distance2 = Math.sqrt((line[1].x - c.x) ** 2 + (line[1].y - c.y) ** 2)
                        // const angle2 = Math.atan2(line[1].y - c.y, line[1].x - c.x);
                        // const queryPoint2 = {
                        //     x: Math.cos(angle2) * (distance2 - 1) + c.x,
                        //     y: Math.sin(angle2) * (distance2 - 1) + c.y
                        // }
                        collisionLines.push(line)
                    }
                }

                return collisionLines;
            }

            function circleLineCollisions(a, b, c, radius) {
                // calculate distances
                const angleOffset = Math.atan2(b.y - a.y, b.x - a.x);
                const sideB = Math.sqrt((a.x - c.x) ** 2 + (a.y - c.y) ** 2);
                const sideC = Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);
                const sideA = Math.sqrt((c.x - b.x) ** 2 + (c.y - b.y) ** 2);

                // calculate the closest point on line AB to point C
                const angleA = Math.acos((sideB ** 2 + sideC ** 2 - sideA ** 2) / (2 * sideB * sideC)) * (a.x - c.x) / -Math.abs(a.x - c.x)
                const sideAD = Math.cos(angleA) * sideB;
                const d = { // closest point
                    x: Math.cos(angleOffset) * sideAD + a.x,
                    y: Math.sin(angleOffset) * sideAD + a.y
                }
                const distance = Math.sqrt((d.x - c.x) ** 2 + (d.y - c.y) ** 2);
                if (distance == radius) {
                    // tangent
                    return [d];
                } else if (distance < radius) {
                    // secant
                    const angleOffset = Math.atan2(d.y - c.y, d.x - c.x);
                    const innerAngle = Math.acos(distance / radius);
                    const intersection1 = {
                        x: Math.cos(angleOffset + innerAngle) * radius + c.x,
                        y: Math.sin(angleOffset + innerAngle) * radius + c.y
                    }

                    const intersection2 = {
                        x: Math.cos(angleOffset - innerAngle) * radius + c.x,
                        y: Math.sin(angleOffset - innerAngle) * radius + c.y
                    }

                    const distance1 = {
                        a: Math.sqrt((intersection1.x - a.x) ** 2 + (intersection1.y - a.y) ** 2),
                        b: Math.sqrt((intersection1.x - b.x) ** 2 + (intersection1.y - b.y) ** 2)
                    }
                    const distance2 = {
                        a: Math.sqrt((intersection2.x - a.x) ** 2 + (intersection2.y - a.y) ** 2),
                        b: Math.sqrt((intersection2.x - b.x) ** 2 + (intersection2.y - b.y) ** 2)
                    }
                    const result = [];
                    if (Math.abs(sideC - (distance1.a + distance1.b)) < 0.01) {
                        result.push(intersection1);
                    } else {
                        if (distance1.a < distance1.b) {
                            if (sideB <= radius) result.push(a);
                        } else {
                            if (sideA <= radius) result.push(b)
                        }
                    }
                    if (Math.abs(sideC - (distance2.a + distance2.b)) < 0.01) {
                        result.push(intersection2);
                    } else {
                        if (distance2.a <= distance2.b) {
                            if (sideB <= radius) result.push(a);
                        } else {
                            if (sideA <= radius) result.push(b)
                        }
                    }

                    return result;
                } else {
                    // no intersection
                    return [];
                }
            }

            var vertices = [];
            for (const obj of simulation.sight.intersectMap) {
                for (var i = 0; i < obj.vertices.length; i++) {
                    const vertex = obj.vertices[i];
                    const angleToVertex = Math.atan2(vertex.y - pos.y, vertex.x - pos.x);
                    // const distanceToVertex = Math.sqrt((vertex.x - pos.x) ** 2 + (vertex.y - pos.y) ** 2);
                    // const queryPoint = { x: Math.cos(angleToVertex) * (distanceToVertex - 1) + pos.x, y: Math.sin(angleToVertex) * (distanceToVertex - 1) + pos.y }
                    const queryPoint = { x: Math.cos(angleToVertex + Math.PI) + vertex.x, y: Math.sin(angleToVertex + Math.PI) + vertex.y }

                    if (Matter.Query.ray(map, pos, queryPoint).length == 0) {
                        var distance = Math.sqrt((vertex.x - pos.x) ** 2 + (vertex.y - pos.y) ** 2);
                        var endPoint = { x: vertex.x, y: vertex.y }

                        if (distance > radius) {
                            const angle = Math.atan2(vertex.y - pos.y, vertex.x - pos.x);
                            endPoint = { x: Math.cos(angle) * radius + pos.x, y: Math.sin(angle) * radius + pos.y }
                            distance = radius
                        }

                        var best = simulation.sight.getIntersection(pos, endPoint, map);
                        if (best.dist >= distance) best = { x: endPoint.x, y: endPoint.y, dist: distance }
                        vertices.push(best)

                        var angle = Math.atan2(vertex.y - pos.y, vertex.x - pos.x);
                        endPoint = { x: Math.cos(angle + 0.001) * radius + pos.x, y: Math.sin(angle + 0.001) * radius + pos.y }
                        best = simulation.sight.getIntersection(pos, endPoint, map);

                        if (best.dist >= radius) best = { x: endPoint.x, y: endPoint.y, dist: radius }
                        vertices.push(best)

                        angle = Math.atan2(vertex.y - pos.y, vertex.x - pos.x);
                        endPoint = { x: Math.cos(angle - 0.001) * radius + pos.x, y: Math.sin(angle - 0.001) * radius + pos.y }

                        best = simulation.sight.getIntersection(pos, endPoint, map);
                        if (best.dist >= radius) best = { x: endPoint.x, y: endPoint.y, dist: radius }
                        vertices.push(best)
                    }
                }
            }

            const outerCollisions = allCircleLineCollisions(pos, radius, map);
            const circleCollisions = [];
            for (const line of outerCollisions) {
                for (const vertex of line) {
                    const distance = Math.sqrt((vertex.x - pos.x) ** 2 + (vertex.y - pos.y) ** 2)
                    const angle = Math.atan2(vertex.y - pos.y, vertex.x - pos.x);
                    const queryPoint = { x: Math.cos(angle + Math.PI) + vertex.x, y: Math.sin(angle + Math.PI) + vertex.y }
                    if (Math.abs(distance - radius) < 1 && Matter.Query.ray(map, pos, queryPoint).length == 0) circleCollisions.push(vertex)
                }
            }
            for (var i = 0; i < circleCollisions.length; i++) {
                const vertex = circleCollisions[i];
                var nextIndex = i + 1;
                if (nextIndex == circleCollisions.length) nextIndex = 0;
                const nextVertex = circleCollisions[nextIndex];
                const angle1 = Math.atan2(vertex.y - pos.y, vertex.x - pos.x);
                const angle2 = Math.atan2(nextVertex.y - pos.y, nextVertex.x - pos.x);
                var newAngle;
                if (Math.abs(angle1) > Math.PI / 2 && Math.abs(angle2) > Math.PI / 2 && angle1 / Math.abs(angle1) != angle2 / Math.abs(angle2)) {
                    // if the arc between the to points crosses over the left side (+/- pi radians)
                    const newAngle1 = (Math.PI - Math.abs(angle1)) * (angle1 / Math.abs(angle1));
                    const newAngle2 = (Math.PI - Math.abs(angle2)) * (angle2 / Math.abs(angle2));
                    newAngle = (newAngle1 + newAngle2) / 2;
                    var multiplier;
                    if (newAngle == 0) {
                        multiplier = 1;
                    } else {
                        multiplier = newAngle / Math.abs(newAngle);
                    }
                    newAngle = Math.PI * multiplier - newAngle * multiplier;
                    test = true;
                } else {
                    newAngle = (angle1 + angle2) / 2;
                }

                // shoot ray between them
                var endPoint = { x: Math.cos(newAngle) * radius + pos.x, y: Math.sin(newAngle) * radius + pos.y }
                var best = simulation.sight.getIntersection(pos, endPoint, map);
                vertices.push(vertex);
                if (best.dist <= radius) vertices.push({ x: best.x, y: best.y })
            }
            vertices.sort((a, b) => Math.atan2(a.y - pos.y, a.x - pos.x) - Math.atan2(b.y - pos.y, b.x - pos.x));
            return vertices;
        },
    },
    draw: {
        // powerUp() { //is set by Bayesian tech
        //     // ctx.globalAlpha = 0.4 * Math.sin(m.cycle * 0.15) + 0.6;
        //     // for (let i = 0, len = powerUp.length; i < len; ++i) {
        //     //   ctx.beginPath();
        //     //   ctx.arc(powerUp[i].position.x, powerUp[i].position.y, powerUp[i].size, 0, 2 * Math.PI);
        //     //   ctx.fillStyle = powerUp[i].color;
        //     //   ctx.fill();
        //     // }
        //     // ctx.globalAlpha = 1;
        // },
        // powerUpNormal() { //back up in case power up draw gets changed
        //     ctx.globalAlpha = 0.4 * Math.sin(m.cycle * 0.15) + 0.6;
        //     for (let i = 0, len = powerUp.length; i < len; ++i) {
        //         ctx.beginPath();
        //         ctx.arc(powerUp[i].position.x, powerUp[i].position.y, powerUp[i].size, 0, 2 * Math.PI);
        //         ctx.fillStyle = powerUp[i].color;
        //         ctx.fill();
        //     }
        //     ctx.globalAlpha = 1;
        // },
        // powerUpBonus() { //draws crackle effect for bonus power ups
        //     ctx.globalAlpha = 0.4 * Math.sin(m.cycle * 0.15) + 0.6;
        //     for (let i = 0, len = powerUp.length; i < len; ++i) {
        //         ctx.beginPath();
        //         ctx.arc(powerUp[i].position.x, powerUp[i].position.y, powerUp[i].size, 0, 2 * Math.PI);
        //         ctx.fillStyle = powerUp[i].color;
        //         ctx.fill();
        //     }
        //     ctx.globalAlpha = 1;
        //     for (let i = 0, len = powerUp.length; i < len; ++i) {
        //         if (powerUp[i].isDuplicated && Math.random() < 0.1) {
        //             //draw electricity
        //             const mag = 5 + powerUp[i].size / 5
        //             let unit = Vector.rotate({
        //                 x: mag,
        //                 y: mag
        //             }, 2 * Math.PI * Math.random())
        //             let path = {
        //                 x: powerUp[i].position.x + unit.x,
        //                 y: powerUp[i].position.y + unit.y
        //             }
        //             ctx.beginPath();
        //             ctx.moveTo(path.x, path.y);
        //             for (let i = 0; i < 6; i++) {
        //                 unit = Vector.rotate(unit, 3 * (Math.random() - 0.5))
        //                 path = Vector.add(path, unit)
        //                 ctx.lineTo(path.x, path.y);
        //             }
        //             ctx.lineWidth = 0.5 + 2 * Math.random();
        //             ctx.strokeStyle = "#000"
        //             ctx.stroke();
        //         }
        //     }
        // },

        // map: function() {
        //     ctx.beginPath();
        //     for (let i = 0, len = map.length; i < len; ++i) {
        //         let vertices = map[i].vertices;
        //         ctx.moveTo(vertices[0].x, vertices[0].y);
        //         for (let j = 1; j < vertices.length; j += 1) {
        //             ctx.lineTo(vertices[j].x, vertices[j].y);
        //         }
        //         ctx.lineTo(vertices[0].x, vertices[0].y);
        //     }
        //     ctx.fillStyle = "#444";
        //     ctx.fill();
        // },
        mapPath: null, //holds the path for the map to speed up drawing
        setPaths() {
            //runs at each new level to store the path for the map since the map doesn't change
            simulation.draw.mapPath = new Path2D();
            for (let i = 0, len = map.length; i < len; ++i) {
                let vertices = map[i].vertices;
                simulation.draw.mapPath.moveTo(vertices[0].x, vertices[0].y);
                for (let j = 1; j < vertices.length; j += 1) {
                    simulation.draw.mapPath.lineTo(vertices[j].x, vertices[j].y);
                }
                simulation.draw.mapPath.lineTo(vertices[0].x, vertices[0].y);
            }
        },
        lineOfSightPrecalculation() {
            simulation.sight.intersectMap = [];
            for (var i = 0; i < map.length; i++) {
                const obj = map[i];
                const newVertices = [];
                const restOfMap = [...map].slice(0, i).concat([...map].slice(i + 1))
                for (var j = 0; j < obj.vertices.length - 1; j++) {
                    var intersections = simulation.sight.getIntersections(obj.vertices[j], obj.vertices[j + 1], restOfMap);
                    newVertices.push(obj.vertices[j]);
                    for (const vertex of intersections) newVertices.push({ x: vertex.x, y: vertex.y });
                }
                intersections = simulation.sight.getIntersections(obj.vertices[obj.vertices.length - 1], obj.vertices[0], restOfMap);
                newVertices.push(obj.vertices[obj.vertices.length - 1]);
                for (const vertex of intersections) newVertices.push({ x: vertex.x, y: vertex.y });
                //draw the vertices as black circles for debugging
                // for (const vertex of newVertices) {
                //     ctx.beginPath();
                //     ctx.moveTo(vertex.x, vertex.y);
                //     ctx.arc(vertex.x, vertex.y, 10, 0, 2 * Math.PI);
                //     ctx.fillStyle = '#000';
                //     ctx.fill()
                // }
                simulation.sight.intersectMap.push({ vertices: newVertices });
            }
        },
        drawMapPath() { },
        drawMapPathDefault() {
            ctx.fillStyle = color.map;
            ctx.fill(simulation.draw.mapPath);
        },
        drawMapSight() {
            if (!simulation.isTimeSkipping) {
                const pos = m.pos
                const radius = 4000
                const vertices = simulation.sight.circleLoS(pos, radius);
                if (vertices.length) {
                    ctx.beginPath();
                    ctx.moveTo(vertices[0].x, vertices[0].y);
                    for (var i = 1; i < vertices.length; i++) {
                        var currentDistance = Math.sqrt((vertices[i - 1].x - pos.x) ** 2 + (vertices[i - 1].y - pos.y) ** 2);
                        var newDistance = Math.sqrt((vertices[i].x - pos.x) ** 2 + (vertices[i].y - pos.y) ** 2);
                        if (Math.abs(currentDistance - radius) < 1 && Math.abs(newDistance - radius) < 1) {
                            const currentAngle = Math.atan2(vertices[i - 1].y - pos.y, vertices[i - 1].x - pos.x);
                            const newAngle = Math.atan2(vertices[i].y - pos.y, vertices[i].x - pos.x);
                            ctx.arc(pos.x, pos.y, radius, currentAngle, newAngle);
                        } else {
                            ctx.lineTo(vertices[i].x, vertices[i].y)
                        }
                    }
                    newDistance = Math.sqrt((vertices[0].x - pos.x) ** 2 + (vertices[0].y - pos.y) ** 2);
                    currentDistance = Math.sqrt((vertices[vertices.length - 1].x - pos.x) ** 2 + (vertices[vertices.length - 1].y - pos.y) ** 2);
                    if (Math.abs(currentDistance - radius) < 1 && Math.abs(newDistance - radius) < 1) {
                        const currentAngle = Math.atan2(vertices[vertices.length - 1].y - pos.y, vertices[vertices.length - 1].x - pos.x);
                        const newAngle = Math.atan2(vertices[0].y - pos.y, vertices[0].x - pos.x);
                        ctx.arc(pos.x, pos.y, radius, currentAngle, newAngle);
                    } else {
                        ctx.lineTo(vertices[0].x, vertices[0].y)
                    }

                    // outline map edges, best with lighter colored document.body.style.backgroundColor
                    ctx.strokeStyle = "#000";
                    ctx.lineWidth = 5;
                    ctx.stroke(simulation.draw.mapPath);

                    ctx.globalCompositeOperation = "destination-in";
                    ctx.fillStyle = "#000";
                    ctx.fill();
                    ctx.globalCompositeOperation = "source-over";

                    // make map visible
                    // ctx.fill(simulation.draw.mapPath);
                    // ctx.fillStyle = "#000";

                    ctx.clip(); //this doesn't seem to be required, but it helps with performance, probably stops the canvas context from drawing the whole map
                }
            }
        },
        body() {
            ctx.beginPath();
            for (let i = 0, len = body.length; i < len; ++i) {
                let vertices = body[i].vertices;
                ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let j = 1; j < vertices.length; j++) {
                    ctx.lineTo(vertices[j].x, vertices[j].y);
                }
                ctx.lineTo(vertices[0].x, vertices[0].y);
            }
            ctx.lineWidth = 2;
            ctx.fillStyle = color.block;
            ctx.fill();
            ctx.strokeStyle = color.blockS;
            ctx.stroke();
        },
        cons() {
            ctx.beginPath();
            for (let i = 0, len = cons.length; i < len; ++i) {
                ctx.moveTo(cons[i].pointA.x, cons[i].pointA.y);
                // ctx.lineTo(cons[i].bodyB.position.x, cons[i].bodyB.position.y);
                ctx.lineTo(cons[i].bodyB.position.x + cons[i].pointB.x, cons[i].bodyB.position.y + cons[i].pointB.y);
            }
            for (let i = 0, len = consBB.length; i < len; ++i) {
                ctx.moveTo(consBB[i].bodyA.position.x, consBB[i].bodyA.position.y);
                ctx.lineTo(consBB[i].bodyB.position.x, consBB[i].bodyB.position.y);
            }
            ctx.lineWidth = 2;
            // ctx.strokeStyle = "#999";
            ctx.strokeStyle = "rgba(0,0,0,0.15)";
            ctx.stroke();
        },
        wireFrame() {
            // ctx.textAlign = "center";
            // ctx.textBaseline = "middle";
            // ctx.fillStyle = "#999";
            const bodies = Composite.allBodies(engine.world);
            ctx.beginPath();
            for (let i = 0; i < bodies.length; ++i) {
                //ctx.fillText(bodies[i].id,bodies[i].position.x,bodies[i].position.y);  //shows the id of every body
                let vertices = bodies[i].vertices;
                ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let j = 1; j < vertices.length; j++) {
                    ctx.lineTo(vertices[j].x, vertices[j].y);
                }
                ctx.lineTo(vertices[0].x, vertices[0].y);
            }
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#000";
            ctx.stroke();
        },
        testing() {
            //jump
            ctx.beginPath();
            let bodyDraw = jumpSensor.vertices;
            ctx.moveTo(bodyDraw[0].x, bodyDraw[0].y);
            for (let j = 1; j < bodyDraw.length; ++j) {
                ctx.lineTo(bodyDraw[j].x, bodyDraw[j].y);
            }
            ctx.lineTo(bodyDraw[0].x, bodyDraw[0].y);
            ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
            ctx.fill();
            // ctx.strokeStyle = "#000";
            // ctx.stroke();
            //main body
            ctx.beginPath();
            bodyDraw = playerBody.vertices;
            ctx.moveTo(bodyDraw[0].x, bodyDraw[0].y);
            for (let j = 1; j < bodyDraw.length; ++j) {
                ctx.lineTo(bodyDraw[j].x, bodyDraw[j].y);
            }
            ctx.lineTo(bodyDraw[0].x, bodyDraw[0].y);
            ctx.fillStyle = "rgba(0, 255, 255, 0.25)";
            ctx.fill();
            // ctx.stroke();
            //head
            ctx.beginPath();
            bodyDraw = playerHead.vertices;
            ctx.moveTo(bodyDraw[0].x, bodyDraw[0].y);
            for (let j = 1; j < bodyDraw.length; ++j) {
                ctx.lineTo(bodyDraw[j].x, bodyDraw[j].y);
            }
            ctx.lineTo(bodyDraw[0].x, bodyDraw[0].y);
            ctx.fillStyle = "rgba(255, 255, 0, 0.4)";
            ctx.fill();
            // ctx.stroke();
            //head sensor
            ctx.beginPath();
            bodyDraw = headSensor.vertices;
            ctx.moveTo(bodyDraw[0].x, bodyDraw[0].y);
            for (let j = 1; j < bodyDraw.length; ++j) {
                ctx.lineTo(bodyDraw[j].x, bodyDraw[j].y);
            }
            ctx.lineTo(bodyDraw[0].x, bodyDraw[0].y);
            ctx.fillStyle = "rgba(0, 0, 255, 0.25)";
            ctx.fill();
            // ctx.stroke();
        }
    },
    checkLineIntersection(v1, v1End, v2, v2End) {
        // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
        let denominator, a, b, numerator1, numerator2;
        let result = {
            x: null,
            y: null,
            onLine1: false,
            onLine2: false
        };
        denominator = (v2End.y - v2.y) * (v1End.x - v1.x) - (v2End.x - v2.x) * (v1End.y - v1.y);
        if (denominator == 0) {
            return result;
        }
        a = v1.y - v2.y;
        b = v1.x - v2.x;
        numerator1 = (v2End.x - v2.x) * a - (v2End.y - v2.y) * b;
        numerator2 = (v1End.x - v1.x) * a - (v1End.y - v1.y) * b;
        a = numerator1 / denominator;
        b = numerator2 / denominator;

        // if we cast these lines infinitely in both directions, they intersect here:
        result.x = v1.x + a * (v1End.x - v1.x);
        result.y = v1.y + a * (v1End.y - v1.y);
        // if line1 is a segment and line2 is infinite, they intersect if:
        if (a > 0 && a < 1) result.onLine1 = true;
        // if line2 is a segment and line1 is infinite, they intersect if:
        if (b > 0 && b < 1) result.onLine2 = true;
        // if line1 and line2 are segments, they intersect if both of the above are true
        return result;
    },
    constructMouseDownPosition: {
        x: 0,
        y: 0
    },
    constructMapString: [],
    constructCycle() {
        if (simulation.isConstructionMode && simulation.constructMouseDownPosition) {
            function round(num, round = 25) {
                return Math.ceil(num / round) * round;
            }
            const x = round(simulation.constructMouseDownPosition.x)
            const y = round(simulation.constructMouseDownPosition.y)
            const dx = Math.max(25, round(simulation.mouseInGame.x) - x)
            const dy = Math.max(25, round(simulation.mouseInGame.y) - y)

            ctx.strokeStyle = "#000"
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, dx, dy);
        }
    },
    enableConstructMode() {
        level.isProcedural = false //this is set to be true in levels like labs that need x+ and y+ in front of positions
        level.isVerticalFLipLevel = false
        simulation.isConstructionMode = true;
        simulation.isHorizontalFlipped = false;
        simulation.isAutoZoom = false;
        simulation.zoomScale = 2600;
        simulation.setZoom();

        document.body.addEventListener("mouseup", (e) => {
            if (simulation.testing && simulation.constructMouseDownPosition) {
                function round(num, round = 25) {
                    return Math.ceil(num / round) * round;
                }
                //clean up positions
                const x = round(simulation.constructMouseDownPosition.x)
                const y = round(simulation.constructMouseDownPosition.y)
                const dx = Math.max(25, round(simulation.mouseInGame.x) - x)
                const dy = Math.max(25, round(simulation.mouseInGame.y) - y)
                if (e.button === 1) {
                    if (level.isProcedural) {
                        simulation.outputMapString(`spawn.randomMob(x+${x}, ${y}, 0);\n`);
                    } else {
                        simulation.outputMapString(`spawn.randomMob(${x}, ${y}, 0);\n`);
                    }
                } else if (e.button === 4) {
                    simulation.outputMapString(`${Math.floor(simulation.constructMouseDownPosition.x)}, ${Math.floor(simulation.constructMouseDownPosition.y)}`);
                } else if (simulation.mouseInGame.x > simulation.constructMouseDownPosition.x && simulation.mouseInGame.y > simulation.constructMouseDownPosition.y) { //make sure that the width and height are positive
                    if (e.button === 0) { //add map
                        // if (level.isProcedural) {
                        //     simulation.outputMapString(`spawn.mapRect(x+${x}, ${y}, ${dx}, ${dy});\n`);
                        // } else {
                        //     simulation.outputMapString(`spawn.mapRect(${x}, ${y}, ${dx}, ${dy});\n`);
                        // }
                        if (level.isProcedural) {
                            simulation.outputMapString(`spawn.mapRect(x+${x}, ${y}, ${dx}, ${dy});\n`);
                        } else if (level.isVerticalFLipLevel) {
                            console.log('hi')
                            simulation.outputMapString(`spawn.mapRect(${x}, ${y}, ${dx}, ${dy});\n`);
                            simulation.outputMapString(`//spawn.mapRect(${x}, ${-y - dy}, ${dx}, ${dy});\n`);
                        } else {
                            simulation.outputMapString(`spawn.mapRect(${x}, ${y}, ${dx}, ${dy});\n`);
                        }
                        //see map in world
                        spawn.mapRect(x, y, dx, dy);
                        len = map.length - 1
                        map[len].collisionFilter.category = cat.map;
                        map[len].collisionFilter.mask = cat.player | cat.map | cat.body | cat.bullet | cat.powerUp | cat.mob | cat.mobBullet;
                        Matter.Body.setStatic(map[len], true); //make static
                        Composite.add(engine.world, map[len]); //add to world
                        simulation.draw.setPaths() //update map graphics
                    } else if (e.button === 2) { //add body
                        if (level.isProcedural) {
                            simulation.outputMapString(`spawn.bodyRect(x+${x}, ${y}, ${dx}, ${dy});\n`);
                        } else {
                            simulation.outputMapString(`spawn.bodyRect(${x}, ${y}, ${dx}, ${dy});\n`);
                        }
                        //see map in world
                        spawn.bodyRect(x, y, dx, dy);
                    }
                }
            }
            simulation.constructMouseDownPosition.x = undefined
            simulation.constructMouseDownPosition.y = undefined
        });
        simulation.constructMouseDownPosition.x = undefined
        simulation.constructMouseDownPosition.y = undefined
        document.body.addEventListener("mousedown", (e) => {
            if (simulation.testing) {
                simulation.constructMouseDownPosition.x = simulation.mouseInGame.x
                simulation.constructMouseDownPosition.y = simulation.mouseInGame.y
            }
        });

        document.body.addEventListener("wheel", (e) => {
            if (e.deltaY > 0) {
                simulation.setZoom(simulation.zoomScale / 0.9)
            } else {
                simulation.setZoom(simulation.zoomScale * 0.9)
            }
        });




        //undo last element added after you press z
        document.body.addEventListener("keydown", (event) => { // e.keyCode   z=90  m=77 b=66  shift = 16  c = 67
            if (simulation.testing && event.code === "KeyZ" && simulation.constructMapString.length) {
                if (simulation.constructMapString[simulation.constructMapString.length - 1][6] === 'm') { //remove map from current level
                    const index = map.length - 1
                    Matter.Composite.remove(engine.world, map[index]);
                    map.splice(index, 1);
                    simulation.draw.setPaths() //update map graphics  
                } else if (simulation.constructMapString[simulation.constructMapString.length - 1][6] === 'b') { //remove body from current level
                    const index = body.length - 1
                    Matter.Composite.remove(engine.world, body[index]);
                    body.splice(index, 1);
                }
                simulation.constructMapString.pop();
                simulation.outputMapString();
            }
        });
    },
    outputMapString(string) {
        if (string) simulation.constructMapString.push(string) //store command as a string in the next element of an array
        let out = "" //combine set of map strings to one string
        let outHTML = ""
        for (let i = 0, len = simulation.constructMapString.length; i < len; i++) {
            out += simulation.constructMapString[i];
            outHTML += "<div>" + simulation.constructMapString[i] + "</div>"
        }
        console.log(out)
        navigator.clipboard.writeText(out).then(function () {
            /* clipboard successfully set */
        }, function () {
            /* clipboard write failed */
            console.log('copy failed')
        });
        document.getElementById("construct").innerHTML = outHTML
    },
    // copyToClipBoard(value) {
    //     // Create a fake textarea
    //     const textAreaEle = document.createElement('textarea');

    //     // Reset styles
    //     textAreaEle.style.border = '0';
    //     textAreaEle.style.padding = '0';
    //     textAreaEle.style.margin = '0';

    //     // Set the absolute position
    //     // User won't see the element
    //     textAreaEle.style.position = 'absolute';
    //     textAreaEle.style.left = '-9999px';
    //     textAreaEle.style.top = `0px`;

    //     // Set the value
    //     textAreaEle.value = value

    //     // Append the textarea to body
    //     document.body.appendChild(textAreaEle);

    //     // Focus and select the text
    //     textAreaEle.focus();
    //     textAreaEle.select();

    //     // Execute the "copy" command
    //     try {
    //         document.execCommand('copy');
    //     } catch (err) {
    //         // Unable to copy
    //         console.log(err)
    //     } finally {
    //         // Remove the textarea
    //         document.body.removeChild(textAreaEle);
    //     }
    // },
};
    </script>
    <script>
        //global player variables for use in matter.js physics
let player, jumpSensor, playerBody, playerHead, headSensor;

// player Object Prototype *********************************************
const m = {
    spawn() {
        //load player in matter.js physic engine
        // let vector = Vertices.fromPath("0 40  50 40   50 115   0 115   30 130   20 130"); //player as a series of vertices
        let vertices = Vertices.fromPath("0,40, 50,40, 50,115, 30,130, 20,130, 0,115, 0,40"); //player as a series of vertices
        playerBody = Bodies.fromVertices(0, 0, vertices);
        jumpSensor = Bodies.rectangle(0, 46, 36, 6, {       //(0, 46, 50, 6, { //for wall jumping
            //this sensor check if the player is on the ground to enable jumping
            sleepThreshold: 99999999999,
            isSensor: true
        });
        vertices = Vertices.fromPath("16 -82  2 -66  2 -37  43 -37  43 -66  30 -82");
        playerHead = Bodies.fromVertices(0, -55, vertices); //this part of the player lowers on crouch
        headSensor = Bodies.rectangle(0, -57, 48, 45, {
            //senses if the player's head is empty and can return after crouching
            sleepThreshold: 99999999999,
            isSensor: true
        });
        player = Body.create({
            //combine jumpSensor and playerBody
            parts: [playerBody, playerHead, jumpSensor, headSensor],
            inertia: Infinity, //prevents player rotation
            friction: 0.002,
            frictionAir: 0.001,
            //frictionStatic: 0.5,
            restitution: 0,
            sleepThreshold: Infinity,
            collisionFilter: {
                group: 0,
                category: cat.player,
                mask: cat.body | cat.map | cat.mob | cat.mobBullet | cat.mobShield
            },
        });
        Matter.Body.setMass(player, m.mass);
        Composite.add(engine.world, [player]);
    },
    cycle: 600, //starts at 600 cycles instead of 0 to prevent bugs with m.history
    lastKillCycle: 0,
    lastHarmCycle: 0,
    width: 50,
    radius: 30,
    eyeFillColor: null,
    fillColor: null, //set by setFillColors
    fillColorDark: null, //set by setFillColors
    bodyGradient: null, //set by setFillColors
    color: {
        hue: 0,
        sat: 0,
        light: 100,
    },
    setFillColors() {
        m.fillColor = `hsl(${m.color.hue},${m.color.sat}%,${m.color.light}%)`
        m.fillColorDark = `hsl(${m.color.hue},${m.color.sat}%,${m.color.light - 25}%)`
        let grd = ctx.createLinearGradient(-30, 0, 30, 0);
        grd.addColorStop(0, m.fillColorDark);
        grd.addColorStop(1, m.fillColor);
        m.bodyGradient = grd
    },
    // setFillColorsAlpha(alpha = 0.5) {
    //     m.fillColor = `hsla(${m.color.hue},${m.color.sat}%,${m.color.light}%,${alpha})`
    //     m.fillColorDark = `hsla(${m.color.hue},${m.color.sat}%,${m.color.light - 25}%,${alpha})`
    //     let grd = ctx.createLinearGradient(-30, 0, 30, 0);
    //     grd.addColorStop(0, m.fillColorDark);
    //     grd.addColorStop(1, m.fillColor);
    //     m.bodyGradient = grd
    // },
    height: 42,
    yOffWhen: {
        crouch: 22,
        stand: 49,
        jump: 70
    },
    defaultMass: 5,
    mass: 5,
    FxNotHolding: 0.015,
    Fx: 0.016, //run Force on ground //
    jumpForce: 0.42,
    setMovement() {
        // console.log(player.mass)
        // m.FxAir = 0.4 / mass / mass 
        m.Fx = tech.baseFx * m.fieldFx * m.squirrelFx * (tech.isFastTime ? 1.5 : 1) / player.mass //base player mass is 5
        m.jumpForce = tech.baseJumpForce * m.fieldJump * m.squirrelJump * (tech.isFastTime ? 1.13 : 1) / player.mass / player.mass //base player mass is 5
    },
    FxAir: 0.016, // 0.4/5/5  run Force in Air
    yOff: 70,
    yOffGoal: 70,
    onGround: false, //checks if on ground or in air
    lastOnGroundCycle: 0, //use to calculate coyote time
    coyoteCycles: 5,
    hardLanding: 130,
    squirrelFx: 1,
    squirrelJump: 1,
    velocitySmooth: { x: 0, y: 0 },//use for drawing skin's velocity gel tail
    standingOn: undefined,
    numTouching: 0,
    crouch: false,
    // isHeadClear: true,
    spawnPos: {
        x: 0,
        y: 0
    },
    spawnVel: {
        x: 0,
        y: 0
    },
    pos: {
        x: 0,
        y: 0
    },
    yPosDifference: 24.2859, //player.position.y - m.pos.y  //24.285923217549026
    // yPosDifferenceCrouched: -2.7140767824453604,
    Sy: 0, //adds a smoothing effect to vertical only
    Vx: 0,
    Vy: 0,
    friction: {
        ground: 0.01,
        air: 0.0025
    },
    airSpeedLimit: 125, // 125/mass/mass = 5
    angle: 0,
    walk_cycle: 0,
    stepSize: 0,
    flipLegs: -1,
    hip: {
        x: 12,
        y: 24
    },
    knee: {
        x: 0,
        y: 0,
        x2: 0,
        y2: 0
    },
    foot: {
        x: 0,
        y: 0
    },
    legLength1: 55,
    legLength2: 45,
    transX: 0,
    transY: 0,
    history: new Array(600), //[], //tracks the last second of player position
    rewindCount: 0, //used with CPT
    resetHistory() {
        const set = {
            position: {
                x: player.position.x,
                y: player.position.y,
            },
            velocity: {
                x: player.velocity.x,
                y: player.velocity.y
            },
            yOff: m.yOff,
            angle: m.angle,
            health: m.health,
            energy: m.energy,
            activeGun: b.activeGun
        }
        for (let i = 0; i < 600; i++) { //reset history
            m.history[i] = set
        }
    },
    move() {
        m.pos.x = player.position.x;
        m.pos.y = playerBody.position.y - m.yOff;
        m.Vx = player.velocity.x;
        m.Vy = player.velocity.y;

        //tracks the last 10s of player information
        m.history.splice(m.cycle % 600, 1, {
            position: {
                x: player.position.x,
                y: player.position.y,
            },
            velocity: {
                x: player.velocity.x,
                y: player.velocity.y
            },
            yOff: m.yOff,
            angle: m.angle,
            health: m.health,
            energy: m.energy,
            activeGun: b.activeGun
        });
        // const back = 59  // 59 looks at 1 second ago //29 looks at 1/2 a second ago
        // historyIndex = (m.cycle - back) % 600
    },
    transSmoothX: 0,
    transSmoothY: 0,
    lastGroundedPositionY: 0,
    // mouseZoom: 0,
    lookSmoothing: 0.07, //1 is instant jerky,  0.001 is slow smooth zoom, 0.07 is standard
    look() { }, //set to lookDefault()
    lookDefault() {
        //always on mouse look
        m.angle = Math.atan2(simulation.mouseInGame.y - m.pos.y, simulation.mouseInGame.x - m.pos.x);
        //smoothed mouse look translations
        const scale = 0.8;
        m.transSmoothX = canvas.width2 - m.pos.x - (simulation.mouse.x - canvas.width2) * scale
        m.transSmoothY = canvas.height2 - m.pos.y - (simulation.mouse.y - canvas.height2) * scale

        m.transX += (m.transSmoothX - m.transX) * m.lookSmoothing;
        m.transY += (m.transSmoothY - m.transY) * m.lookSmoothing;
    },
    doCrouch() {
        if (!m.crouch) {
            m.crouch = true;
            m.yOffGoal = m.yOffWhen.crouch;
            if ((playerHead.position.y - player.position.y) < 0) {
                Matter.Body.setPosition(playerHead, { x: player.position.x, y: player.position.y + 9.1740767 })
            }
        }
    },
    undoCrouch() {
        if (m.crouch) {
            m.crouch = false;
            m.yOffGoal = m.yOffWhen.stand;
            if ((playerHead.position.y - player.position.y) > 0) {
                Matter.Body.setPosition(playerHead, { x: player.position.x, y: player.position.y - 30.28592321 })
            }
        }
    },
    hardLandCD: 0,
    hardLandCDScale: 1,
    checkHeadClear() {
        if (Matter.Query.collides(headSensor, map).length > 0) {
            return false
        } else {
            return true
        }
    },
    buttonCD_jump: 0, //cool down for player buttons
    jump() {
        m.buttonCD_jump = m.cycle; //can't jump again until 20 cycles pass
        //apply a fraction of the jump force to the body the player is jumping off of
        Matter.Body.applyForce(m.standingOn, m.pos, { x: 0, y: m.jumpForce * 0.12 * Math.min(m.standingOn.mass, 5) });
        player.force.y = -m.jumpForce; //player jump force
        Matter.Body.setVelocity(player, { //zero player y-velocity for consistent jumps
            x: player.velocity.x,
            y: Math.max(-10, Math.min(m.standingOn.velocity.y, 10)) //cap velocity contribution from blocks you are standing on to 10 in the vertical
        });
    },
    moverX: 0, //used to tell the player about moving platform x velocity
    groundControl() {
        //check for crouch or jump
        if (m.crouch) {
            if (!(input.down) && m.checkHeadClear() && m.hardLandCD < m.cycle) m.undoCrouch();
        } else if (input.down || m.hardLandCD > m.cycle) {
            m.doCrouch(); //on ground && not crouched and pressing s or down
        } else if (input.up && m.buttonCD_jump + 20 < m.cycle) {
            m.jump()
        }
        const moveX = player.velocity.x - m.moverX //account for mover platforms
        if (input.left) {
            if (moveX > -2) {
                player.force.x -= m.Fx * 1.5
            } else {
                player.force.x -= m.Fx
            }
            // }
        } else if (input.right) {
            if (moveX < 2) {
                player.force.x += m.Fx * 1.5
            } else {
                player.force.x += m.Fx
            }
        } else {
            const stoppingFriction = 0.92; //come to a stop if no move key is pressed
            Matter.Body.setVelocity(player, { x: m.moverX * 0.08 + player.velocity.x * stoppingFriction, y: player.velocity.y * stoppingFriction });
        }

        if (Math.abs(moveX) > 4) { //come to a stop if fast     // if (player.speed > 4) { //come to a stop if fast 
            const stoppingFriction = (m.crouch) ? 0.65 : 0.89; // this controls speed when crouched
            Matter.Body.setVelocity(player, { x: m.moverX * (1 - stoppingFriction) + player.velocity.x * stoppingFriction, y: player.velocity.y * stoppingFriction });
        }
        m.moverX = 0 //reset the level mover offset
    },
    airControl() {
        //check for coyote time jump
        if (input.up && m.buttonCD_jump + 20 < m.cycle && m.lastOnGroundCycle + m.coyoteCycles > m.cycle) m.jump()

        //check for short jumps   //moving up   //recently pressed jump  //but not pressing jump key now
        if (m.buttonCD_jump + 60 > m.cycle && !(input.up) && m.Vy < 0) {
            Matter.Body.setVelocity(player, { x: player.velocity.x, y: player.velocity.y * 0.94 }); //reduce player y-velocity every cycle
        }

        if (input.left) {
            if (player.velocity.x > -m.airSpeedLimit / player.mass / player.mass) player.force.x -= m.FxAir; // move player   left / a
        } else if (input.right) {
            if (player.velocity.x < m.airSpeedLimit / player.mass / player.mass) player.force.x += m.FxAir; //move player  right / d
        }
    },
    printBlock() {
        const sides = Math.floor(4 + 6 * Math.random() * Math.random())
        body[body.length] = Matter.Bodies.polygon(m.pos.x, m.pos.y, sides, 8, {
            friction: 0.05,
            frictionAir: 0.001,
            collisionFilter: { category: 0, mask: 0 }, //no collision because player is holding
            classType: "body",
            isPrinted: true,
            radius: 10, //used to grow and warp the shape of the block
            density: 0.002, //double density for 2x damage
        });
        const who = body[body.length - 1]
        Composite.add(engine.world, who); //add to world
        m.throwCharge = 4;
        m.holdingTarget = who
        m.isHolding = true;
    },
    alive: false,
    isSwitchingWorlds: false,
    switchWorlds(giveTech = "") {
        if (!m.isSwitchingWorlds) {
            let totalTech = 0;
            for (let i = tech.tech.length - 1; i > -1; i--) {
                if (tech.tech[i].count > 0 && !tech.tech[i].isLore && !tech.tech[i].isNonRefundable && !tech.tech[i].isAltRealityTech) {
                    totalTech += tech.tech[i].count
                }
            }
            powerUps.boost.endCycle = 0
            simulation.isTextLogOpen = false; //prevent console spam
            tech.resetAllTech()
            if (giveTech) tech.giveTech(giveTech) //give many worlds back

            //remove all bullets
            for (let i = 0; i < bullet.length; ++i) Matter.Composite.remove(engine.world, bullet[i]);
            bullet = [];

            //randomize
            powerUps.research.count = Math.floor(powerUps.research.count * (0.5 + 1.5 * Math.random()))
            m.coupling = Math.floor(m.coupling * (0.5 + 1.5 * Math.random()))
            //randomize health
            m.health = m.health * (1 + 0.5 * (Math.random() - 0.5))
            if (m.health > 1) m.health = 1;
            //randomize field
            m.setField(Math.ceil(Math.random() * (m.fieldUpgrades.length - 1)))
            //removes guns and ammo  
            b.inventory = [];
            b.activeGun = null;
            b.inventoryGun = 0;
            for (let i = 0, len = b.guns.length; i < len; ++i) {
                b.guns[i].have = false;
                if (b.guns[i].ammo !== Infinity) {
                    b.guns[i].ammo = 0;
                    b.guns[i].ammoPack = b.guns[i].defaultAmmoPack;
                }
            }
            //give random guns
            // const totalGuns = 1 + Math.floor(b.inventory.length * (0.5 + 1.5 * Math.random()))
            const totalGuns = 1 + Math.floor(Math.random() * Math.random() * 7)
            for (let i = 0; i < totalGuns; i++) b.giveGuns()

            //randomize ammo based on ammo/ammoPack count
            for (let i = 0, len = b.inventory.length; i < len; i++) {
                if (b.guns[b.inventory[i]].ammo !== Infinity) b.guns[b.inventory[i]].ammo = Math.floor(b.guns[b.inventory[i]].ammo * (0.25 + Math.random() + Math.random() + Math.random()))
            }

            let loop = () => {
                if (!(m.cycle % 10)) {
                    if (totalTech > 0 && m.alive) {
                        totalTech--
                        let options = [];
                        for (let i = 0, len = tech.tech.length; i < len; i++) {
                            if (tech.tech[i].count < tech.tech[i].maxCount && tech.tech[i].allowed() && !tech.tech[i].isBadRandomOption && !tech.tech[i].isLore && !tech.tech[i].isJunk) {
                                for (let j = 0; j < tech.tech[i].frequency; j++) options.push(i);
                            }
                        }
                        if (options.length > 0) tech.giveTech(options[Math.floor(Math.random() * options.length)]) //add a new tech from options pool
                        requestAnimationFrame(loop);
                    } else {
                        m.isSwitchingWorlds = false
                    }
                } else if (m.alive) {
                    requestAnimationFrame(loop);
                } else {
                    m.isSwitchingWorlds = false
                }
            }
            requestAnimationFrame(loop);

            b.respawnBots();
            // for (let i = 0; i < randomBotCount; i++) b.randomBot()
            simulation.makeGunHUD(); //update gun HUD
            simulation.updateTechHUD();
            m.displayHealth();
            simulation.isTextLogOpen = true;
            m.drop();
            if (simulation.paused) build.pauseGrid() //update the build when paused
        }
    },
    // switchWorlds() {
    //     if (!m.isSwitchingWorlds) {
    //         powerUps.boost.endCycle = 0
    //         const totalGuns = b.inventory.length
    //         //track ammo/ ammoPack count
    //         let ammoCount = 0
    //         for (let i = 0, len = b.inventory.length; i < len; i++) {
    //             if (b.guns[b.inventory[i]].ammo !== Infinity) {
    //                 ammoCount += b.guns[b.inventory[i]].ammo / b.guns[b.inventory[i]].ammoPack
    //             } else {
    //                 ammoCount += 5
    //             }
    //         }

    //         simulation.isTextLogOpen = false; //prevent console spam
    //         //remove all tech and count current tech total
    //         let totalTech = 0;
    //         for (let i = tech.tech.length - 1; i > -1; i--) {
    //             if (tech.tech[i].isJunk) tech.tech[i].frequency = 0
    //             if (tech.tech[i].count > 0 && !tech.tech[i].isLore) {
    //                 if (tech.tech[i].frequencyDefault) {
    //                     tech.tech[i].frequency = tech.tech[i].frequencyDefault
    //                 } else {
    //                     tech.tech[i].frequency = 1
    //                 }
    //                 if (!tech.tech[i].isNonRefundable && !tech.tech[i].isAltRealityTech) {
    //                     totalTech += tech.tech[i].count
    //                     tech.tech[i].remove();
    //                     tech.tech[i].isLost = false
    //                     tech.tech[i].count = 0
    //                 }
    //             }
    //         }
    //         // lore.techCount = 0;
    //         // tech.removeLoreTechFromPool();
    //         // tech.addLoreTechToPool();
    //         // tech.removeJunkTechFromPool();


    //         // tech.junkChance = 0;
    //         // tech.duplication = 0;
    //         // tech.extraMaxHealth = 0;
    //         // tech.totalCount = 0;
    //         // tech.removeCount = 0;
    //         // const randomBotCount = b.totalBots()
    //         // b.zeroBotCount()
    //         //remove all bullets, respawn bots
    //         for (let i = 0; i < bullet.length; ++i) Matter.Composite.remove(engine.world, bullet[i]);
    //         bullet = [];

    //         //randomize health
    //         m.health = m.health * (1 + 0.5 * (Math.random() - 0.5))
    //         if (m.health > 1) m.health = 1;
    //         m.displayHealth();
    //         //randomize field
    //         m.setField(Math.ceil(Math.random() * (m.fieldUpgrades.length - 1)))
    //         //removes guns and ammo  
    //         b.inventory = [];
    //         b.activeGun = null;
    //         b.inventoryGun = 0;
    //         for (let i = 0, len = b.guns.length; i < len; ++i) {
    //             b.guns[i].have = false;
    //             if (b.guns[i].ammo !== Infinity) {
    //                 b.guns[i].ammo = 0;
    //                 b.guns[i].ammoPack = b.guns[i].defaultAmmoPack;
    //             }
    //         }
    //         //give random guns
    //         for (let i = 0; i < totalGuns; i++) b.giveGuns()

    //         //randomize ammo based on ammo/ammoPack count
    //         for (let i = 0, len = b.inventory.length; i < len; i++) {
    //             if (b.guns[b.inventory[i]].ammo !== Infinity) b.guns[b.inventory[i]].ammo = Math.max(0, Math.floor(ammoCount / b.inventory.length * b.guns[b.inventory[i]].ammoPack * (2.5 + 0.3 * (Math.random() - 0.5))))
    //         }


    //         //randomize tech
    //         // for (let i = 0; i < totalTech; i++) {
    //         //     let options = [];
    //         //     for (let i = 0, len = tech.tech.length; i < len; i++) {
    //         //         if (tech.tech[i].count < tech.tech[i].maxCount && tech.tech[i].allowed() && !tech.tech[i].isBadRandomOption && !tech.tech[i].isLore && !tech.tech[i].isJunk) {
    //         //             for (let j = 0; j < tech.tech[i].frequency; j++) options.push(i);
    //         //         }
    //         //     }
    //         //     if (options.length > 0) tech.giveTech(options[Math.floor(Math.random() * options.length)]) //add a new tech from options pool

    //         // }
    //         let loop = () => {
    //             if (!(m.cycle % 10)) {
    //                 if (totalTech > 0 && m.alive) {
    //                     totalTech--
    //                     let options = [];
    //                     for (let i = 0, len = tech.tech.length; i < len; i++) {
    //                         if (tech.tech[i].count < tech.tech[i].maxCount && tech.tech[i].allowed() && !tech.tech[i].isBadRandomOption && !tech.tech[i].isLore && !tech.tech[i].isJunk) {
    //                             for (let j = 0; j < tech.tech[i].frequency; j++) options.push(i);
    //                         }
    //                     }
    //                     if (options.length > 0) tech.giveTech(options[Math.floor(Math.random() * options.length)]) //add a new tech from options pool
    //                     requestAnimationFrame(loop);
    //                 } else {
    //                     m.isSwitchingWorlds = false
    //                 }
    //             } else if (m.alive) {
    //                 requestAnimationFrame(loop);
    //             } else {
    //                 m.isSwitchingWorlds = false
    //             }
    //         }
    //         requestAnimationFrame(loop);

    //         b.respawnBots();
    //         // for (let i = 0; i < randomBotCount; i++) b.randomBot()
    //         simulation.makeGunHUD(); //update gun HUD
    //         simulation.updateTechHUD();
    //         simulation.isTextLogOpen = true;
    //         m.drop();
    //         if (simulation.paused) build.pauseGrid() //update the build when paused
    //     }
    // },
    // switchWorlds() {
    //     if (!m.isSwitchingWorlds) {
    //         powerUps.boost.endCycle = 0
    //         const totalGuns = b.inventory.length
    //         //track ammo/ ammoPack count
    //         let ammoCount = 0
    //         for (let i = 0, len = b.inventory.length; i < len; i++) {
    //             if (b.guns[b.inventory[i]].ammo !== Infinity) {
    //                 ammoCount += b.guns[b.inventory[i]].ammo / b.guns[b.inventory[i]].ammoPack
    //             } else {
    //                 ammoCount += 5
    //             }
    //         }

    //         simulation.isTextLogOpen = false; //prevent console spam
    //         //remove all tech and count current tech total
    //         let totalTech = 0;
    //         for (let i = 0, len = tech.tech.length; i < len; i++) {
    //             if (tech.tech[i].isJunk) tech.tech[i].frequency = 0
    //             if (tech.tech[i].count > 0 && !tech.tech[i].isLore) {
    //                 if (tech.tech[i].frequencyDefault) {
    //                     tech.tech[i].frequency = tech.tech[i].frequencyDefault
    //                 } else {
    //                     tech.tech[i].frequency = 1
    //                 }
    //                 if (
    //                     !tech.tech[i].isNonRefundable &&
    //                     // !tech.tech[i].isFromAppliedScience &&
    //                     !tech.tech[i].isAltRealityTech
    //                 ) {
    //                     totalTech += tech.tech[i].count
    //                     tech.tech[i].remove();
    //                     tech.tech[i].isLost = false
    //                     tech.tech[i].count = 0
    //                 }
    //             }
    //         }
    //         // lore.techCount = 0;
    //         // tech.removeLoreTechFromPool();
    //         // tech.addLoreTechToPool();
    //         // tech.removeJunkTechFromPool();


    //         tech.junkChance = 0;
    //         tech.duplication = 0;
    //         tech.extraMaxHealth = 0;
    //         tech.totalCount = 0;
    //         tech.removeCount = 0;
    //         // const randomBotCount = b.totalBots()
    //         b.zeroBotCount()
    //         //remove all bullets, respawn bots
    //         for (let i = 0; i < bullet.length; ++i) Matter.Composite.remove(engine.world, bullet[i]);
    //         bullet = [];

    //         //randomize health
    //         m.health = m.health * (1 + 0.5 * (Math.random() - 0.5))
    //         if (m.health > 1) m.health = 1;
    //         m.displayHealth();
    //         //randomize field
    //         m.setField(Math.ceil(Math.random() * (m.fieldUpgrades.length - 1)))
    //         //removes guns and ammo  
    //         b.inventory = [];
    //         b.activeGun = null;
    //         b.inventoryGun = 0;
    //         for (let i = 0, len = b.guns.length; i < len; ++i) {
    //             b.guns[i].have = false;
    //             if (b.guns[i].ammo !== Infinity) {
    //                 b.guns[i].ammo = 0;
    //                 b.guns[i].ammoPack = b.guns[i].defaultAmmoPack;
    //             }
    //         }
    //         //give random guns
    //         for (let i = 0; i < totalGuns; i++) b.giveGuns()

    //         //randomize ammo based on ammo/ammoPack count
    //         for (let i = 0, len = b.inventory.length; i < len; i++) {
    //             if (b.guns[b.inventory[i]].ammo !== Infinity) b.guns[b.inventory[i]].ammo = Math.max(0, Math.floor(ammoCount / b.inventory.length * b.guns[b.inventory[i]].ammoPack * (2.5 + 0.3 * (Math.random() - 0.5))))
    //         }


    //         //randomize tech
    //         // for (let i = 0; i < totalTech; i++) {
    //         //     let options = [];
    //         //     for (let i = 0, len = tech.tech.length; i < len; i++) {
    //         //         if (tech.tech[i].count < tech.tech[i].maxCount && tech.tech[i].allowed() && !tech.tech[i].isBadRandomOption && !tech.tech[i].isLore && !tech.tech[i].isJunk) {
    //         //             for (let j = 0; j < tech.tech[i].frequency; j++) options.push(i);
    //         //         }
    //         //     }
    //         //     if (options.length > 0) tech.giveTech(options[Math.floor(Math.random() * options.length)]) //add a new tech from options pool

    //         // }
    //         let loop = () => {
    //             if (!(m.cycle % 10)) {
    //                 if (totalTech > 0 && m.alive) {
    //                     totalTech--
    //                     let options = [];
    //                     for (let i = 0, len = tech.tech.length; i < len; i++) {
    //                         if (tech.tech[i].count < tech.tech[i].maxCount && tech.tech[i].allowed() && !tech.tech[i].isBadRandomOption && !tech.tech[i].isLore && !tech.tech[i].isJunk) {
    //                             for (let j = 0; j < tech.tech[i].frequency; j++) options.push(i);
    //                         }
    //                     }
    //                     if (options.length > 0) tech.giveTech(options[Math.floor(Math.random() * options.length)]) //add a new tech from options pool
    //                     requestAnimationFrame(loop);
    //                 } else {
    //                     m.isSwitchingWorlds = false
    //                 }
    //             } else if (m.alive) {
    //                 requestAnimationFrame(loop);
    //             } else {
    //                 m.isSwitchingWorlds = false
    //             }
    //         }
    //         requestAnimationFrame(loop);

    //         b.respawnBots();
    //         // for (let i = 0; i < randomBotCount; i++) b.randomBot()
    //         simulation.makeGunHUD(); //update gun HUD
    //         simulation.updateTechHUD();
    //         simulation.isTextLogOpen = true;
    //         m.drop();
    //         if (simulation.paused) build.pauseGrid() //update the build when paused
    //     }
    // },
    death() {
        if (tech.isImmortal) { //if player has the immortality buff, spawn on the same level with randomized damage
            //remove immortality tech
            // for (let i = 0; i < tech.tech.length; i++) {
            //     if (tech.tech[i].name === "quantum immortality") tech.removeTech(i)
            // }

            m.setMaxHealth()
            m.health = 1;
            // m.addHealth(1)

            simulation.wipe = function () { //set wipe to have trails
                ctx.fillStyle = "rgba(255,255,255,0)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            level.isFlipped = false
            simulation.clearNow = true; //triggers a map reset

            m.switchWorlds()
            const swapPeriod = 1000
            for (let i = 0, len = 5; i < len; i++) {
                setTimeout(function () {
                    simulation.wipe = function () { //set wipe to have trails
                        ctx.fillStyle = "rgba(255,255,255,0)";
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    // simulation.clearNow = true; //triggers a map reset
                    // m.switchWorlds()
                    simulation.isTextLogOpen = true;
                    simulation.inGameConsole(`simulation.amplitude <span class='color-symbol'>=</span> 0.${len - i - 1}`, swapPeriod);
                    simulation.isTextLogOpen = false;
                    simulation.wipe = function () { //set wipe to have trails
                        ctx.fillStyle = `rgba(255,255,255,${(i + 1) * (i + 1) * 0.006})`;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                }, (i + 1) * swapPeriod);
            }
            setTimeout(function () {
                simulation.wipe = function () { //set wipe to normal
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                simulation.isTextLogOpen = true;
                simulation.inGameConsole("simulation.amplitude <span class='color-symbol'>=</span> null");
                tech.isImmortal = false //disable future immortality
            }, 6 * swapPeriod);
        } else if (m.alive) { //normal death code here            
            m.storeTech()
            m.alive = false;
            simulation.paused = true;
            m.health = 0;
            simulation.ephemera = []
            document.getElementById("defense-bar").style.display = "none"; //hide defense
            document.getElementById("damage-bar").style.display = "none"
            m.displayHealth();
            document.getElementById("text-log").style.display = "none"
            document.getElementById("fade-out").style.opacity = 0.9; //slowly fade to 90% white on top of canvas
            setTimeout(function () {
                Composite.clear(engine.world);
                Engine.clear(engine);
                simulation.splashReturn();
            }, 5000);
        }
    },
    storeTech() { //store a copy of your tech,  it will show up at your location next run in the entanglement power up
        if (localSettings.isAllowed && !simulation.isCheating) {
            const gunList = [] //store gun names
            for (i = 0, len = b.inventory.length; i < len; i++) gunList.push(b.inventory[i])
            const techList = [] //store tech names
            for (let i = 0; i < tech.tech.length; i++) {
                if (tech.tech[i].count > 0 && !tech.tech[i].isNonRefundable) techList.push(tech.tech[i].name)
            }
            if (techList.length) {
                localSettings.entanglement = {
                    fieldIndex: m.fieldMode,
                    gunIndexes: gunList,
                    techIndexes: techList,
                    position: {
                        x: m.pos.x,
                        y: m.pos.y
                    },
                    levelName: level.levels[level.onLevel],
                    isHorizontalFlipped: simulation.isHorizontalFlipped
                }
                if (localSettings.isAllowed) localStorage.setItem("localSettings", JSON.stringify(localSettings)); //update local storage
            }
        }
    },
    health: 0,
    maxHealth: 1, //set in simulation.reset()
    drawHealth() {
        if (m.health < 1) {
            ctx.fillStyle = "rgba(100, 100, 100, 0.5)";
            ctx.fillRect(m.pos.x - m.radius, m.pos.y - 50, 60, 10);
            ctx.fillStyle = "#f00";
            ctx.fillRect(
                m.pos.x - m.radius,
                m.pos.y - 50,
                60 * m.health,
                10
            );
        }
    },
    displayHealth() {
        id = document.getElementById("health");
        // health display is a x^1.5 rule to make it seem like the player has lower health 
        id.style.width = Math.floor(300 * m.maxHealth * Math.pow(Math.max(0, m.health) / m.maxHealth, 1.4)) + "px";
        if (m.health < 0) {
            id.style.borderRightColor = "#f00"
        } else {
            id.style.borderRightColor = "rgb(51, 162, 125)"
        }
        //css animation blink if health is low
        // if (m.health < 0.3) {
        //     id.classList.add("low-health");
        // } else {
        //     id.classList.remove("low-health");
        // }
    },
    addHealth(heal) {
        if (!tech.isEnergyHealth) {
            m.health += heal * simulation.healScale * (level.isLowHeal ? 0.5 : 1);
            if (m.health > m.maxHealth) m.health = m.maxHealth;
            m.displayHealth();
        }
    },
    baseHealth: 1,
    setMaxHealth(isMessage) {
        m.maxHealth = m.baseHealth + tech.extraMaxHealth + 5 * tech.isFallingDamage
        if (level.isReducedHealth) {
            level.reducedHealthLost = Math.max(0, m.health - m.maxHealth * 0.5)
            m.maxHealth *= 0.5
        }
        document.getElementById("health-bg").style.width = `${Math.floor(300 * m.maxHealth)}px`
        document.getElementById("defense-bar").style.width = Math.floor(300 * m.maxHealth * (1 - m.defense())) + "px";

        if (isMessage) simulation.inGameConsole(`<span class='color-var'>m</span>.<span class='color-h'>maxHealth</span> <span class='color-symbol'>=</span> ${m.maxHealth.toFixed(2)}`)
        if (m.health > m.maxHealth) m.health = m.maxHealth;
        m.displayHealth();
    },
    defaultFPSCycle: 0, //tracks when to return to normal fps
    immuneCycle: 0, //used in engine
    lastCalculatedDamage: 0, //used to decided if damage bar needs to be redrawn  (in simulation.checks)
    lastCalculatedDefense: 0, //used to decided if defense bar needs to be redrawn  (in simulation.checks)
    damageDone: 1,
    damageReduction: 1,
    defense() {
        let dmg = m.damageReduction * powerUps.difficulty.damageReduction
        if (tech.energyDefense && m.energy > 1.99) dmg *= 0.1
        if (powerUps.boost.isDefense && powerUps.boost.endCycle > simulation.cycle) dmg *= 0.3
        if (tech.isMaxHealthDefense && (m.health === m.maxHealth || (tech.isEnergyHealth && m.energy > m.maxEnergy - 0.01))) dmg *= 0.1
        if (tech.isDiaphragm) dmg *= 0.55 + 0.35 * Math.sin(m.cycle * 0.0075);
        if (tech.isHarmDarkMatter) dmg *= (tech.isMoveDarkMatter || tech.isNotDarkMatter) ? 0.25 : 0.4
        if (tech.isImmortal) dmg *= 0.7
        if (m.fieldMode === 0 || m.fieldMode === 3) dmg *= 0.973 ** m.coupling
        if (tech.isHarmReduceNoKill && m.lastKillCycle + 300 < m.cycle) dmg *= 0.3
        if (tech.isAddBlockMass && m.isHolding) dmg *= 0.1
        if (tech.isSpeedHarm && (tech.speedAdded + player.speed) > 0.1) dmg *= 1 - Math.min((tech.speedAdded + player.speed) * 0.01583, 0.95) //capped at speed of 55
        if (tech.isHarmReduce && input.field) dmg *= 0.1
        if (tech.isNeutronium && input.field && m.fieldCDcycle < m.cycle) dmg *= 0.05
        if (tech.isBotArmor) dmg *= 0.96 ** b.totalBots()
        if (tech.isHarmArmor && m.lastHarmCycle + 600 > m.cycle) dmg *= 0.4;
        if (tech.isNoFireDefense && m.cycle > m.fireCDcycle + 120) dmg *= 0.3
        if (tech.isTurret && m.crouch) dmg *= 0.3;
        if (tech.isFirstDer && b.inventory[0] === b.activeGun) dmg *= 0.85 ** b.inventory.length
        // if (tech.isLowHealthDefense) dmg *= Math.pow(0.3, Math.max(0, (tech.isEnergyHealth ? m.maxEnergy - m.energy : m.maxHealth - m.health)))
        if (tech.isLowHealthDefense) dmg *= Math.pow(0.2, Math.max(0, 1 - (tech.isEnergyHealth ? m.energy / m.maxEnergy : m.health / m.maxHealth)))
        if (tech.isRemineralize) {
            //reduce mineral percent based on time since last check
            const seconds = (simulation.cycle - tech.mineralLastCheck) / 60
            tech.mineralLastCheck = simulation.cycle
            tech.mineralDamage = 1 + (tech.mineralDamage - 1) * Math.pow(0.9, seconds);
            tech.mineralDamageReduction = 1 - (1 - tech.mineralDamageReduction) * Math.pow(0.9, seconds);
            dmg *= tech.mineralDamageReduction
        }
        if (tech.isInPilot && m.fieldOn && Vector.magnitude(Vector.sub(m.fieldPosition, m.pos)) < m.fieldRadius + 100) dmg *= 0.1
        // return tech.isEnergyHealth ? Math.pow(dmg, 0.7) : dmg //defense has less effect
        // dmg *= m.fieldHarmReduction
        return dmg * m.fieldHarmReduction
    },
    rewind(steps) { // m.rewind(Math.floor(Math.min(599, 137 * m.energy)))
        if (tech.isRewindGrenade) {
            const immunityDuration = 50
            const immunityCycle = m.cycle + immunityDuration + 10 + tech.isPetalsExplode * 30 + tech.isCircleExplode * 21
            if (m.immuneCycle < immunityCycle) m.immuneCycle = immunityCycle; //player is immune to damage until after grenades might explode...

            for (let i = 1, len = Math.floor(4 + steps / 40); i < len; i++) {
                b.grenade(Vector.add(m.pos, { x: 10 * (Math.random() - 0.5), y: 10 * (Math.random() - 0.5) }), -i * Math.PI / len) //fire different angles for each grenade
                const who = bullet[bullet.length - 1]

                if (tech.isNeutronBomb) {
                    Matter.Body.setVelocity(who, { x: who.velocity.x * 0.3, y: who.velocity.y * 0.3 });
                } else if (tech.isVacuumBomb) {
                    Matter.Body.setVelocity(who, { x: who.velocity.x * 0.5, y: who.velocity.y * 0.5 });
                    who.endCycle = simulation.cycle + immunityDuration

                } else if (tech.isRPG) {
                    who.endCycle = simulation.cycle + 10
                } else {
                    Matter.Body.setVelocity(who, { x: who.velocity.x * 0.5, y: who.velocity.y * 0.5 });
                    who.endCycle = simulation.cycle + immunityDuration
                }
            }
        }

        let history = m.history[(m.cycle - steps) % 600]
        Matter.Body.setPosition(player, history.position);
        Matter.Body.setVelocity(player, { x: history.velocity.x, y: history.velocity.y });
        m.yOff = history.yOff
        if (m.yOff < 48) {
            m.doCrouch()
        } else {
            m.undoCrouch()
        }

        // b.activeGun = history.activeGun
        // for (let i = 0; i < b.inventory.length; i++) {
        //     if (b.inventory[i] === b.activeGun) b.inventoryGun = i
        // }
        // simulation.updateGunHUD();
        // simulation.boldActiveGunHUD();

        // move bots to player's new position
        for (let i = 0; i < bullet.length; i++) {
            if (bullet[i].botType) {
                Matter.Body.setPosition(bullet[i], Vector.add(player.position, {
                    x: 250 * (Math.random() - 0.5),
                    y: 250 * (Math.random() - 0.5)
                }));
                Matter.Body.setVelocity(bullet[i], {
                    x: 0,
                    y: 0
                });
            }
        }
        m.energy = Math.max(m.energy - steps / 330, 0.01)
        if (m.immuneCycle < m.cycle + m.collisionImmuneCycles) m.immuneCycle = m.cycle + m.collisionImmuneCycles; //player is immune to damage for 30 cycles

        let isDrawPlayer = true
        const shortPause = function () {
            if (m.defaultFPSCycle < m.cycle) { //back to default values
                simulation.fpsCap = simulation.fpsCapDefault
                simulation.fpsInterval = 1000 / simulation.fpsCap;
                document.getElementById("dmg").style.transition = "opacity 1s";
                document.getElementById("dmg").style.opacity = "0";
            } else {
                requestAnimationFrame(shortPause);
                if (isDrawPlayer) {
                    isDrawPlayer = false
                    ctx.save();
                    ctx.globalCompositeOperation = "lighter";
                    ctx.translate(canvas.width2, canvas.height2); //center
                    ctx.scale(simulation.zoom / simulation.edgeZoomOutSmooth, simulation.zoom / simulation.edgeZoomOutSmooth); //zoom in once centered
                    ctx.translate(-canvas.width2 + m.transX, -canvas.height2 + m.transY); //translate
                    for (let i = 1; i < steps; i++) {
                        history = m.history[(m.cycle - i) % 600]
                        m.pos.x = history.position.x
                        m.pos.y = history.position.y + m.yPosDifference - history.yOff
                        m.yOff = history.yOff
                        m.draw();
                    }
                    ctx.restore();
                    m.resetHistory()
                }
            }
        };

        if (m.defaultFPSCycle < m.cycle) requestAnimationFrame(shortPause);
        simulation.fpsCap = 3 //1 is longest pause, 4 is standard
        simulation.fpsInterval = 1000 / simulation.fpsCap;
        m.defaultFPSCycle = m.cycle
        if (tech.isRewindBot) {
            const len = steps * 0.05 * tech.isRewindBot
            const botStep = Math.floor(steps / len)
            for (let i = 0; i < len; i++) {
                const where = m.history[Math.abs(m.cycle - i * botStep) % 600].position //spread out spawn locations along past history
                b.randomBot({
                    x: where.x + 20 * (Math.random() - 0.5),
                    y: where.y + 20 * (Math.random() - 0.5)
                }, false, false)
                bullet[bullet.length - 1].endCycle = simulation.cycle + 440 + Math.floor(120 * Math.random()) //8-10 seconds
            }
        }
    },
    collisionImmuneCycles: 30,
    takeDamage(dmg, isDefense = true) {
        if (tech.isRewindAvoidDeath && (m.energy + 0.05) > Math.min(0.95, m.maxEnergy) && dmg > 0.01) {
            const steps = Math.floor(Math.min(299, 150 * m.energy))
            simulation.inGameConsole(`<span class='color-var'>m</span>.rewind(${steps})`)
            m.rewind(steps)
            return
        }
        m.lastHarmCycle = m.cycle
        if (tech.isDroneOnDamage && bullet.length < 180) { //chance to build a drone on damage from tech
            const len = Math.min((dmg - 0.045 * Math.random()) * 95, 65) / tech.droneEnergyReduction * (tech.isEnergyHealth ? 0.5 : 1)
            for (let i = 0; i < len; i++) {
                if (Math.random() < 0.5) b.drone({
                    x: m.pos.x + 30 * Math.cos(m.angle) + 100 * (Math.random() - 0.5),
                    y: m.pos.y + 30 * Math.sin(m.angle) + 100 * (Math.random() - 0.5)
                }) //spawn drone
            }
        }
        if (tech.isEnergyHealth) {
            if (isDefense) dmg *= Math.pow(m.defense(), 0.6)
            m.energy -= dmg //scale damage with heal reduction difficulty
            if (m.energy < 0 || isNaN(m.energy)) { //taking deadly damage
                if (tech.isDeathAvoid && powerUps.research.count && !tech.isDeathAvoidedThisLevel) {
                    tech.isDeathAvoidedThisLevel = true
                    powerUps.research.changeRerolls(-1)
                    simulation.inGameConsole(`<span class='color-var'>m</span>.<span class='color-r'>research</span><span class='color-symbol'>--</span><br>${powerUps.research.count}`)
                    for (let i = 0; i < 22; i++) powerUps.spawn(m.pos.x + 100 * (Math.random() - 0.5), m.pos.y + 100 * (Math.random() - 0.5), "heal", false);
                    m.energy = m.maxEnergy + 0.1
                    if (m.immuneCycle < m.cycle + 300) m.immuneCycle = m.cycle + 300 //disable this.immuneCycle bonus seconds
                    simulation.wipe = function () { //set wipe to have trails
                        ctx.fillStyle = "rgba(255,255,255,0.03)";
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    setTimeout(function () {
                        simulation.wipe = function () { //set wipe to normal
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                    }, 3000);
                } else { //death
                    m.health = 0;
                    m.energy = 0;
                    m.death();
                }
                return;
            }
        } else {
            if (isDefense) dmg *= m.defense()
            m.health -= dmg;
            if (m.health < 0 || isNaN(m.health)) {
                if (tech.isDeathAvoid && powerUps.research.count > 0 && !tech.isDeathAvoidedThisLevel) { //&& Math.random() < 0.5
                    tech.isDeathAvoidedThisLevel = true
                    m.health = 0.05
                    powerUps.research.changeRerolls(-1)
                    simulation.inGameConsole(`<span class='color-var'>m</span>.<span class='color-r'>research</span><span class='color-symbol'>--</span><br>${powerUps.research.count}`)
                    for (let i = 0; i < 16; i++) powerUps.spawn(m.pos.x + 100 * (Math.random() - 0.5), m.pos.y + 100 * (Math.random() - 0.5), "heal", false);
                    if (m.immuneCycle < m.cycle + 300) m.immuneCycle = m.cycle + 300 //disable this.immuneCycle bonus seconds
                    simulation.wipe = function () { //set wipe to have trails
                        ctx.fillStyle = "rgba(255,255,255,0.03)";
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    setTimeout(function () {
                        simulation.wipe = function () { //set wipe to normal
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                    }, 3000);
                } else if (tech.isNoDeath) {
                    if (tech.isDeathTech && !tech.isDeathTechTriggered) {
                        tech.isDeathTechTriggered = true
                        powerUps.spawn(player.position.x, player.position.y, "tech");
                        // simulation.inGameConsole(`<span class='color-var'>tech</span>.damage *= ${1.05} //Zeno`);
                        tech.addJunkTechToPool(0.02)
                    }
                } else {
                    m.health = 0;
                    m.displayHealth();
                    m.death();
                    return;
                }
            }
            m.displayHealth();
            document.getElementById("dmg").style.transition = "opacity 0s";
            document.getElementById("dmg").style.opacity = 0.1 + Math.min(0.6, dmg * 4);
        }
        if (dmg > 0.03) {
            m.lastHit = dmg;
            if (dmg > 0.06 / m.holdingMassScale) m.drop(); //drop block if holding  // m.holdingMassScale = 0.5 for most fields
            if (m.isCloak) m.fireCDcycle = m.cycle //forced exit cloak
        }
        const normalFPS = function () {
            if (m.defaultFPSCycle < m.cycle) { //back to default values
                simulation.fpsCap = simulation.fpsCapDefault
                simulation.fpsInterval = 1000 / simulation.fpsCap;
                document.getElementById("dmg").style.transition = "opacity 1s";
                document.getElementById("dmg").style.opacity = "0";
            } else {
                requestAnimationFrame(normalFPS);
            }
        };

        if (m.defaultFPSCycle < m.cycle) requestAnimationFrame(normalFPS);
        if (dmg > 0.05) { // freeze game for high damage hits
            simulation.fpsCap = 4 //40 - Math.min(25, 100 * dmg)
            simulation.fpsInterval = 1000 / simulation.fpsCap;
            if (tech.isHarmFreeze) {
                for (let i = 0, len = mob.length; i < len; i++) mobs.statusSlow(mob[i], 480) //freeze all mobs
            }
        } else {
            simulation.fpsCap = simulation.fpsCapDefault
            simulation.fpsInterval = 1000 / simulation.fpsCap;
        }
        m.defaultFPSCycle = m.cycle
        if (level.isMobHealPlayerDamage) {
            for (let i = 0; i < mob.length; i++) {
                if (mob[i].health < 1 && mob[i].isDropPowerUp && mob[i].alive) {
                    simulation.drawList.push({
                        x: mob[i].position.x,
                        y: mob[i].position.y,
                        radius: mob[i].radius + 20,
                        color: "rgba(0,255,100,0.5)",
                        time: 10
                    });
                    mob[i].health += dmg * 7
                    if (mob[i].health > 1) mob[i].health = 1
                }
            }
        }
        // if (tech.isSlowFPS) { // slow game 
        //     simulation.fpsCap = 30 //new fps
        //     simulation.fpsInterval = 1000 / simulation.fpsCap;
        //     //how long to wait to return to normal fps
        //     m.defaultFPSCycle = m.cycle + 20 + Math.min(90, Math.floor(200 * dmg))
        //     if (tech.isHarmFreeze) { //freeze all mobs
        //         for (let i = 0, len = mob.length; i < len; i++) {
        //             mobs.statusSlow(mob[i], 450)
        //         }
        //     }
        // } else {
        //     if (dmg > 0.05) { // freeze game for high damage hits
        //         simulation.fpsCap = 4 //40 - Math.min(25, 100 * dmg)
        //         simulation.fpsInterval = 1000 / simulation.fpsCap;
        //     } else {
        //         simulation.fpsCap = simulation.fpsCapDefault
        //         simulation.fpsInterval = 1000 / simulation.fpsCap;
        //     }
        //     m.defaultFPSCycle = m.cycle
        // }
        // if (!noTransition) {
        //   document.getElementById("health").style.transition = "width 0s ease-out"
        // } else {
        //   document.getElementById("health").style.transition = "width 1s ease-out"
        // }
    },
    buttonCD: 0, //cool down for player buttons
    // *********************************************
    // ****** drawing player and skins *************
    // *********************************************
    drawLeg(stroke) { },
    calcLeg(cycle_offset, offset) {
        m.hip.x = 12 + offset;
        m.hip.y = 24 + offset;
        //stepSize goes to zero if Vx is zero or not on ground (make m transition cleaner)
        m.stepSize = 0.8 * m.stepSize + 0.2 * (7 * Math.sqrt(Math.min(9, Math.abs(m.Vx))) * m.onGround);
        //changes to stepsize are smoothed by adding only a percent of the new value each cycle
        const stepAngle = 0.034 * m.walk_cycle + cycle_offset;
        m.foot.x = 2.2 * m.stepSize * Math.cos(stepAngle) + offset;
        m.foot.y = offset + 1.2 * m.stepSize * Math.sin(stepAngle) + m.yOff + m.height;
        const Ymax = m.yOff + m.height;
        if (m.foot.y > Ymax) m.foot.y = Ymax;

        //calculate knee position as intersection of circle from hip and foot
        const d = Math.sqrt((m.hip.x - m.foot.x) * (m.hip.x - m.foot.x) + (m.hip.y - m.foot.y) * (m.hip.y - m.foot.y));
        const l = (m.legLength1 * m.legLength1 - m.legLength2 * m.legLength2 + d * d) / (2 * d);
        const h = Math.sqrt(m.legLength1 * m.legLength1 - l * l);
        m.knee.x = (l / d) * (m.foot.x - m.hip.x) - (h / d) * (m.foot.y - m.hip.y) + m.hip.x + offset;
        m.knee.y = (l / d) * (m.foot.y - m.hip.y) + (h / d) * (m.foot.x - m.hip.x) + m.hip.y;
    },
    draw() { },
    isAltSkin: false,
    drawBoost() {

    },
    resetSkin() {
        simulation.isAutoZoom = true;
        m.hardLandCDScale = 1
        m.yOffWhen.jump = 70
        m.yOffWhen.stand = 49
        m.yOffWhen.crouch = 22
        m.isAltSkin = false
        m.coyoteCycles = 5
        m.hardLanding = 130
        m.squirrelFx = 1;
        m.squirrelJump = 1;
        m.velocitySmooth = { x: 0, y: 0 }
        requestAnimationFrame(() => { m.setMovement() })
        m.color = {
            hue: 0,
            sat: 0,
            light: 100,
        }
        m.setFillColors();
        m.draw = function () {
            ctx.fillStyle = m.fillColor;
            m.walk_cycle += m.flipLegs * m.Vx;
            ctx.save();
            ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5 //|| (m.cycle % 40 > 20)
            ctx.translate(m.pos.x, m.pos.y);
            m.calcLeg(Math.PI, -3);
            m.drawLeg("#4a4a4a");
            m.calcLeg(0, 0);
            m.drawLeg("#333");
            ctx.rotate(m.angle);
            ctx.beginPath();
            ctx.arc(0, 0, 30, 0, 2 * Math.PI);
            ctx.fillStyle = m.bodyGradient
            ctx.fill();
            ctx.arc(15, 0, 4, 0, 2 * Math.PI);
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
            m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal
            powerUps.boost.draw()
        }
        m.drawLeg = function (stroke) {
            // if (simulation.mouseInGame.x > m.pos.x) {
            if (m.angle > -Math.PI / 2 && m.angle < Math.PI / 2) {
                m.flipLegs = 1;
            } else {
                m.flipLegs = -1;
            }
            ctx.save();
            ctx.scale(m.flipLegs, 1); //leg lines
            ctx.beginPath();
            ctx.moveTo(m.hip.x, m.hip.y);
            ctx.lineTo(m.knee.x, m.knee.y);
            ctx.lineTo(m.foot.x, m.foot.y);
            ctx.strokeStyle = stroke;
            ctx.lineWidth = 5;
            ctx.stroke();

            //toe lines
            ctx.beginPath();
            ctx.moveTo(m.foot.x, m.foot.y);
            if (m.onGround) {
                ctx.lineTo(m.foot.x - 14, m.foot.y + 5);
                ctx.moveTo(m.foot.x, m.foot.y);
                ctx.lineTo(m.foot.x + 14, m.foot.y + 5);
            } else {
                ctx.lineTo(m.foot.x - 12, m.foot.y + 8);
                ctx.moveTo(m.foot.x, m.foot.y);
                ctx.lineTo(m.foot.x + 12, m.foot.y + 8);
            }
            ctx.lineWidth = 4;
            ctx.stroke();

            //hip joint
            ctx.beginPath();
            ctx.arc(m.hip.x, m.hip.y, 9, 0, 2 * Math.PI);
            //knee joint
            ctx.moveTo(m.knee.x + 5, m.knee.y);
            ctx.arc(m.knee.x, m.knee.y, 5, 0, 2 * Math.PI);
            //foot joint
            ctx.moveTo(m.foot.x + 4, m.foot.y + 1);
            ctx.arc(m.foot.x, m.foot.y + 1, 4, 0, 2 * Math.PI);
            ctx.fillStyle = m.fillColor;
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        }
    },
    skin: {
        none() {
            m.isAltSkin = true
        },
        favicon() { //used to render the favicon, not actually in game
            m.yOffWhen.jump = 70
            m.yOffWhen.stand = 49
            m.yOffWhen.crouch = 22
            m.isAltSkin = false

            m.fillColor = `hsl(${m.color.hue},${m.color.sat}%,${m.color.light}%)`
            m.fillColorDark = `hsl(${m.color.hue},${m.color.sat}%,${m.color.light - 10}%)`
            let grd = ctx.createLinearGradient(-30, 0, 30, 0);
            grd.addColorStop(0, m.fillColorDark);
            grd.addColorStop(1, m.fillColor);
            m.bodyGradient = grd

            m.draw = function () {
                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5 //|| (m.cycle % 40 > 20)
                ctx.translate(m.pos.x, m.pos.y);
                // m.calcLeg(Math.PI, -3);
                // m.drawLeg("#4a4a4a");
                // m.calcLeg(0, 0);
                // m.drawLeg("#333");
                // ctx.rotate(m.angle);
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                ctx.arc(12, 0, 4.5, 0, 2 * Math.PI);
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 4.5;
                ctx.stroke();
                ctx.restore();
                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal
                powerUps.boost.draw()
            }
        },
        egg() {
            m.isAltSkin = true
            m.yOffWhen.stand = 52
            m.yOffWhen.jump = 72
            m.squirrelJump = 1.15;
            m.setMovement()

            m.draw = function () {
                if (powerUps.boost.endCycle > simulation.cycle) {
                    //gel that acts as if the wind is blowing it when player moves
                    ctx.save();
                    ctx.translate(m.pos.x, m.pos.y);
                    m.velocitySmooth = Vector.add(Vector.mult(m.velocitySmooth, 0.8), Vector.mult(player.velocity, 0.2))
                    ctx.rotate(Math.atan2(m.velocitySmooth.y, m.velocitySmooth.x))
                    ctx.beginPath();
                    const radius = 39
                    const mag = 14 * Vector.magnitude(m.velocitySmooth) + radius
                    ctx.arc(0, 0, radius, -Math.PI / 2, Math.PI / 2);
                    ctx.bezierCurveTo(-radius, radius, -radius, 0, -mag, 0); // bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
                    ctx.bezierCurveTo(-radius, 0, -radius, -radius, 0, -radius);

                    // const time = (powerUps.boost.endCycle - m.cycle) / powerUps.boost.duration
                    const time = Math.min(0.5, (powerUps.boost.endCycle - simulation.cycle) / powerUps.boost.duration)

                    ctx.fillStyle = `rgba(0,0,0,${0.04 + 0.3 * time})`
                    ctx.fill()
                    // ctx.strokeStyle = "#333"
                    // ctx.lineWidth = 1
                    // ctx.stroke();
                    ctx.restore();
                }

                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5 //|| (m.cycle % 40 > 20)
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(Math.PI, -1.25);
                m.drawLeg("#606060");
                m.calcLeg(0, 0);
                m.drawLeg("#444");

                ctx.rotate(m.angle);
                ctx.beginPath();
                // ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.ellipse(0, 0, 0.9 * 31, 1.05 * 31, 0, 0, 2 * Math.PI);
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                // ctx.arc(15, 0, 4, 0, 2 * Math.PI);
                ctx.ellipse(15, 0, 0.8 * 4, 1.1 * 4, 0, 0, 2 * Math.PI);

                ctx.strokeStyle = "#333";
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
                m.yOff = m.yOff * 0.75 + m.yOffGoal * 0.25; //smoothly move leg height towards height goal
            }
            m.drawLeg = function (stroke) {
                if (m.angle > -Math.PI / 2 && m.angle < Math.PI / 2) {
                    m.flipLegs = 1;
                } else {
                    m.flipLegs = -1;
                }
                const hip = { x: m.hip.x - 5, y: m.hip.y + 5 }
                const sub = Vector.sub(m.knee, hip)
                const off = Vector.mult(Vector.rotate(Vector.normalise(sub), Math.PI / 2), 8)
                const kneeBraceHigh = Vector.add(hip, off)
                const kneeBraceLow = Vector.add(kneeBraceHigh, Vector.mult(sub, 0.9))
                const foot = { x: m.foot.x - 10, y: m.foot.y - 15 }
                ctx.save();
                ctx.scale(m.flipLegs, 1); //leg lines
                ctx.beginPath();
                ctx.moveTo(hip.x, hip.y);
                ctx.lineTo(m.knee.x, m.knee.y);
                ctx.lineTo(foot.x, foot.y);
                //extra upper leg brace
                ctx.moveTo(kneeBraceHigh.x, kneeBraceHigh.y);
                ctx.lineTo(kneeBraceLow.x, kneeBraceLow.y);
                ctx.lineTo(m.knee.x, m.knee.y);

                ctx.strokeStyle = stroke;
                ctx.lineWidth = 3;
                ctx.stroke();
                //foot
                ctx.beginPath();
                ctx.moveTo(foot.x, foot.y);
                ctx.quadraticCurveTo(m.foot.x - 30, m.foot.y + 12, m.foot.x + 13, m.foot.y + 3);
                ctx.lineWidth = 1.5;
                ctx.stroke();

                //hip joint
                ctx.beginPath();
                ctx.arc(m.hip.x, m.hip.y - 2, 11, 0, 2 * Math.PI);
                //knee joint
                ctx.moveTo(m.knee.x + 3, m.knee.y);
                ctx.arc(m.knee.x, m.knee.y, 3, 0, 2 * Math.PI);
                //knee brace
                // ctx.moveTo(kneeBraceHigh.x + 4, kneeBraceHigh.y);
                // ctx.arc(kneeBraceHigh.x, kneeBraceHigh.y, 4, 0, 2 * Math.PI);
                ctx.moveTo(kneeBraceLow.x + 2.5, kneeBraceLow.y);
                ctx.arc(kneeBraceLow.x, kneeBraceLow.y, 2.5, 0, 2 * Math.PI);
                //foot joint
                ctx.moveTo(foot.x + 2.5, foot.y);
                ctx.arc(foot.x, foot.y, 2.5, 0, 2 * Math.PI);
                ctx.fillStyle = "#f6f6f6"//m.fillColor;
                ctx.fill();
                ctx.lineWidth = 1;
                // ctx.strokeStyle = "#333"
                ctx.stroke();
                ctx.restore();
            }
        },
        mech() {
            m.isAltSkin = true
            m.yOffWhen.stand = 52
            m.yOffWhen.jump = 72
            m.coyoteCycles = 11
            m.hardLandCDScale = 0.5
            m.hardLanding = 160
            m.squirrelFx = 1.4;
            m.squirrelJump = 1.16;
            m.setMovement()

            m.draw = function () {
                if (powerUps.boost.endCycle > simulation.cycle) {
                    //gel that acts as if the wind is blowing it when player moves
                    ctx.save();
                    ctx.translate(m.pos.x, m.pos.y);
                    m.velocitySmooth = Vector.add(Vector.mult(m.velocitySmooth, 0.8), Vector.mult(player.velocity, 0.2))
                    ctx.rotate(Math.atan2(m.velocitySmooth.y, m.velocitySmooth.x))
                    ctx.beginPath();
                    const radius = 39
                    const mag = 14 * Vector.magnitude(m.velocitySmooth) + radius
                    ctx.arc(0, 0, radius, -Math.PI / 2, Math.PI / 2);
                    ctx.bezierCurveTo(-radius, radius, -radius, 0, -mag, 0); // bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
                    ctx.bezierCurveTo(-radius, 0, -radius, -radius, 0, -radius);

                    // const time = (powerUps.boost.endCycle - m.cycle) / powerUps.boost.duration
                    const time = Math.min(0.5, (powerUps.boost.endCycle - simulation.cycle) / powerUps.boost.duration)

                    ctx.fillStyle = `rgba(0,0,0,${0.04 + 0.3 * time})`
                    ctx.fill()
                    // ctx.strokeStyle = "#333"
                    // ctx.lineWidth = 1
                    // ctx.stroke();
                    ctx.restore();
                }

                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5 //|| (m.cycle % 40 > 20)
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(Math.PI, -1.25);
                m.drawLeg("#606060");
                m.calcLeg(0, 0);
                m.drawLeg("#444");

                ctx.rotate(m.angle);
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                ctx.arc(15, 0, 4, 0, 2 * Math.PI);
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
                m.yOff = m.yOff * 0.75 + m.yOffGoal * 0.25; //smoothly move leg height towards height goal
            }
            m.drawLeg = function (stroke) {
                if (m.angle > -Math.PI / 2 && m.angle < Math.PI / 2) {
                    m.flipLegs = 1;
                } else {
                    m.flipLegs = -1;
                }
                const hip = { x: m.hip.x - 5, y: m.hip.y + 5 }
                const sub = Vector.sub(m.knee, hip)
                const off = Vector.mult(Vector.rotate(Vector.normalise(sub), Math.PI / 2), 8)
                const kneeBraceHigh = Vector.add(hip, off)
                const kneeBraceLow = Vector.add(kneeBraceHigh, Vector.mult(sub, 0.9))
                const foot = { x: m.foot.x - 10, y: m.foot.y - 15 }
                ctx.save();
                ctx.scale(m.flipLegs, 1); //leg lines
                ctx.beginPath();
                ctx.moveTo(hip.x, hip.y);
                ctx.lineTo(m.knee.x, m.knee.y);
                ctx.lineTo(foot.x, foot.y);
                //extra upper leg brace
                ctx.moveTo(kneeBraceHigh.x, kneeBraceHigh.y);
                ctx.lineTo(kneeBraceLow.x, kneeBraceLow.y);
                ctx.lineTo(m.knee.x, m.knee.y);

                ctx.strokeStyle = stroke;
                ctx.lineWidth = 3;
                ctx.stroke();
                //foot
                ctx.beginPath();
                ctx.moveTo(foot.x, foot.y);
                ctx.quadraticCurveTo(m.foot.x - 30, m.foot.y + 12, m.foot.x + 13, m.foot.y + 3);
                ctx.lineWidth = 1.5;
                ctx.stroke();

                //hip joint
                ctx.beginPath();
                ctx.arc(m.hip.x, m.hip.y - 1, 11, 0, 2 * Math.PI);
                //knee joint
                ctx.moveTo(m.knee.x + 3, m.knee.y);
                ctx.arc(m.knee.x, m.knee.y, 3, 0, 2 * Math.PI);
                //knee brace
                // ctx.moveTo(kneeBraceHigh.x + 4, kneeBraceHigh.y);
                // ctx.arc(kneeBraceHigh.x, kneeBraceHigh.y, 4, 0, 2 * Math.PI);
                ctx.moveTo(kneeBraceLow.x + 2.5, kneeBraceLow.y);
                ctx.arc(kneeBraceLow.x, kneeBraceLow.y, 2.5, 0, 2 * Math.PI);
                //foot joint
                ctx.moveTo(foot.x + 2.5, foot.y);
                ctx.arc(foot.x, foot.y, 2.5, 0, 2 * Math.PI);
                ctx.fillStyle = m.fillColor;
                ctx.fill();
                ctx.lineWidth = 1;
                // ctx.strokeStyle = "#333"
                ctx.stroke();
                ctx.restore();
            }
        },
        polar() {
            m.isAltSkin = true
            // m.setFillColors();
            m.fillColor = `hsl(${m.color.hue},${m.color.sat}%,${m.color.light}%)`
            m.fillColorDark = `hsl(${m.color.hue},${m.color.sat}%,${m.color.light - 35}%)`
            let grd = ctx.createLinearGradient(-30, 0, 30, 0);
            grd.addColorStop(0, m.fillColorDark);
            grd.addColorStop(0.7, m.fillColor);
            // grd.addColorStop(1, m.fillColor);
            m.bodyGradient = grd

            m.draw = function () {
                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5 //|| (m.cycle % 40 > 20)
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(Math.PI, -3);

                const diff = (m.lastKillCycle - m.cycle + tech.isDamageCooldownTime) / tech.isDamageCooldownTime
                const color = diff < 0 ? "#fff" : "#aaa"
                const hue = 220 + 20 * Math.sin(0.01 * m.cycle)
                const colorInverse = diff < 0 ? `hsl(${hue}, 80%, 40%)` : "#fff"
                m.drawLeg(color, colorInverse);
                m.calcLeg(0, 0);
                m.drawLeg(color, colorInverse);

                ctx.rotate(m.angle);
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.fillStyle = color
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(15, 0)
                ctx.lineTo(28, 0)
                ctx.strokeStyle = colorInverse;
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.restore();

                ctx.beginPath();
                ctx.ellipse(m.pos.x, m.pos.y, 24, 18, 3.14 * Math.random(), 0, 2 * Math.PI)
                ctx.fillStyle = diff < 0 ? `hsl(${hue}, 80%, 40%)` : `rgba(255,255,255,${Math.min(Math.max(0, diff + 0.3), 1)})`
                ctx.fill();

                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal
                powerUps.boost.draw()
            }
            m.drawLeg = function (stroke, circles) {
                // if (simulation.mouseInGame.x > m.pos.x) {
                if (m.angle > -Math.PI / 2 && m.angle < Math.PI / 2) {
                    m.flipLegs = 1;
                } else {
                    m.flipLegs = -1;
                }
                ctx.save();
                ctx.scale(m.flipLegs, 1); //leg lines
                ctx.beginPath();
                ctx.moveTo(m.hip.x, m.hip.y);
                ctx.lineTo(m.knee.x, m.knee.y);
                ctx.lineTo(m.foot.x, m.foot.y);
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 5;
                ctx.stroke();

                //toe lines
                ctx.beginPath();
                ctx.moveTo(m.foot.x, m.foot.y);
                if (m.onGround) {
                    ctx.lineTo(m.foot.x - 15, m.foot.y + 5);
                    ctx.moveTo(m.foot.x, m.foot.y);
                    ctx.lineTo(m.foot.x + 15, m.foot.y + 5);
                } else {
                    ctx.lineTo(m.foot.x - 13, m.foot.y + 8);
                    ctx.moveTo(m.foot.x, m.foot.y);
                    ctx.lineTo(m.foot.x + 13, m.foot.y + 8);
                }
                ctx.lineWidth = 3;
                ctx.stroke();

                //hip joint
                ctx.beginPath();
                ctx.arc(m.hip.x, m.hip.y, 11, 0, 2 * Math.PI);
                //knee joint
                ctx.moveTo(m.knee.x + 5, m.knee.y);
                ctx.arc(m.knee.x, m.knee.y, 5, 0, 2 * Math.PI);
                //foot joint
                ctx.moveTo(m.foot.x + 5, m.foot.y);
                ctx.arc(m.foot.x, m.foot.y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = circles;
                ctx.fill();
                // ctx.lineWidth = 2;
                // ctx.stroke();
                ctx.restore();
            }
        },
        strokeGap() {
            m.isAltSkin = true
            m.yOffWhen.stand = 52
            m.yOffWhen.jump = 72
            // m.speedSmooth = 0
            // m.smoothAngle = 0
            m.draw = function () {
                if (powerUps.boost.endCycle > simulation.cycle) {
                    //gel that acts as if the wind is blowing it when player moves
                    ctx.save();
                    ctx.translate(m.pos.x, m.pos.y);
                    m.velocitySmooth = Vector.add(Vector.mult(m.velocitySmooth, 0.8), Vector.mult(player.velocity, 0.2))
                    ctx.rotate(Math.atan2(m.velocitySmooth.y, m.velocitySmooth.x))
                    ctx.beginPath();
                    const radius = 40
                    const mag = 9 * Vector.magnitude(m.velocitySmooth) + radius
                    ctx.arc(0, 0, radius, -Math.PI / 2, Math.PI / 2);
                    ctx.bezierCurveTo(-radius, radius, -radius, 0, -mag, 0); // bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
                    ctx.bezierCurveTo(-radius, 0, -radius, -radius, 0, -radius);

                    // const time = (powerUps.boost.endCycle - m.cycle) / powerUps.boost.duration
                    const time = Math.min(0.5, (powerUps.boost.endCycle - simulation.cycle) / powerUps.boost.duration)

                    // ctx.fillStyle = `rgba(255,0,200,${0.4 * time})`
                    // ctx.fill()
                    // ctx.strokeStyle = "#f09"

                    ctx.fillStyle = `rgba(255,255,255,${0.3 + time})`;
                    ctx.fill()
                    ctx.strokeStyle = "#446"
                    ctx.lineWidth = 0.2 + 4 * time
                    // ctx.lineWidth = 1
                    ctx.stroke();
                    ctx.restore();
                }

                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5 //|| (m.cycle % 40 > 20)
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(Math.PI, -1.25);
                m.drawLeg("#606080");
                m.calcLeg(0, 0);
                m.drawLeg("#446");

                ctx.rotate(m.angle);
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                // ctx.arc(0, 0, 30, m.angle + 1, m.angle - 1);
                ctx.fillStyle = "#fff"//m.bodyGradient
                ctx.fill();
                ctx.beginPath();
                const arc = 0.7 + 0.17 * Math.sin(m.cycle * 0.012)
                ctx.arc(0, 0, 30, -arc, arc, true); //- Math.PI / 2
                ctx.strokeStyle = "#446";
                ctx.lineWidth = 2;
                ctx.stroke();

                //fire outline directed opposite player look direction
                // ctx.beginPath();
                // const radius = 40
                // const extend = -50
                // ctx.arc(0, 0, radius, -Math.PI / 2, Math.PI / 2);
                // ctx.bezierCurveTo(extend, radius, extend, 0, -100, 0); // bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
                // ctx.bezierCurveTo(extend, 0, extend, -radius, 0, -radius);
                // ctx.fillStyle = "rgba(255,0,255,0.3)";
                // ctx.fill()
                ctx.beginPath();
                ctx.moveTo(13, 0)
                ctx.lineTo(20, 0)
                ctx.lineWidth = 5;
                ctx.stroke();

                ctx.restore();
                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal
            }
            m.drawLeg = function (stroke) {
                // if (simulation.mouseInGame.x > m.pos.x) {
                if (m.angle > -Math.PI / 2 && m.angle < Math.PI / 2) {
                    m.flipLegs = 1;
                } else {
                    m.flipLegs = -1;
                }
                ctx.save();
                ctx.scale(m.flipLegs, 1); //leg lines
                ctx.beginPath();
                ctx.moveTo(m.hip.x, m.hip.y);
                ctx.lineTo(m.knee.x, m.knee.y);
                ctx.lineTo(m.foot.x, m.foot.y);
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 5;
                ctx.stroke();

                //toe lines
                ctx.beginPath();
                ctx.moveTo(m.foot.x, m.foot.y);
                if (m.onGround) {
                    ctx.lineTo(m.foot.x - 14, m.foot.y + 5);
                    ctx.moveTo(m.foot.x, m.foot.y);
                    ctx.lineTo(m.foot.x + 14, m.foot.y + 5);
                } else {
                    ctx.lineTo(m.foot.x - 12, m.foot.y + 8);
                    ctx.moveTo(m.foot.x, m.foot.y);
                    ctx.lineTo(m.foot.x + 12, m.foot.y + 8);
                }
                ctx.lineWidth = 4;
                ctx.stroke();

                //hip joint
                ctx.beginPath();
                ctx.arc(m.hip.x, m.hip.y, 8, 0, 2 * Math.PI);
                //knee joint
                ctx.moveTo(m.knee.x + 4, m.knee.y);
                ctx.arc(m.knee.x, m.knee.y, 4, 0, 2 * Math.PI);
                //foot joint
                ctx.moveTo(m.foot.x + 4, m.foot.y + 1);
                ctx.arc(m.foot.x, m.foot.y + 1, 4, 0, 2 * Math.PI);
                ctx.fillStyle = m.fillColor;
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
            }
        },
        energy() {
            m.isAltSkin = true
            m.color = {
                hue: 184,
                sat: 100,
                light: 85,
            }
            m.setFillColors();
            m.draw = function () {
                if (powerUps.boost.endCycle > simulation.cycle) {
                    //gel that acts as if the wind is blowing it when player moves
                    ctx.save();
                    ctx.translate(m.pos.x, m.pos.y);
                    m.velocitySmooth = Vector.add(Vector.mult(m.velocitySmooth, 0.8), Vector.mult(player.velocity, 0.2))
                    ctx.rotate(Math.atan2(m.velocitySmooth.y, m.velocitySmooth.x))
                    ctx.beginPath();
                    const radius = 40
                    const mag = 10 * Vector.magnitude(m.velocitySmooth) + radius
                    ctx.arc(0, 0, radius, -Math.PI / 2, Math.PI / 2);
                    ctx.bezierCurveTo(-radius, radius, -radius, 0, -mag, 0); // bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
                    ctx.bezierCurveTo(-radius, 0, -radius, -radius, 0, -radius);

                    // const time = (powerUps.boost.endCycle - m.cycle) / powerUps.boost.duration
                    const time = Math.min(0.5, (powerUps.boost.endCycle - simulation.cycle) / powerUps.boost.duration)

                    ctx.fillStyle = `hsla(184,100%,70%,${0.1 + 1.5 * time})`
                    ctx.fill()
                    ctx.strokeStyle = "#035"//"hsl(184,100%,70%)"
                    ctx.lineWidth = 0.2 + 3 * time
                    ctx.stroke();
                    ctx.restore();
                }

                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5 //|| (m.cycle % 40 > 20)
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(Math.PI, -3);
                m.drawLeg("#456");
                m.calcLeg(0, 0);
                m.drawLeg("#345");
                ctx.rotate(m.angle);
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.strokeStyle = "rgba(0,255,255,0.25)";
                ctx.lineWidth = 15;
                ctx.stroke();
                ctx.fillStyle = 'hsl(184,100%,85%)' //m.fillColor; //"#9ff" //m.bodyGradient
                ctx.fill();

                ctx.beginPath();
                ctx.arc(17, 0, 5.5, 0, 2 * Math.PI);
                ctx.fillStyle = "#357"
                ctx.fill();
                ctx.restore();

                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal
            }
            m.drawLeg = function (stroke) {
                // if (simulation.mouseInGame.x > m.pos.x) {
                if (m.angle > -Math.PI / 2 && m.angle < Math.PI / 2) {
                    m.flipLegs = 1;
                } else {
                    m.flipLegs = -1;
                }
                ctx.save();
                ctx.scale(m.flipLegs, 1); //leg lines
                ctx.beginPath();
                ctx.moveTo(m.hip.x, m.hip.y);
                ctx.lineTo(m.knee.x, m.knee.y);
                ctx.lineTo(m.foot.x, m.foot.y);
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 5;
                ctx.stroke();

                //toe lines
                ctx.beginPath();
                ctx.moveTo(m.foot.x, m.foot.y);
                if (m.onGround) {
                    ctx.lineTo(m.foot.x - 15, m.foot.y + 5);
                    ctx.moveTo(m.foot.x, m.foot.y);
                    ctx.lineTo(m.foot.x + 15, m.foot.y + 5);
                } else {
                    ctx.lineTo(m.foot.x - 13, m.foot.y + 8);
                    ctx.moveTo(m.foot.x, m.foot.y);
                    ctx.lineTo(m.foot.x + 13, m.foot.y + 8);
                }
                ctx.lineWidth = 3;
                ctx.stroke();

                //hip joint
                ctx.beginPath();
                ctx.arc(m.hip.x, m.hip.y, 10, 0, 2 * Math.PI);
                //knee joint
                ctx.moveTo(m.knee.x + 6, m.knee.y);
                ctx.arc(m.knee.x, m.knee.y, 6, 0, 2 * Math.PI);
                //foot joint
                ctx.moveTo(m.foot.x + 5, m.foot.y);
                ctx.arc(m.foot.x, m.foot.y + 1, 5, 0, 2 * Math.PI);
                ctx.strokeStyle = "rgba(0,255,255,0.25)";
                ctx.lineWidth = 6;
                ctx.stroke();
                ctx.fillStyle = m.fillColor;
                ctx.fill();
                ctx.restore();
            }
        },
        tungsten() {
            m.hardLandCDScale = 2
            m.hardLanding = 60
            // m.coyoteCycles = 0
            m.isAltSkin = true
            m.color = {
                hue: 210,
                sat: 5,
                light: 75,
            }
            // m.setFillColors();
            m.fillColor = `hsl(${m.color.hue},${m.color.sat}%,${m.color.light}%)`
            m.fillColorDark = `hsl(${m.color.hue},${m.color.sat}%,${m.color.light - 50}%)`
            const grd = ctx.createLinearGradient(-30, -5, 30, 10);
            grd.addColorStop(0, `#e0e0e0`);
            grd.addColorStop(0.3, `#bbb`);
            grd.addColorStop(0.4, `#b3b3b3`);
            grd.addColorStop(0.5, `#c5c5c5`);
            grd.addColorStop(0.65, `#bbb`);
            grd.addColorStop(0.7, `#b3b3b3`);
            grd.addColorStop(0.75, `#bbb`);
            grd.addColorStop(1, `#e0e0e0`);
            // const grdRad = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
            // grdRad.addColorStop(0, `rgba(0,0,0,0.3)`);
            // grdRad.addColorStop(0.5, `rgba(210,210,210,0)`);
            m.bodyGradient = grd

            m.draw = function () {
                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5 //|| (m.cycle % 40 > 20)
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(4.2, -3);
                m.drawLeg("#666");
                m.calcLeg(2.1, -1);
                m.drawLeg("#5f5f5f");
                m.calcLeg(0, 1);
                m.drawLeg("#555");
                ctx.rotate(m.angle);

                const size = 33
                ctx.beginPath();
                ctx.lineTo(size * 1, size * 0)
                ctx.lineTo(size * 0.5, size * 0.866)
                ctx.lineTo(size * -0.5, size * 0.866)
                ctx.lineTo(size * -1, size * 0)
                ctx.lineTo(size * -0.5, size * -0.866)
                ctx.lineTo(size * 0.5, size * -0.866)
                ctx.lineTo(size * 1, size * 0)
                ctx.lineTo(size * 0.5, size * 0)
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 1.5;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(15, 0, 3, 0, 2 * Math.PI);
                ctx.fillStyle = "#333"
                ctx.fill();

                ctx.restore();
                m.yOff = m.yOff * 0.9 + m.yOffGoal * 0.1; //smoothly move leg height towards height goal
                powerUps.boost.draw()
            }
            m.drawLeg = function (stroke) {
                // if (simulation.mouseInGame.x > m.pos.x) {
                if (m.angle > -Math.PI / 2 && m.angle < Math.PI / 2) {
                    m.flipLegs = 1;
                } else {
                    m.flipLegs = -1;
                }
                ctx.save();
                ctx.scale(m.flipLegs, 1); //leg lines
                ctx.beginPath();
                ctx.moveTo(m.hip.x, m.hip.y);
                ctx.lineTo(m.knee.x, m.knee.y);
                ctx.lineTo(m.foot.x, m.foot.y);
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 4.5;
                ctx.stroke();

                //toe lines
                ctx.beginPath();
                ctx.moveTo(m.foot.x, m.foot.y - 1);
                ctx.lineTo(m.foot.x - 15, m.foot.y + 5);
                ctx.lineTo(m.foot.x + 15, m.foot.y + 5);
                ctx.lineTo(m.foot.x, m.foot.y - 1);
                ctx.lineWidth = 4;
                ctx.stroke();

                //hip joint
                ctx.beginPath();
                ctx.arc(m.hip.x, m.hip.y - 4, 12, 0, 2 * Math.PI);
                //knee joint
                ctx.moveTo(m.knee.x + 6, m.knee.y);
                ctx.arc(m.knee.x, m.knee.y, 6, 0, 2 * Math.PI);
                //foot joint
                ctx.moveTo(m.foot.x + 5, m.foot.y);
                ctx.arc(m.foot.x, m.foot.y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = m.fillColor;
                ctx.fill();
                ctx.lineWidth = 1;
                ctx.strokeStyle = "#000"
                ctx.stroke();
                ctx.restore();
            }

        },
        anodize() {
            m.isAltSkin = true
            m.color = {
                hue: 210,
                sat: 14,
                light: 65,
            }
            m.fillColor = `hsl(${m.color.hue},${m.color.sat}%,${m.color.light}%)`
            m.fillColorDark = `hsl(${m.color.hue},${m.color.sat}%,${m.color.light - 50}%)`
            const grd = ctx.createRadialGradient(16, 0, 0, 0, 0, 40);
            grd.addColorStop(0, `#c78034`);
            grd.addColorStop(0.04, `#bd5235`);
            grd.addColorStop(0.08, `#ab554d`);
            grd.addColorStop(0.12, `#8f5d8f`);
            grd.addColorStop(0.16, `#4352ab`);
            grd.addColorStop(0.2, `#2058b3`);
            grd.addColorStop(0.24, `#1a6fc4`);
            grd.addColorStop(0.28, `#1b85cf`);
            grd.addColorStop(0.32, `#2d9bd7`);
            grd.addColorStop(0.4, `#d2d7b4`);
            grd.addColorStop(0.44, `#e1cd87`);
            grd.addColorStop(0.48, `#f0b955`);
            grd.addColorStop(0.52, `#ffa050`);
            grd.addColorStop(0.56, `#ff8269`);
            grd.addColorStop(0.6, `#f5697d`);
            grd.addColorStop(0.64, `#e65aaf`);
            grd.addColorStop(0.68, `#d732d7`);
            grd.addColorStop(0.72, `#c846e6`);
            grd.addColorStop(0.76, `#c850fa`);
            grd.addColorStop(0.8, `#878cf0`);
            grd.addColorStop(0.84, `#37beeb`);
            grd.addColorStop(0.88, `#00d2be`);
            grd.addColorStop(0.92, `#00e19b`);
            grd.addColorStop(0.96, `#19f5aa`);
            grd.addColorStop(1, `#aaf5af`);
            m.bodyGradient = grd

            m.draw = function () {
                if (powerUps.boost.endCycle > simulation.cycle) {
                    //gel that acts as if the wind is blowing it when player moves
                    ctx.save();
                    ctx.translate(m.pos.x, m.pos.y);
                    m.velocitySmooth = Vector.add(Vector.mult(m.velocitySmooth, 0.8), Vector.mult(player.velocity, 0.2))
                    ctx.rotate(Math.atan2(m.velocitySmooth.y, m.velocitySmooth.x))
                    ctx.beginPath();
                    const radius = 40
                    const mag = 12 * Vector.magnitude(m.velocitySmooth) + radius
                    ctx.arc(0, 0, radius, -Math.PI / 2, Math.PI / 2);
                    ctx.bezierCurveTo(-radius, radius, -radius, 0, -mag, 0); // bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
                    ctx.bezierCurveTo(-radius, 0, -radius, -radius, 0, -radius);
                    // const time = (powerUps.boost.endCycle - m.cycle) / powerUps.boost.duration
                    const time = Math.min(0.5, (powerUps.boost.endCycle - simulation.cycle) / powerUps.boost.duration)

                    ctx.fillStyle = `hsla(${simulation.cycle},100%,70%,${0.1 + 2 * time})`
                    ctx.fill()
                    ctx.restore();
                }

                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5 //|| (m.cycle % 40 > 20)
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(Math.PI, -3);
                m.drawLeg("#4a4a5a");
                m.calcLeg(0, 0);
                m.drawLeg("#445");
                ctx.rotate(m.angle);
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                // ctx.arc(15, 0, 4, 0, 2 * Math.PI);
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 2;
                // ctx.stroke();
                ctx.restore();
                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal
            }
            m.drawLeg = function (stroke) {
                // if (simulation.mouseInGame.x > m.pos.x) {
                if (m.angle > -Math.PI / 2 && m.angle < Math.PI / 2) {
                    m.flipLegs = 1;
                } else {
                    m.flipLegs = -1;
                }
                ctx.save();
                ctx.scale(m.flipLegs, 1); //leg lines
                ctx.beginPath();
                ctx.moveTo(m.hip.x, m.hip.y);
                ctx.lineTo(m.knee.x, m.knee.y);
                ctx.lineTo(m.foot.x, m.foot.y);
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 5;
                ctx.stroke();

                //toe lines
                ctx.beginPath();
                ctx.moveTo(m.foot.x, m.foot.y);
                if (m.onGround) {
                    ctx.lineTo(m.foot.x - 15, m.foot.y + 5);
                    ctx.moveTo(m.foot.x, m.foot.y);
                    ctx.lineTo(m.foot.x + 15, m.foot.y + 5);
                } else {
                    ctx.lineTo(m.foot.x - 13, m.foot.y + 8);
                    ctx.moveTo(m.foot.x, m.foot.y);
                    ctx.lineTo(m.foot.x + 13, m.foot.y + 8);
                }
                ctx.lineWidth = 4;
                ctx.stroke();

                //hip joint
                ctx.beginPath();
                ctx.arc(m.hip.x, m.hip.y, 9, 0, 2 * Math.PI);
                ctx.fillStyle = "#222";
                ctx.fill();
                //knee joint
                ctx.beginPath();
                ctx.arc(m.knee.x, m.knee.y, 5, 0, 2 * Math.PI);
                ctx.fill();
                //foot joint
                ctx.beginPath();
                ctx.arc(m.foot.x, m.foot.y, 4, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();
            }
        },
        dilate() {
            m.isAltSkin = true
            simulation.isAutoZoom = false;
            m.draw = function () {
                const amplitude = 8 + 4 * Math.sin(m.cycle * 0.01)
                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5 //|| (m.cycle % 40 > 20)
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(Math.PI, -3);
                m.drawLeg("#456");
                m.calcLeg(0, 0);
                m.drawLeg("#345");
                ctx.rotate(m.angle);
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                ctx.strokeStyle = "#345";
                ctx.lineWidth = 2;
                ctx.arc(12, 0, amplitude, 0, 2 * Math.PI); //big eye
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(12, 0, amplitude, 0, 2 * Math.PI); //big eye
                // ctx.fillStyle = `hsl(0,0%,${50+50*Math.sin(m.cycle * 0.0075+Math.PI)}%)` //`hsl(${150+50*Math.sin(m.cycle * 0.0075)},100%,50%)`
                // ctx.fill();
                ctx.stroke();
                ctx.restore();
                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal

                if (powerUps.boost.endCycle > simulation.cycle) {
                    //gel that acts as if the wind is blowing it when player moves
                    ctx.save();
                    ctx.translate(m.pos.x, m.pos.y);
                    m.velocitySmooth = Vector.add(Vector.mult(m.velocitySmooth, 0.8), Vector.mult(player.velocity, 0.2))
                    ctx.rotate(Math.atan2(m.velocitySmooth.y, m.velocitySmooth.x))
                    ctx.beginPath();
                    const radius = 39
                    const mag = 6 * Vector.magnitude(m.velocitySmooth) + radius
                    ctx.arc(0, 0, radius, -Math.PI / 2, Math.PI / 2);
                    ctx.bezierCurveTo(-radius, radius, -radius, 0, -mag, 0); // bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
                    ctx.bezierCurveTo(-radius, 0, -radius, -radius, 0, -radius);
                    // ctx.fillStyle = `hsla(${simulation.cycle * 0.5},100%,70%,0.4)`
                    // ctx.fill()
                    ctx.strokeStyle = "#345"
                    // const time = (powerUps.boost.endCycle - m.cycle) / powerUps.boost.duration
                    const time = Math.min(0.5, (powerUps.boost.endCycle - simulation.cycle) / powerUps.boost.duration)

                    ctx.lineWidth = 0.2 + 4 * time
                    ctx.stroke();
                    ctx.restore();
                }

                //zoom camera in and out
                simulation.setZoom(1800 + 400 * Math.sin(m.cycle * 0.01))
            }
        },
        dilate2() {
            m.isAltSkin = true
            m.draw = function () {
                const amplitude = Math.sin(m.cycle * 0.01)

                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5 //|| (m.cycle % 40 > 20)
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(Math.PI, -3);
                m.drawLeg("#456");
                m.calcLeg(0, 0);
                m.drawLeg("#345");
                ctx.rotate(m.angle);
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                ctx.strokeStyle = "#345";
                ctx.lineWidth = 3 + 3 * Math.sin(m.cycle * 0.01 + Math.PI);
                ctx.stroke();
                // ctx.arc(12, 0, 8 + 4 * amplitude, 0, 2 * Math.PI); //big eye
                ctx.beginPath();
                ctx.arc(12, 0, 8 + 4 * amplitude, 0, 2 * Math.PI); //big eye
                ctx.fillStyle = "#345"
                // ctx.fillStyle = //`hsl(0,0%,${50+50*Math.sin(m.cycle * 0.0075+Math.PI)}%)` //`hsl(${150+50*Math.sin(m.cycle * 0.0075)},100%,50%)`
                // ctx.fillStyle = `hsl(${150 + 100 * amplitude},100%,50%)`
                ctx.fill();
                // ctx.stroke();
                ctx.restore();
                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal

                if (powerUps.boost.endCycle > simulation.cycle) {
                    //gel that acts as if the wind is blowing it when player moves
                    ctx.save();
                    ctx.translate(m.pos.x, m.pos.y);
                    m.velocitySmooth = Vector.add(Vector.mult(m.velocitySmooth, 0.8), Vector.mult(player.velocity, 0.2))
                    ctx.rotate(Math.atan2(m.velocitySmooth.y, m.velocitySmooth.x))
                    ctx.beginPath();
                    const radius = 39
                    const mag = 6 * Vector.magnitude(m.velocitySmooth) + radius
                    ctx.arc(0, 0, radius, -Math.PI / 2, Math.PI / 2);
                    ctx.bezierCurveTo(-radius, radius, -radius, 0, -mag, 0); // bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
                    ctx.bezierCurveTo(-radius, 0, -radius, -radius, 0, -radius);
                    // ctx.fillStyle = `hsla(${simulation.cycle * 0.5},100%,70%,0.4)`
                    // ctx.fill()
                    const time = Math.min(0.5, (powerUps.boost.endCycle - simulation.cycle) / powerUps.boost.duration)

                    ctx.strokeStyle = "#345"
                    ctx.lineWidth = 0.2 + 7 * time
                    // ctx.lineWidth = (4 + 3 * Math.sin(m.cycle * 0.01 + Math.PI)) * time;
                    ctx.stroke();
                    ctx.restore();
                }

                simulation.setZoom(1800 + 400 * amplitude)
            }
            m.drawLeg = function (stroke) {
                // if (simulation.mouseInGame.x > m.pos.x) {
                if (m.angle > -Math.PI / 2 && m.angle < Math.PI / 2) {
                    m.flipLegs = 1;
                } else {
                    m.flipLegs = -1;
                }
                ctx.save();
                ctx.scale(m.flipLegs, 1); //leg lines
                ctx.beginPath();
                ctx.moveTo(m.hip.x, m.hip.y);
                ctx.lineTo(m.knee.x, m.knee.y);
                ctx.lineTo(m.foot.x, m.foot.y);
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 6 + 2 * Math.sin(m.cycle * 0.01 + Math.PI);
                ctx.stroke();

                //toe lines
                ctx.beginPath();
                ctx.moveTo(m.foot.x, m.foot.y);
                if (m.onGround) {
                    ctx.lineTo(m.foot.x - 15, m.foot.y + 5);
                    ctx.moveTo(m.foot.x, m.foot.y);
                    ctx.lineTo(m.foot.x + 15, m.foot.y + 5);
                } else {
                    ctx.lineTo(m.foot.x - 13, m.foot.y + 8);
                    ctx.moveTo(m.foot.x, m.foot.y);
                    ctx.lineTo(m.foot.x + 13, m.foot.y + 8);
                }
                ctx.lineWidth = 4;
                ctx.stroke();

                //hip joint
                ctx.beginPath();
                ctx.arc(m.hip.x, m.hip.y, 11, 0, 2 * Math.PI);
                //knee joint
                ctx.moveTo(m.knee.x + 7, m.knee.y);
                ctx.arc(m.knee.x, m.knee.y, 7, 0, 2 * Math.PI);
                //foot joint
                ctx.moveTo(m.foot.x + 6, m.foot.y);
                ctx.arc(m.foot.x, m.foot.y, 6, 0, 2 * Math.PI);
                ctx.fillStyle = "#345";
                ctx.fill();
                ctx.lineWidth = 3 + 3 * Math.sin(m.cycle * 0.01 + Math.PI);
                ctx.stroke();
                ctx.restore();
            }
        },
        CPT() {
            m.isAltSkin = true

            m.fillColor = `hsl(${m.color.hue},${m.color.sat}%,${m.color.light}%)`
            m.fillColorDark = `hsl(${m.color.hue},${m.color.sat}%,${m.color.light - 35}%)`
            let grd = ctx.createLinearGradient(-20, 0, 15, 0);
            grd.addColorStop(0, m.fillColorDark);
            grd.addColorStop(1, m.fillColor);
            // grd.addColorStop(1, m.fillColor);
            m.bodyGradient = grd
            m.draw = function () {
                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5 //|| (m.cycle % 40 > 20)
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(Math.PI, -3);
                m.drawLeg("#eee");
                m.calcLeg(0, 0);
                m.drawLeg("#fff");

                ctx.rotate(0.024 * simulation.cycle);
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.fillStyle = m.energy > 0.85 * Math.min(1, m.maxEnergy) ? m.bodyGradient : "#fff"
                ctx.fill();
                ctx.restore();

                ctx.beginPath();
                ctx.arc(m.pos.x + 15 * Math.cos(m.angle), m.pos.y + 15 * Math.sin(m.angle), 5, 0, 2 * Math.PI);
                ctx.fillStyle = "#000"
                ctx.fill();
                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal
                powerUps.boost.draw()
            }
            m.drawLeg = function (stroke) {
                // if (simulation.mouseInGame.x > m.pos.x) {
                if (m.angle > -Math.PI / 2 && m.angle < Math.PI / 2) {
                    m.flipLegs = 1;
                } else {
                    m.flipLegs = -1;
                }
                ctx.save();
                ctx.scale(m.flipLegs, 1); //leg lines
                ctx.beginPath();
                ctx.moveTo(m.hip.x, m.hip.y);
                ctx.lineTo(m.knee.x, m.knee.y);
                ctx.lineTo(m.foot.x, m.foot.y);
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 5;
                ctx.stroke();

                //toe lines
                ctx.beginPath();
                ctx.moveTo(m.foot.x, m.foot.y);
                if (m.onGround) {
                    ctx.lineTo(m.foot.x - 15, m.foot.y + 5);
                    ctx.moveTo(m.foot.x, m.foot.y);
                    ctx.lineTo(m.foot.x + 15, m.foot.y + 5);
                } else {
                    ctx.lineTo(m.foot.x - 13, m.foot.y + 8);
                    ctx.moveTo(m.foot.x, m.foot.y);
                    ctx.lineTo(m.foot.x + 13, m.foot.y + 8);
                }
                ctx.lineWidth = 3;
                ctx.stroke();

                //hip joint
                ctx.beginPath();
                ctx.arc(m.hip.x, m.hip.y, 11, 0, 2 * Math.PI);
                //knee joint
                ctx.moveTo(m.knee.x + 5, m.knee.y);
                ctx.arc(m.knee.x, m.knee.y, 5, 0, 2 * Math.PI);
                //foot joint
                ctx.moveTo(m.foot.x + 5, m.foot.y);
                ctx.arc(m.foot.x, m.foot.y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = "#000";
                ctx.fill();
                // ctx.lineWidth = 2;
                // ctx.stroke();
                ctx.restore();
            }
        },
        verlet() {
            m.isAltSkin = true
            m.draw = function () {
                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5 //|| (m.cycle % 40 > 20)
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(Math.PI, -2);
                m.drawLeg("#4a4a4a");
                m.calcLeg(0, 0);
                m.drawLeg("#333");

                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                const rate = 0.09
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(0, 0, rate * (simulation.cycle + 0) % 30, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(0, 0, rate * (simulation.cycle + 15 / rate) % 30, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.stroke();

                ctx.globalCompositeOperation = "difference";
                ctx.rotate(m.angle);
                ctx.beginPath();
                ctx.arc(21, 0, 8, 0, 2 * Math.PI);
                ctx.fillStyle = input.fire ? "#0ff" : input.field ? "#d30" : `#fff`
                ctx.fill();
                ctx.restore();

                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal
                powerUps.boost.draw()
            }
            m.drawLeg = function (stroke) {
                // if (simulation.mouseInGame.x > m.pos.x) {
                if (m.angle > -Math.PI / 2 && m.angle < Math.PI / 2) {
                    m.flipLegs = 1;
                } else {
                    m.flipLegs = -1;
                }
                ctx.save();
                ctx.scale(m.flipLegs, 1); //leg lines
                ctx.beginPath();
                ctx.moveTo(m.hip.x, m.hip.y);
                ctx.lineTo(m.knee.x, m.knee.y);
                ctx.lineTo(m.foot.x, m.foot.y);
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 1;
                ctx.stroke();

                //toe lines
                ctx.beginPath();
                ctx.moveTo(m.foot.x, m.foot.y);
                const footDrop = m.onGround ? 5 : 10
                ctx.lineTo(m.foot.x - 15, m.foot.y + footDrop);
                ctx.moveTo(m.foot.x, m.foot.y);
                ctx.lineTo(m.foot.x + 15, m.foot.y + footDrop);
                ctx.lineWidth = 1;
                ctx.stroke();

                //hip joint
                ctx.beginPath();
                ctx.arc(m.hip.x, m.hip.y, 9, 0, 2 * Math.PI);
                //knee joint
                ctx.moveTo(m.knee.x + 5, m.knee.y);
                ctx.arc(m.knee.x, m.knee.y, 3, 0, 2 * Math.PI);
                //foot joint
                ctx.moveTo(m.foot.x + 5, m.foot.y);
                ctx.arc(m.foot.x, m.foot.y, 4, 0, 2 * Math.PI);
                ctx.fillStyle = "#000";
                ctx.fill();
                // ctx.lineWidth = 2;
                // ctx.stroke();
                ctx.restore();
            }
        },
        stubs() {
            m.isAltSkin = true
            m.draw = function () {
                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5 //|| (m.cycle % 40 > 20)
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(Math.PI, -3);
                m.drawLeg("#555");
                m.calcLeg(0, 0);
                m.drawLeg("#333");
                ctx.rotate(m.angle);
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                ctx.arc(15, 0, 4, 0, 2 * Math.PI);
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal
                powerUps.boost.draw()
            }
            m.drawLeg = function (stroke) {
                // if (simulation.mouseInGame.x > m.pos.x) {
                if (m.angle > -Math.PI / 2 && m.angle < Math.PI / 2) {
                    m.flipLegs = 1;
                } else {
                    m.flipLegs = -1;
                }
                ctx.save();
                ctx.scale(m.flipLegs, 1); //leg lines
                ctx.beginPath();
                ctx.moveTo(m.hip.x, m.hip.y);
                ctx.lineTo(m.knee.x, m.knee.y);
                ctx.lineTo(m.foot.x, m.foot.y + 5);
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 6;
                ctx.stroke();
                ctx.restore();
            }
        },
        Sleipnir() {
            m.isAltSkin = true
            m.draw = function () {
                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5
                ctx.translate(m.pos.x, m.pos.y);
                for (let i = 0; i < 16; i++) {
                    m.calcLeg(Math.PI * i / 8, -3 * i / 16)
                    m.drawLeg("#444")
                }
                ctx.rotate(m.angle);
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                ctx.arc(15, 0, 4, 0, 2 * Math.PI);
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal
                powerUps.boost.draw()
            }
        },
        diegesis() {
            m.isAltSkin = true
            m.draw = function () {
                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;

                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(Math.PI, -3);
                m.drawLeg("#4a4a4a");
                m.calcLeg(0, 0);
                m.drawLeg("#333");
                ctx.rotate(m.angle - (m.fireCDcycle !== Infinity ? m.flipLegs * 0.25 * Math.pow(Math.max(m.fireCDcycle - m.cycle, 0), 0.5) : 0));

                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                ctx.arc(15, 0, 4, 0, 2 * Math.PI);
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal
                powerUps.boost.draw()
            }
        },
        cat() {
            m.isAltSkin = true
            m.coyoteCycles = 10
            m.draw = function () {
                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(Math.PI, -3);
                m.drawLeg("#4a4a4a");
                if (!(m.angle > -Math.PI / 2 && m.angle < Math.PI / 2)) {
                    ctx.scale(1, -1);
                    ctx.rotate(Math.PI);
                }
                ctx.beginPath();
                ctx.moveTo(-30, 0);
                ctx.bezierCurveTo(-65, -75,
                    -5, 150 + (5 * Math.sin(simulation.cycle / 10)),
                    -70 + (10 * Math.sin(simulation.cycle / 10)), 0 + (10 * Math.sin(simulation.cycle / 10)));
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 4;
                ctx.stroke();

                if (!(m.angle > -Math.PI / 2 && m.angle < Math.PI / 2)) {
                    ctx.scale(1, -1);
                    ctx.rotate(0 - Math.PI);
                }
                m.calcLeg(0, 0);
                m.drawLeg("#333");

                ctx.rotate(m.angle);
                if (!(m.angle > -Math.PI / 2 && m.angle < Math.PI / 2)) ctx.scale(1, -1);
                ctx.beginPath();
                ctx.moveTo(5, -30);
                ctx.lineTo(20, -40);
                ctx.lineTo(20, -20);
                ctx.lineWidth = 2;
                ctx.fillStyle = "#f3f";
                ctx.fill();
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                ctx.stroke();
                ctx.moveTo(19, 0);
                ctx.arc(15, 0, 4, Math.PI, 2 * Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(24.3, 6, 5, Math.PI * 2, Math.PI);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(30, 6);
                ctx.lineTo(32, 0);
                ctx.lineTo(26, 0);
                ctx.lineTo(30, 6);
                ctx.fillStyle = "#f3f";
                ctx.fill();
                ctx.stroke();

                ctx.restore();
                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal
                powerUps.boost.draw()
            }
        },
        pareidolia() {
            m.isAltSkin = true
            m.draw = function () {
                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.7
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(Math.PI, -3);
                m.drawLeg("#4a4a4a");
                m.calcLeg(0, 0);
                m.drawLeg("#333");
                ctx.rotate(m.angle);
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 2;
                if (!(m.angle > -Math.PI / 2 && m.angle < Math.PI / 2)) ctx.scale(1, -1); //here is the flip
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(2, -6, 7, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(25, -6, 7, 0.25 * Math.PI, 1.6 * Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(2, -10, 9, 1.25 * Math.PI, 1.75 * Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(25, -10, 9, 1.25 * Math.PI, 1.4 * Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(18, 13, 10, 0, 2 * Math.PI);
                ctx.fillStyle = m.bodyGradient;
                ctx.fill();
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(18, 13, 6, 0, 2 * Math.PI);
                ctx.fillStyle = "#555";
                ctx.fill();
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(3, -6, 3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(26, -6, 3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15;
                powerUps.boost.draw()
            }
        },
        flipFlop() {
            m.isAltSkin = true
            m.draw = function () {
                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;

                //draw body
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5
                ctx.translate(m.pos.x, m.pos.y);

                m.calcLeg(Math.PI, -3);
                m.drawLeg("#4a4a4a");
                m.calcLeg(0, 0);
                m.drawLeg("#333");

                ctx.rotate(m.angle);
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                ctx.arc(15, 0, 4, 0, 2 * Math.PI);
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 2;
                ctx.stroke();
                //draw eye
                ctx.beginPath();
                ctx.arc(15, 0, 3.5, 0, 2 * Math.PI);
                ctx.fillStyle = m.eyeFillColor;
                ctx.fill()
                ctx.restore();

                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal
                powerUps.boost.draw()
            }
        },
        hexagon() {
            m.isAltSkin = true

            m.fillColor = `hsl(${m.color.hue},${m.color.sat}%,${m.color.light}%)`
            m.fillColorDark = `hsl(${m.color.hue},${m.color.sat}%,${m.color.light - 35}%)`
            let grd = ctx.createLinearGradient(-30, 0, 30, 0);
            grd.addColorStop(0, m.fillColorDark);
            grd.addColorStop(0.7, m.fillColor);
            // grd.addColorStop(1, m.fillColor);
            m.bodyGradient = grd

            m.draw = function () {
                ctx.fillStyle = m.fillColor;
                m.walk_cycle += m.flipLegs * m.Vx;
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5 //|| (m.cycle % 40 > 20)
                ctx.translate(m.pos.x, m.pos.y);
                m.calcLeg(Math.PI, -3);
                m.drawLeg("#4a4a4a");
                m.calcLeg(0, 0);
                m.drawLeg("#333");
                ctx.rotate(m.angle);

                const size = 32
                ctx.beginPath();
                ctx.lineTo(size * 1, size * 0)
                ctx.lineTo(size * 0.5, size * 0.866)
                ctx.lineTo(size * -0.5, size * 0.866)
                ctx.lineTo(size * -1, size * 0)
                ctx.lineTo(size * -0.5, size * -0.866)
                ctx.lineTo(size * 0.5, size * -0.866)
                ctx.lineTo(size * 1, size * 0)
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                ctx.arc(15, 0, 4, 0, 2 * Math.PI);
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
                m.yOff = m.yOff * 0.85 + m.yOffGoal * 0.15; //smoothly move leg height towards height goal
                powerUps.boost.draw()
            }
            m.drawLeg = function (stroke) {
                // if (simulation.mouseInGame.x > m.pos.x) {
                if (m.angle > -Math.PI / 2 && m.angle < Math.PI / 2) {
                    m.flipLegs = 1;
                } else {
                    m.flipLegs = -1;
                }
                ctx.save();
                ctx.scale(m.flipLegs, 1); //leg lines
                ctx.beginPath();
                ctx.moveTo(m.hip.x, m.hip.y);
                ctx.lineTo(m.knee.x, m.knee.y);
                ctx.lineTo(m.foot.x, m.foot.y);
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 6;
                ctx.stroke();

                //toe lines
                ctx.beginPath();
                ctx.moveTo(m.foot.x, m.foot.y);
                if (m.onGround) {
                    ctx.lineTo(m.foot.x - 15, m.foot.y + 5);
                    ctx.moveTo(m.foot.x, m.foot.y);
                    ctx.lineTo(m.foot.x + 15, m.foot.y + 5);
                } else {
                    ctx.lineTo(m.foot.x - 13, m.foot.y + 8);
                    ctx.moveTo(m.foot.x, m.foot.y);
                    ctx.lineTo(m.foot.x + 13, m.foot.y + 8);
                }
                ctx.lineWidth = 3;
                ctx.stroke();

                //hip joint
                ctx.beginPath();
                ctx.arc(m.hip.x, m.hip.y, 11, 0, 2 * Math.PI);
                //knee joint
                ctx.moveTo(m.knee.x + 5, m.knee.y);
                ctx.arc(m.knee.x, m.knee.y, 5, 0, 2 * Math.PI);
                //foot joint
                ctx.moveTo(m.foot.x + 5, m.foot.y);
                ctx.arc(m.foot.x, m.foot.y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = "#000";
                ctx.fill();
                // ctx.lineWidth = 2;
                // ctx.stroke();
                ctx.restore();
            }
        },
    },
    // *********************************************
    // **************** fields *********************
    // *********************************************
    closest: {
        dist: 1000,
        index: 0
    },
    isHolding: false,
    isCloak: false,
    throwCharge: 0,
    fireCDcycle: 0,
    fieldCDcycle: 0,
    fieldMode: 0, //basic field mode before upgrades
    maxEnergy: 1, //can be increased by a tech
    holdingTarget: null,
    timeSkipLastCycle: 0,
    coupling: 0,
    // these values are set on reset by setHoldDefaults()
    fieldFx: 1,
    fieldJump: 1,
    blockingRecoil: 4,
    grabPowerUpRange2: 0,
    isFieldActive: false,
    fieldRange: 155,
    fieldShieldingScale: 1,
    fieldDamage: 1,
    isSneakAttack: false,
    lastHit: 0, //stores value of last damage player took above a threshold, in m.damage
    sneakAttackCycle: 0,
    enterCloakCycle: 0,
    duplicateChance: 0,
    energy: 0,
    fieldRegen: 0.001,
    fieldMode: 0,
    fieldFire: false,
    fieldHarmReduction: 1,
    holdingMassScale: 0,
    hole: {
        isOn: false,
        isReady: false,
        pos1: { x: 0, y: 0 },
        pos2: { x: 0, y: 0 },
    },
    fieldArc: 0,
    fieldThreshold: 0,
    calculateFieldThreshold() {
        m.fieldThreshold = Math.cos((m.fieldArc) * Math.PI)
    },
    setHoldDefaults() {
        // if (tech.isFreeWormHole && m.fieldMode !== 9) { //not wormhole
        //     const removed = tech.removeTech("charmed baryon") //neutronum can get player stuck so it has to be removed if player has wrong field
        //     if (removed) powerUps.directSpawn(m.pos.x, m.pos.y, "tech");
        // }
        if (tech.isNeutronium && m.fieldMode !== 3) { //not negative mass field
            const removed = tech.removeTech("neutronium") //neutronum can get player stuck so it has to be removed if player has wrong field
            if (removed) powerUps.directSpawn(m.pos.x, m.pos.y, "tech");
        }
        if (m.energy < m.maxEnergy) m.energy = m.maxEnergy;
        m.fieldMeterColor = "#0cf"
        m.eyeFillColor = m.fieldMeterColor
        m.fieldShieldingScale = 1;
        m.fieldBlockCD = 10;
        m.fieldDamage = 1
        m.fieldHarmReduction = 1;
        m.isSneakAttack = false
        m.duplicateChance = 0
        m.grabPowerUpRange2 = 200000;
        m.blockingRecoil = 4;
        m.fieldRange = 155;
        m.fieldFire = false;
        m.fieldCDcycle = 0;
        m.isCloak = false;
        player.collisionFilter.mask = cat.body | cat.map | cat.mob | cat.mobBullet | cat.mobShield
        m.airSpeedLimit = 125
        m.fieldFx = 1
        m.fieldJump = 1
        m.setFieldRegen();
        m.setMovement();
        m.drop();
        m.holdingMassScale = 0.5;
        m.fieldArc = 0.2; //run calculateFieldThreshold after setting fieldArc, used for powerUp grab and mobPush with lookingAt(mob)
        m.calculateFieldThreshold(); //run calculateFieldThreshold after setting fieldArc, used for powerUp grab and mobPush with lookingAt(mob)
        m.isTimeDilated = true;
        m.wakeCheck();
        m.setMaxEnergy(false);
        m.setMaxHealth(false);
        m.couplingChange()
        m.hole = {
            isOn: false,
            isReady: false,
            pos1: { x: 0, y: 0 },
            pos2: { x: 0, y: 0 },
        }
    },
    setMaxEnergy(isMessage = true) {
        m.maxEnergy = (tech.isMaxEnergyTech ? 0.5 : 1) + tech.bonusEnergy + tech.healMaxEnergyBonus + tech.harmonicEnergy + 3 * tech.isGroundState + 1.5 * (m.fieldMode === 1) + (m.fieldMode === 0 || m.fieldMode === 1) * 0.05 * m.coupling + 0.77 * tech.isStandingWaveExpand
        if (level.isReducedEnergy) m.maxEnergy *= 0.5
        if (isMessage) simulation.inGameConsole(`<span class='color-var'>m</span>.<span class='color-f'>maxEnergy</span> <span class='color-symbol'>=</span> ${(m.maxEnergy.toFixed(2))}`)
    },
    fieldMeterColor: "#0cf",
    drawRegenEnergy(bgColor = "rgba(0, 0, 0, 0.4)", range = 60) {
        if (m.energy < m.maxEnergy) {
            m.regenEnergy();
            ctx.fillStyle = bgColor;
            const xOff = m.pos.x - m.radius * m.maxEnergy
            const yOff = m.pos.y - 50
            ctx.fillRect(xOff, yOff, range * m.maxEnergy, 10);
            ctx.fillStyle = m.fieldMeterColor;
            ctx.fillRect(xOff, yOff, range * m.energy, 10);
        } else if (m.energy > m.maxEnergy + 0.05) {
            ctx.fillStyle = bgColor;
            const xOff = m.pos.x - m.radius * m.energy
            const yOff = m.pos.y - 50
            // ctx.fillRect(xOff, yOff, range * m.maxEnergy, 10);
            ctx.fillStyle = m.fieldMeterColor;
            ctx.fillRect(xOff, yOff, range * m.energy, 10);
        }
    },
    drawRegenEnergyCloaking: function () {
        if (m.energy < m.maxEnergy) { // replaces m.drawRegenEnergy() with custom code
            m.regenEnergy();
            const xOff = m.pos.x - m.radius * m.maxEnergy
            const yOff = m.pos.y - 50
            ctx.fillStyle = "rgba(0, 0, 0, 0.2)" //
            ctx.fillRect(xOff, yOff, 60 * m.maxEnergy, 10);
            ctx.fillStyle = "#fff" //m.cycle > m.lastKillCycle + 300 ? "#000" : "#fff" //"#fff";
            ctx.fillRect(xOff, yOff, 60 * m.energy, 10);
            ctx.beginPath()
            ctx.rect(xOff, yOff, 60 * m.maxEnergy, 10);
            ctx.strokeStyle = m.fieldMeterColor;
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    },
    setFieldRegen() {
        if (m.fieldMode === 0) {
            m.fieldRegen = 0.00067  //4 energy per second for field emitter
        } else if (m.fieldMode === 6) {
            m.fieldRegen = 0.002  //12 energy per second for time dilation
        } else if (m.fieldMode === 2) {
            m.fieldRegen = 0.000833 //5 energy per second perfect dia
        } else if (m.fieldMode === 4) {
            m.fieldRegen = 0.002 //12 energy per second molecular assembler
        } else if (m.fieldMode === 5) {
            m.fieldRegen = 0.001667 //10 energy per second  plasma torch
        } else if (m.fieldMode === 8) {
            m.fieldRegen = 0.001667 //10 energy per second pilot wave
        } else if (m.fieldMode === 9) {
            m.fieldRegen = 0.001334 //8 energy per second wormhole
        } else if (m.fieldMode === 10) {
            m.fieldRegen = 0.0015 //9 energy per second grappling hook
        } else {
            m.fieldRegen = 0.001 //6 energy per second
        }
        if (m.fieldMode === 0 || m.fieldMode === 4) m.fieldRegen += 0.0001 * m.coupling
        if (tech.isTimeCrystals) {
            m.fieldRegen *= 2.5
        } else if (tech.isGroundState) {
            m.fieldRegen *= 0.66
        }
    },
    regenEnergy() { //used in drawRegenEnergy  // rewritten by some tech
        if (m.immuneCycle < m.cycle && m.fieldCDcycle < m.cycle) m.energy += m.fieldRegen * level.isReducedRegen;
        if (m.energy < 0) m.energy = 0
    },
    regenEnergyDefault() {
        if (m.immuneCycle < m.cycle && m.fieldCDcycle < m.cycle) m.energy += m.fieldRegen * level.isReducedRegen;
        if (m.energy < 0) m.energy = 0
    },
    lookingAt(who) {
        //calculate a vector from body to player and make it length 1
        const diff = Vector.normalise(Vector.sub(who.position, m.pos));
        //make a vector for the player's direction of length 1
        const dir = { x: Math.cos(m.angle), y: Math.sin(m.angle) };
        //the dot product of diff and dir will return how much over lap between the vectors
        if (Vector.dot(dir, diff) > m.fieldThreshold) {
            return true;
        }
        return false;
    },
    drop() {
        if (m.isHolding) {
            m.fieldCDcycle = m.cycle + 15;
            m.isHolding = false;
            m.throwCharge = 0;
            m.definePlayerMass()
        }
        if (m.holdingTarget) {
            m.holdingTarget.collisionFilter.category = cat.body;
            m.holdingTarget.collisionFilter.mask = cat.player | cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet
            m.holdingTarget = null;
        }
    },
    definePlayerMass(mass = m.defaultMass) {
        Matter.Body.setMass(player, mass);
        //reduce air and ground move forces
        m.setMovement()
        //make player stand a bit lower when holding heavy masses
        m.yOffWhen.stand = Math.max(m.yOffWhen.crouch, Math.min(49, 49 - (mass - 5) * 6))
        if (m.onGround && !m.crouch) m.yOffGoal = m.yOffWhen.stand;
    },
    drawHold(target, stroke = true) {
        if (target) {
            const eye = 15;
            const len = target.vertices.length - 1;
            ctx.fillStyle = "rgba(110,170,200," + (0.2 + 0.4 * Math.random()) + ")";
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#000";
            ctx.beginPath();
            ctx.moveTo(
                m.pos.x + eye * Math.cos(m.angle),
                m.pos.y + eye * Math.sin(m.angle)
            );
            ctx.lineTo(target.vertices[len].x, target.vertices[len].y);
            ctx.lineTo(target.vertices[0].x, target.vertices[0].y);
            ctx.fill();
            if (stroke) ctx.stroke();
            for (let i = 0; i < len; i++) {
                ctx.beginPath();
                ctx.moveTo(
                    m.pos.x + eye * Math.cos(m.angle),
                    m.pos.y + eye * Math.sin(m.angle)
                );
                ctx.lineTo(target.vertices[i].x, target.vertices[i].y);
                ctx.lineTo(target.vertices[i + 1].x, target.vertices[i + 1].y);
                ctx.fill();
                if (stroke) ctx.stroke();
            }
        }
    },
    holding() {
        if (m.fireCDcycle < m.cycle) m.fireCDcycle = m.cycle - 1
        if (m.holdingTarget) {
            m.energy -= m.fieldRegen;
            if (m.energy < 0) m.energy = 0;
            Matter.Body.setPosition(m.holdingTarget, {
                x: m.pos.x + 70 * Math.cos(m.angle),
                y: m.pos.y + 70 * Math.sin(m.angle)
            });
            Matter.Body.setVelocity(m.holdingTarget, player.velocity);
            Matter.Body.rotate(m.holdingTarget, 0.01 / m.holdingTarget.mass); //gently spin the block
        } else {
            m.isHolding = false
        }
    },
    throwBlock() { },
    throwBlockDefault() {
        if (m.holdingTarget) {
            if (input.field) {
                if (m.energy > 0.001) {
                    if (m.fireCDcycle < m.cycle) m.fireCDcycle = m.cycle
                    if (tech.isCapacitor && m.throwCharge < 4) m.throwCharge = 4
                    m.throwCharge += 0.5 / m.holdingTarget.mass / b.fireCDscale
                    if (m.throwCharge < 6) m.energy -= 0.001 / b.fireCDscale; // m.throwCharge caps at 5 

                    //trajectory path prediction
                    if (tech.isTokamak) {
                        //draw charge
                        const x = m.pos.x + 15 * Math.cos(m.angle);
                        const y = m.pos.y + 15 * Math.sin(m.angle);
                        const len = m.holdingTarget.vertices.length - 1;
                        const opacity = m.throwCharge > 4 ? 0.65 : m.throwCharge * 0.06
                        ctx.fillStyle = `rgba(255,0,255,${opacity})`;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(m.holdingTarget.vertices[len].x, m.holdingTarget.vertices[len].y);
                        ctx.lineTo(m.holdingTarget.vertices[0].x, m.holdingTarget.vertices[0].y);
                        ctx.fill();
                        for (let i = 0; i < len; i++) {
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(m.holdingTarget.vertices[i].x, m.holdingTarget.vertices[i].y);
                            ctx.lineTo(m.holdingTarget.vertices[i + 1].x, m.holdingTarget.vertices[i + 1].y);
                            ctx.fill();
                        }
                        if (tech.isTokamakFly && m.throwCharge > 4 && m.energy > 0.01) {
                            player.force.y -= 0.5 * player.mass * simulation.g; //add some reduced gravity
                            // const mass = (player.mass + 10) / 3 * simulation.g //this makes it so you fly slower with larger blocks
                            let isDrain = false
                            const thrust = player.mass * simulation.g * Math.pow(5 / player.mass, 0.1)
                            if (input.down) {
                                isDrain = true
                                player.force.y += 0.9 * thrust;
                            } else if (input.up) {
                                isDrain = true
                                player.force.y -= 0.9 * thrust
                            }
                            if (!m.onGround) {
                                if (input.left) {
                                    isDrain = true
                                    player.force.x -= 0.4 * thrust
                                } else if (input.right) {
                                    isDrain = true
                                    player.force.x += 0.4 * thrust
                                }
                                if (isDrain) m.energy -= 0.0017;
                            }

                        }
                    } else {
                        if (tech.isGroupThrow) {
                            const range = 810000

                            for (let i = 0; i < body.length; i++) {
                                const sub = Vector.sub(m.pos, body[i].position)
                                const dist2 = Vector.magnitudeSquared(sub)
                                if (dist2 < range) {
                                    body[i].force.y -= body[i].mass * (simulation.g * 1.01); //remove a bit more then standard gravity
                                    if (dist2 > 40000) {
                                        const f = Vector.mult(Vector.normalise(sub), 0.0008 * body[i].mass)
                                        body[i].force.x += f.x
                                        body[i].force.y += f.y
                                        Matter.Body.setVelocity(body[i], { x: 0.96 * body[i].velocity.x, y: 0.96 * body[i].velocity.y });
                                    }
                                }
                            }
                            ctx.beginPath();
                            ctx.arc(m.pos.x, m.pos.y, Math.sqrt(range), 0, 2 * Math.PI);
                            ctx.fillStyle = "rgba(245,245,255,0.15)";
                            ctx.fill();
                            // ctx.globalCompositeOperation = "difference";
                            // ctx.globalCompositeOperation = "source-over";
                        }
                        //draw charge
                        const x = m.pos.x + 15 * Math.cos(m.angle);
                        const y = m.pos.y + 15 * Math.sin(m.angle);
                        const len = m.holdingTarget.vertices.length - 1;
                        const edge = m.throwCharge * m.throwCharge * m.throwCharge;
                        const grd = ctx.createRadialGradient(x, y, edge, x, y, edge + 5);
                        grd.addColorStop(0, "rgba(255,50,150,0.3)");
                        grd.addColorStop(1, "transparent");
                        ctx.fillStyle = grd;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(m.holdingTarget.vertices[len].x, m.holdingTarget.vertices[len].y);
                        ctx.lineTo(m.holdingTarget.vertices[0].x, m.holdingTarget.vertices[0].y);
                        ctx.fill();
                        for (let i = 0; i < len; i++) {
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(m.holdingTarget.vertices[i].x, m.holdingTarget.vertices[i].y);
                            ctx.lineTo(m.holdingTarget.vertices[i + 1].x, m.holdingTarget.vertices[i + 1].y);
                            ctx.fill();
                        }
                        //trajectory prediction
                        const cycles = 30
                        const charge = Math.min(m.throwCharge / 5, 1)
                        const speed = (tech.isPrinter ? 15 + 80 * charge * Math.min(0.85, 0.8 / Math.pow(m.holdingTarget.mass, 0.1)) : 80 * charge * Math.min(0.85, 0.8 / Math.pow(m.holdingTarget.mass, 0.25)))
                        const v = { x: speed * Math.cos(m.angle), y: speed * Math.sin(m.angle) }
                        ctx.beginPath()
                        for (let i = 1, len = 10; i < len + 1; i++) {
                            const time = cycles * i / len
                            ctx.lineTo(m.pos.x + time * v.x, m.pos.y + time * v.y + 0.34 * time * time)
                        }
                        ctx.strokeStyle = "rgba(68, 68, 68, 0.15)" //color.map
                        ctx.lineWidth = 2
                        ctx.stroke()
                    }
                } else {
                    m.drop()
                }
            } else if (m.throwCharge > 0) { //Matter.Query.region(mob, player.bounds)
                if (m.holdingTarget.isPrinted) m.holdingTarget.isPrinted = undefined
                //throw the body
                m.fieldCDcycle = m.cycle + 20;
                m.fireCDcycle = m.cycle + 20;

                m.isHolding = false;

                if (tech.isTokamak && m.throwCharge > 4) { //remove the block body and pulse  in the direction you are facing
                    //m.throwCharge > 5 seems to be when the field full colors in a block you are holding
                    m.throwCycle = m.cycle + 180 //used to detect if a block was thrown in the last 3 seconds
                    if (m.immuneCycle < m.cycle) m.energy += 0.25 * Math.sqrt(m.holdingTarget.mass) * Math.min(5, m.throwCharge) * level.isReducedRegen
                    m.throwCharge = 0;
                    m.definePlayerMass() //return to normal player mass
                    //remove block before pulse, so it doesn't get in the way
                    for (let i = 0; i < body.length; i++) {
                        if (body[i] === m.holdingTarget) {
                            Matter.Composite.remove(engine.world, body[i]);
                            body.splice(i, 1);
                        }
                    }
                    b.pulse(60 * Math.pow(m.holdingTarget.mass, 0.25), m.angle)
                    if (tech.isTokamakHeal && tech.tokamakHealCount < 5) {
                        tech.tokamakHealCount++
                        let massScale = Math.min(65 * Math.sqrt(m.maxHealth), 14 * Math.pow(m.holdingTarget.mass, 0.4))
                        if (powerUps.healGiveMaxEnergy) massScale = powerUps["heal"].size()
                        powerUps.spawn(m.pos.x, m.pos.y, "heal", true, massScale * (simulation.healScale ** 0.25) * Math.sqrt(tech.largerHeals * (tech.isHalfHeals ? 0.5 : 1)))  //    spawn(x, y, target, moving = true, mode = null, size = powerUps[target].size()) {
                    }
                } else { //normal throw
                    //bullet-like collisions
                    m.holdingTarget.collisionFilter.category = cat.bullet
                    m.holdingTarget.collisionFilter.mask = cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet | cat.mobShield;
                    if (tech.isBlockRestitution) {
                        m.holdingTarget.restitution = 0.999 //extra bouncy
                        m.holdingTarget.friction = m.holdingTarget.frictionStatic = m.holdingTarget.frictionAir = 0.001
                    }
                    //check every second to see if player is away from thrown body, and make solid
                    const solid = function (that) {
                        const dx = that.position.x - player.position.x;
                        const dy = that.position.y - player.position.y;
                        // if (that.speed < 3 && dx * dx + dy * dy > 10000 && that !== m.holdingTarget) {
                        if (dx * dx + dy * dy > 10000 && that !== m.holdingTarget) {
                            that.collisionFilter.category = cat.body; //make solid
                            that.collisionFilter.mask = cat.player | cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet; //can hit player now
                        } else {
                            setTimeout(solid, 40, that);
                        }
                    };
                    setTimeout(solid, 200, m.holdingTarget);

                    const charge = Math.min(m.throwCharge / 5, 1)
                    //***** scale throw speed with the first number, 80 *****
                    // let speed = 80 * charge * Math.min(0.85, 0.8 / Math.pow(m.holdingTarget.mass, 0.25));
                    let speed = (tech.isPrinter ? 15 + 80 * charge * Math.min(0.85, 0.8 / Math.pow(m.holdingTarget.mass, 0.1)) : 80 * charge * Math.min(0.85, 0.8 / Math.pow(m.holdingTarget.mass, 0.25)))

                    if (Matter.Query.collides(m.holdingTarget, map).length !== 0) {
                        speed *= 0.7 //drop speed by 30% if touching map
                        if (Matter.Query.ray(map, m.holdingTarget.position, m.pos).length !== 0) speed = 0 //drop to zero if the center of the block can't see the center of the player through the map
                    }
                    m.throwCharge = 0;
                    m.throwCycle = m.cycle + 180 //used to detect if a block was thrown in the last 3 seconds
                    Matter.Body.setVelocity(m.holdingTarget, {
                        x: player.velocity.x * 0.5 + Math.cos(m.angle) * speed,
                        y: player.velocity.y * 0.5 + Math.sin(m.angle) * speed
                    });
                    Matter.Body.setVelocity(player, {
                        x: player.velocity.x - Math.cos(m.angle) * speed / (m.crouch ? 30 : 10) * Math.sqrt(m.holdingTarget.mass),
                        y: player.velocity.y - Math.sin(m.angle) * speed / 30 * Math.sqrt(m.holdingTarget.mass)
                    });
                    m.definePlayerMass() //return to normal player mass

                    if (tech.isStaticBlock) m.holdingTarget.isStatic = true
                    if (tech.isAddBlockMass) {
                        const expand = function (that, massLimit) {
                            if (that.mass < massLimit) {
                                const scale = 1.04;
                                Matter.Body.scale(that, scale, scale);
                                setTimeout(expand, 20, that, massLimit);
                            }
                        };
                        expand(m.holdingTarget, Math.min(20, m.holdingTarget.mass * 3))
                    }
                    if (tech.isGroupThrow) {
                        const range = 810000
                        for (let i = 0; i < body.length; i++) {
                            if (body[i] !== m.holdingTarget) {
                                const dist2 = Vector.magnitudeSquared(Vector.sub(m.pos, body[i].position))
                                if (dist2 < range) {
                                    const blockSpeed = 90 * charge * Math.min(0.85, 0.8 / Math.pow(body[i].mass, 0.25)) * Math.pow((range - dist2) / range, 0.2)
                                    Matter.Body.setVelocity(body[i], {
                                        x: body[i].velocity.x * 0.5 + Math.cos(m.angle) * blockSpeed,
                                        y: body[i].velocity.y * 0.5 + Math.sin(m.angle) * blockSpeed
                                    });
                                }
                            }
                        }
                    }
                }
            }
        } else {
            m.isHolding = false
        }
    },
    throwSelf() {
        if (m.holdingTarget) {
            if (input.field) {
                if (m.energy > 0.001) {
                    if (m.fireCDcycle < m.cycle) m.fireCDcycle = m.cycle
                    if (tech.isCapacitor && m.throwCharge < 4) m.throwCharge = 4
                    m.throwCharge += 0.5 / m.holdingTarget.mass / b.fireCDscale
                    if (m.throwCharge < 6) m.energy -= 0.001 / b.fireCDscale; // m.throwCharge caps at 5 

                    //trajectory path prediction
                    //draw charge
                    const x = m.pos.x + 15 * Math.cos(m.angle);
                    const y = m.pos.y + 15 * Math.sin(m.angle);
                    const len = m.holdingTarget.vertices.length - 1;
                    const edge = m.throwCharge * m.throwCharge * m.throwCharge;
                    const grd = ctx.createRadialGradient(x, y, edge, x, y, edge + 5);
                    grd.addColorStop(0, "rgba(255,50,150,0.3)");
                    grd.addColorStop(1, "transparent");
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(m.holdingTarget.vertices[len].x, m.holdingTarget.vertices[len].y);
                    ctx.lineTo(m.holdingTarget.vertices[0].x, m.holdingTarget.vertices[0].y);
                    ctx.fill();
                    for (let i = 0; i < len; i++) {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(m.holdingTarget.vertices[i].x, m.holdingTarget.vertices[i].y);
                        ctx.lineTo(m.holdingTarget.vertices[i + 1].x, m.holdingTarget.vertices[i + 1].y);
                        ctx.fill();
                    }
                    //trajectory prediction
                    const cycles = 30
                    const charge = Math.min(m.throwCharge / 5, 1)
                    const speed = (tech.isPrinter ? 15 + 80 * charge * Math.min(0.85, 0.8 / Math.pow(m.holdingTarget.mass, 0.1)) : 80 * charge * Math.min(0.85, 0.8 / Math.pow(m.holdingTarget.mass, 0.25)))
                    const v = { x: speed * Math.cos(m.angle), y: speed * Math.sin(m.angle) }
                    ctx.beginPath()
                    for (let i = 1, len = 10; i < len + 1; i++) {
                        const time = cycles * i / len
                        ctx.lineTo(m.pos.x + time * v.x, m.pos.y + time * v.y + 0.34 * time * time)
                    }
                    ctx.strokeStyle = "rgba(68, 68, 68, 0.15)" //color.map
                    ctx.lineWidth = 2
                    ctx.stroke()

                } else {
                    m.drop()
                }
            } else if (m.throwCharge > 0) { //Matter.Query.region(mob, player.bounds)
                if (m.holdingTarget.isPrinted) m.holdingTarget.isPrinted = undefined
                //throw the body
                m.fieldCDcycle = m.cycle + 20;
                m.fireCDcycle = m.cycle + 20;

                m.isHolding = false;
                //bullet-like collisions
                m.holdingTarget.collisionFilter.category = cat.bullet
                m.holdingTarget.collisionFilter.mask = cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet | cat.mobShield;
                if (tech.isBlockRestitution) {
                    m.holdingTarget.restitution = 0.999 //extra bouncy
                    m.holdingTarget.friction = m.holdingTarget.frictionStatic = m.holdingTarget.frictionAir = 0.001
                }
                //check every second to see if player is away from thrown body, and make solid
                const solid = function (that) {
                    const dx = that.position.x - player.position.x;
                    const dy = that.position.y - player.position.y;
                    // if (that.speed < 3 && dx * dx + dy * dy > 10000 && that !== m.holdingTarget) {
                    if (dx * dx + dy * dy > 10000 && that !== m.holdingTarget) {
                        that.collisionFilter.category = cat.body; //make solid
                        that.collisionFilter.mask = cat.player | cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet; //can hit player now
                    } else {
                        setTimeout(solid, 40, that);
                    }
                };
                setTimeout(solid, 200, m.holdingTarget);

                const charge = Math.min(m.throwCharge / 5, 1)
                //***** scale throw speed with the first number, 80 *****
                // let speed = 80 * charge * Math.min(0.85, 0.8 / Math.pow(m.holdingTarget.mass, 0.25));
                let speed = (tech.isPrinter ? 15 + 80 * charge * Math.min(0.85, 0.8 / Math.pow(m.holdingTarget.mass, 0.1)) : 80 * charge * Math.min(0.85, 0.8 / Math.pow(m.holdingTarget.mass, 0.25)))


                m.throwCharge = 0;
                m.throwCycle = m.cycle + 180 //used to detect if a block was thrown in the last 3 seconds
                Matter.Body.setVelocity(m.holdingTarget, {
                    x: Math.cos(m.angle) * speed / (m.crouch ? 30 : 10) * Math.sqrt(m.holdingTarget.mass),
                    y: player.velocity.y - Math.sin(m.angle) * speed / 30 * Math.sqrt(m.holdingTarget.mass)
                });
                Matter.Body.setVelocity(player, {
                    x: player.velocity.x - player.velocity.x * 0.5 + Math.cos(m.angle) * speed,
                    y: player.velocity.y - player.velocity.y * 0.5 + Math.sin(m.angle) * speed
                });
                m.definePlayerMass() //return to normal player mass

                if (tech.isAddBlockMass) {
                    const expand = function (that, massLimit) {
                        if (that.mass < massLimit) {
                            const scale = 1.04;
                            Matter.Body.scale(that, scale, scale);
                            setTimeout(expand, 20, that, massLimit);
                        }
                    };
                    expand(m.holdingTarget, Math.min(20, m.holdingTarget.mass * 3))
                }

            }
        } else {
            m.isHolding = false
        }
    },
    drawField() {
        if (m.holdingTarget) {
            ctx.fillStyle = "rgba(110,170,200," + (m.energy * (0.05 + 0.05 * Math.random())) + ")";
            ctx.strokeStyle = "rgba(110, 200, 235, " + (0.3 + 0.08 * Math.random()) + ")" //"#9bd" //"rgba(110, 200, 235, " + (0.5 + 0.1 * Math.random()) + ")"
        } else {
            ctx.fillStyle = "rgba(110,170,200," + (0.02 + m.energy * (0.15 + 0.15 * Math.random())) + ")";
            ctx.strokeStyle = "rgba(110, 200, 235, " + (0.6 + 0.2 * Math.random()) + ")" //"#9bd" //"rgba(110, 200, 235, " + (0.5 + 0.1 * Math.random()) + ")"
        }
        // const off = 2 * Math.cos(simulation.cycle * 0.1)
        const range = m.fieldRange;
        ctx.beginPath();
        ctx.arc(m.pos.x, m.pos.y, range, m.angle - Math.PI * m.fieldArc, m.angle + Math.PI * m.fieldArc, false);
        ctx.lineWidth = 2;
        ctx.stroke();
        let eye = 13;
        let aMag = 0.75 * Math.PI * m.fieldArc
        let a = m.angle + aMag
        let cp1x = m.pos.x + 0.6 * range * Math.cos(a)
        let cp1y = m.pos.y + 0.6 * range * Math.sin(a)
        ctx.quadraticCurveTo(cp1x, cp1y, m.pos.x + eye * Math.cos(m.angle), m.pos.y + eye * Math.sin(m.angle))
        a = m.angle - aMag
        cp1x = m.pos.x + 0.6 * range * Math.cos(a)
        cp1y = m.pos.y + 0.6 * range * Math.sin(a)
        ctx.quadraticCurveTo(cp1x, cp1y, m.pos.x + 1 * range * Math.cos(m.angle - Math.PI * m.fieldArc), m.pos.y + 1 * range * Math.sin(m.angle - Math.PI * m.fieldArc))
        ctx.fill();
        // ctx.lineTo(m.pos.x + eye * Math.cos(m.angle), m.pos.y + eye * Math.sin(m.angle));

        //draw random lines in field for cool effect
        let offAngle = m.angle + 1.7 * Math.PI * m.fieldArc * (Math.random() - 0.5);
        ctx.beginPath();
        eye = 15;
        ctx.moveTo(m.pos.x + eye * Math.cos(m.angle), m.pos.y + eye * Math.sin(m.angle));
        ctx.lineTo(m.pos.x + range * Math.cos(offAngle), m.pos.y + range * Math.sin(offAngle));
        ctx.strokeStyle = "rgba(120,170,255,0.6)";
        ctx.lineWidth = 1;
        ctx.stroke();
    },
    grabPowerUp() { //look for power ups to grab with field
        if (m.fireCDcycle < m.cycle) m.fireCDcycle = m.cycle - 1
        for (let i = 0, len = powerUp.length; i < len; ++i) {
            if (tech.isEnergyNoAmmo && powerUp[i].name === "ammo") continue
            const dxP = m.pos.x - powerUp[i].position.x;
            const dyP = m.pos.y - powerUp[i].position.y;
            const dist2 = dxP * dxP + dyP * dyP + 10;
            // float towards player  if looking at and in range  or  if very close to player
            if (
                dist2 < m.grabPowerUpRange2 &&
                (m.lookingAt(powerUp[i]) || dist2 < 10000) &&
                Matter.Query.ray(map, powerUp[i].position, m.pos).length === 0
            ) {
                if (!tech.isHealAttract || powerUp[i].name !== "heal") { //if you have accretion heals are already pulled in a different way
                    powerUp[i].force.x += 0.04 * (dxP / Math.sqrt(dist2)) * powerUp[i].mass;
                    powerUp[i].force.y += 0.04 * (dyP / Math.sqrt(dist2)) * powerUp[i].mass - powerUp[i].mass * simulation.g; //negate gravity
                    Matter.Body.setVelocity(powerUp[i], { x: powerUp[i].velocity.x * 0.11, y: powerUp[i].velocity.y * 0.11 }); //extra friction
                }
                if ( //use power up if it is close enough
                    dist2 < 5000 &&
                    !simulation.isChoosing &&
                    (powerUp[i].name !== "heal" || m.maxHealth - m.health > 0.01 || tech.isOverHeal)
                ) {
                    powerUps.onPickUp(powerUp[i]);
                    Matter.Body.setVelocity(player, { //player knock back, after grabbing power up
                        x: player.velocity.x + powerUp[i].velocity.x / player.mass * 4 * powerUp[i].mass,
                        y: player.velocity.y + powerUp[i].velocity.y / player.mass * 4 * powerUp[i].mass
                    });
                    powerUp[i].effect();
                    Matter.Composite.remove(engine.world, powerUp[i]);
                    powerUp.splice(i, 1);
                    return; //because the array order is messed up after splice
                }
            }
        }
    },
    minEnergyToDeflect: 0.05,
    bulletsToBlocks(who) {
        if (who.isMobBullet && !who.isInvulnerable && who.mass < 10 && body.length < mobs.maxMobBody) {
            // spawn block
            body[body.length] = Matter.Bodies.polygon(who.position.x, who.position.y, who.vertices.length, who.radius, {
                friction: 0.05,
                frictionAir: 0.001,
                collisionFilter: {
                    category: cat.bullet,
                    mask: cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet | cat.mobShield
                },
                classType: "body",
                isPrinted: true,
                radius: 10, //used to grow and warp the shape of the block
                density: 0.002, //double density for 2x damage
            });
            const block = body[body.length - 1]
            Composite.add(engine.world, block); //add to world
            //reverse velocity and make sure it's above 40
            const unit = Vector.mult(Vector.normalise(who.velocity), -Math.max(40, who.speed))
            Matter.Body.setVelocity(block, unit);

            simulation.ephemera.push({
                name: "remove block",
                count: 120, //cycles before it self removes
                do() {
                    this.count--
                    if (this.count < 0) {
                        simulation.removeEphemera(this.name)
                        Matter.Composite.remove(engine.world, block);
                        //find block
                        for (let i = 0; i < body.length; i++) {
                            if (body[i] === block) {
                                body.splice(i, 1);
                                break
                            }
                        }

                    }
                },
            })
            //remove mob bullet
            Matter.Composite.remove(engine.world, who); //remove from physics early to avoid collisions with block
            who.alive = false
        }
    },
    pushMass(who, fieldBlockCost = (0.025 + Math.sqrt(who.mass) * Vector.magnitude(Vector.sub(who.velocity, player.velocity)) * 0.002) * m.fieldShieldingScale) {
        if (m.energy > m.minEnergyToDeflect) { //shield needs at least some of the cost to block
            if (who.isShielded) fieldBlockCost *= 2; //shielded mobs take more energy to block
            m.energy -= fieldBlockCost
            if (m.energy < m.minEnergyToDeflect) {
                m.energy = 0;
                m.fieldCDcycle = m.cycle + Math.max(m.fieldBlockCD, 60);
                if (tech.isLaserField) {
                    simulation.ephemera.push({
                        name: "laser field", //used to find this array element in simulation.removeEphemera()
                        count: 20 + Math.floor(m.maxEnergy * 30 * 0.0018 / tech.laserDrain), //how many cycles the ephemera lasts, scales with max energy
                        do() {
                            this.count--
                            if (this.count < 0) simulation.removeEphemera(this.name)
                            for (let i = 0, num = 12; i < num; i++) { //draw random lasers
                                const angle = 6.28 * i / num + m.cycle * 0.04
                                b.laser({ x: m.pos.x + 30 * Math.cos(angle), y: m.pos.y + 30 * Math.sin(angle) }, { x: m.pos.x + 3000 * Math.cos(angle), y: m.pos.y + 3000 * Math.sin(angle) }, tech.laserDamage * 2.5)//dmg = tech.laserDamage, reflections = tech.laserReflections, isThickBeam = false, push = 1
                            }
                        },
                    })
                }
            } else {
                m.fieldCDcycle = m.cycle + m.fieldBlockCD;
            }
            if (!who.isInvulnerable && (m.coupling && m.fieldMode === 0) && bullet.length < 200) { //for field emitter iceIX
                for (let i = 0; i < m.coupling; i++) {
                    if (0.1 * m.coupling - i > 1.25 * Math.random()) {
                        const sub = Vector.mult(Vector.normalise(Vector.sub(who.position, m.pos)), (m.fieldRange * m.harmonicRadius) * (0.4 + 0.3 * Math.random())) //m.harmonicRadius should be 1 unless you are standing wave expansion
                        const rad = Vector.rotate(sub, 1 * (Math.random() - 0.5))
                        const angle = Math.atan2(sub.y, sub.x)
                        b.iceIX(6 + 6 * Math.random(), angle + 3 * (Math.random() - 0.5), Vector.add(m.pos, rad))
                    }
                }
            }
            m.bulletsToBlocks(who)
            const unit = Vector.normalise(Vector.sub(player.position, who.position))
            if (tech.blockDmg) {
                Matter.Body.setVelocity(who, { x: 0.5 * who.velocity.x, y: 0.5 * who.velocity.y });
                if (who.isShielded) {
                    for (let i = 0, len = mob.length; i < len; i++) {
                        if (mob[i].id === who.shieldID) mob[i].damage(tech.blockDmg * (tech.isBlockRadiation ? 6 : 2), true)
                    }
                } else if (tech.isBlockRadiation) {
                    if (who.isMobBullet) {
                        who.damage(tech.blockDmg * 3, true)
                    } else {
                        mobs.statusDoT(who, tech.blockDmg * 0.42, 180) //200% increase -> x (1+2) //over 7s -> 360/30 = 12 half seconds -> 3/12
                    }
                } else {
                    who.damage(tech.blockDmg, true)
                }
                const step = 40
                ctx.beginPath(); //draw electricity
                for (let i = 0, len = 0.5 * tech.blockDmg; i < len; i++) {
                    let x = m.pos.x - 20 * unit.x;
                    let y = m.pos.y - 20 * unit.y;
                    ctx.moveTo(x, y);
                    for (let i = 0; i < 8; i++) {
                        x += step * (-unit.x + 1.5 * (Math.random() - 0.5))
                        y += step * (-unit.y + 1.5 * (Math.random() - 0.5))
                        ctx.lineTo(x, y);
                    }
                }
                ctx.lineWidth = 3;
                ctx.strokeStyle = "#f0f";
                ctx.stroke();
            } else {
                m.drawHold(who);
            }
            if (tech.isStunField) mobs.statusStun(who, tech.isStunField)
            //knock backs
            const massRoot = Math.sqrt(Math.min(12, Math.max(0.15, who.mass))); // masses above 12 can start to overcome the push back
            Matter.Body.setVelocity(who, { x: player.velocity.x - (15 * unit.x) / massRoot, y: player.velocity.y - (15 * unit.y) / massRoot });
            if (who.isUnstable) {
                if (m.fieldCDcycle < m.cycle + 30) m.fieldCDcycle = m.cycle + 10
                who.death();
            }
            if (m.crouch) {
                Matter.Body.setVelocity(player, { x: player.velocity.x + 0.1 * m.blockingRecoil * unit.x * massRoot, y: player.velocity.y + 0.1 * m.blockingRecoil * unit.y * massRoot });
            } else {
                Matter.Body.setVelocity(player, { x: player.velocity.x + m.blockingRecoil * unit.x * massRoot, y: player.velocity.y + m.blockingRecoil * unit.y * massRoot });
            }
        }
    },
    pushMobsFacing() { // find mobs in range and in direction looking
        for (let i = 0, len = mob.length; i < len; ++i) {
            if (
                Vector.magnitude(Vector.sub(mob[i].position, m.pos)) - mob[i].radius < m.fieldRange &&
                m.lookingAt(mob[i]) &&
                !mob[i].isUnblockable &&
                Matter.Query.ray(map, mob[i].position, m.pos).length === 0
            ) {
                mob[i].locatePlayer();
                m.pushMass(mob[i]);

                if (tech.deflectEnergy && !mob[i].isInvulnerable && !mob[i].isShielded) {
                    m.energy += tech.deflectEnergy * level.isReducedRegen
                }
            }
        }
    },
    lookForBlock() { //find body to pickup
        const grabbing = {
            targetIndex: null,
            targetRange: 150,
            // lookingAt: false //false to pick up object in range, but not looking at
        };
        for (let i = 0, len = body.length; i < len; ++i) {
            if (Matter.Query.ray(map, body[i].position, m.pos).length === 0) {
                //is m next body a better target then my current best
                const dist = Vector.magnitude(Vector.sub(body[i].position, m.pos));
                const looking = m.lookingAt(body[i]);
                // if (dist < grabbing.targetRange && (looking || !grabbing.lookingAt) && !body[i].isNotHoldable) {
                if (dist < grabbing.targetRange + 30 && looking && !body[i].isNotHoldable) {
                    grabbing.targetRange = dist;
                    grabbing.targetIndex = i;
                    // grabbing.lookingAt = looking;
                }
            }
        }
        // set pick up target for when mouse is released
        if (body[grabbing.targetIndex]) {
            m.holdingTarget = body[grabbing.targetIndex];
            ctx.beginPath(); //draw on each valid body
            let vertices = m.holdingTarget.vertices;
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let j = 1; j < vertices.length; j += 1) {
                ctx.lineTo(vertices[j].x, vertices[j].y);
            }
            ctx.lineTo(vertices[0].x, vertices[0].y);
            ctx.fillStyle = "rgba(190,215,230," + (0.3 + 0.7 * Math.random()) + ")";
            ctx.fill();

            ctx.globalAlpha = 0.2;
            m.drawHold(m.holdingTarget);
            ctx.globalAlpha = 1;
        } else {
            m.holdingTarget = null;
        }
    },
    pickUp() {
        //triggers when a hold target exits and field button is released
        m.isHolding = true;
        //conserve momentum when player mass changes
        totalMomentum = Vector.add(Vector.mult(player.velocity, player.mass), Vector.mult(m.holdingTarget.velocity, m.holdingTarget.mass))
        Matter.Body.setVelocity(player, Vector.mult(totalMomentum, 1 / (m.defaultMass + m.holdingTarget.mass)));

        m.definePlayerMass(m.defaultMass + m.holdingTarget.mass * m.holdingMassScale)
        //make block collide with nothing
        m.holdingTarget.collisionFilter.category = 0;
        m.holdingTarget.collisionFilter.mask = 0;
    },
    wakeCheck() {
        if (m.isTimeDilated) {
            m.isTimeDilated = false;

            function wake(who) {
                for (let i = 0, len = who.length; i < len; ++i) {
                    Matter.Sleeping.set(who[i], false)
                    if (who[i].storeVelocity) {
                        Matter.Body.setVelocity(who[i], {
                            x: who[i].storeVelocity.x,
                            y: who[i].storeVelocity.y
                        })
                        Matter.Body.setAngularVelocity(who[i], who[i].storeAngularVelocity)
                    }
                }
            }
            // if (tech.isFreezeMobs) {
            //     for (let i = 0, len = mob.length; i < len; ++i) {
            //         const ICE_DRAIN = 0.0005
            //         if (m.energy > ICE_DRAIN) m.energy -= ICE_DRAIN;
            //         Matter.Sleeping.set(mob[i], false)
            //         mobs.statusSlow(mob[i], 60)
            //     }
            // } else {
            //     wake(mob);
            // }
            wake(mob);
            wake(body);
            wake(bullet);
            for (let i = 0, len = cons.length; i < len; i++) {
                if (cons[i].stiffness === 0) {
                    cons[i].stiffness = cons[i].storeStiffness
                }
            }
            // wake(powerUp);
        }
    },
    hold() { },
    couplingDescription(couple = m.coupling) {
        switch (m.fieldMode) {
            case 0: //field emitter
                return `<strong>all</strong> effects`
            case 1: //standing wave
                // return `<span style = 'font-size:95%;'><strong>deflecting</strong> condenses +${couple.toFixed(1)} <strong class='color-s'>ice IX</strong></span>`
                return `+${(couple * 5).toFixed(0)} maximum <strong class='color-f'>energy</strong>`
            case 2: //perfect diamagnetism
                return `<span style = 'font-size:95%;'><strong>deflecting</strong> condenses ${(0.1 * couple).toFixed(2)} <strong class='color-s'>ice IX</strong></span>`
            // return `<span style = 'font-size:89%;'><strong>invulnerable</strong> <strong>+${2*couple}</strong> seconds post collision</span>`
            case 3: //negative mass
                return `<strong>${(0.973 ** couple).toFixed(2)}x</strong> <strong class='color-defense'>damage taken</strong>`
            case 4: //assembler
                return `<strong>+${(0.6 * couple).toFixed(1)}</strong> <strong class='color-f'>energy</strong> per second`
            case 5: //plasma
                return `<strong>${(1 + 0.025 * couple).toFixed(3)}x</strong> <strong class='color-d'>damage</strong>`
            case 6: //time dilation
                return `<strong>+${(1 + 0.05 * couple).toFixed(2)}x</strong> longer <strong style='letter-spacing: 2px;'>stopped time</strong>` //<strong>movement</strong>, <strong>jumping</strong>, and 
            case 7: //cloaking
                // return `<strong>${(1 + 3.3 * couple).toFixed(3)}x</strong> ambush <strong class='color-d'>damage</strong>`
                return `<strong>${(1 + 0.05 * couple).toFixed(3)}x</strong> ambush <strong class='color-d'>damage</strong>`
            case 8: //pilot wave
                return `<strong>${(1 + 0.05 * couple).toFixed(2)}x</strong> <strong class='color-block'>block</strong> collision <strong class='color-d'>damage</strong>`
            case 9: //wormhole
                return `<span style = 'font-size:89%;'>after eating <strong class='color-block'>blocks</strong> <strong>+${(2 * couple).toFixed(0)}</strong> <strong class='color-f'>energy</strong></span>`
            case 10: //grappling hook
                return `<span style="opacity: 1;">${powerUps.orb.ammo(1)}</span> give ${(4 * couple).toFixed(0)}% more ammo`
        }
    },
    couplingChange(change = 0) {
        if (change > 0 && level.onLevel !== -1) simulation.inGameConsole(`<div class="coupling-circle"></div> m.coupling <span class='color-symbol'>+=</span> ${change}`, 60); //level.onLevel !== -1  means not on lore level
        m.coupling += change
        if (m.coupling < 0) {
            //look for coupling power ups on this level and remove them to prevent exploiting tech ejections
            for (let i = powerUp.length - 1; i > -1; i--) {
                if (powerUp[i].name === "coupling") {
                    Matter.Composite.remove(engine.world, powerUp[i]);
                    powerUp.splice(i, 1);
                    m.coupling += 1
                    if (!(m.coupling < 0)) break
                }
            }
            m.coupling = 0 //can't go negative
        }
        m.setMaxEnergy(false);
        // m.setMaxHealth();
        m.setFieldRegen()
        mobs.setMobSpawnHealth();
        powerUps.setPowerUpMode();

        // if ((m.fieldMode === 0 || m.fieldMode === 9) && !build.isExperimentSelection && !simulation.isTextLogOpen) simulation.circleFlare(0.4);
    },
    setField(index) {
        // console.log("field mode: ", index)
        window.removeEventListener("keydown", m.fieldEvent);
        if (m.fieldUpgrades[8].collider) {
            Matter.Composite.remove(engine.world, m.fieldUpgrades[8].collider);
            m.fieldUpgrades[8].collider = null
        }

        if (isNaN(index)) { //find index by name
            let found = false
            for (let i = 0; i < m.fieldUpgrades.length; i++) {
                if (index === m.fieldUpgrades[i].name) {
                    index = i;
                    found = true;
                    break;
                }
            }
            if (!found) return //if you can't find the field don't give a field to avoid game crash
        }
        m.fieldMode = index;
        document.getElementById("field").innerHTML = m.fieldUpgrades[index].name
        m.setHoldDefaults();
        m.fieldUpgrades[index].effect();
        simulation.inGameConsole(`<div class="circle-grid field"></div> &nbsp; <span class='color-var'>m</span>.setField("<strong class='color-text'>${m.fieldUpgrades[m.fieldMode].name}</strong>")<br>input.key.field<span class='color-symbol'>:</span> ["<span class='color-text'>MouseRight</span>"]`);
        if (m.fieldMode === 4) simulation.inGameConsole(`simulation<span class='color-symbol'>.</span>molecularMode <span class='color-symbol'>=</span> ${m.fieldUpgrades[4].modeText()} &nbsp; &nbsp; <em style="float: right;font-family: monospace;font-size: 1rem;color: #055;">↓↘→↓↙←↑↑↓</em>`);
        if (m.fieldMode === 8) simulation.inGameConsole(`Composite<span class='color-symbol'>.</span>add<span class='color-symbol'>(</span>engine.world<span class='color-symbol'>,</span> block<span class='color-symbol'>)</span> &nbsp; &nbsp; <em style ="float: right; font-family: monospace;font-size:1rem;color:#055;">//↓↓→↘↓↙←↓↓</em>`);
    },
    fieldEvent: null,
    fieldUpgrades: [
        {
            name: "field emitter",
            imageNumber: Math.floor(Math.random() * 26), //pick one of the 25 field emitter image files at random
            description: `<em>initial field</em><br>use <strong class='color-f'>energy</strong> to <strong>deflect</strong> mobs and <strong>throw</strong> <strong class='color-block'>blocks</strong>
        <br><strong>4</strong> <strong class='color-f'>energy</strong> per second`, //            <br><strong>100</strong> max <strong class='color-f'>energy</strong>
            effect: () => {
                m.hold = function () {
                    if (m.isHolding) {
                        m.drawHold(m.holdingTarget);
                        m.holding();
                        m.throwBlock();
                    } else if ((input.field && m.fieldCDcycle < m.cycle)) { //not hold but field button is pressed
                        if (m.energy > m.fieldRegen) m.energy -= m.fieldRegen
                        m.grabPowerUp();
                        m.lookForBlock();
                        if (m.energy > m.minEnergyToDeflect) {
                            m.drawField();
                            m.pushMobsFacing();
                        }
                    } else if (m.holdingTarget && m.fieldCDcycle < m.cycle) { //holding, but field button is released
                        m.pickUp();
                    } else {
                        m.holdingTarget = null; //clears holding target (this is so you only pick up right after the field button is released and a hold target exists)
                    }
                    m.drawRegenEnergy()
                }
            }
        },
        {
            name: "standing wave",
            //<strong>deflecting</strong> protects you in every <strong>direction</strong>
            description: `<strong>3</strong> oscillating <strong>shields</strong> are permanently active
            <br><strong>+150</strong> max <strong class='color-f'>energy</strong>
            <br><strong>6</strong> <strong class='color-f'>energy</strong> per second`,
            drainCD: 0,
            effect: () => {
                m.fieldBlockCD = 0;
                m.blockingRecoil = 1 //4 is normal
                m.fieldRange = 185
                m.fieldShieldingScale = 1.6 * Math.pow(0.5, (tech.harmonics - 2))
                // m.fieldHarmReduction = 0.66; //33% reduction

                m.harmonic3Phase = () => { //normal standard 3 different 2-d circles
                    const fieldRange1 = (0.75 + 0.3 * Math.sin(m.cycle / 23)) * m.fieldRange * m.harmonicRadius
                    const fieldRange2 = (0.68 + 0.37 * Math.sin(m.cycle / 37)) * m.fieldRange * m.harmonicRadius
                    const fieldRange3 = (0.7 + 0.35 * Math.sin(m.cycle / 47)) * m.fieldRange * m.harmonicRadius
                    const netFieldRange = Math.max(fieldRange1, fieldRange2, fieldRange3)
                    ctx.fillStyle = "rgba(110,170,200," + Math.min(0.6, (0.04 + 0.7 * m.energy * (0.1 + 0.11 * Math.random()))) + ")";
                    ctx.beginPath();
                    ctx.arc(m.pos.x, m.pos.y, fieldRange1, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(m.pos.x, m.pos.y, fieldRange2, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(m.pos.x, m.pos.y, fieldRange3, 0, 2 * Math.PI);
                    ctx.fill();
                    //360 block
                    for (let i = 0, len = mob.length; i < len; ++i) {
                        if (Vector.magnitude(Vector.sub(mob[i].position, m.pos)) - mob[i].radius < netFieldRange && !mob[i].isUnblockable) { // && Matter.Query.ray(map, mob[i].position, m.pos).length === 0
                            mob[i].locatePlayer();
                            if (this.drainCD > m.cycle) {
                                m.pushMass(mob[i], 0);
                            } else {
                                m.pushMass(mob[i]);
                                this.drainCD = m.cycle + 15
                            }
                        }
                    }
                }
                m.harmonicRadius = 1 //for smoothing function when player holds mouse (for harmonicAtomic)
                m.harmonicAtomic = () => { //several ellipses spinning about different axises
                    const rotation = simulation.cycle * 0.0031
                    const phase = simulation.cycle * 0.023
                    const radius = m.fieldRange * m.harmonicRadius
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = "rgba(110,170,200,0.8)"
                    ctx.fillStyle = "rgba(110,170,200," + Math.min(0.6, 0.7 * m.energy * (0.11 + 0.1 * Math.random()) * (3 / tech.harmonics)) + ")";
                    // ctx.fillStyle = "rgba(110,170,200," + Math.min(0.7, m.energy * (0.22 - 0.01 * tech.harmonics) * (0.5 + 0.5 * Math.random())) + ")";
                    for (let i = 0; i < tech.harmonics; i++) {
                        ctx.beginPath();
                        ctx.ellipse(m.pos.x, m.pos.y, radius * Math.abs(Math.sin(phase + i / tech.harmonics * Math.PI)), radius, rotation + i / tech.harmonics * Math.PI, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    }
                    //360 block
                    for (let i = 0, len = mob.length; i < len; ++i) {
                        if (Vector.magnitude(Vector.sub(mob[i].position, m.pos)) - mob[i].radius < radius && !mob[i].isUnblockable) { // && Matter.Query.ray(map, mob[i].position, m.pos).length === 0
                            mob[i].locatePlayer();
                            if (this.drainCD > m.cycle) {
                                m.pushMass(mob[i], 0);
                            } else {
                                m.pushMass(mob[i]);
                                this.drainCD = m.cycle + 15
                            }
                        }
                    }
                }
                if (tech.harmonics === 2) {
                    m.harmonicShield = m.harmonic3Phase
                } else {
                    m.harmonicShield = m.harmonicAtomic
                }
                m.hold = function () {
                    if (m.isHolding) {
                        m.drawHold(m.holdingTarget);
                        m.holding();
                        m.throwBlock();
                    } else if ((input.field) && m.fieldCDcycle < m.cycle) { //not hold but field button is pressed
                        if (m.energy > m.fieldRegen) m.energy -= m.fieldRegen
                        m.grabPowerUp();
                        m.lookForBlock();
                    } else if (m.holdingTarget && m.fieldCDcycle < m.cycle) { //holding, but field button is released
                        m.pickUp();
                    } else {
                        m.holdingTarget = null; //clears holding target (this is so you only pick up right after the field button is released and a hold target exists)
                    }
                    if (m.energy > m.minEnergyToDeflect && m.fieldCDcycle < m.cycle) {
                        if (tech.isStandingWaveExpand) {
                            if (input.field) {
                                // const oldHarmonicRadius = m.harmonicRadius
                                m.harmonicRadius = 0.99 * m.harmonicRadius + 0.01 * 4
                                // m.energy -= 0.1 * (m.harmonicRadius - oldHarmonicRadius)
                            } else {
                                m.harmonicRadius = 0.994 * m.harmonicRadius + 0.006
                            }
                        }
                        if (!simulation.isTimeSkipping) m.harmonicShield()
                    }
                    m.drawRegenEnergy()
                }
            }
        },
        {
            name: "perfect diamagnetism",
            description: `<strong>deflecting</strong> does not drain <strong class='color-f'>energy</strong><br><strong>shield</strong> maintains <strong>functionality</strong> while inactive<br><strong>5</strong> <strong class='color-f'>energy</strong> per second`,
            effect: () => {
                m.fieldMeterColor = "#48f" //"#0c5"
                m.eyeFillColor = m.fieldMeterColor
                m.fieldShieldingScale = 0;
                m.fieldBlockCD = 3;
                m.grabPowerUpRange2 = 10000000
                m.fieldPosition = { x: m.pos.x, y: m.pos.y }
                m.fieldAngle = m.angle
                m.perfectPush = (isFree = false) => {
                    if (m.fieldCDcycle < m.cycle) {
                        for (let i = 0, len = mob.length; i < len; ++i) {
                            if (
                                Vector.magnitude(Vector.sub(mob[i].position, m.fieldPosition)) - mob[i].radius < m.fieldRange &&
                                !mob[i].isUnblockable &&
                                Vector.dot({ x: Math.cos(m.fieldAngle), y: Math.sin(m.fieldAngle) }, Vector.normalise(Vector.sub(mob[i].position, m.fieldPosition))) > m.fieldThreshold &&
                                Matter.Query.ray(map, mob[i].position, m.fieldPosition).length === 0
                            ) {
                                mob[i].locatePlayer();
                                const unit = Vector.normalise(Vector.sub(m.fieldPosition, mob[i].position))
                                m.fieldCDcycle = m.cycle + m.fieldBlockCD + (mob[i].isShielded ? 10 : 0);
                                if (!mob[i].isInvulnerable && bullet.length < 250) {
                                    for (let i = 0; i < m.coupling; i++) {
                                        if (0.1 * m.coupling - i > Math.random()) {
                                            const angle = m.fieldAngle + 4 * m.fieldArc * (Math.random() - 0.5)
                                            const radius = m.fieldRange * (0.6 + 0.3 * Math.random())
                                            b.iceIX(6 + 6 * Math.random(), angle, Vector.add(m.fieldPosition, {
                                                x: radius * Math.cos(angle),
                                                y: radius * Math.sin(angle)
                                            }))
                                        }
                                    }
                                }
                                if (tech.blockDmg) { //electricity
                                    Matter.Body.setVelocity(mob[i], { x: 0.5 * mob[i].velocity.x, y: 0.5 * mob[i].velocity.y });
                                    if (mob[i].isShielded) {
                                        for (let j = 0, len = mob.length; j < len; j++) {
                                            if (mob[j].id === mob[i].shieldID) mob[j].damage(tech.blockDmg * (tech.isBlockRadiation ? 6 : 2), true)
                                        }
                                    } else if (tech.isBlockRadiation) {
                                        if (mob[i].isMobBullet) {
                                            mob[i].damage(tech.blockDmg * 3, true)
                                        } else {
                                            mobs.statusDoT(mob[i], tech.blockDmg * 0.42, 180) //200% increase -> x (1+2) //over 7s -> 360/30 = 12 half seconds -> 3/12
                                        }
                                    } else {
                                        mob[i].damage(tech.blockDmg, true)
                                    }
                                    const step = 40
                                    ctx.beginPath();
                                    for (let i = 0, len = 0.5 * tech.blockDmg; i < len; i++) {
                                        let x = m.fieldPosition.x - 20 * unit.x;
                                        let y = m.fieldPosition.y - 20 * unit.y;
                                        ctx.moveTo(x, y);
                                        for (let i = 0; i < 8; i++) {
                                            x += step * (-unit.x + 1.5 * (Math.random() - 0.5))
                                            y += step * (-unit.y + 1.5 * (Math.random() - 0.5))
                                            ctx.lineTo(x, y);
                                        }
                                    }
                                    ctx.lineWidth = 3;
                                    ctx.strokeStyle = "#f0f";
                                    ctx.stroke();
                                } else if (isFree) {
                                    ctx.lineWidth = 2; //when blocking draw this graphic
                                    ctx.fillStyle = `rgba(110,150,220, ${0.2 + 0.4 * Math.random()})`
                                    ctx.strokeStyle = "#000";
                                    const len = mob[i].vertices.length - 1;
                                    const mag = mob[i].radius
                                    ctx.beginPath();
                                    ctx.moveTo(mob[i].vertices[len].x + mag * (Math.random() - 0.5), mob[i].vertices[len].y + mag * (Math.random() - 0.5))
                                    for (let j = 0; j < len; j++) {
                                        ctx.lineTo(mob[i].vertices[j].x + mag * (Math.random() - 0.5), mob[i].vertices[j].y + mag * (Math.random() - 0.5));
                                    }
                                    ctx.lineTo(mob[i].vertices[len].x + mag * (Math.random() - 0.5), mob[i].vertices[len].y + mag * (Math.random() - 0.5))
                                    ctx.fill();
                                    ctx.stroke();
                                } else {

                                    const eye = 15; //when blocking draw this graphic
                                    const len = mob[i].vertices.length - 1;
                                    ctx.lineWidth = 1;
                                    ctx.fillStyle = `rgba(110,150,220, ${0.2 + 0.4 * Math.random()})`
                                    ctx.strokeStyle = "#000";
                                    ctx.beginPath();
                                    ctx.moveTo(m.fieldPosition.x + eye * Math.cos(m.fieldAngle), m.fieldPosition.y + eye * Math.sin(m.fieldAngle));
                                    ctx.lineTo(mob[i].vertices[len].x, mob[i].vertices[len].y);
                                    ctx.lineTo(mob[i].vertices[0].x, mob[i].vertices[0].y);
                                    ctx.fill();
                                    ctx.stroke();
                                    for (let j = 0; j < len; j++) {
                                        ctx.beginPath();
                                        ctx.moveTo(m.fieldPosition.x + eye * Math.cos(m.fieldAngle), m.fieldPosition.y + eye * Math.sin(m.fieldAngle));
                                        ctx.lineTo(mob[i].vertices[j].x, mob[i].vertices[j].y);
                                        ctx.lineTo(mob[i].vertices[j + 1].x, mob[i].vertices[j + 1].y);
                                        ctx.fill();
                                        ctx.stroke();
                                    }
                                }
                                m.bulletsToBlocks(mob[i])
                                if (tech.isStunField) mobs.statusStun(mob[i], tech.isStunField)
                                //mob knock backs
                                const massRoot = Math.sqrt(Math.max(1, mob[i].mass));
                                Matter.Body.setVelocity(mob[i], {
                                    x: player.velocity.x - (30 * unit.x) / massRoot,
                                    y: player.velocity.y - (30 * unit.y) / massRoot
                                });
                                if (mob[i].isUnstable) {
                                    if (m.fieldCDcycle < m.cycle + 10) m.fieldCDcycle = m.cycle + 6
                                    mob[i].death();
                                }
                                if (!isFree) { //player knock backs
                                    if (mob[i].isDropPowerUp && player.speed < 12) {
                                        const massRootCap = Math.sqrt(Math.min(10, Math.max(0.2, mob[i].mass)));
                                        Matter.Body.setVelocity(player, {
                                            x: 0.9 * player.velocity.x + 0.6 * unit.x * massRootCap,
                                            y: 0.9 * player.velocity.y + 0.6 * unit.y * massRootCap
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
                m.hold = function () {
                    const wave = Math.sin(m.cycle * 0.022);
                    m.fieldRange = 180 + 12 * wave + 100 * tech.isBigField
                    m.fieldArc = 0.35 + 0.045 * wave + 0.065 * tech.isBigField //run calculateFieldThreshold after setting fieldArc, used for powerUp grab and mobPush with lookingAt(mob)
                    m.calculateFieldThreshold();
                    if (m.isHolding) {
                        m.drawHold(m.holdingTarget);
                        m.holding();
                        m.throwBlock();
                    } else if (input.field) { //not hold but field button is pressed
                        //float while field is on
                        const angleReduction = 0.5 + 0.7 * (Math.PI / 2 - Math.min(Math.PI / 2, Math.abs(m.angle + Math.PI / 2)))
                        // console.log(angleReduction)
                        if (player.velocity.y > 1) {
                            player.force.y -= angleReduction * (tech.isBigField ? 0.95 : 0.5) * player.mass * simulation.g;

                            const pushX = 0.0007 * angleReduction * player.mass
                            if (player.velocity.x > 0.5) {
                                player.force.x += pushX
                            } else if (player.velocity.x < -0.5) {
                                player.force.x -= pushX
                            }

                            Matter.Body.setVelocity(player, {
                                x: player.velocity.x,
                                y: 0.98 * player.velocity.y
                            });

                            //set velocity to cap, but keep the direction
                            // capX = 28
                            // Matter.Body.setVelocity(player, {
                            //     x: Math.abs(player.velocity.x) < capX ? Math.max(-capX, Math.min(1.0155 * player.velocity.x, capX)) : player.velocity.x,
                            //     y: 0.98 * player.velocity.y
                            // }); 
                        }

                        // go invulnerable while field is active, but also drain energy
                        // if (true && m.energy > 2 * m.fieldRegen && m.immuneCycle < m.cycle + tech.cyclicImmunity) {
                        //     m.immuneCycle = m.cycle + 1; //player is immune to damage for 60 cycles
                        //     m.energy -= 2 * m.fieldRegen
                        //     if (m.energy < m.fieldRegen) m.fieldCDcycle = m.cycle + 90;
                        // }

                        if (m.energy > m.fieldRegen) m.energy -= m.fieldRegen
                        m.grabPowerUp();
                        m.lookForBlock();
                        m.fieldPosition = { x: m.pos.x, y: m.pos.y }
                        m.fieldAngle = m.angle
                        //draw field attached to player
                        if (m.holdingTarget) {
                            ctx.fillStyle = `rgba(110,150,220, ${0.06 + 0.03 * Math.random()})`
                            ctx.strokeStyle = `rgba(110,150,220, ${0.35 + 0.05 * Math.random()})`
                        } else {
                            ctx.fillStyle = `rgba(110,150,220, ${0.27 + 0.2 * Math.random() - 0.1 * wave})`
                            ctx.strokeStyle = `rgba(110,150,220, ${0.4 + 0.5 * Math.random()})`
                        }
                        ctx.beginPath();
                        ctx.arc(m.pos.x, m.pos.y, m.fieldRange, m.angle - Math.PI * m.fieldArc, m.angle + Math.PI * m.fieldArc, false);
                        ctx.lineWidth = 2.5 - 1.5 * wave;
                        ctx.stroke();
                        const curve = 0.57 + 0.04 * wave
                        const aMag = (1 - curve * 1.2) * Math.PI * m.fieldArc
                        let a = m.angle + aMag
                        let cp1x = m.pos.x + curve * m.fieldRange * Math.cos(a)
                        let cp1y = m.pos.y + curve * m.fieldRange * Math.sin(a)
                        ctx.quadraticCurveTo(cp1x, cp1y, m.pos.x + 30 * Math.cos(m.angle), m.pos.y + 30 * Math.sin(m.angle))
                        a = m.angle - aMag
                        cp1x = m.pos.x + curve * m.fieldRange * Math.cos(a)
                        cp1y = m.pos.y + curve * m.fieldRange * Math.sin(a)
                        ctx.quadraticCurveTo(cp1x, cp1y, m.pos.x + 1 * m.fieldRange * Math.cos(m.angle - Math.PI * m.fieldArc), m.pos.y + 1 * m.fieldRange * Math.sin(m.angle - Math.PI * m.fieldArc))
                        ctx.fill();
                        m.perfectPush();
                    } else if (m.holdingTarget && m.fieldCDcycle < m.cycle) { //holding, but field button is released
                        m.pickUp();
                    } else {
                        m.holdingTarget = null; //clears holding target (this is so you only pick up right after the field button is released and a hold target exists)
                        if (!input.field) { //&& tech.isFieldFree
                            //draw field free of player
                            ctx.fillStyle = `rgba(110,150,220, ${0.27 + 0.2 * Math.random() - 0.1 * wave})`
                            ctx.strokeStyle = `rgba(110,180,255, ${0.4 + 0.5 * Math.random()})`
                            ctx.beginPath();
                            ctx.arc(m.fieldPosition.x, m.fieldPosition.y, m.fieldRange, m.fieldAngle - Math.PI * m.fieldArc, m.fieldAngle + Math.PI * m.fieldArc, false);
                            ctx.lineWidth = 2.5 - 1.5 * wave;
                            ctx.stroke();
                            const curve = 0.8 + 0.06 * wave
                            const aMag = (1 - curve * 1.2) * Math.PI * m.fieldArc
                            let a = m.fieldAngle + aMag
                            ctx.quadraticCurveTo(m.fieldPosition.x + curve * m.fieldRange * Math.cos(a), m.fieldPosition.y + curve * m.fieldRange * Math.sin(a), m.fieldPosition.x + 1 * m.fieldRange * Math.cos(m.fieldAngle - Math.PI * m.fieldArc), m.fieldPosition.y + 1 * m.fieldRange * Math.sin(m.fieldAngle - Math.PI * m.fieldArc))
                            ctx.fill();
                            m.perfectPush(true);
                        }
                    }
                    // m.drawRegenEnergy()
                    m.drawRegenEnergy("rgba(0,0,0,0.2)")
                    if (tech.isPerfectBrake) { //cap mob speed around player
                        const range = 200 + 140 * wave + 150 * m.energy
                        for (let i = 0; i < mob.length; i++) {
                            const distance = Vector.magnitude(Vector.sub(m.pos, mob[i].position))
                            if (distance < range) {
                                const cap = mob[i].isShielded ? 8 : 4
                                if (mob[i].speed > cap && Vector.dot(mob[i].velocity, Vector.sub(m.pos, mob[i].position)) > 0) { // if velocity is directed towards player
                                    Matter.Body.setVelocity(mob[i], Vector.mult(Vector.normalise(mob[i].velocity), cap)); //set velocity to cap, but keep the direction
                                }
                            }
                        }
                        ctx.beginPath();
                        ctx.arc(m.pos.x, m.pos.y, range, 0, 2 * Math.PI);
                        ctx.fillStyle = "hsla(200,50%,61%,0.08)";
                        ctx.fill();
                    }
                }
            }
        },
        {
            name: "negative mass",
            //<br>hold <strong class='color-block'>blocks</strong> as if they have a lower <strong>mass</strong>
            description: `use <strong class='color-f'>energy</strong> to nullify &nbsp;<strong style='letter-spacing: 7px;'>gravity</strong><br><strong>0.5x</strong> <strong class='color-defense'>damage taken</strong><br><strong>6</strong> <strong class='color-f'>energy</strong> per second`,
            fieldDrawRadius: 0,
            effect: () => {
                m.fieldFire = true;
                m.holdingMassScale = 0.01; //can hold heavier blocks with lower cost to jumping
                m.fieldMeterColor = "#333"
                m.eyeFillColor = m.fieldMeterColor
                m.fieldHarmReduction = 0.5;
                m.fieldDrawRadius = 0;

                m.hold = function () {
                    m.airSpeedLimit = 125 //5 * player.mass * player.mass
                    m.FxAir = 0.016
                    if (m.isHolding) {
                        m.drawHold(m.holdingTarget);
                        m.holding();
                        m.throwBlock();
                    } else if (input.field) { //push away
                        if (m.energy > m.fieldRegen && tech.negativeMassCost > 0) m.energy -= m.fieldRegen
                        m.grabPowerUp();
                        m.lookForBlock();
                        if (m.energy >= tech.negativeMassCost && m.fieldCDcycle < m.cycle) {
                            if (tech.isFlyFaster) {
                                //look for nearby objects to make zero-g
                                function moveThis(who, range, mag = 1.06) {
                                    for (let i = 0, len = who.length; i < len; ++i) {
                                        sub = Vector.sub(who[i].position, m.pos);
                                        dist = Vector.magnitude(sub);
                                        if (dist < range) {
                                            who[i].force.y -= who[i].mass * (simulation.g * mag); //add a bit more then standard gravity
                                            if (input.left) { //blocks move horizontally with the same force as the player
                                                who[i].force.x -= m.FxAir * who[i].mass / 10; // move player   left / a
                                            } else if (input.right) {
                                                who[i].force.x += m.FxAir * who[i].mass / 10; //move player  right / d
                                            }
                                            //loose attraction to player
                                            // const sub = Vector.sub(m.pos, body[i].position)
                                            // const unit = Vector.mult(Vector.normalise(sub), who[i].mass * 0.0000002 * Vector.magnitude(sub))
                                            // body[i].force.x += unit.x
                                            // body[i].force.y += unit.y
                                        }
                                    }
                                }
                                //control horizontal acceleration
                                m.airSpeedLimit = 1000 // 7* player.mass * player.mass
                                m.FxAir = 0.01
                                //control vertical acceleration
                                if (input.down) { //down
                                    player.force.y += 0.5 * player.mass * simulation.g;
                                    this.fieldDrawRadius = this.fieldDrawRadius * 0.97 + 500 * 0.03;
                                    moveThis(powerUp, this.fieldDrawRadius, 0);
                                    moveThis(body, this.fieldDrawRadius, 0);
                                } else if (input.up) { //up
                                    m.energy -= 5 * tech.negativeMassCost;
                                    this.fieldDrawRadius = this.fieldDrawRadius * 0.97 + 1100 * 0.03;
                                    player.force.y -= 2.25 * player.mass * simulation.g;
                                    moveThis(powerUp, this.fieldDrawRadius, 1.8);
                                    moveThis(body, this.fieldDrawRadius, 1.8);
                                } else {
                                    m.energy -= tech.negativeMassCost;
                                    this.fieldDrawRadius = this.fieldDrawRadius * 0.97 + 800 * 0.03;
                                    player.force.y -= 1.07 * player.mass * simulation.g; // slow upward drift
                                    moveThis(powerUp, this.fieldDrawRadius);
                                    moveThis(body, this.fieldDrawRadius);
                                }
                            } else {
                                //look for nearby objects to make zero-g
                                function verticalForce(who, range, mag = 1.06) {
                                    for (let i = 0, len = who.length; i < len; ++i) {
                                        sub = Vector.sub(who[i].position, m.pos);
                                        dist = Vector.magnitude(sub);
                                        if (dist < range) {
                                            who[i].force.y -= who[i].mass * (simulation.g * mag); //add a bit more then standard gravity
                                            if (input.left) { //blocks move horizontally with the same force as the player
                                                who[i].force.x -= m.FxAir * who[i].mass / 10; // move player   left / a
                                            } else if (input.right) {
                                                who[i].force.x += m.FxAir * who[i].mass / 10; //move player  right / d
                                            }
                                        }



                                        // sub = Vector.sub(who[i].position, m.pos);
                                        // dist = Vector.magnitude(sub);
                                        // if (dist < range) who[i].force.y -= who[i].mass * (simulation.g * mag);
                                    }
                                }
                                //control horizontal acceleration
                                m.airSpeedLimit = 400 // 7* player.mass * player.mass
                                m.FxAir = 0.005
                                //control vertical acceleration
                                if (input.down) { //down
                                    player.force.y -= 0.5 * player.mass * simulation.g;
                                    this.fieldDrawRadius = this.fieldDrawRadius * 0.97 + 400 * 0.03;
                                    verticalForce(powerUp, this.fieldDrawRadius, 0.7);
                                    verticalForce(body, this.fieldDrawRadius, 0.7);
                                } else if (input.up) { //up
                                    m.energy -= 5 * tech.negativeMassCost;
                                    this.fieldDrawRadius = this.fieldDrawRadius * 0.97 + 850 * 0.03;
                                    player.force.y -= 1.45 * player.mass * simulation.g;
                                    verticalForce(powerUp, this.fieldDrawRadius, 1.38);
                                    verticalForce(body, this.fieldDrawRadius, 1.38);
                                } else {
                                    m.energy -= tech.negativeMassCost;
                                    this.fieldDrawRadius = this.fieldDrawRadius * 0.97 + 650 * 0.03;
                                    player.force.y -= 1.07 * player.mass * simulation.g; // slow upward drift
                                    verticalForce(powerUp, this.fieldDrawRadius);
                                    verticalForce(body, this.fieldDrawRadius);
                                }
                            }

                            if (m.energy < 0) {
                                m.fieldCDcycle = m.cycle + 120;
                                m.energy = 0;
                            }
                            //add extra friction for horizontal motion
                            if (input.down || input.up || input.left || input.right) {
                                Matter.Body.setVelocity(player, { x: player.velocity.x * 0.99, y: player.velocity.y * 0.98 });
                            } else { //slow rise and fall
                                Matter.Body.setVelocity(player, { x: player.velocity.x * 0.99, y: player.velocity.y * 0.98 });
                            }
                            // if (tech.isFreezeMobs) {
                            //     const ICE_DRAIN = 0.0005
                            //     for (let i = 0, len = mob.length; i < len; i++) {
                            //         if (!mob[i].isMobBullet && !mob[i].shield && !mob[i].isShielded && ((mob[i].distanceToPlayer() + mob[i].radius) < this.fieldDrawRadius)) {
                            //             if (m.energy > ICE_DRAIN * 2) {
                            //                 m.energy -= ICE_DRAIN;
                            //                 this.fieldDrawRadius -= 2;
                            //                 mobs.statusSlow(mob[i], 60)
                            //             } else {
                            //                 break;
                            //             }
                            //         }
                            //     }
                            // }
                            //draw zero-G range
                            if (!simulation.isTimeSkipping) {
                                ctx.beginPath();
                                ctx.arc(m.pos.x, m.pos.y, this.fieldDrawRadius, 0, 2 * Math.PI);
                                ctx.fillStyle = "#f5f5ff";
                                ctx.globalCompositeOperation = "difference";
                                ctx.fill();
                                ctx.globalCompositeOperation = "source-over";
                            }
                        }
                    } else if (m.holdingTarget && m.fieldCDcycle < m.cycle) { //holding, but field button is released
                        m.pickUp();
                        this.fieldDrawRadius = 0
                    } else {
                        m.holdingTarget = null; //clears holding target (this is so you only pick up right after the field button is released and a hold target exists)
                        this.fieldDrawRadius = 0
                    }
                    m.drawRegenEnergy("rgba(0,0,0,0.2)")


                    // if (tech.isHealAttract) {
                    //     for (let i = 0; i < powerUp.length; i++) {
                    //         if (powerUp[i].name === "heal") {
                    //             //&& Vector.magnitudeSquared(Vector.sub(powerUp[i].position, m.pos)) < 500000
                    //             let attract = Vector.mult(Vector.normalise(Vector.sub(m.pos, powerUp[i].position)), 0.01 * powerUp[i].mass)
                    //             powerUp[i].force.x += attract.x;
                    //             powerUp[i].force.y += attract.y - powerUp[i].mass * simulation.g; //negate gravity
                    //             Matter.Body.setVelocity(powerUp[i], Vector.mult(powerUp[i].velocity, 0.7));
                    //         }
                    //     }
                    // }


                    // powerUp[i].force.x += 0.05 * (dxP / Math.sqrt(dist2)) * powerUp[i].mass;
                    // powerUp[i].force.y += 0.05 * (dyP / Math.sqrt(dist2)) * powerUp[i].mass - powerUp[i].mass * simulation.g; //negate gravity
                    // //extra friction
                    // Matter.Body.setVelocity(powerUp[i], {
                    //     x: powerUp[i].velocity.x * 0.11,
                    //     y: powerUp[i].velocity.y * 0.11
                    // });

                }
            }
        },
        {
            name: "molecular assembler",
            modeText() {
                return `${simulation.molecularMode === 0 ? "<strong class='color-p' style='letter-spacing: 2px;'>spores" : simulation.molecularMode === 1 ? "<strong>missiles" : simulation.molecularMode === 2 ? "<strong class='color-s'>ice IX" : "<strong>drones"}</strong>`
            },
            description: `use <strong class='color-f'>energy</strong> to <strong>deflect</strong> mobs<br>excess <strong class='color-f'>energy</strong> used to <strong class='color-print'>print</strong> ${simulation.molecularMode === 0 ? "<strong class='color-p' style='letter-spacing: 2px;'>spores" : simulation.molecularMode === 1 ? "<strong>missiles" : simulation.molecularMode === 2 ? "<strong class='color-s'>ice IX" : "<strong>drones"}</strong><br><strong>12</strong> <strong class='color-f'>energy</strong> per second <em style ="float: right; font-family: monospace;font-size:1rem;color:#fff;">↓↘→↓↙←↑↑↓</em>`,
            setDescription() {
                return `use <strong class='color-f'>energy</strong> to <strong>deflect</strong> mobs<br>excess <strong class='color-f'>energy</strong> used to <strong class='color-print'>print</strong> ${simulation.molecularMode === 0 ? "<strong class='color-p' style='letter-spacing: 2px;'>spores" : simulation.molecularMode === 1 ? "<strong>missiles" : simulation.molecularMode === 2 ? "<strong class='color-s'>ice IX" : "<strong>drones"}</strong><br><strong>12</strong> <strong class='color-f'>energy</strong> per second <em style ="float: right; font-family: monospace;font-size:1rem;color:#fff;">↓↘→↓↙←↑↑↓</em>`
            },
            keyLog: [null, null, null, null, null, null, null],
            effect: () => {
                //store event function so it can be found and removed in m.setField()
                m.fieldEvent = function (event) {
                    m.fieldUpgrades[4].keyLog.shift() //remove first element
                    m.fieldUpgrades[4].keyLog.push(event.code) //add new key to end
                    const patternA = ["ArrowDown", "ArrowRight", "ArrowDown", "ArrowLeft", "ArrowUp", "ArrowUp", "ArrowDown"]
                    const patternB = [input.key.down, input.key.right, input.key.down, input.key.left, input.key.up, input.key.up, input.key.down]
                    const arraysEqual = (a, b) => a.length === b.length && a.every((val, i) => val === b[i]);
                    if (arraysEqual(m.fieldUpgrades[4].keyLog, patternA) || arraysEqual(m.fieldUpgrades[4].keyLog, patternB)) {
                        //cycle to next molecular mode
                        simulation.molecularMode = simulation.molecularMode < 3 ? simulation.molecularMode + 1 : 0
                        m.fieldUpgrades[4].description = m.fieldUpgrades[4].setDescription()
                        const name = `${simulation.molecularMode === 0 ? "<em class='color-p' style='letter-spacing: 2px;'>spores" : simulation.molecularMode === 1 ? "<em>missiles" : simulation.molecularMode === 2 ? "<em class='color-s'>ice IX" : "<em>drones"}</em>`
                        simulation.inGameConsole(`simulation<span class='color-symbol'>.</span>molecularMode <span class='color-symbol'>=</span> ${simulation.molecularMode} // ${name} &nbsp; <em style="float: right;font-family: monospace;font-size: 1rem;color: #055;">↓↘→↓↙←↑↑↓</em>`);
                    }
                    // console.log(event.code, m.fieldUpgrades[4].keyLog)
                }
                window.addEventListener("keydown", m.fieldEvent);

                m.fieldMeterColor = "#ff0"
                m.eyeFillColor = m.fieldMeterColor
                m.hold = function () {
                    if (m.energy > m.maxEnergy - 0.02 && m.fieldCDcycle < m.cycle && !input.field && bullet.length < 300 && (m.cycle % 2)) {
                        if (simulation.molecularMode === 0) {
                            if (tech.isSporeFlea) {
                                const drain = 0.18 + (Math.max(bullet.length, 130) - 130) * 0.02
                                if (m.energy > drain) {
                                    m.energy -= drain
                                    const speed = m.crouch ? 20 + 8 * Math.random() : 10 + 3 * Math.random()
                                    b.flea({
                                        x: m.pos.x + 35 * Math.cos(m.angle),
                                        y: m.pos.y + 35 * Math.sin(m.angle)
                                    }, {
                                        x: speed * Math.cos(m.angle),
                                        y: speed * Math.sin(m.angle)
                                    })
                                }
                            } else if (tech.isSporeWorm) {
                                const drain = 0.18 + (Math.max(bullet.length, 130) - 130) * 0.02
                                if (m.energy > drain) {
                                    m.energy -= drain
                                    b.worm({
                                        x: m.pos.x + 35 * Math.cos(m.angle),
                                        y: m.pos.y + 35 * Math.sin(m.angle)
                                    })
                                    const SPEED = 2 + 1 * Math.random();
                                    Matter.Body.setVelocity(bullet[bullet.length - 1], {
                                        x: SPEED * Math.cos(m.angle),
                                        y: SPEED * Math.sin(m.angle)
                                    });
                                }
                            } else {
                                const drain = 0.095 + (Math.max(bullet.length, 130) - 130) * 0.01
                                for (let i = 0, len = 5; i < len; i++) {
                                    if (m.energy > 3 * drain) {
                                        m.energy -= drain
                                        const unit = Vector.rotate({ x: 1, y: 0 }, 6.28 * Math.random())
                                        b.spore(Vector.add(m.pos, Vector.mult(unit, 25)), Vector.mult(unit, 10))
                                    } else {
                                        break
                                    }
                                }
                            }
                        } else if (simulation.molecularMode === 1) {
                            m.energy -= 0.33;
                            const direction = { x: Math.cos(m.angle), y: Math.sin(m.angle) }
                            const push = Vector.mult(Vector.perp(direction), 0.08)
                            b.missile({ x: m.pos.x + 30 * direction.x, y: m.pos.y + 30 * direction.y }, m.angle, -15)
                            bullet[bullet.length - 1].force.x += push.x * (Math.random() - 0.5)
                            bullet[bullet.length - 1].force.y += 0.005 + push.y * (Math.random() - 0.5)
                            // b.missile({ x: m.pos.x, y: m.pos.y - 40 }, -Math.PI / 2 + 0.5 * (Math.random() - 0.5), 0, 1)
                        } else if (simulation.molecularMode === 2) {
                            m.energy -= 0.044;
                            b.iceIX(1)
                        } else if (simulation.molecularMode === 3) {
                            if (tech.isDroneRadioactive) {
                                const drain = 0.8 + (Math.max(bullet.length, 50) - 50) * 0.01
                                if (m.energy > drain) {
                                    m.energy -= drain
                                    b.droneRadioactive({
                                        x: m.pos.x + 30 * Math.cos(m.angle) + 10 * (Math.random() - 0.5),
                                        y: m.pos.y + 30 * Math.sin(m.angle) + 10 * (Math.random() - 0.5)
                                    }, 25)
                                }
                            } else {
                                //every bullet above 100 adds 0.005 to the energy cost per drone
                                //at 200 bullets the energy cost is 0.45 + 100*0.006 = 1.05
                                const drain = (0.45 + (Math.max(bullet.length, 100) - 100) * 0.006) * tech.droneEnergyReduction
                                if (m.energy > drain) {
                                    m.energy -= drain
                                    b.drone()
                                }
                            }
                        }
                    }
                    if (m.isHolding) {
                        m.drawHold(m.holdingTarget);
                        m.holding();
                        if (tech.isPrinter && m.holdingTarget.isPrinted && input.field) {
                            // if (Math.random() < 0.004 && m.holdingTarget.vertices.length < 12) m.holdingTarget.vertices.push({ x: 0, y: 0 }) //small chance to increase the number of vertices
                            m.holdingTarget.radius += Math.min(1.1, 1.3 / m.holdingTarget.mass) //grow up to a limit
                            const r1 = m.holdingTarget.radius * (1 + 0.12 * Math.sin(m.cycle * 0.11))
                            const r2 = m.holdingTarget.radius * (1 + 0.12 * Math.cos(m.cycle * 0.11))
                            let angle = (m.cycle * 0.01) % (2 * Math.PI) //rotate the object 
                            let vertices = []
                            for (let i = 0, len = m.holdingTarget.vertices.length; i < len; i++) {
                                angle += 2 * Math.PI / len
                                vertices.push({ x: m.holdingTarget.position.x + r1 * Math.cos(angle), y: m.holdingTarget.position.y + r2 * Math.sin(angle) })
                            }
                            Matter.Body.setVertices(m.holdingTarget, vertices)
                            m.definePlayerMass(m.defaultMass + m.holdingTarget.mass * m.holdingMassScale)
                        }
                        m.throwBlock();
                    } else if ((input.field && m.fieldCDcycle < m.cycle)) { //not hold but field button is pressed
                        if (m.energy > m.fieldRegen) m.energy -= m.fieldRegen
                        m.grabPowerUp();
                        m.lookForBlock();
                        if (tech.isPrinter && input.down) {
                            m.printBlock();
                        } else if (m.energy > m.minEnergyToDeflect) {
                            m.drawField();
                            m.pushMobsFacing();
                        }
                    } else if (m.holdingTarget && m.fieldCDcycle < m.cycle) { //holding, but field button is released
                        m.pickUp();
                    } else {
                        m.holdingTarget = null; //clears holding target (this is so you only pick up right after the field button is released and a hold target exists)
                    }
                    m.drawRegenEnergy()
                }
            }
        },
        {
            name: "plasma torch",
            description: "use <strong class='color-f'>energy</strong> to emit short range <strong class='color-plasma'>plasma</strong><br><strong>1.5x</strong> <strong class='color-d'>damage</strong><br><strong>10</strong> <strong class='color-f'>energy</strong> per second",
            set() {
                b.isExtruderOn = false
                m.fieldDamage = 1.5
                if (m.plasmaBall) {
                    m.plasmaBall.reset()
                    Matter.Composite.remove(engine.world, m.plasmaBall);
                }
                if (tech.isPlasmaBall) {
                    m.plasmaBall = Bodies.circle(m.pos.x + 10 * Math.cos(m.angle), m.pos.y + 10 * Math.sin(m.angle), 1, {
                        isSensor: true,
                        frictionAir: 0,
                        alpha: 0.7,
                        isAttached: false,
                        isOn: false,
                        drain: 0.0018,
                        radiusLimit: 10,
                        damage: 0.7,
                        effectRadius: 10,
                        setPositionToNose() {
                            const r = 27
                            const nose = { x: m.pos.x + r * Math.cos(m.angle), y: m.pos.y + r * Math.sin(m.angle) }
                            m.plasmaBall.effectRadius = 2 * m.plasmaBall.circleRadius
                            Matter.Body.setPosition(this, Vector.add(nose, Vector.mult(Vector.normalise(Vector.sub(nose, m.pos)), this.effectRadius)));
                        },
                        fire() {
                            const drain = 0.06
                            if (m.energy > drain) m.energy -= drain
                            this.isAttached = false;
                            const speed = 5 + Math.min(15, 80 / this.mass) //scale speed with mass
                            Matter.Body.setVelocity(this, {
                                x: player.velocity.x * 0.4 + speed * Math.cos(m.angle),
                                y: speed * Math.sin(m.angle)
                            });
                            m.plasmaBall.setPositionToNose()
                        },
                        scale(scale) {
                            if (this.circleRadius > this.radiusLimit) Matter.Body.scale(m.plasmaBall, scale, scale); //shrink fast
                        },
                        reset() {
                            const scale = 1 / this.circleRadius
                            Matter.Body.scale(this, scale, scale); //grow
                            this.alpha = 0.7
                            this.isOn = false
                            // this.isAttached = true;
                        },
                        do() {
                            if (this.isOn) {
                                this.effectRadius = 2 * m.plasmaBall.circleRadius * (0.6 + 0.4 * tech.isPlasmaRange)

                                if (Matter.Query.collides(this, map).length > 0) {
                                    if (this.isAttached) {
                                        this.scale(Math.max(0.9, 0.99 - 0.1 / this.circleRadius))
                                    } else {
                                        m.plasmaBall.explode()
                                        Matter.Body.setVelocity(this, { x: 0, y: 0 });
                                        this.reset()
                                    }
                                }

                                //damage nearby mobs
                                const dmg = this.damage * ((tech.isControlPlasma && !this.isAttached) ? 2 : 1)
                                const arcList = []
                                const dischargeRange = 150 + 1600 * tech.plasmaDischarge + 1.3 * this.effectRadius
                                for (let i = 0, len = mob.length; i < len; i++) {
                                    if (mob[i].alive && (!mob[i].isBadTarget || mob[i].isMobBullet) && !mob[i].isInvulnerable) {
                                        const sub = Vector.magnitude(Vector.sub(this.position, mob[i].position))
                                        if (sub < this.effectRadius + mob[i].radius) {
                                            mob[i].damage(dmg);
                                            if (mob[i].speed > 5) {
                                                Matter.Body.setVelocity(mob[i], { x: mob[i].velocity.x * 0.6, y: mob[i].velocity.y * 0.6 });
                                            } else {
                                                Matter.Body.setVelocity(mob[i], { x: mob[i].velocity.x * 0.93, y: mob[i].velocity.y * 0.93 });
                                            }
                                        } else if (sub < dischargeRange + mob[i].radius && Matter.Query.ray(map, mob[i].position, this.position).length === 0) {
                                            arcList.push(mob[i]) //populate electrical arc list
                                        }
                                    }
                                }
                                for (let i = 0; i < arcList.length; i++) {
                                    if (tech.plasmaDischarge > Math.random()) {
                                        const who = arcList[Math.floor(Math.random() * arcList.length)]
                                        who.damage(dmg * 4);
                                        //draw arcs
                                        const sub = Vector.sub(who.position, this.position)
                                        const unit = Vector.normalise(sub)
                                        let len = 12
                                        const step = Vector.magnitude(sub) / (len + 2)
                                        let x = this.position.x
                                        let y = this.position.y
                                        ctx.beginPath();
                                        ctx.moveTo(x, y);
                                        for (let i = 0; i < len; i++) {
                                            x += step * (unit.x + (Math.random() - 0.5))
                                            y += step * (unit.y + (Math.random() - 0.5))
                                            ctx.lineTo(x, y);
                                        }
                                        ctx.lineTo(who.position.x, who.position.y);
                                        ctx.strokeStyle = "#88f";
                                        ctx.lineWidth = 6 + 3 * Math.random();
                                        ctx.stroke();
                                        if (who.damageReduction) {
                                            simulation.drawList.push({
                                                x: who.position.x,
                                                y: who.position.y,
                                                radius: 15,
                                                color: "rgba(150,150,255,0.4)",
                                                time: 15
                                            });
                                        }
                                    }
                                }

                                //graphics
                                const radius = this.effectRadius * (0.99 + 0.02 * Math.random()) + 3 * Math.random()
                                const gradient = ctx.createRadialGradient(this.position.x, this.position.y, 0, this.position.x, this.position.y, radius);
                                const alpha = this.alpha + 0.15 * Math.random()
                                const stop = 0.75 + 0.1 * Math.random()
                                gradient.addColorStop(0, `rgba(255,255,255,${alpha})`);
                                gradient.addColorStop(stop, `rgba(255,245,255,${alpha})`);
                                gradient.addColorStop(stop + 0.1, `rgba(255,200,255,${alpha})`);
                                gradient.addColorStop(1, `rgba(255,75,255,${alpha})`);
                                // gradient.addColorStop(1, `rgba(255,150,255,${alpha})`);
                                ctx.fillStyle = gradient
                                ctx.beginPath();
                                ctx.arc(this.position.x, this.position.y, radius, 0, 2 * Math.PI);
                                ctx.fill();
                                if (tech.isControlPlasma) {
                                    if (!this.isAttached) {
                                        //extra stroke to show 2x damage
                                        ctx.strokeStyle = "rgb(255, 0, 212)";
                                        ctx.lineWidth = Math.max(2, 0.04 * this.effectRadius);
                                        ctx.stroke();
                                    }
                                    //mouse control
                                    const mouseUnit = Vector.normalise(Vector.sub(simulation.mouseInGame, this.position))
                                    const speed = Vector.magnitude(this.velocity) //save current speed
                                    const push = Vector.mult(mouseUnit, 0.008 * Math.pow(speed, 1.8)) //roughly optimized to produce similar turing radius for different sizes
                                    Matter.Body.setVelocity(this, Vector.add(push, this.velocity));
                                    Matter.Body.setVelocity(this, Vector.mult(Vector.normalise(this.velocity), speed)); //keep speed constant
                                }

                                //draw arc from radius inward in a random walk
                                ctx.beginPath();
                                const unit = Vector.rotate({ x: 1, y: 0 }, Math.random() * 6.28)
                                let where = Vector.add(this.position, Vector.mult(unit, 0.98 * radius))
                                ctx.moveTo(where.x, where.y)
                                const sub = Vector.normalise(Vector.sub(this.position, where))
                                for (let i = 0, len = 7; i < len; i++) {
                                    const step = Vector.rotate(Vector.mult(sub, 17 * Math.random()), 2 * (Math.random() - 0.5))
                                    where = Vector.add(where, step)
                                    ctx.lineTo(where.x, where.y)
                                }
                                ctx.strokeStyle = "#88f";
                                ctx.lineWidth = 0.5 + 2 * Math.random();
                                ctx.stroke();
                            }
                        },
                        explode() {
                            simulation.ephemera.push({
                                name: "plasma ball",
                                vertices: this.vertices,
                                position: {
                                    x: m.plasmaBall.position.x,
                                    y: m.plasmaBall.position.y
                                },
                                radius: m.plasmaBall.effectRadius,
                                alpha: 1,
                                do() {
                                    // console.log(this.radius)
                                    //grow and fade
                                    this.radius *= 1.05
                                    this.alpha -= 0.05
                                    if (this.alpha < 0) simulation.removeEphemera(this.name)
                                    //graphics
                                    const radius = this.radius * (0.99 + 0.02 * Math.random()) + 3 * Math.random()
                                    const gradient = ctx.createRadialGradient(this.position.x, this.position.y, 0, this.position.x, this.position.y, radius);
                                    const alpha = this.alpha + 0.15 * Math.random()
                                    const stop = 0.75 + 0.1 * Math.random()
                                    gradient.addColorStop(0, `rgba(255,255,255,${alpha})`);
                                    gradient.addColorStop(stop, `rgba(255,245,255,${alpha})`);
                                    gradient.addColorStop(stop + 0.1, `rgba(255,200,255,${alpha})`);
                                    gradient.addColorStop(1, `rgba(255,75,255,${alpha})`);
                                    // gradient.addColorStop(1, `rgba(255,150,255,${alpha})`);
                                    ctx.fillStyle = gradient
                                    ctx.beginPath();
                                    ctx.arc(this.position.x, this.position.y, radius, 0, 2 * Math.PI);
                                    ctx.fill();

                                    //damage nearby mobs
                                    const dmg = m.plasmaBall.damage
                                    for (let i = 0, len = mob.length; i < len; i++) {
                                        if (mob[i].alive && (!mob[i].isBadTarget || mob[i].isMobBullet) && !mob[i].isInvulnerable) {
                                            const sub = Vector.magnitude(Vector.sub(this.position, mob[i].position))
                                            if (sub < this.radius + mob[i].radius) {
                                                mob[i].damage(dmg);
                                            }
                                        }
                                    }

                                },
                            })
                        }
                    });

                    Composite.add(engine.world, m.plasmaBall);
                    m.hold = function () {
                        if (m.isHolding) {
                            m.drawHold(m.holdingTarget);
                            m.holding();
                            m.throwBlock();
                        } else if (input.field) { //not hold but field button is pressed
                            if (tech.isPlasmaBoost && powerUps.boost.endCycle < simulation.cycle + 60) powerUps.boost.endCycle = simulation.cycle + 60

                            if (m.energy > m.fieldRegen) m.energy -= m.fieldRegen
                            m.grabPowerUp();
                            m.lookForBlock();
                            if (m.fieldCDcycle < m.cycle) {
                                //field is active
                                if (!m.plasmaBall.isAttached) { //return ball to player
                                    if (m.plasmaBall.isOn) {
                                        m.plasmaBall.explode()
                                        m.plasmaBall.reset()
                                    } else {
                                        m.plasmaBall.isAttached = true
                                        m.plasmaBall.isOn = true
                                        m.plasmaBall.alpha = 0.7
                                        m.plasmaBall.setPositionToNose()

                                    }
                                } else if (m.energy > m.plasmaBall.drain) { //charge up when attached
                                    if (tech.isCapacitor) {
                                        m.energy -= m.plasmaBall.drain * 2;
                                        const scale = 1 + 48 * Math.pow(Math.max(1, m.plasmaBall.circleRadius), -1.8)
                                        Matter.Body.scale(m.plasmaBall, scale, scale); //grow
                                    } else {
                                        m.energy -= m.plasmaBall.drain;
                                        const scale = 1 + 16 * Math.pow(Math.max(1, m.plasmaBall.circleRadius), -1.8)
                                        Matter.Body.scale(m.plasmaBall, scale, scale); //grow    
                                    }
                                    if (m.energy > m.maxEnergy) {
                                        m.energy -= m.plasmaBall.drain * 2;
                                        const scale = 1 + 16 * Math.pow(Math.max(1, m.plasmaBall.circleRadius), -1.8)
                                        Matter.Body.scale(m.plasmaBall, scale, scale); //grow    
                                    }
                                    m.plasmaBall.setPositionToNose()

                                    //float
                                    const slowY = (player.velocity.y > 0) ? Math.max(0.5, 1 - 0.006 * player.velocity.y * player.velocity.y) : Math.max(0.997, 1 - 0.001 * Math.abs(player.velocity.y)) //down : up
                                    Matter.Body.setVelocity(player, {
                                        x: Math.max(0.95, 1 - 0.002 * Math.abs(player.velocity.x)) * player.velocity.x,
                                        y: slowY * player.velocity.y
                                    });
                                    if (player.velocity.y > 5) {
                                        player.force.y -= 0.9 * player.mass * simulation.g //less gravity when falling fast
                                    } else {
                                        player.force.y -= 0.5 * player.mass * simulation.g;
                                    }
                                } else {
                                    // m.fieldCDcycle = m.cycle + 60;
                                    m.plasmaBall.fire()
                                }
                            }
                        } else if (m.holdingTarget && m.fieldCDcycle < m.cycle) { //holding, but field button is released
                            m.pickUp();
                            if (m.plasmaBall.isAttached) {
                                // m.fieldCDcycle = m.cycle;
                                m.plasmaBall.fire()
                            }
                        } else {
                            m.holdingTarget = null; //clears holding target (this is so you only pick up right after the field button is released and a hold target exists)
                            if (m.plasmaBall.isAttached) {
                                // m.fieldCDcycle = m.cycle;
                                m.plasmaBall.fire()
                            }
                        }
                        m.drawRegenEnergy("rgba(0, 0, 0, 0.2)")
                        m.plasmaBall.do()
                    }
                } else if (tech.isExtruder) {
                    m.hold = function () {
                        b.isExtruderOn = false
                        if (m.isHolding) {
                            m.drawHold(m.holdingTarget);
                            m.holding();
                            m.throwBlock();
                        } else if (input.field && m.fieldCDcycle < m.cycle) { //not hold but field button is pressed
                            if (tech.isPlasmaBoost && powerUps.boost.endCycle < simulation.cycle + 60) powerUps.boost.endCycle = simulation.cycle + 60

                            if (m.energy > m.fieldRegen) m.energy -= m.fieldRegen
                            m.grabPowerUp();
                            m.lookForBlock();
                            b.extruder();
                        } else if (m.holdingTarget && m.fieldCDcycle < m.cycle) { //holding, but field button is released
                            m.pickUp();
                        } else {
                            m.holdingTarget = null; //clears holding target (this is so you only pick up right after the field button is released and a hold target exists)
                        }
                        m.drawRegenEnergy("rgba(0, 0, 0, 0.2)")
                        if (input.field) {
                            b.wasExtruderOn = true
                        } else {
                            b.wasExtruderOn = false
                            b.canExtruderFire = true
                        }
                        ctx.beginPath(); //draw all the wave bullets
                        for (let i = 1, len = bullet.length; i < len; i++) { //skip the first bullet (which is is oldest bullet)
                            if (bullet[i].isWave) {
                                if (bullet[i].isBranch || bullet[i - 1].isBranch) {
                                    ctx.moveTo(bullet[i].position.x, bullet[i].position.y)
                                } else {
                                    ctx.lineTo(bullet[i].position.x, bullet[i].position.y)
                                }
                            }
                        }
                        if (b.wasExtruderOn && b.isExtruderOn) ctx.lineTo(m.pos.x + 15 * Math.cos(m.angle), m.pos.y + 15 * Math.sin(m.angle))
                        ctx.lineWidth = 4;
                        ctx.strokeStyle = "#f07"
                        ctx.stroke();
                        ctx.lineWidth = tech.extruderRange;
                        ctx.strokeStyle = "rgba(255,0,110,0.06)"
                        ctx.stroke();
                    }
                } else {
                    m.hold = function () {
                        if (m.isHolding) {
                            m.drawHold(m.holdingTarget);
                            m.holding();
                            m.throwBlock();
                        } else if (input.field && m.fieldCDcycle < m.cycle) { //not hold but field button is pressed
                            if (tech.isPlasmaBoost && powerUps.boost.endCycle < simulation.cycle + 60) powerUps.boost.endCycle = simulation.cycle + 60

                            if (m.energy > m.fieldRegen) m.energy -= m.fieldRegen
                            m.grabPowerUp();
                            m.lookForBlock();
                            b.plasma();
                        } else if (m.holdingTarget && m.fieldCDcycle < m.cycle) { //holding, but field button is released
                            m.pickUp();
                        } else {
                            m.holdingTarget = null; //clears holding target (this is so you only pick up right after the field button is released and a hold target exists)
                        }
                        m.drawRegenEnergy("rgba(0, 0, 0, 0.2)")
                    }
                }
            },
            effect() {
                m.fieldMeterColor = "#f0f"
                m.eyeFillColor = m.fieldMeterColor
                this.set();
            }
        },
        {
            name: "time dilation",
            description: `use <strong class='color-f'>energy</strong> to <strong style='letter-spacing: 2px;'>stop time</strong><br><strong>1.2x</strong> movement and <strong><em>fire rate</em></strong><br><strong>12</strong> <strong class='color-f'>energy</strong> per second`,
            set() {
                // m.fieldMeterColor = "#0fc"
                // m.fieldMeterColor = "#ff0"
                m.fieldMeterColor = "#3fe"
                m.eyeFillColor = m.fieldMeterColor
                m.fieldFx = 1.25
                // m.fieldJump = 1.09
                m.setMovement();
                b.setFireCD()
                const timeStop = () => {
                    m.immuneCycle = m.cycle + 10; //invulnerable to harm while time is stopped,  this also disables regen
                    //draw field everywhere
                    ctx.globalCompositeOperation = "saturation"
                    ctx.fillStyle = "#ccc";
                    ctx.fillRect(-50000, -50000, 100000, 100000)
                    ctx.globalCompositeOperation = "source-over"
                    //stop time
                    m.isTimeDilated = true;

                    function sleep(who) {
                        for (let i = 0, len = who.length; i < len; ++i) {
                            if (!who[i].isSleeping) {
                                who[i].storeVelocity = who[i].velocity
                                who[i].storeAngularVelocity = who[i].angularVelocity
                            }
                            Matter.Sleeping.set(who[i], true)
                        }
                    }
                    sleep(mob);
                    sleep(body);
                    sleep(bullet);
                    simulation.cycle--; //pause all functions that depend on game cycle increasing
                }
                if (tech.isRewindField) {
                    this.rewindCount = 0
                    m.grabPowerUpRange2 = 300000//        m.grabPowerUpRange2 = 200000;

                    m.hold = function () {
                        // console.log(m.fieldCDcycle)
                        m.grabPowerUp();
                        // //grab power ups
                        // for (let i = 0, len = powerUp.length; i < len; ++i) {
                        //     if (
                        //         Vector.magnitudeSquared(Vector.sub(m.pos, powerUp[i].position)) < 100000 &&
                        //         !simulation.isChoosing &&
                        //         (powerUp[i].name !== "heal" || m.health !== m.maxHealth || tech.isOverHeal)
                        //     ) {
                        //         powerUps.onPickUp(powerUp[i]);
                        //         powerUp[i].effect();
                        //         Matter.Composite.remove(engine.world, powerUp[i]);
                        //         powerUp.splice(i, 1);
                        //         break; //because the array order is messed up after splice
                        //     }
                        // }
                        if (m.isHolding) {
                            m.drawHold(m.holdingTarget);
                            m.holding();
                            m.throwBlock();
                            m.wakeCheck();
                        } else if (input.field && m.fieldCDcycle < m.cycle) { //not hold but field button is pressed
                            const drain = 0.0014 / (1 + 0.05 * m.coupling)
                            if (m.energy > drain) m.energy -= drain
                            m.grabPowerUp();
                            if (this.rewindCount === 0) {
                                m.lookForBlock();
                            }

                            if (!m.holdingTarget) {
                                if (this.rewindCount === 0) { //large upfront energy cost to enter rewind mode
                                    if (m.energy > 0.3) {
                                        m.energy -= 0.3
                                    } else {
                                        this.rewindCount = 0;
                                        m.resetHistory();
                                        if (m.fireCDcycle < m.cycle + 60) m.fieldCDcycle = m.cycle + 60
                                        m.immuneCycle = m.cycle //if you reach the end of the history disable harm immunity
                                    }
                                }
                                this.rewindCount += 6;
                                const DRAIN = 0.003
                                let history = m.history[(m.cycle - this.rewindCount) % 600]
                                if (this.rewindCount > 599 || m.energy < DRAIN) {
                                    this.rewindCount = 0;
                                    m.resetHistory();
                                    if (m.fireCDcycle < m.cycle + 60) m.fieldCDcycle = m.cycle + 60
                                    m.immuneCycle = m.cycle //if you reach the end of the history disable harm immunity
                                } else {
                                    //draw field everywhere
                                    ctx.globalCompositeOperation = "saturation"
                                    ctx.fillStyle = "#ccc";
                                    ctx.fillRect(-100000, -100000, 200000, 200000)
                                    ctx.globalCompositeOperation = "source-over"
                                    // m.grabPowerUp(); //a second grab power up to make the power ups easier to grab, and they more fast which matches the time theme
                                    m.energy -= DRAIN
                                    if (m.immuneCycle < m.cycle + 5) m.immuneCycle = m.cycle + 5; //player is immune to damage for 5 cycles
                                    Matter.Body.setPosition(player, history.position);
                                    Matter.Body.setVelocity(player, {
                                        x: history.velocity.x,
                                        y: history.velocity.y
                                    });
                                    if (m.health < history.health) {
                                        m.health = history.health
                                        if (m.health > m.maxHealth) m.health = m.maxHealth
                                        m.displayHealth();
                                    }
                                    m.yOff = history.yOff
                                    if (m.yOff < 48) {
                                        m.doCrouch()
                                    } else {
                                        m.undoCrouch()
                                    }
                                    if (tech.isRewindBot && !(this.rewindCount % 60)) {
                                        for (let i = 0; i < tech.isRewindBot; i++) {
                                            b.randomBot(m.pos, false, false)
                                            bullet[bullet.length - 1].endCycle = simulation.cycle + 300 + Math.floor(180 * Math.random()) //8-9 seconds
                                        }
                                    }
                                    if (tech.isRewindGrenade && !(this.rewindCount % 30)) {
                                        b.grenade(m.pos, this.rewindCount) //Math.PI / 2
                                        const who = bullet[bullet.length - 1]
                                        who.endCycle = simulation.cycle + 120
                                    }
                                }
                            }
                            m.wakeCheck();
                        } else if (m.holdingTarget && m.fieldCDcycle < m.cycle) { //holding, but field button is released
                            m.pickUp();
                            this.rewindCount = 0;
                            m.wakeCheck();
                        } else if (tech.isTimeStop && player.speed < 1 && m.onGround && !input.fire) {
                            timeStop();
                            this.rewindCount = 0;
                        } else {
                            m.holdingTarget = null; //clears holding target (this is so you only pick up right after the field button is released and a hold target exists)
                            this.rewindCount = 0;
                            m.wakeCheck();
                        }
                        m.drawRegenEnergy() // this calls  m.regenEnergy(); also
                    }
                } else {
                    m.fieldFire = true;
                    m.isTimeDilated = false;
                    m.hold = function () {
                        if (m.isHolding) {
                            m.wakeCheck();
                            m.drawHold(m.holdingTarget);
                            m.holding();
                            m.throwBlock();
                        } else if (input.field && m.fieldCDcycle < m.cycle) {
                            const drain = 0.0026 / (1 + 0.03 * m.coupling)
                            if (m.energy > drain) m.energy -= drain
                            m.grabPowerUp();
                            m.lookForBlock(); //this drains energy 0.001
                            if (m.energy > drain) {
                                timeStop();
                            } else { //holding, but field button is released
                                m.fieldCDcycle = m.cycle + 120;
                                m.energy = 0;
                                m.wakeCheck();
                                m.wakeCheck();
                            }
                        } else if (tech.isTimeStop && player.speed < 1 && m.onGround && m.fireCDcycle < m.cycle && !input.fire) {
                            timeStop();
                            //makes things move at 1/5 time rate, but has an annoying flicker for mob graphics, and other minor bugs
                            // if (!(m.cycle % 4)) {
                            //     // requestAnimationFrame(() => {
                            //     m.wakeCheck();
                            //     // simulation.timePlayerSkip(1)
                            //     // }); //wrapping in animation frame prevents errors, probably          
                            //     ctx.globalCompositeOperation = "saturation"
                            //     ctx.fillStyle = "#ccc";
                            //     ctx.fillRect(-100000, -100000, 200000, 200000)
                            //     ctx.globalCompositeOperation = "source-over"
                            // } else {
                            //     timeStop();
                            // }
                        } else if (m.holdingTarget && m.fieldCDcycle < m.cycle) { //holding, but field button is released
                            m.wakeCheck();
                            m.pickUp();
                        } else {
                            m.wakeCheck();
                            m.holdingTarget = null; //clears holding target (this is so you only pick up right after the field button is released and a hold target exists)
                        }
                        m.drawRegenEnergy()
                    }
                }
            },
            effect() {
                if (tech.isTimeStop) {
                    m.fieldHarmReduction = 0.6;
                } else {
                    m.fieldHarmReduction = 1;
                }
                this.set();
            }
        },
        {
            name: "metamaterial cloaking",
            description: `<strong>0.4x</strong> <strong class='color-defense'>damage taken</strong> while <strong class='color-cloaked'>cloaked</strong><br>after <strong class='color-cloaked'>decloaking</strong> <strong>4.5x</strong> <strong class='color-d'>damage</strong> for <strong>2</strong> s<br><strong>6</strong> <strong class='color-f'>energy</strong> per second`,
            effect: () => {
                m.fieldFire = true;
                m.fieldMeterColor = "#333";
                m.eyeFillColor = m.fieldMeterColor
                m.fieldPhase = 0;
                m.isCloak = false
                m.fieldDrawRadius = 0
                m.isSneakAttack = true;
                m.sneakAttackCycle = 0;
                m.enterCloakCycle = 0;
                m.drawCloakedM = function () {
                    m.walk_cycle -= m.flipLegs * m.Vx;
                    m.pos.x += 4
                    m.draw();
                }
                m.drawCloak = function () {
                    m.fieldPhase += 0.007
                    const wiggle = 0.15 * Math.sin(m.fieldPhase * 0.5)
                    ctx.beginPath();
                    ctx.ellipse(m.pos.x, m.pos.y, m.fieldDrawRadius * (1 - wiggle), m.fieldDrawRadius * (1 + wiggle), m.fieldPhase, 0, 2 * Math.PI);
                    ctx.fillStyle = "#fff"
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = "#000"
                    // ctx.stroke()
                    ctx.globalCompositeOperation = "destination-in";
                    ctx.fill();
                    ctx.globalCompositeOperation = "source-over";
                    ctx.clip();
                }
                m.hold = function () {
                    if (m.isHolding) {
                        m.drawHold(m.holdingTarget);
                        m.holding();
                        m.throwBlock();
                    } else if (input.field && m.fieldCDcycle < m.cycle) { //not hold and field button is pressed
                        if (m.energy > m.fieldRegen) m.energy -= m.fieldRegen
                        m.grabPowerUp();
                        m.lookForBlock();
                    } else if (m.holdingTarget && m.fieldCDcycle < m.cycle) { //holding target exists, and field button is not pressed
                        m.pickUp();
                    } else {
                        m.holdingTarget = null; //clears holding target (this is so you only pick up right after the field button is released and a hold target exists)
                    }
                    //not shooting (or using field) enable cloak
                    if (m.energy < 0.05 && m.fireCDcycle < m.cycle && !input.fire) m.fireCDcycle = m.cycle
                    if (m.fireCDcycle + 10 < m.cycle && !input.fire) { //automatically cloak if not firing
                        // const drain = 0.02
                        if (!m.isCloak) { //&& m.energy > drain + 0.03
                            // m.energy -= drain
                            m.isCloak = true //enter cloak
                            m.fieldHarmReduction = 0.4;
                            m.enterCloakCycle = m.cycle
                            if (tech.isCloakHealLastHit && m.lastHit > 0) {
                                const heal = Math.min(0.75 * m.lastHit, m.energy)
                                m.addHealth(heal); //heal from last hit
                                m.lastHit = 0
                                simulation.drawList.push({ //add dmg to draw queue
                                    x: m.pos.x,
                                    y: m.pos.y,
                                    radius: Math.sqrt(heal) * 200,
                                    color: "rgba(0,255,200,0.6)",
                                    time: 16
                                });
                            }
                            if (tech.isIntangible) {
                                for (let i = 0; i < bullet.length; i++) {
                                    if (bullet[i].botType && bullet[i].botType !== "orbit") bullet[i].collisionFilter.mask = cat.map | cat.bullet | cat.mobBullet | cat.mobShield
                                }
                            }
                        }
                    } else if (m.isCloak) { //exit cloak
                        m.sneakAttackCycle = m.cycle
                        m.isCloak = false
                        m.fieldHarmReduction = 1

                        if (tech.isIntangible) {
                            for (let i = 0; i < bullet.length; i++) {
                                if (bullet[i].botType && bullet[i].botType !== "orbit") bullet[i].collisionFilter.mask = cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet | cat.mobShield
                            }
                        }
                        if (tech.isCloakStun) { //stun nearby mobs after exiting cloak
                            // let isMobsAround = false
                            const stunRange = m.fieldDrawRadius * 1.25
                            // const drain = 0.01
                            // if (m.energy > drain) {
                            for (let i = 0, len = mob.length; i < len; ++i) {
                                if (Vector.magnitude(Vector.sub(mob[i].position, m.pos)) < stunRange && Matter.Query.ray(map, mob[i].position, m.pos).length === 0 && !mob[i].isBadTarget) {
                                    isMobsAround = true
                                    mobs.statusStun(mob[i], 120)
                                }
                            }
                            // if (isMobsAround) {
                            //     m.energy -= drain
                            //     simulation.drawList.push({
                            //         x: m.pos.x,
                            //         y: m.pos.y,
                            //         radius: stunRange,
                            //         color: "hsla(0,50%,100%,0.7)",
                            //         time: 7
                            //     });
                            // }
                            // }
                        }
                    }

                    if (m.isCloak) {
                        m.fieldRange = m.fieldRange * 0.85 + 130
                        m.fieldDrawRadius = m.fieldRange * 1.1 //* 0.88 //* Math.min(1, 0.3 + 0.5 * Math.min(1, energy * energy));
                        m.drawCloak()
                        // ctx.globalCompositeOperation = "lighter";
                        // m.drawCloakedM()
                        // ctx.globalCompositeOperation = "source-over";

                        ctx.beginPath();
                        ctx.arc(m.pos.x, m.pos.y, 35, 0, 2 * Math.PI);
                        ctx.strokeStyle = "rgba(255,255,255,0.25)";//"rgba(0,0,0,0.7)";//"rgba(255,255,255,0.7)";//"rgba(255,0,100,0.7)";
                        ctx.lineWidth = 10
                        ctx.stroke();

                    } else if (m.fieldRange < 4000) {
                        m.fieldRange += 90
                        m.fieldDrawRadius = m.fieldRange //* Math.min(1, 0.3 + 0.5 * Math.min(1, energy * energy));
                        m.drawCloak()
                    }
                    if (tech.isIntangible) {
                        if (m.isCloak) {
                            player.collisionFilter.mask = cat.map
                            let inPlayer = Matter.Query.region(mob, player.bounds)
                            if (inPlayer.length > 0) {
                                for (let i = 0; i < inPlayer.length; i++) {
                                    if (m.energy > 0) {
                                        if (!inPlayer[i].isUnblockable) m.energy -= 0.004 + 0.0005 * simulation.difficultyMode;
                                        if (inPlayer[i].shield) m.energy -= 0.015 + 0.001 * simulation.difficultyMode;
                                    }
                                }
                            }
                        } else {
                            player.collisionFilter.mask = cat.body | cat.map | cat.mob | cat.mobBullet | cat.mobShield //normal collisions
                        }
                    }
                    this.drawRegenEnergyCloaking()
                    if (m.isSneakAttack && m.sneakAttackCycle + Math.min(100, 0.66 * (m.cycle - m.enterCloakCycle)) > m.cycle) { //show sneak attack status
                        m.fieldDamage = 4.5 * (1 + 0.05 * m.coupling)
                        const timeLeft = (m.sneakAttackCycle + Math.min(100, 0.66 * (m.cycle - m.enterCloakCycle)) - m.cycle) * 0.5
                        ctx.beginPath();
                        ctx.arc(m.pos.x, m.pos.y, 32, 0, 2 * Math.PI);
                        ctx.strokeStyle = "rgba(180,30,70,0.5)";//"rgba(0,0,0,0.7)";//"rgba(255,255,255,0.7)";//"rgba(255,0,100,0.7)";
                        ctx.lineWidth = Math.max(Math.min(10, timeLeft), 3);
                        ctx.stroke();
                        // ctx.globalCompositeOperation = "multiply";
                        // m.drawCloakedM()
                        // ctx.globalCompositeOperation = "source-over";
                    } else {
                        m.fieldDamage = 1
                    }
                }
            }
        },
        {
            name: "pilot wave",
            description: `use <strong class='color-f'>energy</strong> to guide <strong class='color-block'>blocks</strong><em style ="float: right; font-family: monospace;font-size:1rem;color:#fff;">↓↓→↘↓↙←↓↓</em><br><div class="circle-grid tech"></div>, <div class="circle-grid gun"></div>, and <div class="circle-grid field"></div> have <strong>+3</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong><br><strong>10</strong> <strong class='color-f'>energy</strong> per second`,
            keyLog: [null, null, null, null, null, null, null],
            collider: null,
            fieldMass: 1,
            drain: 1,
            effect: () => {
                m.fieldUpgrades[8].collider = Matter.Bodies.polygon(m.pos.x, m.pos.y, 8, 35, {
                    friction: 0,
                    frictionAir: 0.12,
                    collisionFilter: { category: cat.player, mask: cat.map }, //no collision because player is holding
                    classType: "field",
                    lastSpeed: 0,
                });
                Composite.add(engine.world, m.fieldUpgrades[8].collider); //add to world

                //store event function so it can be found and removed in m.setField()
                m.fieldEvent = function (event) {
                    m.fieldUpgrades[4].keyLog.shift() //remove first element
                    m.fieldUpgrades[4].keyLog.push(event.code) //add new key to end
                    const patternA = ["ArrowDown", "ArrowDown", "ArrowRight", "ArrowDown", "ArrowLeft", "ArrowDown", "ArrowDown"]
                    const patternB = [input.key.down, input.key.down, input.key.right, input.key.down, input.key.left, input.key.down, input.key.down]
                    const arraysEqual = (a, b) => a.length === b.length && a.every((val, i) => val === b[i]);

                    const width = 90 + Math.floor(30 * Math.random())
                    const height = 11 + Math.floor(7 * Math.random())
                    const yOff = 60
                    const blockRegion = {
                        min: {
                            x: m.pos.x - width,
                            y: m.pos.y + yOff - height
                        },
                        max: {
                            x: m.pos.x + width,
                            y: m.pos.y + yOff + height
                        }
                    }
                    if (
                        (arraysEqual(m.fieldUpgrades[4].keyLog, patternA) || arraysEqual(m.fieldUpgrades[4].keyLog, patternB))
                        && !Matter.Query.region(map, blockRegion).length
                        && !m.crouch
                    ) {
                        //move player up away from block
                        Matter.Body.setPosition(player, { x: player.position.x, y: player.position.y - height })

                        //spawn a block
                        body[body.length] = Matter.Bodies.rectangle(m.pos.x, blockRegion.max.y, width * 2, height * 2, {
                            friction: 0.05,
                            frictionAir: 0.001,
                            collisionFilter: {
                                category: cat.body,
                                mask: cat.player | cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet
                            },
                            classType: "body",
                            isPilotWave: true,
                        });
                        Composite.add(engine.world, body[body.length - 1]); //add to world
                        simulation.inGameConsole(`Composite<span class='color-symbol'>.</span>add<span class='color-symbol'>(</span>engine.world<span class='color-symbol'>,</span> block<span class='color-symbol'>)</span> &nbsp; &nbsp; <em style ="float: right; font-family: monospace;font-size:1rem;color:#fff;">//↓↓→↘↓↙←↓↓</em>`);
                    }
                }
                window.addEventListener("keydown", m.fieldEvent);

                m.fieldMeterColor = "#333"
                m.eyeFillColor = m.fieldMeterColor
                m.fieldPhase = 0;
                m.fieldPosition = { x: simulation.mouseInGame.x, y: simulation.mouseInGame.y }
                m.lastFieldPosition = { x: simulation.mouseInGame.x, y: simulation.mouseInGame.y }
                m.fieldOn = false;
                if (tech.isNoPilotCost) m.fieldFire = true;


                m.fieldRadius = 0;
                m.drop();
                m.hold = function () {
                    let isOn = (tech.isNoPilotCost ? !input.field : input.field)
                    if (tech.isPrinter) {
                        //spawn blocks if field and crouch
                        if (input.field && m.fieldCDcycle < m.cycle && input.down && !m.isHolding) {
                            m.printBlock()
                        }
                        //if holding block grow it
                        if (m.isHolding) {
                            m.drawHold(m.holdingTarget);
                            m.holding();
                            if (tech.isPrinter && m.holdingTarget.isPrinted && input.field) {
                                // if (Math.random() < 0.004 && m.holdingTarget.vertices.length < 12) m.holdingTarget.vertices.push({ x: 0, y: 0 }) //small chance to increase the number of vertices
                                m.holdingTarget.radius += Math.min(1.1, 1.3 / m.holdingTarget.mass) //grow up to a limit
                                const r1 = m.holdingTarget.radius * (1 + 0.12 * Math.sin(m.cycle * 0.11))
                                const r2 = m.holdingTarget.radius * (1 + 0.12 * Math.cos(m.cycle * 0.11))
                                let angle = (m.cycle * 0.01) % (2 * Math.PI) //rotate the object 
                                let vertices = []
                                for (let i = 0, len = m.holdingTarget.vertices.length; i < len; i++) {
                                    angle += 2 * Math.PI / len
                                    vertices.push({ x: m.holdingTarget.position.x + r1 * Math.cos(angle), y: m.holdingTarget.position.y + r2 * Math.sin(angle) })
                                }
                                Matter.Body.setVertices(m.holdingTarget, vertices)
                                m.definePlayerMass(m.defaultMass + m.holdingTarget.mass * m.holdingMassScale)
                            }
                            m.throwBlock()
                        } else {
                            m.holdingTarget = null; //clears holding target (this is so you only pick up right after the field button is released and a hold target exists)
                        }
                        //if releasing field throw it

                    }
                    if (isOn) {
                        if (m.fieldCDcycle < m.cycle) {
                            if (!m.fieldOn) { // if field was off, teleport to player
                                m.fieldOn = true;
                                Matter.Body.setPosition(m.fieldUpgrades[8].collider, m.pos);
                                m.fieldPosition.x = m.pos.x
                                m.fieldPosition.y = m.pos.y
                            }
                            const graphicScale = 1.2 //the draw range is a bit bigger then the interaction range
                            //when field is on it smoothly moves towards the mouse
                            const sub = Vector.sub(simulation.mouseInGame, m.fieldUpgrades[8].collider.position)
                            const mag = Vector.magnitude(sub)

                            //adjust speed of field here, and with friction and mass above where the collier is spawned
                            const fieldMassScale = Math.max(1.5, Math.pow(m.fieldUpgrades[8].fieldMass, 0.3)) //how much mass inside the field slows the push and cap
                            const scaledMag = 0.00000017 / fieldMassScale * Math.pow(mag, 2) //having the mag squared makes the effect weaker in close for fine movement
                            let push = Vector.mult(Vector.normalise(sub), scaledMag)
                            const cap = 0.17 / fieldMassScale //acts like a "speed limit"
                            if (Vector.magnitude(push) > cap) push = Vector.mult(Vector.normalise(push), cap)
                            m.fieldUpgrades[8].collider.force = push

                            //check for map collisions
                            if (Matter.Query.ray(map, m.fieldPosition, m.fieldUpgrades[8].collider.position).length) {
                                Matter.Body.setVelocity(m.fieldUpgrades[8].collider, Vector.mult(m.fieldUpgrades[8].collider.velocity, 0.6))
                                m.fieldRadius *= 0.6
                            }
                            m.fieldPosition.x = m.fieldUpgrades[8].collider.position.x
                            m.fieldPosition.y = m.fieldUpgrades[8].collider.position.y

                            //grab power ups into the field
                            for (let i = 0, len = powerUp.length; i < len; ++i) {
                                if (tech.isEnergyNoAmmo && powerUp[i].name === "ammo") continue

                                const dxP = m.fieldPosition.x - powerUp[i].position.x;
                                const dyP = m.fieldPosition.y - powerUp[i].position.y;
                                const dist2 = dxP * dxP + dyP * dyP + 200;
                                const graphicRange = graphicScale * m.fieldRadius
                                // float towards field  if looking at and in range  or  if very close to player
                                // if (
                                //     dist2 < graphicRange * graphicRange &&
                                //     (m.lookingAt(powerUp[i]) || dist2 < 16000)
                                // ) {
                                //     powerUp[i].force.x += 0.05 * (dxP / Math.sqrt(dist2)) * powerUp[i].mass;
                                //     powerUp[i].force.y += 0.05 * (dyP / Math.sqrt(dist2)) * powerUp[i].mass - powerUp[i].mass * simulation.g; //negate gravity
                                //     Matter.Body.setVelocity(powerUp[i], { x: powerUp[i].velocity.x * 0.11, y: powerUp[i].velocity.y * 0.11 }); //extra friction
                                if (
                                    dist2 < graphicRange * graphicRange &&
                                    !simulation.isChoosing &&
                                    (tech.isOverHeal || powerUp[i].name !== "heal" || m.maxHealth - m.health > 0.01)
                                    // (powerUp[i].name !== "heal" || m.health < 0.94 * m.maxHealth)
                                    // (powerUp[i].name !== "ammo" || b.guns[b.activeGun].ammo !== Infinity)
                                ) { //use power up if it is close enough

                                    simulation.ephemera.push({
                                        name: "pilot grab",
                                        count: 5, //cycles before it self removes
                                        PposX: powerUp[i].position.x,
                                        PposY: powerUp[i].position.y,
                                        size: powerUp[i].size,
                                        color: powerUp[i].color,
                                        do() {
                                            this.count--
                                            if (this.count < 0) simulation.removeEphemera(this.name)
                                            ctx.beginPath();
                                            ctx.arc(this.PposX, this.PposY, this.size * (this.count + 2) / 7, 0, 2 * Math.PI);
                                            ctx.fillStyle = this.color
                                            ctx.fill();
                                        },
                                    })

                                    powerUps.onPickUp(powerUp[i]);
                                    powerUp[i].effect();
                                    Matter.Composite.remove(engine.world, powerUp[i]);
                                    powerUp.splice(i, 1);
                                    // m.fieldRadius += 50
                                    break; //because the array order is messed up after splice
                                }
                                // }
                            }

                            let radiusGoal, radiusSmooth, drainPassive
                            if (Matter.Query.ray(map, m.fieldPosition, player.position).length) { //is there something blocking the player's view of the field
                                radiusGoal = 0
                                radiusSmooth = 0.995
                                drainPassive = 1.5 * m.fieldRegen * m.fieldUpgrades[8].drain
                            } else {
                                radiusGoal = Math.max(50, 250 - 2 * m.fieldUpgrades[8].collider.speed)
                                radiusSmooth = 0.97
                                drainPassive = m.fieldRegen * m.fieldUpgrades[8].drain
                            }
                            if (tech.isNoPilotCost) drainPassive = 0
                            m.fieldRadius = m.fieldRadius * radiusSmooth + radiusGoal * (1 - radiusSmooth)

                            //track velocity change for calculating block energy drain
                            const speedChange = Math.max(0, m.fieldUpgrades[8].collider.speed - m.fieldUpgrades[8].collider.lastSpeed)
                            m.fieldUpgrades[8].collider.lastSpeed = m.fieldUpgrades[8].collider.speed

                            if (m.energy >= drainPassive) {
                                m.energy -= drainPassive;
                                m.fieldUpgrades[8].fieldMass = 1
                                for (let i = 0, len = body.length; i < len; ++i) {
                                    if (Vector.magnitude(Vector.sub(body[i].position, m.fieldPosition)) < m.fieldRadius && !body[i].isNotHoldable) {
                                        // const drainBlock = m.fieldUpgrades[8].collider.speed * body[i].mass * 0.0000013
                                        const drainBlock = m.fieldUpgrades[8].drain * speedChange * body[i].mass * 0.000095
                                        if (m.energy > drainBlock) {
                                            m.energy -= drainBlock;
                                            Matter.Body.setVelocity(body[i], m.fieldUpgrades[8].collider.velocity); //give block mouse velocity
                                            Matter.Body.setAngularVelocity(body[i], body[i].angularVelocity * 0.8)
                                            m.fieldUpgrades[8].fieldMass += body[i].mass
                                            //blocks drift towards center of pilot wave
                                            const sub = Vector.sub(m.fieldPosition, body[i].position)
                                            const push = Vector.mult(Vector.normalise(sub), 0.0001 * body[i].mass * Vector.magnitude(sub))
                                            body[i].force.x += push.x
                                            body[i].force.y += push.y - body[i].mass * simulation.g //remove gravity effects

                                            if (m.standingOn === body[i] && m.onGround) {
                                                //try to stop the walk animation
                                                m.walk_cycle -= m.flipLegs * m.Vx
                                                m.stepSize *= 0
                                                //extra stability
                                                Matter.Body.setAngularVelocity(body[i], body[i].angularVelocity * 0)
                                                //match velocity upto a change of 10 per cycle
                                                const limit = 10
                                                const deltaV = Math.max(-limit, Math.min((m.fieldUpgrades[8].collider.velocity.x - player.velocity.x), limit))
                                                Matter.Body.setVelocity(player, { x: player.velocity.x + deltaV, y: player.velocity.y });
                                            }

                                        } else {
                                            m.fieldCDcycle = m.cycle + 60;
                                            m.fieldOn = false
                                            m.fieldRadius = 0
                                            break
                                        }
                                    }
                                }

                                // if (tech.isFreezeMobs) {
                                //     for (let i = 0, len = mob.length; i < len; ++i) {
                                //         if (!mob[i].isMobBullet && !mob[i].shield && !mob[i].isShielded && Vector.magnitude(Vector.sub(mob[i].position, m.fieldPosition)) < m.fieldRadius + mob[i].radius) {
                                //             const ICE_DRAIN = 0.0005
                                //             if (m.energy > ICE_DRAIN) m.energy -= ICE_DRAIN;
                                //             mobs.statusSlow(mob[i], 180)
                                //         }
                                //     }
                                // }

                                ctx.beginPath();
                                const rotate = m.cycle * 0.008;
                                m.fieldPhase += 0.2 // - 0.5 * Math.sqrt(Math.min(m.energy, 1));
                                const off1 = 1 + 0.06 * Math.sin(m.fieldPhase);
                                const off2 = 1 - 0.06 * Math.sin(m.fieldPhase);
                                ctx.beginPath();
                                ctx.ellipse(m.fieldPosition.x, m.fieldPosition.y, graphicScale * m.fieldRadius * off1, graphicScale * m.fieldRadius * off2, rotate, 0, 2 * Math.PI);
                                ctx.globalCompositeOperation = "exclusion";
                                ctx.fillStyle = "#fff";
                                ctx.fill();
                                ctx.globalCompositeOperation = "source-over";
                                ctx.beginPath();
                                ctx.ellipse(m.fieldPosition.x, m.fieldPosition.y, graphicScale * m.fieldRadius * off1, graphicScale * m.fieldRadius * off2, rotate, 0, 2 * Math.PI * m.energy / m.maxEnergy);
                                if (radiusGoal || m.cycle % 5) {
                                    ctx.strokeStyle = "#000";
                                } else {
                                    ctx.strokeStyle = "#fff";
                                }
                                ctx.lineWidth = 4;
                                ctx.stroke();

                            } else {
                                m.fieldCDcycle = m.cycle + 60;
                                m.fieldOn = false
                                m.fieldRadius = 0
                            }
                        } else {
                            m.grabPowerUp();
                        }
                    } else {
                        m.fieldOn = false
                        m.fieldRadius = 0
                    }
                    //grab power ups normally at player too
                    if (input.field) m.grabPowerUp();

                    m.drawRegenEnergy("rgba(0,0,0,0.2)")

                    // //draw physics collider
                    // ctx.beginPath();
                    // const vertices = m.fieldUpgrades[8].collider.vertices;
                    // ctx.moveTo(vertices[0].x, vertices[0].y);
                    // for (let j = 1, len = vertices.length; j < len; ++j) ctx.lineTo(vertices[j].x, vertices[j].y);
                    // ctx.lineTo(vertices[0].x, vertices[0].y);
                    // ctx.strokeStyle = "#000";
                    // ctx.lineWidth = 2;
                    // ctx.stroke();
                }
            }
        },
        {
            name: "wormhole",
            // setDescription() {
            //     return `use <strong>${tech.isFreeWormHole ? 2 : 16}</strong> <strong class='color-f'>energy</strong> to <strong>tunnel</strong> through a <strong class='color-worm'>wormhole</strong><br><strong>+8%</strong> chance to <strong class='color-dup'>duplicate</strong> spawned <strong>power ups</strong><br><strong>8</strong> <strong class='color-f'>energy</strong> per second`
            // },
            description: `use <strong>16</strong> <strong class='color-f'>energy</strong> to <strong>tunnel</strong> through a <strong class='color-worm'>wormhole</strong><br><strong>+8%</strong> chance to <strong class='color-dup'>duplicate</strong> <strong>power ups</strong><br><strong>8</strong> <strong class='color-f'>energy</strong> per second`,
            drain: 0,
            effect: function () {
                m.fieldMeterColor = "#bbf" //"#0c5"
                m.eyeFillColor = m.fieldMeterColor

                m.duplicateChance = 0.08
                m.fieldRange = 0
                powerUps.setPowerUpMode(); //needed after adjusting duplication chance

                m.hold = function () {
                    // m.hole = {  //this is reset with each new field, but I'm leaving it here for reference
                    //   isOn: false,
                    //   isReady: true,
                    //   pos1: {x: 0,y: 0},
                    //   pos2: {x: 0,y: 0},
                    //   angle: 0,
                    //   unit:{x:0,y:0},
                    // }
                    if (m.hole.isOn) {
                        // draw holes
                        m.fieldRange = 0.97 * m.fieldRange + 0.03 * (50 + 10 * Math.sin(simulation.cycle * 0.025))
                        const semiMajorAxis = m.fieldRange + 30
                        const edge1a = Vector.add(Vector.mult(m.hole.unit, semiMajorAxis), m.hole.pos1)
                        const edge1b = Vector.add(Vector.mult(m.hole.unit, -semiMajorAxis), m.hole.pos1)
                        const edge2a = Vector.add(Vector.mult(m.hole.unit, semiMajorAxis), m.hole.pos2)
                        const edge2b = Vector.add(Vector.mult(m.hole.unit, -semiMajorAxis), m.hole.pos2)
                        ctx.beginPath();
                        ctx.moveTo(edge1a.x, edge1a.y)
                        ctx.bezierCurveTo(m.hole.pos1.x, m.hole.pos1.y, m.hole.pos2.x, m.hole.pos2.y, edge2a.x, edge2a.y);
                        ctx.lineTo(edge2b.x, edge2b.y)
                        ctx.bezierCurveTo(m.hole.pos2.x, m.hole.pos2.y, m.hole.pos1.x, m.hole.pos1.y, edge1b.x, edge1b.y);
                        ctx.fillStyle = `rgba(255,255,255,${200 / m.fieldRange / m.fieldRange})` //"rgba(0,0,0,0.1)"
                        ctx.fill();
                        ctx.beginPath();
                        ctx.ellipse(m.hole.pos1.x, m.hole.pos1.y, m.fieldRange, semiMajorAxis, m.hole.angle, 0, 2 * Math.PI)
                        ctx.ellipse(m.hole.pos2.x, m.hole.pos2.y, m.fieldRange, semiMajorAxis, m.hole.angle, 0, 2 * Math.PI)
                        ctx.fillStyle = `rgba(255,255,255,${32 / m.fieldRange})`
                        ctx.fill();

                        //suck power ups
                        for (let i = 0, len = powerUp.length; i < len; ++i) {
                            if (tech.isEnergyNoAmmo && powerUp[i].name === "ammo") continue
                            //which hole is closer
                            const dxP1 = m.hole.pos1.x - powerUp[i].position.x;
                            const dyP1 = m.hole.pos1.y - powerUp[i].position.y;
                            const dxP2 = m.hole.pos2.x - powerUp[i].position.x;
                            const dyP2 = m.hole.pos2.y - powerUp[i].position.y;
                            let dxP, dyP, dist2
                            if (dxP1 * dxP1 + dyP1 * dyP1 < dxP2 * dxP2 + dyP2 * dyP2) {
                                dxP = dxP1
                                dyP = dyP1
                            } else {
                                dxP = dxP2
                                dyP = dyP2
                            }
                            dist2 = dxP * dxP + dyP * dyP;
                            if (dist2 < 600000) { //&& !(m.health === m.maxHealth && powerUp[i].name === "heal")
                                powerUp[i].force.x += 4 * (dxP / dist2) * powerUp[i].mass; // float towards hole
                                powerUp[i].force.y += 4 * (dyP / dist2) * powerUp[i].mass - powerUp[i].mass * simulation.g; //negate gravity
                                Matter.Body.setVelocity(powerUp[i], { x: powerUp[i].velocity.x * 0.05, y: powerUp[i].velocity.y * 0.05 });
                                if (dist2 < 1000 && !simulation.isChoosing) { //use power up if it is close enough

                                    simulation.ephemera.push({
                                        name: "womrhole grab",
                                        count: 5, //cycles before it self removes
                                        PposX: powerUp[i].position.x,
                                        PposY: powerUp[i].position.y,
                                        size: powerUp[i].size,
                                        color: powerUp[i].color,
                                        do() {
                                            this.count--
                                            if (this.count < 0) simulation.removeEphemera(this.name)
                                            ctx.beginPath();
                                            ctx.arc(this.PposX, this.PposY, Math.max(1, this.size * (this.count + 1) / 7), 0, 2 * Math.PI);
                                            ctx.fillStyle = this.color
                                            ctx.fill();
                                        },
                                    })

                                    m.fieldRange *= 0.8
                                    powerUps.onPickUp(powerUp[i]);
                                    powerUp[i].effect();
                                    Matter.Composite.remove(engine.world, powerUp[i]);
                                    powerUp.splice(i, 1);
                                    break; //because the array order is messed up after splice
                                }
                            }
                        }
                        //suck and shrink blocks
                        const suckRange = 500
                        const shrinkRange = 100
                        const shrinkScale = 0.97;
                        const slowScale = 0.9
                        for (let i = 0, len = body.length; i < len; i++) {
                            if (!body[i].isNotHoldable) {
                                const dist1 = Vector.magnitude(Vector.sub(m.hole.pos1, body[i].position))
                                const dist2 = Vector.magnitude(Vector.sub(m.hole.pos2, body[i].position))
                                if (dist1 < dist2) {
                                    if (dist1 < suckRange) {
                                        const pull = Vector.mult(Vector.normalise(Vector.sub(m.hole.pos1, body[i].position)), 1)
                                        const slow = Vector.mult(body[i].velocity, slowScale)
                                        Matter.Body.setVelocity(body[i], Vector.add(slow, pull));
                                        //shrink
                                        if (Vector.magnitude(Vector.sub(m.hole.pos1, body[i].position)) < shrinkRange) {
                                            Matter.Body.scale(body[i], shrinkScale, shrinkScale);
                                            if (body[i].mass < 0.05) {
                                                Matter.Composite.remove(engine.world, body[i]);
                                                body.splice(i, 1);
                                                m.fieldRange *= 0.8
                                                if ((m.fieldMode === 0 || m.fieldMode === 9) && m.immuneCycle < m.cycle) m.energy += 0.02 * m.coupling * level.isReducedRegen
                                                if (tech.isWormholeWorms) { //pandimensional spermia
                                                    for (let i = 0, len = 1 + Math.floor(4 * Math.random()); i < len; i++) {
                                                        b.worm(Vector.add(m.hole.pos2, Vector.rotate({ x: m.fieldRange * 0.4, y: 0 }, 2 * Math.PI * Math.random())))
                                                        Matter.Body.setVelocity(bullet[bullet.length - 1], Vector.mult(Vector.rotate(m.hole.unit, Math.PI / 2), -10));
                                                    }
                                                }
                                                if (tech.isBlockDup) {
                                                    if (tech.blockDupCount < 0.4) {
                                                        tech.blockDupCount += 0.02
                                                        simulation.inGameConsole(`<span class='color-var'>duplicationChance</span><span class='color-symbol'>++</span> <em>//${(tech.blockDupCount * 100).toFixed(0)}% for anyon</em>`);
                                                    } else {
                                                        simulation.inGameConsole(`//<em><span class='color-var'>duplicationChance</span> limit reached for this level</em>`);
                                                    }
                                                }
                                                break
                                            }
                                        }
                                    }
                                } else if (dist2 < suckRange) {
                                    const pull = Vector.mult(Vector.normalise(Vector.sub(m.hole.pos2, body[i].position)), 1)
                                    const slow = Vector.mult(body[i].velocity, slowScale)
                                    Matter.Body.setVelocity(body[i], Vector.add(slow, pull));
                                    //shrink
                                    if (Vector.magnitude(Vector.sub(m.hole.pos2, body[i].position)) < shrinkRange) {
                                        Matter.Body.scale(body[i], shrinkScale, shrinkScale);
                                        if (body[i].mass < 0.05) {
                                            Matter.Composite.remove(engine.world, body[i]);
                                            body.splice(i, 1);
                                            m.fieldRange *= 0.8
                                            if ((m.fieldMode === 0 || m.fieldMode === 9) && m.immuneCycle < m.cycle) m.energy += 0.02 * m.coupling * level.isReducedRegen
                                            if (m.fieldMode === 0 || m.fieldMode === 9) m.energy += 0.02 * m.coupling * level.isReducedRegen
                                            if (tech.isWormholeWorms) { //pandimensional spermia
                                                for (let i = 0, len = 1 + Math.floor(4 * Math.random()); i < len; i++) {
                                                    b.worm(Vector.add(m.hole.pos2, Vector.rotate({ x: m.fieldRange * 0.4, y: 0 }, 2 * Math.PI * Math.random())))
                                                    Matter.Body.setVelocity(bullet[bullet.length - 1], Vector.mult(Vector.rotate(m.hole.unit, Math.PI / 2), -10));
                                                }
                                            }
                                            if (tech.isBlockDup) {
                                                if (tech.blockDupCount < 0.4) {
                                                    tech.blockDupCount += 0.02
                                                    simulation.inGameConsole(`<span class='color-var'>duplicationChance</span><span class='color-symbol'>++</span> <em>//${(tech.blockDupCount * 100).toFixed(0)}% for anyon</em>`);
                                                } else {
                                                    simulation.inGameConsole(`//<em><span class='color-var'>duplicationChance</span> limit reached for this level</em>`);
                                                }
                                            }
                                            break
                                        }
                                    }
                                }
                            }
                        }
                        if (tech.isWormHoleBullets) {
                            //teleport bullets
                            for (let i = 0, len = bullet.length; i < len; ++i) { //teleport bullets from hole1 to hole2
                                if (!bullet[i].botType && !bullet[i].isInHole) { //don't teleport bots
                                    if (Vector.magnitude(Vector.sub(m.hole.pos1, bullet[i].position)) < m.fieldRange) { //find if bullet is touching hole1
                                        Matter.Body.setPosition(bullet[i], Vector.add(m.hole.pos2, Vector.sub(m.hole.pos1, bullet[i].position)));
                                        m.fieldRange += 5
                                        bullet[i].isInHole = true
                                    } else if (Vector.magnitude(Vector.sub(m.hole.pos2, bullet[i].position)) < m.fieldRange) { //find if bullet is touching hole1
                                        Matter.Body.setPosition(bullet[i], Vector.add(m.hole.pos1, Vector.sub(m.hole.pos2, bullet[i].position)));
                                        m.fieldRange += 5
                                        bullet[i].isInHole = true
                                    }
                                }
                            }
                            // mobs get pushed away
                            for (let i = 0, len = mob.length; i < len; i++) {
                                if (Vector.magnitude(Vector.sub(m.hole.pos1, mob[i].position)) < 200) {
                                    const pull = Vector.mult(Vector.normalise(Vector.sub(m.hole.pos1, mob[i].position)), -0.07)
                                    Matter.Body.setVelocity(mob[i], Vector.add(mob[i].velocity, pull));
                                }
                                if (Vector.magnitude(Vector.sub(m.hole.pos2, mob[i].position)) < 200) {
                                    const pull = Vector.mult(Vector.normalise(Vector.sub(m.hole.pos2, mob[i].position)), -0.07)
                                    Matter.Body.setVelocity(mob[i], Vector.add(mob[i].velocity, pull));
                                }
                            }
                        }
                    }

                    if (m.fieldCDcycle < m.cycle) {
                        const scale = 40
                        const justPastMouse = Vector.add(Vector.mult(Vector.normalise(Vector.sub(simulation.mouseInGame, m.pos)), 25), simulation.mouseInGame) //used to see if the wormhole will collide with wall
                        const sub = Vector.sub(simulation.mouseInGame, m.pos)
                        // const mag = Vector.magnitude(sub)

                        if (input.field) {
                            if (tech.isWormHolePause) {
                                // const drain = m.fieldRegen + 0.000035
                                // if (m.energy > drain) {
                                // m.energy -= drain
                                if (m.immuneCycle < m.cycle + 1) m.immuneCycle = m.cycle + 1; //player is immune to damage for 1 cycle
                                m.isTimeDilated = true;

                                function sleep(who) {
                                    for (let i = 0, len = who.length; i < len; ++i) {
                                        if (!who[i].isSleeping) {
                                            who[i].storeVelocity = who[i].velocity
                                            who[i].storeAngularVelocity = who[i].angularVelocity
                                        }
                                        Matter.Sleeping.set(who[i], true)
                                    }
                                }
                                sleep(mob);
                                sleep(body);
                                sleep(bullet);
                                simulation.cycle--; //pause all functions that depend on game cycle increasing
                                Matter.Body.setVelocity(player, { //keep player frozen
                                    x: 0,
                                    y: -55 * player.mass * simulation.g //undo gravity before it is added
                                });
                                player.force.x = 0
                                player.force.y = 0
                                // } else {
                                //     m.wakeCheck();
                                //     m.energy = 0;
                                // }
                            }

                            m.grabPowerUp();
                            //scale drain with distance
                            // if (tech.isWormholeMapIgnore && Matter.Query.ray(map, m.pos, justPastMouse).length !== 0) {
                            //     this.drain = (0.05 + 0.005 * Math.sqrt(mag)) * 2
                            // } else {
                            //     this.drain = tech.isFreeWormHole ? 0 : 0.05 + 0.005 * Math.sqrt(mag)
                            // }
                            // if (tech.isWormholeMapIgnore && Matter.Query.ray(map, m.pos, justPastMouse).length !== 0) {
                            //     this.drain = tech.isFreeWormHole ? 0 : 0.25
                            // } else {
                            //     this.drain = tech.isFreeWormHole ? 0 : 0.15
                            // }
                            this.drain = tech.isFreeWormHole ? 0.02 : 0.16
                            const unit = Vector.perp(Vector.normalise(sub))
                            const where = { x: m.pos.x + 30 * Math.cos(m.angle), y: m.pos.y + 30 * Math.sin(m.angle) }
                            m.fieldRange = 0.97 * m.fieldRange + 0.03 * (50 + 10 * Math.sin(simulation.cycle * 0.025))
                            const edge2a = Vector.add(Vector.mult(unit, 1.5 * m.fieldRange), simulation.mouseInGame)
                            const edge2b = Vector.add(Vector.mult(unit, -1.5 * m.fieldRange), simulation.mouseInGame)
                            //draw possible wormhole
                            ctx.beginPath();
                            ctx.moveTo(where.x, where.y)
                            ctx.bezierCurveTo(where.x, where.y, simulation.mouseInGame.x, simulation.mouseInGame.y, edge2a.x, edge2a.y);
                            ctx.moveTo(where.x, where.y)
                            ctx.bezierCurveTo(where.x, where.y, simulation.mouseInGame.x, simulation.mouseInGame.y, edge2b.x, edge2b.y);
                            if (
                                m.energy > this.drain &&
                                (tech.isWormholeMapIgnore || Matter.Query.ray(map, m.pos, justPastMouse).length === 0) &&
                                Matter.Query.region(map, {
                                    min: { x: simulation.mouseInGame.x - scale, y: simulation.mouseInGame.y - scale },
                                    max: { x: simulation.mouseInGame.x + scale, y: simulation.mouseInGame.y + scale }
                                }).length === 0
                            ) {
                                m.hole.isReady = true;
                                // ctx.fillStyle = "rgba(255,255,255,0.5)"
                                // ctx.fill();
                                ctx.lineWidth = 1
                                ctx.strokeStyle = "#000"
                                ctx.stroke();
                            } else {
                                m.hole.isReady = false;
                                ctx.lineWidth = 1
                                ctx.strokeStyle = "#000"
                                ctx.lineDashOffset = 30 * Math.random()
                                ctx.setLineDash([20, 40]);
                                ctx.stroke();
                                ctx.setLineDash([]);
                            }
                        } else {
                            if (tech.isWormHolePause && m.isTimeDilated) m.wakeCheck();
                            //make new wormhole
                            if (
                                m.hole.isReady && m.energy > this.drain &&
                                (tech.isWormholeMapIgnore || Matter.Query.ray(map, m.pos, justPastMouse).length === 0) &&
                                Matter.Query.region(map, {
                                    min: { x: simulation.mouseInGame.x - scale, y: simulation.mouseInGame.y - scale },
                                    max: { x: simulation.mouseInGame.x + scale, y: simulation.mouseInGame.y + scale }
                                }).length === 0
                            ) {
                                m.energy -= this.drain
                                m.hole.isReady = false;
                                m.fieldRange = 0
                                if (tech.isWormholeMapIgnore) {
                                    simulation.translatePlayerAndCamera(simulation.mouseInGame) //too jerky
                                } else {
                                    Matter.Body.setPosition(player, simulation.mouseInGame);
                                }
                                m.buttonCD_jump = 0 //this might fix a bug with jumping

                                const velocity = Vector.mult(Vector.normalise(sub), 15)
                                Matter.Body.setVelocity(player, { x: velocity.x, y: velocity.y - 5 }); //an extra vertical kick so the player hangs in place longer

                                if (m.immuneCycle < m.cycle + 5) m.immuneCycle = m.cycle + 5; //player is immune to damage for 1/4 seconds 
                                // move bots to player
                                for (let i = 0; i < bullet.length; i++) {
                                    if (bullet[i].botType) {
                                        Matter.Body.setPosition(bullet[i], Vector.add(player.position, {
                                            x: 250 * (Math.random() - 0.5),
                                            y: 250 * (Math.random() - 0.5)
                                        }));
                                        Matter.Body.setVelocity(bullet[i], {
                                            x: 0,
                                            y: 0
                                        });
                                    }
                                }

                                //set holes
                                m.hole.isOn = true;
                                m.hole.pos1.x = m.pos.x
                                m.hole.pos1.y = m.pos.y
                                m.hole.pos2.x = player.position.x
                                m.hole.pos2.y = player.position.y
                                m.hole.angle = Math.atan2(sub.y, sub.x)
                                m.hole.unit = Vector.perp(Vector.normalise(sub))

                                if (tech.isWormholeDamage) {
                                    who = Matter.Query.ray(mob, m.pos, simulation.mouseInGame, 100)
                                    for (let i = 0; i < who.length; i++) {
                                        if (who[i].body.alive) {
                                            mobs.statusDoT(who[i].body, 1, 420)
                                            mobs.statusStun(who[i].body, 360)
                                        }
                                    }
                                }
                                if (tech.isNewWormHoleDamage) {
                                    const dmg = 1.5
                                    m.damageDone *= dmg
                                    simulation.ephemera.push({
                                        name: `wormholeDamage${m.cycle}`,
                                        count: 300, //cycles before it self removes
                                        do() {
                                            this.count--
                                            if (this.count < 0) {
                                                simulation.removeEphemera(this.name)
                                                m.damageDone /= dmg
                                            }
                                        },
                                    })
                                }
                            }
                        }

                        // if (true && m.energy > 0.5) { //teleport away low mass mobs
                        //     // && !(m.cycle % 1)
                        //     const hit = Matter.Query.region(mob, {
                        //         min: {
                        //             x: m.pos.x - 80,
                        //             y: m.pos.y - 80
                        //         },
                        //         max: {
                        //             x: m.pos.x + 80,
                        //             y: m.pos.y + 160
                        //         }
                        //     })

                        //     // find incoming mob with low mass
                        //     for (let i = 0; i < hit.length; i++) {
                        //         if (hit[i].mass < 4 && m.energy > hit[i].mass * 0.06) {
                        //             //is the mob moving towards the player?

                        //             // console.log('found one', hit[i].mass)
                        //             const unit = Vector.normalise(hit[i].velocity)
                        //             const jump = Vector.mult(unit, 200)
                        //             const where = Vector.add(hit[i].position, jump)
                        //             if (Matter.Query.ray(map, hit[i].position, where).length === 0) { // check if space 180 from mob is clear of body and map
                        //                 // m.energy -= hit[i].mass * 0.06
                        //                 // m.fieldCDcycle = m.cycle + 30;
                        //                 simulation.drawList.push({ x: hit[i].position.x, y: hit[i].position.y, radius: 20, color: "#fff", time: 16 });
                        //                 Matter.Body.setPosition(hit[i], where);
                        //                 simulation.drawList.push({ x: hit[i].position.x, y: hit[i].position.y, radius: 20, color: "#fff", time: 16 });
                        //             }
                        //             // break
                        //         }
                        //     }
                        // }
                    }
                    // if (input.field && m.fieldCDcycle < m.cycle) { //not hold but field button is pressed
                    //     const justPastMouse = Vector.add(Vector.mult(Vector.normalise(Vector.sub(simulation.mouseInGame, m.pos)), 50), simulation.mouseInGame)
                    //     const scale = 60
                    //     const sub = Vector.sub(simulation.mouseInGame, m.pos)
                    //     const mag = Vector.magnitude(sub)
                    //     const drain = tech.isFreeWormHole ? 0 : 0.06 + 0.006 * Math.sqrt(mag)
                    //     if (m.hole.isReady && mag > 250 && m.energy > drain) {
                    //         if (
                    //             Matter.Query.region(map, {
                    //                 min: {
                    //                     x: simulation.mouseInGame.x - scale,
                    //                     y: simulation.mouseInGame.y - scale
                    //                 },
                    //                 max: {
                    //                     x: simulation.mouseInGame.x + scale,
                    //                     y: simulation.mouseInGame.y + scale
                    //                 }
                    //             }).length === 0 &&
                    //             Matter.Query.ray(map, m.pos, justPastMouse).length === 0
                    //             // Matter.Query.ray(map, m.pos, simulation.mouseInGame).length === 0 &&
                    //             // Matter.Query.ray(map, player.position, simulation.mouseInGame).length === 0 &&
                    //             // Matter.Query.ray(map, player.position, justPastMouse).length === 0
                    //         ) {
                    //             m.energy -= drain
                    //             m.hole.isReady = false;
                    //             m.fieldRange = 0
                    //             Matter.Body.setPosition(player, simulation.mouseInGame);
                    //             m.buttonCD_jump = 0 //this might fix a bug with jumping
                    //             const velocity = Vector.mult(Vector.normalise(sub), 20)
                    //             Matter.Body.setVelocity(player, {
                    //                 x: velocity.x,
                    //                 y: velocity.y - 4 //an extra vertical kick so the player hangs in place longer
                    //             });
                    //             if (m.immuneCycle < m.cycle + 15) m.immuneCycle = m.cycle + 15; //player is immune to damage for 1/4 seconds 
                    //             // move bots to player
                    //             for (let i = 0; i < bullet.length; i++) {
                    //                 if (bullet[i].botType) {
                    //                     Matter.Body.setPosition(bullet[i], Vector.add(player.position, {
                    //                         x: 250 * (Math.random() - 0.5),
                    //                         y: 250 * (Math.random() - 0.5)
                    //                     }));
                    //                     Matter.Body.setVelocity(bullet[i], {
                    //                         x: 0,
                    //                         y: 0
                    //                     });
                    //                 }
                    //             }

                    //             //set holes
                    //             m.hole.isOn = true;
                    //             m.hole.pos1.x = m.pos.x
                    //             m.hole.pos1.y = m.pos.y
                    //             m.hole.pos2.x = player.position.x
                    //             m.hole.pos2.y = player.position.y
                    //             m.hole.angle = Math.atan2(sub.y, sub.x)
                    //             m.hole.unit = Vector.perp(Vector.normalise(sub))

                    //             if (tech.isWormholeDamage) {
                    //                 who = Matter.Query.ray(mob, m.pos, simulation.mouseInGame, 100)
                    //                 for (let i = 0; i < who.length; i++) {
                    //                     if (who[i].body.alive) {
                    //                         mobs.statusDoT(who[i].body, 1, 420)
                    //                         mobs.statusStun(who[i].body, 360)
                    //                     }
                    //                 }
                    //             }
                    //         } else {
                    //             //draw failed wormhole
                    //             const unit = Vector.perp(Vector.normalise(Vector.sub(simulation.mouseInGame, m.pos)))
                    //             const where = { x: m.pos.x + 30 * Math.cos(m.angle), y: m.pos.y + 30 * Math.sin(m.angle), }
                    //             m.fieldRange = 0.97 * m.fieldRange + 0.03 * (50 + 10 * Math.sin(simulation.cycle * 0.025))
                    //             const edge2a = Vector.add(Vector.mult(unit, 1.5 * m.fieldRange), simulation.mouseInGame)
                    //             const edge2b = Vector.add(Vector.mult(unit, -1.5 * m.fieldRange), simulation.mouseInGame)
                    //             ctx.beginPath();
                    //             ctx.moveTo(where.x, where.y)
                    //             ctx.bezierCurveTo(where.x, where.y, simulation.mouseInGame.x, simulation.mouseInGame.y, edge2a.x, edge2a.y);
                    //             ctx.lineTo(edge2b.x, edge2b.y)
                    //             ctx.bezierCurveTo(simulation.mouseInGame.x, simulation.mouseInGame.y, where.x, where.y, where.x, where.y);
                    //             // ctx.fillStyle = "rgba(255,255,255,0.5)"
                    //             // ctx.fill();
                    //             ctx.lineWidth = 1
                    //             ctx.strokeStyle = "#000"
                    //             ctx.lineDashOffset = 30 * Math.random()
                    //             ctx.setLineDash([20, 40]);
                    //             ctx.stroke();
                    //             ctx.setLineDash([]);
                    //         }
                    //     }
                    //     m.grabPowerUp();
                    // } else {
                    //     m.hole.isReady = true;
                    // }
                    m.drawRegenEnergy()
                }
            },

            // rewind: function() {
            //     if (input.down) {
            //         if (input.field && m.fieldCDcycle < m.cycle) { //not hold but field button is pressed
            //             const DRAIN = 0.01
            //             if (this.rewindCount < 289 && m.energy > DRAIN) {
            //                 m.energy -= DRAIN


            //                 if (this.rewindCount === 0) {
            //                     const shortPause = function() {
            //                         if (m.defaultFPSCycle < m.cycle) { //back to default values
            //                             simulation.fpsCap = simulation.fpsCapDefault
            //                             simulation.fpsInterval = 1000 / simulation.fpsCap;
            //                             // document.getElementById("dmg").style.transition = "opacity 1s";
            //                             // document.getElementById("dmg").style.opacity = "0";
            //                         } else {
            //                             requestAnimationFrame(shortPause);
            //                         }
            //                     };
            //                     if (m.defaultFPSCycle < m.cycle) requestAnimationFrame(shortPause);
            //                     simulation.fpsCap = 4 //1 is longest pause, 4 is standard
            //                     simulation.fpsInterval = 1000 / simulation.fpsCap;
            //                     m.defaultFPSCycle = m.cycle
            //                 }


            //                 this.rewindCount += 10;
            //                 simulation.wipe = function() { //set wipe to have trails
            //                     // ctx.fillStyle = "rgba(255,255,255,0)";
            //                     ctx.fillStyle = `rgba(221,221,221,${0.004})`;
            //                     ctx.fillRect(0, 0, canvas.width, canvas.height);
            //                 }
            //                 let history = m.history[(m.cycle - this.rewindCount) % 300]
            //                 Matter.Body.setPosition(player, history.position);
            //                 Matter.Body.setVelocity(player, { x: history.velocity.x, y: history.velocity.y });
            //                 if (history.health > m.health) {
            //                     m.health = history.health
            //                     m.displayHealth();
            //                 }
            //                 //grab power ups
            //                 for (let i = 0, len = powerUp.length; i < len; ++i) {
            //                     const dxP = player.position.x - powerUp[i].position.x;
            //                     const dyP = player.position.y - powerUp[i].position.y;
            //                     if (dxP * dxP + dyP * dyP < 50000 && !simulation.isChoosing && !(m.health === m.maxHealth && powerUp[i].name === "heal")) {
            //                         powerUps.onPickUp(player.position);
            //                         powerUp[i].effect();
            //                         Matter.Composite.remove(engine.world, powerUp[i]);
            //                         powerUp.splice(i, 1);
            //                         const shortPause = function() {
            //                             if (m.defaultFPSCycle < m.cycle) { //back to default values
            //                                 simulation.fpsCap = simulation.fpsCapDefault
            //                                 simulation.fpsInterval = 1000 / simulation.fpsCap;
            //                                 // document.getElementById("dmg").style.transition = "opacity 1s";
            //                                 // document.getElementById("dmg").style.opacity = "0";
            //                             } else {
            //                                 requestAnimationFrame(shortPause);
            //                             }
            //                         };
            //                         if (m.defaultFPSCycle < m.cycle) requestAnimationFrame(shortPause);
            //                         simulation.fpsCap = 3 //1 is longest pause, 4 is standard
            //                         simulation.fpsInterval = 1000 / simulation.fpsCap;
            //                         m.defaultFPSCycle = m.cycle
            //                         break; //because the array order is messed up after splice
            //                     }
            //                 }
            //                 m.immuneCycle = m.cycle + 5; //player is immune to damage for 30 cycles
            //             } else {
            //                 m.fieldCDcycle = m.cycle + 30;
            //                 // m.resetHistory();
            //             }
            //         } else {
            //             if (this.rewindCount !== 0) {
            //                 m.fieldCDcycle = m.cycle + 30;
            //                 m.resetHistory();
            //                 this.rewindCount = 0;
            //                 simulation.wipe = function() { //set wipe to normal
            //                     ctx.clearRect(0, 0, canvas.width, canvas.height);
            //                 }
            //             }
            //             m.holdingTarget = null; //clears holding target (this is so you only pick up right after the field button is released and a hold target exists)
            //         }
            //     }
            //     m.drawRegenEnergy()
            // },
        },
        {
            name: "grappling hook",
            description: `use <strong class='color-f'>energy</strong> to fire a hook that <strong>pulls</strong> you<br><strong>0.5x</strong> <strong class='color-defense'>damage taken</strong><br><strong>9</strong> <strong class='color-f'>energy</strong> per second`,
            effect: () => {
                m.fieldFire = true;
                // m.holdingMassScale = 0.01; //can hold heavier blocks with lower cost to jumping
                // m.fieldMeterColor = "#789"//"#456"
                m.eyeFillColor = m.fieldMeterColor
                m.fieldHarmReduction = 0.5; //40% reduction
                m.grabPowerUpRange2 = 300000 //m.grabPowerUpRange2 = 200000;

                m.hold = function () {
                    if (m.isHolding) {
                        m.drawHold(m.holdingTarget);
                        m.holding();
                        m.throwBlock();
                    } else if (input.field) {
                        m.holdingTarget = null; //clears holding target (this is so you only pick up right after the field button is released and a hold target exists)
                        if (m.fieldCDcycle < m.cycle) {
                            if (m.energy > 0.02) m.energy -= 0.02
                            b.grapple({ x: m.pos.x + 40 * Math.cos(m.angle), y: m.pos.y + 40 * Math.sin(m.angle) }, m.angle)
                            if (m.fieldCDcycle < m.cycle + 20) m.fieldCDcycle = m.cycle + 20
                        }
                        m.grabPowerUp();
                    } else {
                        m.holdingTarget = null; //clears holding target (this is so you only pick up right after the field button is released and a hold target exists)
                        if (tech.isHookDefense && m.energy > 0.15 && m.fieldCDcycle < m.cycle) {
                            const range = 300
                            for (let i = 0; i < mob.length; i++) {
                                if (!mob[i].isBadTarget &&
                                    !mob[i].isInvulnerable &&
                                    Vector.magnitude(Vector.sub(m.pos, mob[i].position)) < range &&
                                    Matter.Query.ray(map, m.pos, mob[i].position).length === 0
                                ) {
                                    m.energy -= 0.1
                                    if (m.fieldCDcycle < m.cycle + 20) m.fieldCDcycle = m.cycle + 20
                                    const angle = Math.atan2(mob[i].position.y - player.position.y, mob[i].position.x - player.position.x);
                                    b.harpoon(m.pos, mob[i], angle, 0.75, true, 20) // harpoon(where, target, angle = m.angle, harpoonSize = 1, isReturn = false, totalCycles = 35, isReturnAmmo = true, thrust = 0.1) {
                                    bullet[bullet.length - 1].drain = 0
                                    const maxCount = 6
                                    for (let j = maxCount - 1; j > 0; j--) {
                                        b.harpoon(m.pos, mob[i], angle + j * 2 * Math.PI / maxCount, 0.75, true, 10)
                                        bullet[bullet.length - 1].drain = 0
                                    }
                                    break
                                }
                            }
                            ctx.beginPath();
                            ctx.arc(m.pos.x, m.pos.y, range, 0, 2 * Math.PI);
                            ctx.strokeStyle = "#000";
                            ctx.lineWidth = 0.25;
                            ctx.setLineDash([10, 30]);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                    }
                    m.drawRegenEnergy()
                    //look for nearby mobs and fire harpoons at them
                }
            }
        },
    ],
    //************************************************************************************
    //************************************************************************************
    //*************************************  SHIP  ***************************************
    //************************************************************************************
    //************************************************************************************
    isShipMode: false,
    shipMode(thrust = 0.03, drag = 0.99, torque = 1.15, rotationDrag = 0.92) { //  m.shipMode() //thrust = 0.03, drag = 0.99, torque = 1.15, rotationDrag = 0.92
        if (!m.isShipMode) {
            //if wires remove them
            for (let i = 0; i < mob.length; i++) {
                if (!mob[i].freeOfWires) mob[i].freeOfWires = true
            }
            m.isShipMode = true
            // simulation.isCheating = true
            const points = [{
                x: 29.979168754143455,
                y: 4.748337243898336
            },
            {
                x: 27.04503734408824,
                y: 13.7801138209198
            },
            {
                x: 21.462582474874278,
                y: 21.462582475257523
            },
            {
                x: 13.780113820536943,
                y: 27.045037344471485
            },
            {
                x: 4.74833724351507,
                y: 29.979168754526473
            },
            {
                x: -4.748337245049098,
                y: 29.979168754526473
            },
            {
                x: -13.780113822071026,
                y: 27.045037344471485
            },
            {
                x: -21.46258247640829,
                y: 21.462582475257523
            },
            {
                x: -27.045037345621797,
                y: 13.7801138209198
            },
            {
                x: -29.979168755677012,
                y: 4.748337243898336
            },
            {
                x: -29.979168755677012,
                y: -4.7483372446656045
            },
            {
                x: -27.045037345621797,
                y: -13.78011382168726
            },
            {
                x: -21.46258247640829,
                y: -21.462582476024817
            },
            {
                x: -13.780113822071026,
                y: -27.045037345239006
            },
            {
                x: -4.748337245049098,
                y: -29.97916875529422
            },
            {
                x: 4.74833724351507,
                y: -29.97916875529422
            },
            {
                x: 13.780113820536943,
                y: -27.045037345239006
            },
            {
                x: 21.462582474874278,
                y: -21.462582476024817
            },
            {
                x: 27.04503734408824,
                y: -13.78011382168726
            },
            {
                x: 29.979168754143455,
                y: -4.7483372446656045
            }
            ]
            // 
            Matter.Body.setVertices(player, Matter.Vertices.create(points, player))
            player.parts.pop()
            player.parts.pop()
            player.parts.pop()
            player.parts.pop()
            // Matter.Body.setDensity(player, 0.01); //extra dense //normal is 0.001 //makes effective life much larger
            m.defaultMass = 30
            Matter.Body.setMass(player, m.defaultMass);
            player.friction = 0.01
            player.restitution = 0.2
            // player.frictionStatic = 0.1
            // Matter.Body.setInertia(player, Infinity); //disable rotation

            // const circle = Bodies.polygon(player.position.x, player.position.x, 30, 30)
            // player.parts[0] = circle
            // Matter.Body.setVertices(player.parts[0], Matter.Vertices.create(points, player.parts[0]))
            m.spin = 0
            // m.groundControl = () => {}         //disable entering ground
            m.onGround = false
            m.lastOnGroundCycle = 0
            // playerOnGroundCheck = () => {}
            m.airControl = () => { //tank controls
                player.force.y -= player.mass * simulation.g; //undo gravity
                Matter.Body.setVelocity(player, {
                    x: drag * player.velocity.x,
                    y: drag * player.velocity.y
                });
                if (input.up) { //forward thrust
                    player.force.x += thrust * Math.cos(m.angle) * m.squirrelJump
                    player.force.y += thrust * Math.sin(m.angle) * m.squirrelJump
                } else if (input.down) {
                    player.force.x -= 0.6 * thrust * Math.cos(m.angle)
                    player.force.y -= 0.6 * thrust * Math.sin(m.angle)
                }
                //rotation
                Matter.Body.setAngularVelocity(player, player.angularVelocity * rotationDrag)
                if (input.right) {
                    player.torque += torque
                } else if (input.left) {
                    player.torque -= torque
                }
                m.angle += m.spin
                m.angle = player.angle
            }





            // level.exit.drawAndCheck = () => { //fix this
            //     if (
            //         player.position.x > level.exit.x &&
            //         player.position.x < level.exit.x + 100 &&
            //         player.position.y > level.exit.y - 150 &&
            //         player.position.y < level.exit.y + 40
            //     ) {
            //         level.nextLevel()
            //     }
            // }
            m.move = () => {
                m.pos.x = player.position.x;
                m.pos.y = player.position.y;
                m.Vx = player.velocity.x;
                m.Vy = player.velocity.y;

                //tracks the last 10s of player information
                m.history.splice(m.cycle % 600, 1, {
                    position: {
                        x: player.position.x,
                        y: player.position.y,
                    },
                    velocity: {
                        x: player.velocity.x,
                        y: player.velocity.y
                    },
                    yOff: m.yOff,
                    angle: m.angle,
                    health: m.health,
                    energy: m.energy,
                    activeGun: b.activeGun
                });
            }

            m.look = () => { //disable mouse aiming
                const scale = 0.8;
                m.transSmoothX = canvas.width2 - m.pos.x - (simulation.mouse.x - canvas.width2) * scale;
                m.transSmoothY = canvas.height2 - m.pos.y - (simulation.mouse.y - canvas.height2) * scale;

                m.transX += (m.transSmoothX - m.transX) * 0.07;
                m.transY += (m.transSmoothY - m.transY) * 0.07;
            }

            simulation.camera = () => {
                const dx = simulation.mouse.x / window.innerWidth - 0.5 //x distance from mouse to window center scaled by window width
                const dy = simulation.mouse.y / window.innerHeight - 0.5 //y distance from mouse to window center scaled by window height
                const d = Math.max(dx * dx, dy * dy)
                simulation.edgeZoomOutSmooth = (1 + 4 * d * d) * 0.04 + simulation.edgeZoomOutSmooth * 0.96

                ctx.save();
                ctx.translate(canvas.width2, canvas.height2); //center
                ctx.scale(simulation.zoom / simulation.edgeZoomOutSmooth, simulation.zoom / simulation.edgeZoomOutSmooth); //zoom in once centered
                ctx.translate(-canvas.width2 + m.transX, -canvas.height2 + m.transY); //translate
                //calculate in game mouse position by undoing the zoom and translations
                simulation.mouseInGame.x = (simulation.mouse.x - canvas.width2) / simulation.zoom * simulation.edgeZoomOutSmooth + canvas.width2 - m.transX;
                simulation.mouseInGame.y = (simulation.mouse.y - canvas.height2) / simulation.zoom * simulation.edgeZoomOutSmooth + canvas.height2 - m.transY;
            }

            m.draw = () => { //just draw the circle
                ctx.save();
                ctx.globalAlpha = (m.immuneCycle < m.cycle) ? 1 : 0.5
                ctx.translate(player.position.x, player.position.y);
                ctx.rotate(player.angle);

                //thrust
                if (input.up) {
                    var grd2 = ctx.createLinearGradient(0, 0, -150, 0);
                    // grd2.addColorStop(0, 'rgba(255, 255, 155, 0.8)');
                    // grd2.addColorStop(1, 'rgba(255, 200, 0, 0.1)');
                    grd2.addColorStop(0, 'rgba(150, 200, 255, 0.7)');
                    grd2.addColorStop(1, 'rgba(150, 200, 255, 0)');
                    ctx.fillStyle = grd2;
                    ctx.beginPath();
                    ctx.moveTo(-18, -25);
                    //10 * (Math.random() - 0.5), 10 * (Math.random() - 0.5)
                    ctx.lineTo(-18, 25);
                    ctx.lineTo(-50 - 100 * Math.random(), 0);
                    ctx.fill();
                } else if (input.down) {
                    var grd2 = ctx.createLinearGradient(0, 0, 80, 0);
                    grd2.addColorStop(0, 'rgba(150, 200, 255, 0.7)');
                    grd2.addColorStop(1, 'rgba(150, 200, 255, 0)');
                    ctx.fillStyle = grd2;
                    ctx.beginPath();
                    ctx.moveTo(20, -16);
                    //10 * (Math.random() - 0.5), 10 * (Math.random() - 0.5)
                    ctx.lineTo(20, 16);
                    ctx.lineTo(35 + 43 * Math.random(), 0);
                    ctx.fill();
                }

                //body
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                ctx.fillStyle = m.bodyGradient
                ctx.fill();
                ctx.arc(15, 0, 4, 0, 2 * Math.PI);
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            }

            //fix collisions
            collisionChecks = function (event) {
                const pairs = event.pairs;
                for (let i = 0, j = pairs.length; i != j; i++) {
                    //mob + (player,bullet,body) collisions
                    for (let k = 0; k < mob.length; k++) {
                        if (mob[k].alive && m.alive) {
                            if (pairs[i].bodyA === mob[k]) {
                                collideMob(pairs[i].bodyB);
                                break;
                            } else if (pairs[i].bodyB === mob[k]) {
                                collideMob(pairs[i].bodyA);
                                break;
                            }

                            function collideMob(obj) {
                                //player + mob collision
                                if (
                                    m.immuneCycle < m.cycle &&
                                    // (obj === playerBody || obj === playerHead) &&
                                    (obj === player) &&
                                    !mob[k].isSlowed && !mob[k].isStunned
                                ) {
                                    mob[k].foundPlayer();
                                    let dmg = Math.min(Math.max(0.025 * Math.sqrt(mob[k].mass), 0.05), 0.3) * mob[k].damageScale();
                                    if (tech.isRewindAvoidDeath && (m.energy + 0.05) > Math.min(0.95, m.maxEnergy) && dmg > 0.01) { //CPT reversal runs in m.damage, but it stops the rest of the collision code here too
                                        m.takeDamage(dmg);
                                        return
                                    }
                                    m.takeDamage(dmg);
                                    if (tech.isPiezo) m.energy += 20.48 * level.isReducedRegen;
                                    if (tech.isStimulatedEmission) powerUps.ejectTech()
                                    if (mob[k].onHit) mob[k].onHit();
                                    if (m.immuneCycle < m.cycle + m.collisionImmuneCycles) m.immuneCycle = m.cycle + m.collisionImmuneCycles; //player is immune to damage for 30 cycles
                                    //extra kick between player and mob              //this section would be better with forces but they don't work...
                                    let angle = Math.atan2(player.position.y - mob[k].position.y, player.position.x - mob[k].position.x);
                                    Matter.Body.setVelocity(player, {
                                        x: player.velocity.x + 8 * Math.cos(angle),
                                        y: player.velocity.y + 8 * Math.sin(angle)
                                    });
                                    Matter.Body.setVelocity(mob[k], {
                                        x: mob[k].velocity.x - 8 * Math.cos(angle),
                                        y: mob[k].velocity.y - 8 * Math.sin(angle)
                                    });

                                    if (tech.isAnnihilation && !mob[k].shield && !mob[k].isShielded && !mob[k].isBoss && mob[k].isDropPowerUp && m.energy > 0.08) {
                                        m.energy -= 0.08 //* Math.max(m.maxEnergy, m.energy) //0.33 * m.energy
                                        m.immuneCycle = 0; //player doesn't go immune to collision damage
                                        mob[k].death();
                                        simulation.drawList.push({ //add dmg to draw queue
                                            x: pairs[i].activeContacts[0].vertex.x,
                                            y: pairs[i].activeContacts[0].vertex.y,
                                            radius: dmg * 1000,
                                            color: "rgba(255,0,255,0.2)",
                                            time: simulation.drawTime
                                        });
                                    } else {
                                        simulation.drawList.push({ //add dmg to draw queue
                                            x: pairs[i].activeContacts[0].vertex.x,
                                            y: pairs[i].activeContacts[0].vertex.y,
                                            radius: dmg * 500,
                                            color: simulation.mobDmgColor,
                                            time: simulation.drawTime
                                        });
                                    }
                                    return;
                                    // }
                                }
                                //mob + bullet collisions
                                if (obj.classType === "bullet" && obj.speed > obj.minDmgSpeed) {
                                    obj.beforeDmg(mob[k]); //some bullets do actions when they hits things, like despawn //forces don't seem to work here
                                    let dmg = (obj.dmg + 0.15 * obj.mass * Vector.magnitude(Vector.sub(mob[k].velocity, obj.velocity)))
                                    if (tech.isCrit && mob[k].isStunned) dmg *= 4
                                    mob[k].damage(dmg);
                                    if (mob[k].alive) mob[k].foundPlayer();
                                    if (mob[k].damageReduction) {
                                        simulation.drawList.push({ //add dmg to draw queue
                                            x: pairs[i].activeContacts[0].vertex.x,
                                            y: pairs[i].activeContacts[0].vertex.y,
                                            radius: Math.log(dmg + 1.1) * 40 * mob[k].damageReduction + 3,
                                            color: simulation.playerDmgColor,
                                            time: simulation.drawTime
                                        });
                                    }
                                    return;
                                }
                                //mob + body collisions
                                if (obj.classType === "body" && obj.speed > 6) {
                                    const v = Vector.magnitude(Vector.sub(mob[k].velocity, obj.velocity));
                                    if (v > 9) {
                                        let dmg = tech.blockDamage * v * obj.mass * (tech.isMobBlockFling ? 2 : 1);
                                        if (mob[k].isShielded) dmg *= 0.7
                                        mob[k].damage(dmg, true);
                                        if (tech.isBlockPowerUps && !mob[k].alive && mob[k].isDropPowerUp && Math.random() < 0.5) {
                                            let type = "ammo"
                                            if (Math.random() < 0.4) {
                                                type = "heal"
                                            } else if (Math.random() < 0.4 && !tech.isSuperDeterminism) {
                                                type = "research"
                                            }
                                            powerUps.spawn(mob[k].position.x, mob[k].position.y, type);
                                            // for (let i = 0, len = Math.ceil(2 * Math.random()); i < len; i++) {}
                                        }

                                        const stunTime = dmg / Math.sqrt(obj.mass)
                                        if (stunTime > 0.5) mobs.statusStun(mob[k], 30 + 60 * Math.sqrt(stunTime))
                                        if (mob[k].alive && mob[k].distanceToPlayer2() < 1000000 && !m.isCloak) mob[k].foundPlayer();
                                        if (tech.fragments && obj.speed > 10 && !obj.hasFragmented) {
                                            obj.hasFragmented = true;
                                            b.targetedNail(obj.position, tech.fragments * 4)
                                        }
                                        if (mob[k].damageReduction) {
                                            simulation.drawList.push({
                                                x: pairs[i].activeContacts[0].vertex.x,
                                                y: pairs[i].activeContacts[0].vertex.y,
                                                radius: Math.log(dmg + 1.1) * 40 * mob[k].damageReduction + 3,
                                                color: simulation.playerDmgColor,
                                                time: simulation.drawTime
                                            });
                                        }
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    },
};
    </script>
    <script>
        let powerUp = [];

const powerUps = {
    ejectGraphic(color = "68, 102, 119") {
        simulation.drawList.push({
            x: m.pos.x,
            y: m.pos.y,
            radius: 100,
            color: `rgba(${color}, 0.8)`,
            time: 4
        });
        simulation.drawList.push({
            x: m.pos.x,
            y: m.pos.y,
            radius: 75,
            color: `rgba(${color}, 0.6)`,
            time: 8
        });
        simulation.drawList.push({
            x: m.pos.x,
            y: m.pos.y,
            radius: 50,
            color: `rgba(${color}, 0.3)`,
            time: 12
        });
        simulation.drawList.push({
            x: m.pos.x,
            y: m.pos.y,
            radius: 25,
            color: `rgba(${color}, 0.15)`,
            time: 16
        });
    },
    healGiveMaxEnergy: false, //for tech 1st ionization energy
    orb: {
        research(num = 1) {
            if (num === 1) return `<div class="research-circle"></div> `
            let text = '<span style="position:relative;">'
            for (let i = 0; i < num; i++) {
                text += `<div class="research-circle" style="position:absolute; top:1.5px; left:${i * 0.6}em;"></div>`
            }
            text += '</span> &nbsp; &nbsp; '
            for (let i = 0; i < num; i++) {
                text += '&nbsp; '
            }
            return text
        },
        ammo(num = 1) {
            switch (num) {
                case 1:
                    return `<div class="ammo-circle"></div>`
            }
            let text = '<span style="position:relative;">'
            for (let i = 0; i < num; i++) {
                text += `<div class="ammo-circle" style="position:absolute; top:1.5px; left:${i * 0.6}em;"></div>`
            }
            text += '</span> &nbsp; &nbsp; '
            for (let i = 0; i < num; i++) {
                text += '&nbsp; '
            }
            return text
        },
        heal(num = 1) {
            if (powerUps.healGiveMaxEnergy) {
                if (num === 1) return `<div class="heal-circle-energy"></div>`

                let text = '<span style="position:relative;">'
                for (let i = 0; i < num; i++) {
                    text += `<div class="heal-circle-energy" style="position:absolute; top:1px; left:${i * 0.6}em;"></div>`
                }
                text += '</span> &nbsp; &nbsp; '
                for (let i = 0; i < num; i++) text += '&nbsp; '
                return text
            } else {
                if (num === 1) return `<div class="heal-circle"></div>`

                let text = '<span style="position:relative;">'
                for (let i = 0; i < num; i++) {
                    text += `<div class="heal-circle" style="position:absolute; top:1px; left:${i * 0.6}em;"></div>`
                }
                text += '</span> &nbsp; &nbsp; '
                for (let i = 0; i < num; i++) text += '&nbsp; '
                return text
            }
        },
        tech(num = 1) {
            return `<div class="circle-grid tech tooltip" style="width: 1.32em; height: 1.32em;"><span class="tooltiptext color-m">tech</span></div>`
        },
        field(num = 1) {
            return `<div class="circle-grid field tooltip"><span class="tooltiptext color-f">field</span></div>`
        },
        gun(num = 1) {
            return `<div class="circle-grid gun tooltip"><span class="tooltiptext color-g">gun</span></div>`
        },
        gunTech(num = 1) {
            return `<div class="circle-grid tech tooltip" style="position:relative; top:-0.05em; left:0.55em;opacity:0.8;margin-left:-0.55em;"><span class="tooltiptext"><span class="color-g">gun</span><span class="color-m">tech</span></span></div>
                    <div class="circle-grid gun tooltip" style="position:relative; top:-0.05em; left:-0.55em; opacity:0.65;margin-right:-0.55em;"><span class="tooltiptext"><span class="color-g">gun</span><span class="color-m">tech</span></span></div>`
        },
        fieldTech(num = 1) {
            return `<div class="circle-grid tech tooltip" style="position:relative; top:-0.05em; left:0.55em;opacity:0.8;margin-left:-0.55em;"><span class="tooltiptext"><span class="color-f">field</span><span class="color-m">tech</span></span></div>
                    <div class="circle-grid field tooltip" style="position:relative; top:-0.05em; left:-0.55em;opacity:0.65;margin-right:-0.55em;"><span class="tooltiptext"><span class="color-f">field</span><span class="color-m">tech</span></span></div>`
        },
        coupling(num = 1) {
            switch (num) {
                case 1:
                    return `<div class="coupling-circle"></div>`
            }
            let text = '<span style="position:relative;">'
            for (let i = 0; i < num; i++) {
                text += `<div class="coupling-circle" style="position:absolute; top:1.5px; left:${i * 0.5}em;"></div>`
            }
            text += '</span> &nbsp; &nbsp;'
            for (let i = 0; i < num; i++) {
                text += '&thinsp; '
            }
            return text
        },
        boost(num = 1) {
            switch (num) {
                case 1:
                    return `<div class="boost-circle"></div>`
            }
            let text = '<span style="position:relative;">'
            for (let i = 0; i < num; i++) {
                text += `<div class="boost-circle" style="position:absolute; top:1.5px; left:${i * 8}px;"></div>`
            }
            text += '</span> &nbsp; &nbsp; '
            for (let i = 0; i < num; i++) {
                text += '&nbsp; '
            }
            return text
        },
    },
    totalPowerUps: 0, //used for tech that count power ups at the end of a level
    do() { },
    setPowerUpMode() {
        if (tech.duplicationChance() > 0 || tech.isAnthropicTech) {
            powerUps.draw = powerUps.drawDup
            if (tech.isPowerUpsVanish) {
                if (tech.isHealAttract) {
                    powerUps.do = () => {
                        powerUps.dupExplode();
                        powerUps.draw();
                        powerUps.attractHeal();
                    }
                } else {
                    powerUps.do = () => {
                        powerUps.dupExplode();
                        powerUps.draw();
                    }
                }
            } else if (tech.isHealAttract) {
                powerUps.do = () => {
                    powerUps.draw();
                    powerUps.attractHeal();
                }
            } else {
                powerUps.do = () => powerUps.draw();
            }
        } else {
            powerUps.draw = powerUps.drawCircle
            if (tech.isHealAttract) {
                powerUps.do = () => {
                    powerUps.draw();
                    powerUps.attractHeal();
                }
            } else {
                powerUps.do = powerUps.draw
            }
        }
    },
    draw() { },
    drawCircle() {
        ctx.globalAlpha = 0.4 * Math.sin(simulation.cycle * 0.15) + 0.6;
        for (let i = 0, len = powerUp.length; i < len; ++i) {
            ctx.beginPath();
            ctx.arc(powerUp[i].position.x, powerUp[i].position.y, powerUp[i].size, 0, 2 * Math.PI);
            ctx.fillStyle = powerUp[i].color;
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    },
    drawDup() {
        ctx.globalAlpha = 0.4 * Math.sin(simulation.cycle * 0.15) + 0.6;
        for (let i = 0, len = powerUp.length; i < len; ++i) {
            ctx.beginPath();
            if (powerUp[i].isDuplicated) {
                let vertices = powerUp[i].vertices;
                ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let j = 1; j < vertices.length; j++) {
                    ctx.lineTo(vertices[j].x, vertices[j].y);
                }
                ctx.lineTo(vertices[0].x, vertices[0].y);
            } else {
                ctx.arc(powerUp[i].position.x, powerUp[i].position.y, powerUp[i].size, 0, 2 * Math.PI);
            }
            ctx.fillStyle = powerUp[i].color;
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    },
    attractHeal() {
        for (let i = 0; i < powerUp.length; i++) { //attract heal power ups to player
            if (powerUp[i].name === "heal") {
                let attract = Vector.mult(Vector.normalise(Vector.sub(m.pos, powerUp[i].position)), 0.015 * powerUp[i].mass)
                powerUp[i].force.x += attract.x;
                powerUp[i].force.y += attract.y - powerUp[i].mass * simulation.g; //negate gravity
                Matter.Body.setVelocity(powerUp[i], Vector.mult(powerUp[i].velocity, 0.7));
            }
        }
    },
    dupExplode() {
        for (let i = 0, len = powerUp.length; i < len; ++i) {
            if (powerUp[i].isDuplicated) {
                if (Math.random() < 0.003 && !m.isTimeDilated) { //  (1-0.003)^240 = chance to be removed after 4 seconds,   240 = 4 seconds * 60 cycles per second
                    b.explosion(powerUp[i].position, 175 + (11 + 3 * Math.random()) * powerUp[i].size);
                    if (powerUp[i]) {
                        Matter.Composite.remove(engine.world, powerUp[i]);
                        powerUp.splice(i, 1);
                    }
                    break
                }
                if (Math.random() < 0.3) {  //draw electricity
                    const mag = Math.max(1, 4 + powerUp[i].size / 5)
                    let unit = Vector.rotate({ x: mag, y: mag }, 2 * Math.PI * Math.random())
                    let path = { x: powerUp[i].position.x + unit.x, y: powerUp[i].position.y + unit.y }
                    ctx.beginPath();
                    ctx.moveTo(path.x, path.y);
                    for (let i = 0; i < 6; i++) {
                        unit = Vector.rotate(unit, 4 * (Math.random() - 0.5))
                        path = Vector.add(path, unit)
                        ctx.lineTo(path.x, path.y);
                    }
                    ctx.lineWidth = 0.5 + 2 * Math.random();
                    ctx.strokeStyle = "#000"
                    ctx.stroke();
                }
            }
        }
    },
    choose(type, index) {
        if (type === "gun") {
            b.giveGuns(index)
            let text = `<div class="circle-grid gun"></div> &nbsp; b.giveGuns("<strong class='color-text'>${b.guns[index].name}</strong>")`
            if (b.inventory.length === 1) text += `<br>input.key.gun<span class='color-symbol'>:</span> ["<span class='color-text'>MouseLeft</span>"]`
            if (b.inventory.length === 2) text += `
            <br>input.key.nextGun<span class='color-symbol'>:</span> ["<span class='color-text'>${input.key.nextGun}</span>","<span class='color-text'>MouseWheel</span>"]
            <br>input.key.previousGun<span class='color-symbol'>:</span> ["<span class='color-text'>${input.key.previousGun}</span>","<span class='color-text'>MouseWheel</span>"]`
            simulation.inGameConsole(text);
        } else if (type === "field") {
            m.setField(index)
        } else if (type === "tech") {
            simulation.inGameConsole(`<div class="circle-grid tech"></div> &nbsp; <span class='color-var'>tech</span>.giveTech("<strong class='color-text'>${tech.tech[index].name}</strong>")`);
            tech.giveTech(index)
        }
        powerUps.endDraft(type);
    },
    showDraft() {
        simulation.isChoosing = true; //stops p from un pausing on key down

        //disable clicking for 1/2 a second to prevent mistake clicks
        document.getElementById("choose-grid").style.pointerEvents = "none";
        document.body.style.cursor = "none";
        setTimeout(() => {
            document.body.style.cursor = "auto";
            document.getElementById("choose-grid").style.pointerEvents = "auto";
            document.getElementById("choose-grid").style.transitionDuration = "0s";
        }, 400);

        if (!simulation.paused) {
            if (tech.isNoDraftPause || level.isNoPause) {
                document.getElementById("choose-grid").style.opacity = "1"
            } else {
                simulation.paused = true;
                document.getElementById("choose-grid").style.opacity = "1"
            }
            document.getElementById("choose-grid").style.transitionDuration = "0.5s"; //how long is the fade in on
            document.getElementById("choose-grid").style.visibility = "visible"

            requestAnimationFrame(() => {
                ctx.fillStyle = `rgba(150,150,150,0.9)`; //`rgba(221,221,221,0.6)`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            });
        }
    },
    endDraft(type, isCanceled = false) { //type should be a gun, tech, or field
        if (isCanceled) {
            if (tech.isCancelDuplication) {
                const value = 0.07
                tech.duplication += value
                simulation.inGameConsole(`tech.duplicationChance() <span class='color-symbol'>+=</span> ${value}`)
                simulation.circleFlare(value);
            }
            if (tech.isCancelRerolls) {
                for (let i = 0, len = 10 + 6 * Math.random(); i < len; i++) {
                    let spawnType
                    if (Math.random() < 0.4) {
                        spawnType = "ammo"
                    } else if (Math.random() < 0.33 && !tech.isSuperDeterminism) {
                        spawnType = "research"
                    } else {
                        spawnType = "heal"
                    }
                    powerUps.spawn(m.pos.x + 40 * (Math.random() - 0.5), m.pos.y + 40 * (Math.random() - 0.5), spawnType, false);
                }
            }
            if (tech.isCancelCouple) powerUps.spawnDelay("coupling", 10)
            if (tech.isCancelTech && tech.cancelTechCount === 0 && type !== "entanglement") {
                tech.cancelTechCount++
                // powerUps.research.use('tech')
                powerUps[type].effect();
                return
            }
        }

        if (tech.isAnsatz && powerUps.research.count < 1) {
            for (let i = 0; i < 3; i++) powerUps.spawn(m.pos.x + 40 * (Math.random() - 0.5), m.pos.y + 40 * (Math.random() - 0.5), "research", false);
        }
        // document.getElementById("choose-grid").style.display = "none"
        document.getElementById("choose-grid").style.visibility = "hidden"
        document.getElementById("choose-grid").style.opacity = "0"

        document.body.style.cursor = "none";
        // document.body.style.overflow = "hidden"
        // if (m.alive){}
        if (simulation.paused) requestAnimationFrame(cycle);
        if (m.alive) simulation.paused = false;
        simulation.isChoosing = false; //stops p from un pausing on key down
        build.unPauseGrid()
        if (m.immuneCycle < m.cycle + 15) m.immuneCycle = m.cycle + 15; //player is immune to damage for 30 cycles
        if (m.holdingTarget) m.drop();
    },
    animatePowerUpGrab(color) {
        simulation.ephemera.push({
            // name: "",
            count: 25, //cycles before it self removes
            do() {
                this.count -= 2
                if (this.count < 5) simulation.removeEphemera(this.name)

                ctx.beginPath();
                ctx.arc(m.pos.x, m.pos.y, Math.max(3, this.count), 0, 2 * Math.PI);
                ctx.fillStyle = color
                ctx.fill();
                // ctx.strokeStyle = "hsla(200,50%,61%,0.18)";
                // ctx.stroke();
            },
        })

    },
    instructions: {
        name: "instructions",
        color: "rgba(100,125,140,0.35)",
        size() {
            return 130
        },
        effect() {
            Matter.Body.setVelocity(player, { x: 0, y: 0 });//power up is so big it launches the player,  this stops that
            requestAnimationFrame(() => { //add a background behind the power up menu
                ctx.fillStyle = `rgba(150,150,150,0.9)`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            });
            powerUps.animatePowerUpGrab('rgba(0, 0, 0,0.6)')

            if (!simulation.paused) {
                simulation.paused = true;
                simulation.isChoosing = true; //stops p from un pausing on key down
                document.body.style.cursor = "auto";
                document.getElementById("choose-grid").style.pointerEvents = "auto";
                document.getElementById("choose-grid").style.transitionDuration = "0s";
            }
            //build level info
            document.getElementById("choose-grid").classList.add('choose-grid-no-images');
            document.getElementById("choose-grid").classList.remove('choose-grid');
            document.getElementById("choose-grid").style.gridTemplateColumns = "800px"//adjust this to increase the width of the whole menu, but mostly the center column
            let lore = localSettings.loreCount > 0 ? "lore.unlockTesting()               //press T to enter testing" : ""
            let text = `<div class="grid-container" style = "font-size:1rem;padding: 0px;"><pre> <strong>//console commands</strong>
 powerUps.instructions.effect()     //reproduce this message
 powerUps.warp.effect()             //warp to any level
 tech.giveTech("name")              //replace "name" with tech name
 m.setField("name")                 //standing wave  perfect diamagnetism  negative mass  molecular assembler  plasma torch  time dilation  metamaterial cloaking  pilot wave  wormhole  grappling hook
 b.giveGuns("name")                 //nail gun  shotgun  super balls  wave  missiles  grenades  spores  drones  foam  harpoon  mine  laser
 m.damageDone *= 2                   //2x damage
 m.immuneCycle = Infinity           //immune to damage            
 m.coyoteCycles = Infinity          //air jumps
 m.energy = 0                       //set energy
 m.health = 1                       //set health
 m.maxHealth = 1                    //set max health
 m.maxEnergy = 1                    //set max energy
 simulation.enableConstructMode()   //press T to build with mouse
 ${lore}

 Matter.Body.setPosition(player, simulation.mouseInGame);
 spawn.bodyRect(simulation.mouseInGame.x, simulation.mouseInGame.y, 50, 50)
 spawn.randomLevelBoss(simulation.mouseInGame.x, simulation.mouseInGame.y) 
 powerUps.spawn(m.pos.x, m.pos.y, "name") //tech gun field heal ammo research coupling boost instructions entanglement
 
 //this URL downloads newest version of n-gon 
 https://codeload.github.com/landgreen/n-gon/zip/refs/heads/master

              <strong>chrome</strong>                     <strong>firefox</strong>
 <strong>Win/Linux:</strong> Ctrl + Shift + J        Ctrl + Shift + J
       <strong>Mac:</strong> Cmd + Option + J        Cmd + Shift + J</pre></div><div class="choose-grid-module" id="exit" style="text-align: center;font-size: 1.3rem;">exit</div>`
            document.getElementById("choose-grid").innerHTML = text
            //show level info
            document.getElementById("choose-grid").style.opacity = "1"
            document.getElementById("choose-grid").style.transitionDuration = "0.3s"; //how long is the fade in on
            document.getElementById("choose-grid").style.visibility = "visible"
            document.getElementById("exit").addEventListener("click", () => {
                level.unPause()
                document.body.style.cursor = "none";
                //reset hide image style
                if (localSettings.isHideImages) {
                    document.getElementById("choose-grid").classList.add('choose-grid-no-images');
                    document.getElementById("choose-grid").classList.remove('choose-grid');
                } else {
                    document.getElementById("choose-grid").classList.add('choose-grid');
                    document.getElementById("choose-grid").classList.remove('choose-grid-no-images');
                }
            });
        },
    },
    warp: {
        name: "warp",
        color: "rgb(110,155,160)",
        size() {
            return 30
        },
        load(name) {
            level.levels[level.onLevel + 1] = name
            powerUps.warp.exit()
            level.nextLevel();
            // simulation.clearNow = true
        },
        exit() {
            level.unPause()
            document.body.style.cursor = "none";
            //reset hide image style
            if (localSettings.isHideImages) {
                document.getElementById("choose-grid").classList.add('choose-grid-no-images');
                document.getElementById("choose-grid").classList.remove('choose-grid');
            } else {
                document.getElementById("choose-grid").classList.add('choose-grid');
                document.getElementById("choose-grid").classList.remove('choose-grid-no-images');
            }
        },
        effect() {
            requestAnimationFrame(() => { //add a background behind the power up menu
                ctx.fillStyle = `rgba(150,150,150,0.9)`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            });
            powerUps.animatePowerUpGrab('rgba(0, 0, 0,0.6)')

            if (!simulation.paused) {
                simulation.paused = true;
                simulation.isChoosing = true; //stops p from un pausing on key down
                document.body.style.cursor = "auto";
                document.getElementById("choose-grid").style.pointerEvents = "auto";
                document.getElementById("choose-grid").style.transitionDuration = "0s";
            }
            //build level info
            document.getElementById("choose-grid").classList.add('choose-grid-no-images');
            document.getElementById("choose-grid").classList.remove('choose-grid');
            document.getElementById("choose-grid").style.gridTemplateColumns = "200px"//adjust this to increase the width of the whole menu, but mostly the center column
            let text = `<div class="choose-grid-module" style="font-size: 1.5rem;color:rgb(110,155,160);text-align:center;"><strong>WARP</strong></div>`
            text += `<div class="choose-grid-module" id="exit" style="font-size: 1rem;color:rgb(110,155,160);text-align:right;padding-right:5px;"><strong>cancel</strong></div>`
            text += `<div class="choose-grid-module" style="font-size: 1rem;color:rgb(110,155,160);background-color:#444;text-align:center;">level.uniqueLevels</div>`
            for (let i = 0; i < level.uniqueLevels.length; i++) {
                text += `<div class="choose-grid-module" style="font-size: 1rem;padding-left:5px;" onclick="powerUps.warp.load('${level.uniqueLevels[i]}')">${level.uniqueLevels[i]}</div>`   //id="uniqueLevels-warp-${i}"
            }
            text += `<div class="choose-grid-module" style="color:rgb(110,155,160);background-color:#444;text-align:center;">level.playableLevels</div>`
            for (let i = 0; i < level.playableLevels.length; i++) {
                text += `<div class="choose-grid-module" style="padding-left:5px;" onclick="powerUps.warp.load('${level.playableLevels[i]}')">${level.playableLevels[i]}</div>`
            }
            text += `<div class="choose-grid-module" style="color:rgb(110,155,160);background-color:#444;text-align:center;">level.communityLevels</div>`
            for (let i = 0; i < level.communityLevels.length; i++) {
                text += `<div class="choose-grid-module" style="padding-left:5px;" onclick="powerUps.warp.load('${level.communityLevels[i]}')">${level.communityLevels[i]}</div>`
            }
            text += `<div class="choose-grid-module" style="color:rgb(110,155,160);background-color:#444;text-align:center;">level.trainingLevels</div>`
            for (let i = 0; i < level.trainingLevels.length; i++) {
                text += `<div class="choose-grid-module" style="padding-left:5px;" onclick="powerUps.warp.load('${level.trainingLevels[i]}')">${level.trainingLevels[i]}</div>`
            }
            document.getElementById("choose-grid").innerHTML = text
            //show level info
            document.getElementById("choose-grid").style.opacity = "1"
            document.getElementById("choose-grid").style.transitionDuration = "0.3s"; //how long is the fade in on
            document.getElementById("choose-grid").style.visibility = "visible"

            document.getElementById("exit").addEventListener("click", () => {
                powerUps.warp.exit()
            });
        },
    },
    difficulty: {
        name: "difficulty",
        color: "#000",
        size() {
            return 80 / Math.pow(localSettings.difficultyMode, 1.5);
        },
        damageDone: 1,
        damageReduction: 1,
        setDamageAndDefense() {
            if (simulation.difficultyMode > 5) {
                this.damageReduction = 2
                this.damageDone = 0.5
            } else if (simulation.difficultyMode === 1) {
                this.damageReduction = 0.5
                this.damageDone = 2
            } else {
                this.damageReduction = 1
                this.damageDone = 1
            }
            spawn.setMobTypeSpawnOrder();
        },
        effect() {
            const initialDifficultyMode = simulation.difficultyMode
            requestAnimationFrame(() => { //add a background behind the power up menu
                ctx.fillStyle = `rgba(150,150,150,0.9)`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            });
            powerUps.animatePowerUpGrab('rgba(0, 0, 0,0.6)')

            if (!simulation.paused) {
                simulation.paused = true;
                simulation.isChoosing = true; //stops p from un pausing on key down
                document.body.style.cursor = "auto";
                document.getElementById("choose-grid").style.pointerEvents = "auto";
                document.getElementById("choose-grid").style.transitionDuration = "0s";
            }
            //build level info
            document.getElementById("choose-grid").classList.add('choose-grid-no-images');
            document.getElementById("choose-grid").classList.remove('choose-grid');
            document.getElementById("choose-grid").style.gridTemplateColumns = "340px" //adjust this to increase the width of the whole menu, but mostly the center column

            //<div class="row" id="constraint-1"><strong>0.87x</strong> <strong class='color-d'>damage</strong>, <strong>1.22x</strong> <strong class='color-defense'>damage taken</strong> per level<br><strong>+1</strong> boss on each level</div>
            //<div class="row" id="constraint-2"><strong>more</strong> mobs per level<br><strong>faster</strong> mobs per level</div>
            //<div class="row" id="constraint-3"><strong>0.87x</strong> <strong class='color-d'>damage</strong>, <strong>1.22x</strong> <strong class='color-defense'>damage taken</strong> per level<br><strong>+1</strong> random <strong class="constraint">constraint</strong> on each level</div>
            //<div class="row" id="constraint-4"><strong>+1</strong> boss on each level<br>bosses spawn <strong>1</strong> fewer ${powerUps.orb.tech()}</div>
            //<div class="row" id="constraint-5"><strong>0.87x</strong> <strong class='color-d'>damage</strong>, <strong>1.22x</strong> <strong class='color-defense'>damage taken</strong> per level<br><strong>+1</strong> random <strong class="constraint">constraint</strong> on each level</div>
            //<div class="row" id="constraint-6"><strong>0.5x</strong> initial <strong class='color-d'>damage</strong><br><strong>2x</strong> initial <strong class='color-defense'>damage taken</strong></div>

            /* <div class="row" id="constraint-1"><strong>0.85x</strong> <strong class='color-d'>damage</strong> per level<br><strong>1.25x</strong> <strong class='color-defense'>damage taken</strong> per level</div> */
            //                    <div class="row" id="constraint-2">spawn <strong>more</strong> mobs<br>mobs move <strong>faster</strong></div>
            // <div class="row" id="constraint-1">spawn higher <strong class="color-tier">TIER</strong> mobs<br>after every <strong>4</strong> levels</div>
            //<div class="row" id="constraint-4">one mob per level will<br>be from <strong>2</strong> <strong class="color-tier">TIER</strong> higher</div>
            let text = `
        <div>
            <div class="grid-container">
                <div class="left-column">
                    <input type="range" id="difficulty-slider" name="temp" type="range" step="1" value="1" min="1" max="7" list="values" dir="ltr"/>
                    <datalist id="values">
                        <option value="1"></option>
                        <option value="2"></option>
                        <option value="3"></option>
                        <option value="4"></option>
                        <option value="5"></option>
                        <option value="6"></option>
                        <option value="7"></option>
                    </datalist>
                </div>
                <div class="right-column">
                    <div class="row" id="constraint-1">increase mob <strong class="color-tier">TIER</strong><br>after every <strong>4</strong> levels</div>
                    <div class="row" id="constraint-2"><strong>0.5x</strong> <strong class='color-d'>damage</strong><br><strong>2x</strong> <strong class='color-defense'>damage taken</strong></div>
                    <div class="row" id="constraint-3">spawn a <strong>2nd boss</strong><br>bosses spawn <strong>fewer</strong> ${powerUps.orb.tech()}</div>
                    <div class="row" id="constraint-4">increase mob <strong class="color-tier">TIER</strong><br>after every <strong>3</strong> levels</div>
                    <div class="row" id="constraint-5"><strong>+1</strong> random <strong class="constraint">constraint</strong><br>fewer initial <strong>power ups</strong></div>
                    <div class="row" id="constraint-6"><strong>0.5x</strong> <strong class='color-d'>damage</strong><br><strong>2x</strong> <strong class='color-defense'>damage taken</strong></div>
                    <div class="row" id="constraint-7"><strong>+1</strong> random <strong class="constraint">constraint</strong><br>fewer ${powerUps.orb.tech()} spawn</div>
                </div>
                <div class="far-right-column">
                    <div id = "constraint-1-record">${localSettings.difficultyCompleted[1] ? "⚆" : " "}</div>
                    <div id = "constraint-2-record">${localSettings.difficultyCompleted[2] ? "⚆" : " "}</div>
                    <div id = "constraint-3-record">${localSettings.difficultyCompleted[3] ? "⚆" : " "}</div>
                    <div id = "constraint-4-record">${localSettings.difficultyCompleted[4] ? "⚆" : " "}</div>
                    <div id = "constraint-5-record">${localSettings.difficultyCompleted[5] ? "⚆" : " "}</div>
                    <div id = "constraint-6-record">${localSettings.difficultyCompleted[6] ? "⚇" : " "}</div>
                    <div id = "constraint-6-record">${localSettings.difficultyCompleted[7] ? "⚇" : " "}</div>
                </div>
            </div>
            <div class="choose-grid-module" id="choose-difficulty">confirm difficulty parameters</div>
        </div>`
            document.getElementById("choose-grid").innerHTML = text
            //show level info
            document.getElementById("choose-grid").style.opacity = "1"
            document.getElementById("choose-grid").style.transitionDuration = "0.5s"; //how long is the fade in on
            document.getElementById("choose-grid").style.visibility = "visible"
            document.getElementById("choose-difficulty").addEventListener("click", () => {
                level.unPause()
                document.body.style.cursor = "none";
                //reset hide image style
                if (localSettings.isHideImages) {
                    document.getElementById("choose-grid").classList.add('choose-grid-no-images');
                    document.getElementById("choose-grid").classList.remove('choose-grid');
                } else {
                    document.getElementById("choose-grid").classList.add('choose-grid');
                    document.getElementById("choose-grid").classList.remove('choose-grid-no-images');
                }
                if (level.levelsCleared === 0 && initialDifficultyMode !== simulation.difficultyMode) {
                    powerUps.difficulty.setDamageAndDefense()
                    //remove and respawn all power ups if difficulty mode was changed
                    for (let i = 0; i < powerUp.length; ++i) Matter.Composite.remove(engine.world, powerUp[i]);
                    powerUp = [];
                    level.initialPowerUps()
                    simulation.trails(30)
                }
            });

            let setDifficultyText = function (isReset = true) {
                for (let i = 1; i < 8; i++) {
                    const id = document.getElementById("constraint-" + i)
                    if (simulation.difficultyMode < i) {
                        id.style.opacity = "0.15"
                    } else {
                        id.style.opacity = "1"
                    }
                }
                if (isReset) {
                    lore.setTechGoal()
                    localSettings.difficultyMode = simulation.difficultyMode
                    powerUps.difficulty.setDamageAndDefense()
                    localSettings.levelsClearedLastGame = 0 //after changing difficulty, reset run history
                    localSettings.entanglement = undefined //after changing difficulty, reset stored tech
                    if (localSettings.isAllowed) localStorage.setItem("localSettings", JSON.stringify(localSettings)); //update local storage
                }
            }
            setDifficultyText(false)
            document.getElementById("difficulty-slider").value = simulation.difficultyMode
            document.getElementById("difficulty-slider").addEventListener("input", () => {
                simulation.difficultyMode = document.getElementById("difficulty-slider").value
                setDifficultyText()
                level.setConstraints()
            });
            for (let i = 1; i < 8; i++) {
                document.getElementById("constraint-" + i).addEventListener("click", () => {
                    simulation.difficultyMode = i
                    document.getElementById("difficulty-slider").value = simulation.difficultyMode
                    setDifficultyText()
                    level.setConstraints()
                });
            }
        },
    },
    coupling: {
        name: "coupling",
        color: "#0ae", //"#0cf",
        size() {
            return 13;
        },
        effect() {
            powerUps.animatePowerUpGrab('rgba(0, 170, 238,0.3)')

            m.couplingChange(1)
        },
        // spawnDelay(num) {
        //     let count = num
        //     let respawnDrones = () => {
        //         if (count > 0) {
        //             requestAnimationFrame(respawnDrones);
        //             if (!simulation.paused && !simulation.isChoosing) { //&& !(simulation.cycle % 2)
        //                 count--
        //                 const where = { x: m.pos.x + 50 * (Math.random() - 0.5), y: m.pos.y + 50 * (Math.random() - 0.5) }
        //                 powerUps.spawn(where.x, where.y, "coupling");
        //             }
        //         }
        //     }
        //     requestAnimationFrame(respawnDrones);
        // }
    },
    boost: {
        name: "boost",
        color: "#f55", //"#0cf",
        size() {
            return 11;
        },
        endCycle: 0,
        duration: null, //set by "tech: band gap"
        damage: null, //set by "tech: band gap"
        isDefense: false,
        effect() {
            powerUps.animatePowerUpGrab('rgba(255, 0, 0, 0.5)')
            powerUps.boost.endCycle = simulation.cycle + Math.floor(Math.max(0, powerUps.boost.endCycle - simulation.cycle) * 0.6) + powerUps.boost.duration //duration+seconds plus 2/3 of current time left
        },
        draw() {
            // console.log(this.endCycle)
            // if (powerUps.boost.endCycle > m.cycle) {
            //     ctx.strokeStyle = "rgba(255,0,0,0.8)" //m.fieldMeterColor; //"rgba(255,255,0,0.2)" //ctx.strokeStyle = `rgba(0,0,255,${0.5+0.5*Math.random()})`
            //     ctx.beginPath();
            //     const arc = (powerUps.boost.endCycle - m.cycle) / powerUps.boost.duration
            //     ctx.arc(m.pos.x, m.pos.y, 28, m.angle - Math.PI * arc, m.angle + Math.PI * arc); //- Math.PI / 2
            //     ctx.lineWidth = 4
            //     ctx.stroke();
            // }

            if (powerUps.boost.endCycle > simulation.cycle) {
                //gel that acts as if the wind is blowing it when player moves
                ctx.save();
                ctx.translate(m.pos.x, m.pos.y);
                m.velocitySmooth = Vector.add(Vector.mult(m.velocitySmooth, 0.8), Vector.mult(player.velocity, 0.2))
                ctx.rotate(Math.atan2(m.velocitySmooth.y, m.velocitySmooth.x))
                ctx.beginPath();
                const radius = 40
                const mag = 8 * Vector.magnitude(m.velocitySmooth) + radius
                ctx.arc(0, 0, radius, -Math.PI / 2, Math.PI / 2);
                ctx.bezierCurveTo(-radius, radius, -radius, 0, -mag, 0); // bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
                ctx.bezierCurveTo(-radius, 0, -radius, -radius, 0, -radius);
                const time = Math.min(0.5, (powerUps.boost.endCycle - simulation.cycle) / powerUps.boost.duration)
                ctx.fillStyle = `rgba(255,0,200,${time})`
                ctx.fill()
                ctx.strokeStyle = "#f09"
                ctx.lineWidth = 0.3 + 4 * time
                ctx.stroke();
                ctx.restore();
            }
        },
    },
    research: {
        count: 0,
        name: "research",
        color: "#f7b",
        size() {
            return 20;
        },
        effect() {
            powerUps.animatePowerUpGrab('rgba(255, 119, 187,0.3)')
            powerUps.research.changeRerolls(1)
        },
        isMakingBots: false, //to prevent bot fabrication from running 2 sessions at once
        changeRerolls(amount) {
            if (amount !== 0) powerUps.research.count += amount
            if (tech.isRerollBots && !this.isMakingBots) {
                let cycle = () => {
                    const cost = 2 + Math.floor(b.totalBots() / 3)
                    if (m.alive && powerUps.research.count >= cost) {
                        requestAnimationFrame(cycle);
                        this.isMakingBots = true

                        if (!simulation.paused && !simulation.isChoosing && !(simulation.cycle % 60)) {
                            powerUps.research.count -= cost
                            b.randomBot()
                            if (tech.renormalization) {
                                for (let i = 0; i < cost; i++) {
                                    if (Math.random() < 0.47) {
                                        m.fieldCDcycle = m.cycle + 20;
                                        powerUps.spawn(m.pos.x + 100 * (Math.random() - 0.5), m.pos.y + 100 * (Math.random() - 0.5), "research");
                                    }
                                }
                            }
                        }
                    } else {
                        this.isMakingBots = false
                    }
                }
                requestAnimationFrame(cycle);
            }

            if (tech.isDeathAvoid && document.getElementById("tech-anthropic")) {
                document.getElementById("tech-anthropic").innerHTML = `-${powerUps.research.count}`
            }
            if (tech.renormalization && Math.random() < 0.47 && amount < 0) {
                for (let i = 0, len = -amount; i < len; i++) powerUps.spawn(m.pos.x, m.pos.y, "research");
            }
            if (tech.isRerollHaste) {
                if (powerUps.research.count === 0) {
                    tech.researchHaste = 0.5;
                    b.setFireCD();
                } else {
                    tech.researchHaste = 1;
                    b.setFireCD();
                }
            }
        },
        currentRerollCount: 0,
        use(type) { //runs when you actually research a list of selections, type can be field, gun, or tech
            if (tech.isJunkResearch && powerUps.research.currentRerollCount < 2) {
                tech.addJunkTechToPool(0.01)
            } else {
                powerUps.research.changeRerolls(-1)
            }
            if (tech.isResearchDamage) {
                m.damageDone *= 1.05
                simulation.inGameConsole(`<span class='color-var'>tech</span>.damage *= ${1.05} //peer review`);
                tech.addJunkTechToPool(0.01)
            }
            powerUps.research.currentRerollCount++
            if (tech.isResearchReality) {
                m.switchWorlds("Ψ(t) collapse")
                simulation.trails()
                simulation.inGameConsole(`simulation.amplitude <span class='color-symbol'>=</span> ${Math.random()}`);
            }
            powerUps[type].effect();
        },
    },
    heal: {
        name: "heal",
        color: "#0eb",
        size() {
            return Math.sqrt(0.1 + 0.25) * 40 * (simulation.healScale ** 0.25) * Math.sqrt(tech.largerHeals * (tech.isHalfHeals ? 0.5 : 1)); //(simulation.healScale ** 0.25)  gives a smaller radius as heal scale goes down
        },
        effect() {
            if (!tech.isEnergyHealth && m.alive) {
                powerUps.animatePowerUpGrab('rgba(0, 238, 187,0.25)')
                let heal = (this.size / 40 / (simulation.healScale ** 0.25)) ** 2 //simulation.healScale is undone here because heal scale is already properly affected on m.addHealth()
                if (heal > 0) {
                    let overHeal = m.health + heal * simulation.healScale - m.maxHealth //used with tech.isOverHeal
                    const healOutput = Math.min(m.maxHealth - m.health, heal) * simulation.healScale
                    m.addHealth(heal);
                    if (healOutput > 0) simulation.inGameConsole(`<div class="circle-grid heal"></div> &nbsp; <span class='color-var'>m</span>.health <span class='color-symbol'>+=</span> ${(healOutput).toFixed(3)}`) // <br>${m.health.toFixed(3)}
                    if (tech.isOverHeal && overHeal > 0) { //tech quenching
                        tech.extraMaxHealth += 0.5 * overHeal //increase max health
                        m.setMaxHealth();
                        simulation.inGameConsole(`<div class="circle-grid heal"></div> &nbsp; <span class='color-var'>m</span>.maxHealth <span class='color-symbol'>+=</span> ${(0.3 * overHeal).toFixed(3)}`)
                        simulation.drawList.push({ //add dmg to draw queue
                            x: m.pos.x,
                            y: m.pos.y,
                            radius: Math.max(3, overHeal * 100 * simulation.healScale),
                            color: "#0eb",
                            time: simulation.drawTime
                        });
                    } else if (overHeal > 0.2) { //if leftover heals spawn a new spammer heal power up
                        requestAnimationFrame(() => {
                            powerUps.directSpawn(this.position.x, this.position.y, "heal", true, Math.min(1, overHeal) * 40 * (simulation.healScale ** 0.25))//    directSpawn(x, y, name, moving = true, mode = null, size = powerUps[name].size()) {
                        });
                    }
                    if (tech.isHealBrake) {
                        const totalTime = 1020
                        //check if you already have this effect
                        let foundActiveEffect = false
                        for (let i = 0; i < simulation.ephemera.length; i++) {
                            if (simulation.ephemera[i].name === "healPush") {
                                foundActiveEffect = true
                                simulation.ephemera[i].count = 0.5 * simulation.ephemera[i].count + totalTime //add time
                                simulation.ephemera[i].scale = 0.5 * (simulation.ephemera[i].scale + Math.min(Math.max(0.6, heal * 6), 2.3)) //take average of scale
                            }
                        }
                        if (!foundActiveEffect) {
                            simulation.ephemera.push({
                                name: "healPush",
                                count: totalTime, //cycles before it self removes
                                range: 0,
                                scale: Math.min(Math.max(0.7, heal * 4), 2.2), //typically heal is 0.35
                                do() {
                                    this.count--
                                    if (this.count < 0) simulation.removeEphemera(this.name)
                                    this.range = this.range * 0.99 + 0.01 * (300 * this.scale + 100 * Math.sin(m.cycle * 0.022))
                                    if (this.count < 120) this.range -= 5 * this.scale
                                    this.range = Math.max(this.range, 1) //don't go negative
                                    // const range = 300 + 100 * Math.sin(m.cycle * 0.022)
                                    for (let i = 0; i < mob.length; i++) {
                                        const distance = Vector.magnitude(Vector.sub(m.pos, mob[i].position))
                                        if (distance < this.range) {
                                            const cap = mob[i].isShielded ? 3 : 1
                                            if (mob[i].speed > cap && Vector.dot(mob[i].velocity, Vector.sub(m.pos, mob[i].position)) > 0) { // if velocity is directed towards player
                                                Matter.Body.setVelocity(mob[i], Vector.mult(Vector.normalise(mob[i].velocity), cap)); //set velocity to cap, but keep the direction
                                            }
                                        }
                                    }
                                    ctx.beginPath();
                                    ctx.arc(m.pos.x, m.pos.y, this.range, 0, 2 * Math.PI);
                                    ctx.fillStyle = "hsla(200,50%,61%,0.18)";
                                    ctx.fill();
                                },
                            })
                        }
                    }
                }
            }
            if (powerUps.healGiveMaxEnergy) {
                tech.healMaxEnergyBonus += 0.15 * tech.largerHeals * (tech.isHalfHeals ? 0.5 : 1)
                m.setMaxEnergy();
            }
        },
        spawn(x, y, size) { //used to spawn a heal with a specific size / heal amount, not normally used
            powerUps.directSpawn(x, y, "heal", false, size)
            if (!level.isNextLevelPowerUps && Math.random() < tech.duplicationChance()) {
                powerUps.directSpawn(x, y, "heal", false, size)
                powerUp[powerUp.length - 1].isDuplicated = true
            }
        }
    },
    ammo: {
        name: "ammo",
        color: "#467",
        size() {
            return 17;
        },
        effect() {
            const couplingExtraAmmo = (m.fieldMode === 10 || m.fieldMode === 0) ? 1 + 0.04 * m.coupling : 1
            if (b.inventory.length > 0) {
                powerUps.animatePowerUpGrab('rgba(68, 102, 119,0.25)')
                if (tech.isAmmoForGun && (b.activeGun !== null && b.activeGun !== undefined)) { //give extra ammo to one gun only with tech logistics
                    const name = b.guns[b.activeGun]
                    if (name.ammo !== Infinity) {
                        if (tech.ammoCap) {
                            name.ammo = Math.ceil(2 * name.ammoPack * tech.ammoCap * couplingExtraAmmo)
                        } else {
                            name.ammo += Math.ceil(2 * (Math.random() + Math.random()) * name.ammoPack * couplingExtraAmmo)
                        }
                    }
                } else { //give ammo to all guns in inventory
                    for (let i = 0, len = b.inventory.length; i < len; i++) {
                        const name = b.guns[b.inventory[i]]
                        if (name.ammo !== Infinity) {
                            if (tech.ammoCap) {
                                name.ammo = Math.ceil(name.ammoPack * tech.ammoCap * couplingExtraAmmo)
                            } else { //default ammo behavior
                                name.ammo += Math.ceil((Math.random() + Math.random()) * name.ammoPack * couplingExtraAmmo)
                            }
                        }
                    }
                }
                simulation.updateGunHUD();
            }
        }
    },
    cancelText(type) {
        if (tech.isSuperDeterminism || type === "constraint") {
            return `<div></div>`
        } else if (tech.isCancelTech && tech.cancelTechCount === 0) {
            return `<div class='cancel-card sticky' onclick='powerUps.endDraft("${type}",true)' style="width: 115px;"><span class="color-randomize">randomize</span></div>`
        } else if (level.levelsCleared === 0 && localSettings.isTrainingNotAttempted && b.inventory.length === 0) { //don't show cancel if on initial level and haven't done tutorial
            return `<div class='cancel-card sticky'  style="visibility: hidden;"></div>`
        } else {
            return `<div class='cancel-card sticky' onclick='powerUps.endDraft("${type}",true)' style="width: 85px;">cancel</div>`
        }
    },
    researchText(type) {
        let text = ""
        if (type === "entanglement") {
            text += `<div class='choose-grid-module entanglement flipX sticky' onclick='powerUps.endDraft("${type}",true)'>entanglement</div>`
        } else if (tech.isJunkResearch && powerUps.research.currentRerollCount < 2) {
            text += `<div onclick="powerUps.research.use('${type}')" class='research-card sticky'>` // style = "margin-left: 192px; margin-right: -192px;"
            text += `<div><div> <span style="position:relative;">`
            text += `<div class="circle-grid junk" style="position:absolute; top:0; left:${15 * i}px ;opacity:0.8; border: 1px #fff solid;width: 1.15em;height: 1.15em;"></div>`
            text += `</span>&nbsp; <span class='research-select'>pseudoscience</span></div></div></div>`
        } else if (powerUps.research.count > 0) {
            text += `<div onclick="powerUps.research.use('${type}')" class='research-card sticky' >` // style = "margin-left: 192px; margin-right: -192px;"
            text += `<div><div><span style="position:relative;">`
            for (let i = 0, len = Math.min(powerUps.research.count, 30); i < len; i++) text += `<div class="circle-grid research" style="font-size:0.82em; position:absolute; top:0; left:${(18 - len * 0.21) * i}px ;opacity:0.8; border: 1px #fff solid;"></div>`
            text += `</span>&nbsp; <span class='research-select'>${tech.isResearchReality ? "<span class='alt'>alternate reality</span>" : "research"}</span></div></div></div>`
        } else {
            text += `<div></div>`
        }
        return text
    },
    researchAndCancelText(type) {
        let text = `<div class='research-cancel'>`
        if (type === "constraint") {
            return
        } else if (type === "entanglement") {
            text += `<span class='research-card entanglement flipX' style="width: 275px;" onclick='powerUps.endDraft("${type}",true)'><span style="letter-spacing: 6px;">entanglement</span></span>`
        } else if (tech.isJunkResearch && powerUps.research.currentRerollCount < 2) {
            text += `<span onclick="powerUps.research.use('${type}')" class='research-card' style="width: 275px;float: left;">` // style = "margin-left: 192px; margin-right: -192px;"
            text += `<div><div><span style="position:relative;">`
            text += `<div class="circle-grid junk" style="position:absolute; top:0; left:${15 * i}px ;opacity:0.8; border: 1px #fff solid;width: 1.15em;height: 1.15em;"></div>`
            text += `</span>&nbsp; <span class='research-select'>${tech.isResearchReality ? "<span class='alt'>alternate reality</span>" : "research"}</span></div></div></span>`
        } else if (powerUps.research.count > 0) {
            text += `<span onclick="powerUps.research.use('${type}')" class='research-card' style="width: 275px;float: left;">` // style = "margin-left: 192px; margin-right: -192px;"
            text += `<div><div><span style="position:relative;">`
            let researchCap = 18
            if (tech.isCancelTech && tech.cancelTechCount === 0) researchCap -= 2
            if (canvas.width < 1951) researchCap -= 3
            if (canvas.width < 1711) researchCap -= 4
            for (let i = 0, len = Math.min(powerUps.research.count, researchCap); i < len; i++) {
                text += `<div class="circle-grid research" style="font-size:0.82em; position:absolute; top:0; left:${(18 - len * 0.21) * i}px ;opacity:0.8; border: 1px #fff solid;"></div>`
            }
            text += `</span>&nbsp; <span class='research-select'>${tech.isResearchReality ? "<span class='alt'>alternate reality</span>" : "research"}</span></div></div></span>`
        } else {
            text += `<span class='research-card' style="width: 275px;float: right; background-color: #aaa;color:#888;">research</span>` //&zwnj;
        }
        if (tech.isSuperDeterminism) {
            text += `<span class='cancel-card' style="width: 95px;float: right;background-color: #aaa;color:#888;">cancel</span>`
        } else if (tech.isCancelTech && tech.cancelTechCount === 0) {
            text += `<span class='cancel-card' onclick='powerUps.endDraft("${type}",true)' style="width: 115px;float: right;font-size:0.9em;padding-top:5px;"><span class="color-randomize">randomize</span></span>`
        } else if (level.levelsCleared === 0 && localSettings.isTrainingNotAttempted && b.inventory.length === 0) {
            text += `<span class='cancel-card' style="visibility: hidden;">cancel</span>` //don't show cancel if on initial level and haven't done tutorial
        } else {
            text += `<span class='cancel-card' onclick='powerUps.endDraft("${type}",true)' style="width: 95px;float: right;">cancel</span>`
        }
        return text + "</div>"
    },
    buildColumns(totalChoices, type) {
        let width
        if (canvas.width < 1710) {
            width = "285px"
        } else if (canvas.width < 1950) {
            width = "340px"
        } else {
            width = "384px"
        }

        let text = ""
        if (localSettings.isHideImages) {
            document.getElementById("choose-grid").style.gridTemplateColumns = width
            text += powerUps.researchAndCancelText(type)
        } else if (totalChoices === 0) {
            document.getElementById("choose-grid").style.gridTemplateColumns = width
            text += powerUps.researchAndCancelText(type)
        } else if (totalChoices === 1 || canvas.width < 1200) {
            document.getElementById("choose-grid").style.gridTemplateColumns = width
            text += powerUps.researchAndCancelText(type)
            // console.log('hi')
            // text += powerUps.cancelText(type)
            // text += powerUps.researchText(type)
        } else if (totalChoices === 2) {
            document.getElementById("choose-grid").style.gridTemplateColumns = `repeat(2, ${width})`
            text += powerUps.researchText(type)
            text += powerUps.cancelText(type)
        } else {
            document.getElementById("choose-grid").style.gridTemplateColumns = `repeat(3, ${width})`
            text += "<div></div>"
            text += powerUps.researchText(type)
            text += powerUps.cancelText(type)
        }
        return text
    },
    hideStyle: `style="height:auto; border: none; background-color: transparent;"`,
    constraintText(choose, click) {
        return `<div class="choose-grid-module card-background" onclick="${click}" onauxclick="${click}"${powerUps.hideStyle}>
        <div class="card-text">
        <div class="grid-title"><div class="circle-grid field"></div> &nbsp; ${m.fieldUpgrades[choose].name}</div>
        ${m.fieldUpgrades[choose].description}</div></div>`
    },
    gunText(choose, click) {
        const style = localSettings.isHideImages ? powerUps.hideStyle : `style="background-image: url('img/gun/${b.guns[choose].name}.webp');"`
        return `<div class="choose-grid-module card-background" onclick="${click}" onauxclick="${click}" ${style}>
            <div class="card-text">
            <div class="grid-title"><div class="circle-grid gun"></div> &nbsp; ${b.guns[choose].name}</div>
            ${b.guns[choose].descriptionFunction()}</div></div>`
    },
    fieldText(choose, click) {
        const style = localSettings.isHideImages ? powerUps.hideStyle : `style="background-image: url('img/field/${m.fieldUpgrades[choose].name}${choose === 0 ? Math.floor(Math.random() * 10) : ""}.webp');"`
        return `<div class="choose-grid-module card-background" onclick="${click}" onauxclick="${click}"${style}>
        <div class="card-text">
        <div class="grid-title"><div class="circle-grid field"></div> &nbsp; ${m.fieldUpgrades[choose].name}</div>
        ${m.fieldUpgrades[choose].description}</div></div>`
    },
    techText(choose, click) {
        const techCountText = tech.tech[choose].count > 0 ? `(${tech.tech[choose].count + 1}x)` : "";
        const style = localSettings.isHideImages || tech.tech[choose].isLore ? powerUps.hideStyle : `style="background-image: url('img/${tech.tech[choose].name}.webp');"`
        return `<div class="choose-grid-module card-background" onclick="${click}" onauxclick="${click}"${style}>
                <div class="card-text">
                <div class="grid-title"><div class="circle-grid tech"></div> &nbsp; ${tech.tech[choose].name} ${techCountText}</div>
                ${tech.tech[choose].descriptionFunction ? tech.tech[choose].descriptionFunction() : tech.tech[choose].description}</div></div>`
    },
    instantTechText(choose, click) {
        const techCountText = tech.tech[choose].count > 0 ? `(${tech.tech[choose].count + 1}x)` : "";
        const style = localSettings.isHideImages || tech.tech[choose].isLore ? powerUps.hideStyle : `style="background-image: url('img/${tech.tech[choose].name}.webp');"`
        // <div class="circle-grid tech"></div>
        return `<div class="choose-grid-module card-background" onclick="${click}" onauxclick="${click}"${style}>
                <div class="card-text">
                <div class="grid-title"> <div class="circle-grid-instant"></div> &nbsp; ${tech.tech[choose].name} ${techCountText}</div>
                ${tech.tech[choose].descriptionFunction ? tech.tech[choose].descriptionFunction() : tech.tech[choose].description}</div></div>`
    },
    skinTechText(choose, click) {
        const techCountText = tech.tech[choose].count > 0 ? `(${tech.tech[choose].count + 1}x)` : "";
        const style = localSettings.isHideImages ? powerUps.hideStyle : `style="background-image: url('img/${tech.tech[choose].name}.webp');"`
        return `<div class="choose-grid-module card-background" onclick="${click}" onauxclick="${click}"${style}>
                <div class="card-text">
                <div class="grid-title">         
                <span style="position:relative;">
                    <div class="circle-grid-skin"></div>
                    <div class="circle-grid-skin-eye"></div>
                </span>
                &nbsp; &nbsp; &nbsp; &nbsp; ${tech.tech[choose].name} ${techCountText}</div>
                ${tech.tech[choose].descriptionFunction ? tech.tech[choose].descriptionFunction() : tech.tech[choose].description}</div></div>`
    },
    fieldTechText(choose, click) {
        const techCountText = tech.tech[choose].count > 0 ? `(${tech.tech[choose].count + 1}x)` : "";
        const style = localSettings.isHideImages ? powerUps.hideStyle : `style="background-image: url('img/${tech.tech[choose].name}.webp');"`
        return `<div class="choose-grid-module card-background" onclick="${click}" onauxclick="${click}"${style}>
                <div class="card-text">
                <div class="grid-title">
                <span style="position:relative;">
                    <div class="circle-grid tech" style="position:absolute; top:0; left:0;opacity:0.8;"></div>
                    <div class="circle-grid field" style="position:absolute; top:0; left:10px;opacity:0.65;"></div>
                </span>
                &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; ${tech.tech[choose].name} ${techCountText}</div>
                ${tech.tech[choose].descriptionFunction ? tech.tech[choose].descriptionFunction() : tech.tech[choose].description}</div></div>`
    },
    gunTechText(choose, click) {
        const techCountText = tech.tech[choose].count > 0 ? `(${tech.tech[choose].count + 1}x)` : "";
        const style = localSettings.isHideImages ? powerUps.hideStyle : `style="background-image: url('img/${tech.tech[choose].name}.webp');"`
        return `<div class="choose-grid-module card-background" onclick="${click}" onauxclick="${click}"${style}>
                <div class="card-text">
                <div class="grid-title">         
                <span style="position:relative;">
                    <div class="circle-grid tech" style="position:absolute; top:0; left:0;opacity:0.8;"></div>
                    <div class="circle-grid gun" style="position:absolute; top:0; left:10px; opacity:0.65;"></div>
                </span>
                &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; ${tech.tech[choose].name} ${techCountText}</div>
                ${tech.tech[choose].descriptionFunction ? tech.tech[choose].descriptionFunction() : tech.tech[choose].description}</div></div>`
    },
    junkTechText(choose, click) {
        const techCountText = tech.tech[choose].count > 0 ? `(${tech.tech[choose].count + 1}x)` : "";
        const style = localSettings.isHideImages ? powerUps.hideStyle : `style="background-size: contain;background-repeat: no-repeat;background-image: url('img/junk.webp');"`
        if (!localSettings.isHideImages) {
            // setTimeout(() => { //delay so that the html element exists
            //     if (tech.tech[choose].url === undefined) { //if on url has been set yet
            //         const url = `https://api.openverse.engineering/v1/images/?q=${tech.tech[choose].name}`;
            //         fetch(url, { signal: AbortSignal.timeout(1000) }) //give up if it takes over 1 second
            //             .then((response) => response.json())
            //             .then((responseJson) => {
            //                 if (responseJson.results.length > 0) {
            //                     const index = Math.floor(Math.random() * responseJson.results.length) //randomly choose from the images
            //                     tech.tech[choose].url = responseJson.results[index].url //store the url
            //                     document.getElementById(`junk-${choose}`).style.backgroundImage = `url('${tech.tech[choose].url}')` //make the url the background image
            //                 }
            //             });
            //     } else {
            //         document.getElementById(`junk-${choose}`).style.backgroundImage = `url('${tech.tech[choose].url}')`
            //     }
            // }, 1);
            // setTimeout(() => { //delay so that the html element exists
            //     document.getElementById(`junk-${choose}`).style.backgroundImage = `url('${tech.tech[choose].url}')`
            // }, 1);
        }
        return `<div id = "junk-${choose}" class="choose-grid-module card-background" onclick="${click}" onauxclick="${click}"${style}>
                <div class="card-text">
                <div class="grid-title"><div class="circle-grid junk"></div> &nbsp; ${tech.tech[choose].name} ${techCountText}</div>
                ${tech.tech[choose].descriptionFunction ? tech.tech[choose].descriptionFunction() : tech.tech[choose].description}</div></div>`
    },
    incoherentTechText(choose, click) {
        // text += `<div class="choose-grid-module" style = "background-color: #efeff5; border: 0px; opacity:0.5; font-size: 60%; line-height: 130%; margin: 1px; padding-top: 6px; padding-bottom: 6px;"><div class="grid-title">${tech.tech[choose].name} <span style = "color: #aaa;font-weight: normal;font-size:80%;">- incoherent</span></div></div>`
        const style = localSettings.isHideImages ? powerUps.hideStyle : `style="background-image: url('img/${tech.tech[choose].name}.webp');"`
        return `<div class="choose-grid-module card-background" ${style}>
                <div class="card-text" style = "background-color: #efeff5;">
                <div class="grid-title" style = "color: #ddd;font-weight: normal;">incoherent</div> <br> <br>
                </div></div>`
    },
    gun: {
        name: "gun",
        color: "#26a",
        size() {
            return 35;
        },
        effect() {
            if (m.alive) {
                let options = [];
                for (let i = 0; i < b.guns.length; i++) {
                    if (!b.guns[i].have) options.push(i);
                }
                // console.log(options.length)
                if (options.length > 0 || !tech.isSuperDeterminism) {
                    let totalChoices = 2 + tech.extraChoices + (tech.isInPilot ? 1 : 3) * (m.fieldMode === 8) - level.fewerChoices
                    if (tech.isCancelTech && tech.cancelTechCount === 1) {
                        totalChoices *= 3
                        tech.cancelTechCount++
                    }
                    if (tech.isDeterminism) totalChoices = 1
                    totalChoices = Math.min(totalChoices, options.length)
                    function removeOption(index) {
                        for (let i = 0; i < options.length; i++) {
                            if (options[i] === index) {
                                options.splice(i, 1) //remove a previous choice from option pool
                                return
                            }
                        }
                    }
                    //check for guns that were a choice last time and remove them
                    for (let i = 0; i < b.guns.length; i++) {
                        if (options.length - 1 < totalChoices) break //you have to repeat choices if there are not enough choices left to display
                        if (b.guns[i].isRecentlyShown) removeOption(i)
                    }
                    for (let i = 0; i < b.guns.length; i++) b.guns[i].isRecentlyShown = false //reset recently shown back to zero
                    // if (options.length > 0) {
                    let text = powerUps.buildColumns(totalChoices, "gun")
                    for (let i = 0; i < totalChoices; i++) {
                        const choose = options[Math.floor(Math.seededRandom(0, options.length))] //pick an element from the array of options                        
                        // text += `<div class="choose-grid-module" onclick="powerUps.choose('gun',${choose})"><div class="grid-title"><div class="circle-grid gun"></div> &nbsp; ${b.guns[choose].name}</div> ${b.guns[choose].description}</div>`
                        text += powerUps.gunText(choose, `powerUps.choose('gun',${choose})`)

                        b.guns[choose].isRecentlyShown = true
                        removeOption(choose)
                        if (options.length < 1) break
                    }
                    if (tech.isExtraBotOption) {
                        const botTech = [] //make an array of bot options
                        for (let i = 0, len = tech.tech.length; i < len; i++) {
                            if (tech.tech[i].isBotTech && tech.tech[i].count < tech.tech[i].maxCount && tech.tech[i].allowed()) botTech.push(i)
                        }
                        if (botTech.length > 0) { //pick random bot tech
                            const choose = botTech[Math.floor(Math.random() * botTech.length)];
                            const techCountText = tech.tech[choose].count > 0 ? `(${tech.tech[choose].count + 1}x)` : "";
                            const style = localSettings.isHideImages ? powerUps.hideStyle : `style="background-image: url('img/${tech.tech[choose].name}.webp');"`
                            text += `<div class="choose-grid-module card-background" onclick="powerUps.choose('tech',${choose})" ${style}>
                                    <div class="card-text">
                                    <div class="grid-title"><span  style = "font-size: 150%;font-family: 'Courier New', monospace;">⭓▸●■</span> &nbsp; ${tech.tech[choose].name} ${techCountText}</div>
                                    ${tech.tech[choose].descriptionFunction ? tech.tech[choose].descriptionFunction() : tech.tech[choose].description}</div></div>`
                        }
                    }
                    if (tech.isOneGun && b.inventory.length > 0) text += `<div style = "color: #f24">replaces your current gun</div>`
                    document.getElementById("choose-grid").innerHTML = text
                    powerUps.showDraft();
                }
                // }
            }
        },
    },
    field: {
        name: "field",
        color: "#0cf",
        size() {
            return 45;
        },
        effect() {
            if (m.alive) {
                let options = [];
                for (let i = 1; i < m.fieldUpgrades.length; i++) { //skip field emitter
                    if (i !== m.fieldMode) options.push(i);
                }
                let totalChoices = 2 + tech.extraChoices + (tech.isInPilot ? 1 : 3) * (m.fieldMode === 8) - level.fewerChoices
                if (tech.isCancelTech && tech.cancelTechCount === 1) {
                    totalChoices *= 3
                    tech.cancelTechCount++
                }
                if (tech.isDeterminism) totalChoices = 1
                totalChoices = Math.max(1, Math.min(totalChoices, options.length))
                function removeOption(index) {
                    for (let i = 0; i < options.length; i++) {
                        if (options[i] === index) {
                            options.splice(i, 1) //remove a previous choice from option pool
                            return
                        }
                    }
                }
                //check for fields that were a choice last time and remove them
                for (let i = 0; i < m.fieldUpgrades.length; i++) {
                    if (options.length - 1 < totalChoices) break //you have to repeat choices if there are not enough choices left to display
                    if (m.fieldUpgrades[i].isRecentlyShown) removeOption(i)
                }
                for (let i = 0; i < m.fieldUpgrades.length; i++) m.fieldUpgrades[i].isRecentlyShown = false //reset recently shown back to zero

                if (options.length > 0 || tech.isExtraBotOption) {
                    let text = powerUps.buildColumns(totalChoices, "field")
                    for (let i = 0; i < totalChoices; i++) {
                        const choose = options[Math.floor(Math.seededRandom(0, options.length))] //pick an element from the array of options
                        //text += `<div class="choose-grid-module" onclick="powerUps.choose('field',${choose})"><div class="grid-title"><div class="circle-grid field"></div> &nbsp; ${m.fieldUpgrades[choose].name}</div> ${m.fieldUpgrades[choose].description}</div>`                         //default
                        text += powerUps.fieldText(choose, `powerUps.choose('field',${choose})`)
                        m.fieldUpgrades[choose].isRecentlyShown = true
                        removeOption(choose)
                        if (options.length < 1) break
                    }
                    if (tech.isExtraBotOption) {
                        const botTech = [] //make an array of bot options
                        for (let i = 0, len = tech.tech.length; i < len; i++) {
                            if (tech.tech[i].isBotTech && tech.tech[i].count < tech.tech[i].maxCount && tech.tech[i].allowed()) botTech.push(i)
                        }
                        if (botTech.length > 0) { //pick random bot tech
                            const choose = botTech[Math.floor(Math.random() * botTech.length)];
                            const techCountText = tech.tech[choose].count > 0 ? `(${tech.tech[choose].count + 1}x)` : "";
                            const style = localSettings.isHideImages ? powerUps.hideStyle : `style="background-image: url('img/${tech.tech[choose].name}.webp');"`
                            text += `<div class="choose-grid-module card-background" onclick="powerUps.choose('tech',${choose})" ${style}>
                                    <div class="card-text">
                                    <div class="grid-title"><span  style = "font-size: 150%;font-family: 'Courier New', monospace;">⭓▸●■</span> &nbsp; ${tech.tech[choose].name} ${techCountText}</div>
                                    ${tech.tech[choose].descriptionFunction ? tech.tech[choose].descriptionFunction() : tech.tech[choose].description}</div></div>`
                        }
                    }
                    document.getElementById("choose-grid").innerHTML = text
                    powerUps.showDraft();
                }
            }
        },
    },
    tech: {
        name: "tech",
        color: "hsl(246,100%,77%)", //"#a8f",
        size() {
            return 42;
        },
        effect() {
            if (m.alive) {
                // powerUps.animatePowerUpGrab('hsla(246, 100%, 77%,0.5)')
                let options = []; //generate all options
                optionLengthNoDuplicates = 0
                for (let i = 0; i < tech.tech.length; i++) {
                    if (tech.tech[i].count < tech.tech[i].maxCount && tech.tech[i].allowed() && !tech.tech[i].isBanished) {
                        if (tech.tech[i].frequency > 0) optionLengthNoDuplicates++
                        for (let j = 0, len = tech.tech[i].frequency; j < len; j++) options.push(i);
                    }
                }
                function removeOption(index) {
                    for (let i = options.length - 1; i > -1; i--) {
                        if (index === options[i]) {
                            options.splice(i, 1) //remove all copies of that option form the options array (some tech are in the options array multiple times because of frequency)
                            optionLengthNoDuplicates--
                        }
                        if (options.length < 1) return;
                    }
                }
                //set total choices
                let totalChoices = 3 + tech.extraChoices + (tech.isInPilot ? 1 : 3) * (m.fieldMode === 8) - level.fewerChoices
                if (tech.isCancelTech && tech.cancelTechCount === 1) {
                    totalChoices *= 3
                    tech.cancelTechCount++
                }
                if (tech.isDeterminism) totalChoices = 1
                totalChoices = Math.max(1, Math.min(totalChoices, options.length))

                if (optionLengthNoDuplicates < totalChoices + 1) { //if not enough options for all the choices
                    totalChoices = optionLengthNoDuplicates
                    if (tech.isBanish) { //when you run out of options eject banish
                        for (let i = 0, len = tech.tech.length; i < len; i++) {
                            if (tech.tech[i].name === "decoherence") powerUps.ejectTech(i, true)
                        }
                        simulation.inGameConsole(`decoherence <span class='color-var'>tech</span> ejected<br>options reset`)
                    }
                }
                if (tech.tooManyTechChoices) {
                    tech.tooManyTechChoices = false
                    totalChoices = optionLengthNoDuplicates
                }
                if (optionLengthNoDuplicates > totalChoices) { //check for tech that were a choice last time and remove them
                    for (let i = 0; i < tech.tech.length; i++) {
                        if (optionLengthNoDuplicates > totalChoices) {
                            if (tech.tech[i].isRecentlyShown) removeOption(i)
                        } else {
                            break //you have to repeat choices if there are not enough choices left to display
                        }

                    }
                }
                for (let i = 0; i < tech.tech.length; i++) tech.tech[i].isRecentlyShown = false //reset recently shown back to zero
                if (options.length > 0) {
                    let text = powerUps.buildColumns(totalChoices, "tech")

                    addTech = (choose) => {
                        if (tech.tech[choose].isFieldTech) {
                            text += powerUps.fieldTechText(choose, `powerUps.choose('tech',${choose})`)
                        } else if (tech.tech[choose].isGunTech) {
                            text += powerUps.gunTechText(choose, `powerUps.choose('tech',${choose})`)
                        } else if (tech.tech[choose].isJunk) {
                            text += powerUps.junkTechText(choose, `powerUps.choose('tech',${choose})`)
                        } else if (tech.tech[choose].isSkin) {
                            text += powerUps.skinTechText(choose, `powerUps.choose('tech',${choose})`)
                        } else if (tech.tech[choose].isInstant) {
                            text += powerUps.instantTechText(choose, `powerUps.choose('tech',${choose})`)
                        } else { //normal tech
                            text += powerUps.techText(choose, `powerUps.choose('tech',${choose})`)
                        }
                    }
                    if (tech.isRetain) {
                        for (let i = 0, len = powerUps.retainList.length; i < len; i++) {
                            //find index from name and add tech to options
                            for (let j = 0, len = tech.tech.length; j < len; j++) {
                                if (tech.tech[j].name === powerUps.retainList[i] && tech.tech[j].count < tech.tech[j].maxCount && tech.tech[j].allowed() && tech.tech[j].frequency > 0) { //&& !tech.tech[j].isRecentlyShown
                                    addTech(j)
                                }
                            }
                        }
                    }
                    for (let i = 0; i < totalChoices; i++) {
                        if (options.length < 1) break
                        if (Math.random() < tech.junkChance + level.junkAdded) { // choose is set to a random JUNK tech
                            const list = []
                            for (let i = 0; i < tech.tech.length; i++) {
                                if (tech.tech[i].isJunk) list.push(i)
                            }
                            chooseJUNK = list[Math.floor(Math.random() * list.length)]
                            if (tech.isRetain) powerUps.retainList.push(tech.tech[chooseJUNK].name)
                            text += powerUps.junkTechText(chooseJUNK, `powerUps.choose('tech',${chooseJUNK})`)
                        } else {
                            const choose = options[Math.floor(Math.seededRandom(0, options.length))] //pick an element from the array of options
                            if (tech.isBanish) {
                                tech.tech[choose].isBanished = true
                                if (i === 0) simulation.inGameConsole(`options.length = ${optionLengthNoDuplicates} <em class='color-text'>//removed from pool by decoherence</em>`)
                            }
                            removeOption(choose) //remove from future options pool to avoid repeats on this selection

                            //this flag prevents this option from being shown the next time you pick up a tech power up
                            //check if not extra choices from "path integral"
                            tech.tech[choose].isRecentlyShown = true
                            if (tech.isRetain && !powerUps.retainList.includes(tech.tech[choose].name)) powerUps.retainList.push(tech.tech[choose].name)
                            addTech(choose)
                        }
                    }
                    if (tech.isExtraBotOption) {
                        const botTech = [] //make an array of bot options
                        for (let i = 0, len = tech.tech.length; i < len; i++) {
                            if (tech.tech[i].isBotTech && tech.tech[i].count < tech.tech[i].maxCount && tech.tech[i].allowed() && !tech.tech[i].isRecentlyShown) botTech.push(i)
                        }
                        if (botTech.length > 0) { //pick random bot tech
                            // const choose = botTech[Math.floor(Math.random() * botTech.length)];
                            // const isCount = tech.tech[choose].count > 0 ? `(${tech.tech[choose].count+1}x)` : "";
                            // text += `<div class="choose-grid-module" onclick="powerUps.choose('tech',${choose})"><div class="grid-title">          <span  style = "font-size: 150%;font-family: 'Courier New', monospace;">⭓▸●■</span>  &nbsp; ${tech.tech[choose].name} ${isCount}</div>          ${tech.tech[choose].descriptionFunction ? tech.tech[choose].descriptionFunction() : tech.tech[choose].description}</div>`
                            const choose = botTech[Math.floor(Math.random() * botTech.length)];
                            const techCountText = tech.tech[choose].count > 0 ? `(${tech.tech[choose].count + 1}x)` : "";
                            const style = localSettings.isHideImages ? powerUps.hideStyle : `style="background-image: url('img/${tech.tech[choose].name}.webp');"`
                            text += `<div class="choose-grid-module card-background" onclick="powerUps.choose('tech',${choose})" ${style}>
                                    <div class="card-text">
                                    <div class="grid-title"><span  style = "font-size: 150%;font-family: 'Courier New', monospace;">⭓▸●■</span> &nbsp; ${tech.tech[choose].name} ${techCountText}</div>
                                    ${tech.tech[choose].descriptionFunction ? tech.tech[choose].descriptionFunction() : tech.tech[choose].description}</div></div>`
                        }
                    }
                    if (tech.isMassProduction) {
                        // const techOptions = [] //make an array of bot options
                        // for (let i = 0, len = tech.tech.length; i < len; i++) {
                        //     if (tech.tech[i].isMassProduction) techOptions.push(i)
                        // }
                        // if (techOptions.length > 0) { //pick random bot tech
                        //     const choose = techOptions[Math.floor(Math.random() * techOptions.length)];
                        //     const style = localSettings.isHideImages ? powerUps.hideStyle : `style="background-image: url('img/${tech.tech[choose].name}.webp');"`
                        //     text += `<div class="choose-grid-module card-background" onclick="powerUps.choose('tech',${choose})" ${style}>
                        //             <div class="card-text">
                        //             <div class="grid-title">${tech.tech[choose].name}</div>
                        //             ${tech.tech[choose].descriptionFunction ? tech.tech[choose].descriptionFunction() : tech.tech[choose].description}</div></div>`
                        // }
                        for (let i = 0, len = tech.tech.length; i < len; i++) {
                            if (tech.tech[i].isMassProduction) {
                                const style = localSettings.isHideImages ? powerUps.hideStyle : `style="background-image: url('img/${tech.tech[i].name}.webp');"`
                                text += `<div class="choose-grid-module card-background" onclick="powerUps.choose('tech',${i})" ${style}>
                                        <div class="card-text">
                                        <div class="grid-title">${tech.tech[i].name}</div>
                                        ${tech.tech[i].descriptionFunction ? tech.tech[i].descriptionFunction() : tech.tech[i].description}</div></div>`
                            }
                        }
                    }
                    if (tech.isExtraGunField) {
                        if (Math.random() > 0.5 && b.inventory.length < b.guns.length) {
                            let gunOptions = [];
                            for (let i = 0; i < b.guns.length; i++) {
                                if (!b.guns[i].have) gunOptions.push(i);
                            }
                            const pick = gunOptions[Math.floor(Math.seededRandom(0, gunOptions.length))] //pick an element from the array of options
                            // text += `<div class="choose-grid-module" onclick="powerUps.choose('gun',${pick})"><div class="grid-title"><div class="circle-grid gun"></div> &nbsp; ${b.guns[pick].name}</div> ${b.guns[pick].description}</div>`
                            text += powerUps.gunText(pick, `powerUps.choose('gun',${pick})`)
                        } else {
                            let fieldOptions = [];
                            for (let i = 1; i < m.fieldUpgrades.length; i++) { //skip field emitter
                                if (i !== m.fieldMode) fieldOptions.push(i);
                            }
                            const pick = fieldOptions[Math.floor(Math.seededRandom(0, fieldOptions.length))] //pick an element from the array of options
                            // text += `<div class="choose-grid-module" onclick="powerUps.choose('field',${pick})"><div class="grid-title"><div class="circle-grid field"></div> &nbsp; ${m.fieldUpgrades[pick].name}</div> ${m.fieldUpgrades[pick].description}</div>`
                            text += powerUps.fieldText(pick, `powerUps.choose('field',${pick})`)
                        }
                    }
                    if (tech.isBrainstorm && !tech.isBrainstormActive && !simulation.isChoosing) {
                        tech.isBrainstormActive = true
                        let count = 1
                        let timeStart = performance.now()
                        const cycle = (timestamp) => {
                            // if (timeStart === undefined) timeStart = timestamp
                            // console.log(timestamp, timeStart)
                            if (timestamp - timeStart > tech.brainStormDelay * count && simulation.isChoosing) {
                                count++
                                powerUps.tech.effect();
                                document.getElementById("choose-grid").style.pointerEvents = "auto"; //turn off the normal 500ms delay
                                document.body.style.cursor = "auto";
                                document.getElementById("choose-grid").style.transitionDuration = "0s";
                            }
                            if (count < 10 && simulation.isChoosing) {
                                requestAnimationFrame(cycle);
                            } else {
                                tech.isBrainstormActive = false
                            }
                        }
                        requestAnimationFrame(cycle);
                    }
                    document.getElementById("choose-grid").innerHTML = text
                    powerUps.showDraft();
                }
            }
        },
    },
    retainList: [],
    entanglement: {
        name: "entanglement",
        color: "#fff", //"hsl(248,100%,65%)",
        size() {
            return 40
        },
        effect() {
            if (m.alive && localSettings.entanglement) {
                // let text = ""
                // document.getElementById("choose-grid").style.gridTemplateColumns = "384px 384px 384px"
                let text = powerUps.buildColumns(3, "entanglement")

                // text += powerUps.researchText('tech')
                // text += "<div></div>"
                // text += "<div class='choose-grid-module entanglement flipX'>entanglement</div>"
                // text += `<div class='choose-grid-module' onclick='powerUps.endDraft("tech",true)' style="width: 82px; text-align: center;font-size: 1.1em;font-weight: 100;justify-self: end;">cancel</div>` //powerUps.cancelText('tech')
                if (localSettings.entanglement.fieldIndex && localSettings.entanglement.fieldIndex !== m.fieldMode) {
                    const choose = localSettings.entanglement.fieldIndex //add field
                    text += powerUps.fieldText(choose, `powerUps.choose('field',${choose})`)
                }
                for (let i = 0; i < localSettings.entanglement.gunIndexes.length; i++) { //add guns
                    const choose = localSettings.entanglement.gunIndexes[i]
                    //check if you always have this gun
                    let alreadyHasGun = false
                    for (let j = 0; j < b.inventory.length; j++) {
                        if (b.inventory[j] === choose) alreadyHasGun = true
                    }
                    // text += `<div class="choose-grid-module" onclick="powerUps.choose('gun',${gun})"><div class="grid-title"><div class="circle-grid gun"></div> &nbsp; ${b.guns[gun].name}</div> ${b.guns[gun].description}</div>`
                    if (!alreadyHasGun) text += powerUps.gunText(choose, `powerUps.choose('gun',${choose})`)
                }
                for (let i = 0; i < localSettings.entanglement.techIndexes.length; i++) { //add tech
                    let found = false;
                    let choose = undefined
                    for (let j = 0; j < tech.tech.length; j++) {
                        if (localSettings.entanglement.techIndexes[i] === tech.tech[j].name) {
                            choose = j;
                            found = true;
                            break;
                        }
                    }
                    if (found && tech.tech[choose]) {
                        const isCount = tech.tech[choose].count > 0 ? `(${tech.tech[choose].count + 1}x)` : "";
                        if (choose === null || tech.tech[choose].count + 1 > tech.tech[choose].maxCount || !tech.tech[choose].allowed()) {
                            text += powerUps.incoherentTechText(choose)
                        } else {
                            if (tech.tech[choose].isFieldTech) {
                                text += powerUps.fieldTechText(choose, `powerUps.choose('tech',${choose})`)
                            } else if (tech.tech[choose].isGunTech) {
                                text += powerUps.gunTechText(choose, `powerUps.choose('tech',${choose})`)
                            } else if (tech.tech[choose].isLore) {
                                text += `<div class="choose-grid-module" onclick="powerUps.choose('tech',${choose})"><div class="grid-title lore-text"><div class="circle-grid lore"></div> &nbsp; ${tech.tech[choose].name} ${isCount}</div>${tech.tech[choose].descriptionFunction ? tech.tech[choose].descriptionFunction() : tech.tech[choose].description}</div>`
                            } else if (tech.tech[choose].isJunk) {
                                text += powerUps.junkTechText(choose, `powerUps.choose('tech',${choose})`)
                            } else if (tech.tech[choose].isSkin) {
                                text += powerUps.skinTechText(choose, `powerUps.choose('tech',${choose})`)
                            } else if (tech.tech[choose].isInstant) {
                                text += powerUps.instantTechText(choose, `powerUps.choose('tech',${choose})`)
                            } else { //normal tech
                                text += powerUps.techText(choose, `powerUps.choose('tech',${choose})`)
                            }
                        }
                    }
                }
                document.getElementById("choose-grid").innerHTML = text
                powerUps.showDraft();
                localSettings.entanglement = undefined
                if (localSettings.isAllowed) localStorage.setItem("localSettings", JSON.stringify(localSettings)); //update local storage
            }
        },
    },
    spawnDelay(type, count, delay = 2) {
        count *= delay
        let cycle = () => {
            if (count > 0) {
                if (m.alive) requestAnimationFrame(cycle);
                if (!simulation.paused && !simulation.isChoosing && powerUp.length < 300) { //&& !(simulation.cycle % 2)
                    count--
                    if (!(count % delay)) {
                        const where = { x: m.pos.x + 50 * (Math.random() - 0.5), y: m.pos.y + 50 * (Math.random() - 0.5) }
                        powerUps.spawn(where.x, where.y, type);
                    }
                }
            }
        }
        requestAnimationFrame(cycle);
    },
    onPickUp(who) {
        powerUps.research.currentRerollCount = 0
        if (tech.isTechDamage && who.name === "tech") m.takeDamage(0.1)
        if (tech.isMassEnergy) m.energy += 2 * level.isReducedRegen;
        if (tech.isMineDrop && bullet.length < 150 && Math.random() < 0.5) {
            if (tech.isLaserMine && input.down) {
                b.laserMine(who.position)
            } else {
                b.mine(who.position, { x: 0, y: 0 }, 0)
            }
        }
        if (level.isNoDamage) level.noDamageCycle = m.cycle
    },
    spawnRandomPowerUp(x, y) { //mostly used after mob dies,  doesn't always return a power up
        if (!tech.isEnergyHealth && (Math.random() * Math.random() - 0.3 > Math.sqrt(m.health)) || Math.random() < 0.04) { //spawn heal chance is higher at low health
            powerUps.spawn(x, y, "heal");
            return;
        }
        if (Math.random() < 0.15 && b.inventory.length > 0) {
            powerUps.spawn(x, y, "ammo");
            return;
        }
        if (Math.random() < 0.0007 * (3 - b.inventory.length)) { //a new gun has a low chance for each not acquired gun up to 3
            powerUps.spawn(x, y, "gun");
            return;
        }
        if (Math.random() < 0.0016) {
            powerUps.spawn(x, y, "field");
            return;
        }
        if (tech.isCouplingPowerUps && Math.random() < 0.17) {
            powerUps.spawn(x, y, "coupling");
            return;
        }
        if (Math.random() < 0.02 || (tech.isBoostPowerUps && Math.random() < 0.14)) {
            powerUps.spawn(x, y, "boost");
            return;
        }
    },
    randomPowerUpCounter: 0,
    isFieldSpawned: false, //makes it so a field spawns once but not more times
    spawnBossPowerUp(x, y) { //boss spawns field and gun tech upgrades
        if (level.levels[level.onLevel] !== "final") {
            if (!powerUps.isFieldSpawned) {
                powerUps.isFieldSpawned = true
                powerUps.spawn(x, y, "field")
            } else {
                powerUpChance()
            }
            if (simulation.difficultyMode < 3) {//don't spawn 2nd or 3rd power up on difficulties with a second boss
                powerUpChance()
                // powerUps.spawn(x, y, "tech")
            }
            function powerUpChance() {
                powerUps.randomPowerUpCounter++
                if (powerUps.randomPowerUpCounter > Math.max(level.levelsCleared, 9) * 0.1 * Math.random()) {
                    powerUps.randomPowerUpCounter = 0; //reset odds
                    if (Math.random() < 0.97) {
                        powerUps.spawn(x, y, "tech")
                    } else {
                        powerUps.spawn(x, y, "gun")
                    }
                } else {
                    if (m.health < 0.65 && !tech.isEnergyHealth) {
                        powerUps.spawn(x, y, "heal");
                        powerUps.spawn(x, y, "heal");
                    } else {
                        powerUps.spawn(x, y, "ammo");
                        powerUps.spawn(x, y, "ammo");
                    }
                }
            }
            powerUps.spawn(x + 25, y - 25, "ammo", false);
            if (simulation.difficultyMode > 5) powerUps.spawn(x - 25, y - 50, "ammo", false);
            if (tech.isAddRemoveMaxHealth) {
                powerUps.spawn(x + 20, y, "tech", false)
                powerUps.spawn(x - 20, y, "research", false)
                powerUps.spawn(x - 40, y, "research", false)
                powerUps.spawn(x + 40, y, "research", false)
                powerUps.spawn(x, y + 20, "research", false)
                powerUps.spawn(x, y - 20, "heal", false)
                powerUps.spawn(x, y + 40, "heal", false)
                powerUps.spawn(x, y - 40, "heal", false)
            }
            if (tech.isResearchReality) powerUps.spawnDelay("research", 6)
            if (tech.isBanish) powerUps.spawnDelay("research", 3)
            if (tech.isCouplingNoHit) powerUps.spawnDelay("coupling", 9)
            // if (tech.isRerollDamage) powerUps.spawnDelay("research", 1)
        }
    },
    chooseRandomPowerUp(x, y) { //100% chance to drop a random power up    //used in spawn.debris
        if (Math.random() < 0.5) {
            powerUps.spawn(x, y, "heal", false);
        } else {
            powerUps.spawn(x, y, "ammo", false);
        }
    },
    addResearchToLevel() { //add a random power up to a location that has a mob,  mostly used to give each level a research
        if ((level.levelsCleared < 17 - simulation.difficultyMode * 3) && mob.length) { //don't spawn late game
            const index = Math.floor(Math.random() * mob.length)
            powerUps.spawn(mob[index].position.x, mob[index].position.y, "research");
        }
    },
    spawnStartingPowerUps(x, y) { //used for map specific power ups, mostly to give player a starting gun
        if (level.levelsCleared < 4 || simulation.difficultyMode < 2) { //runs on first 4 levels on all difficulties
            if (level.levelsCleared > 1 && simulation.difficultyMode < 7) powerUps.spawn(x, y, "tech")
            if (b.inventory.length === 0) {
                powerUps.spawn(x, y, "gun", false); //first gun
            } else if (tech.totalCount === 0) { //first tech
                powerUps.spawn(x - 22, y - 50, "ammo", false); //some ammo
                powerUps.spawn(x, y, "tech", false);
            } else if (b.inventory.length === 1) { //second gun or extra ammo
                if (Math.random() < 0.4) {
                    powerUps.spawn(x, y, "gun", false);
                } else {
                    for (let i = 0; i < 5; i++) powerUps.spawn(x, y, "ammo", false);
                }
            } else {
                for (let i = 0; i < 4; i++) powerUps.spawnRandomPowerUp(x, y);
            }
        } else { //after the first 4 levels just spawn a random power up
            for (let i = 0; i < 3; i++) powerUps.spawnRandomPowerUp(x, y);
        }
    },
    ejectTech(choose = 'random', isOverride = false) {
        if (!simulation.isChoosing || isOverride) {
            // console.log(tech.tech[choose].name, tech.tech[choose].count, tech.tech[choose].isInstant)
            //find which tech you have
            if (choose === 'random') {
                const have = []
                for (let i = 0; i < tech.tech.length; i++) {
                    if (tech.tech[i].count > 0 && !tech.tech[i].isInstant) have.push(i)
                }
                // if (have.length === 0) {
                //     for (let i = 0; i < tech.tech.length; i++) {
                //         if (tech.tech[i].count > 0) have.push(i)
                //     }
                // }

                if (have.length) {
                    choose = have[Math.floor(Math.random() * have.length)]
                    simulation.inGameConsole(`<span class='color-var'>tech</span>.remove("<strong class='color-text'>${tech.tech[choose].name}</strong>")`)

                    for (let i = 0; i < tech.tech[choose].count; i++) {
                        powerUps.directSpawn(m.pos.x, m.pos.y, "tech");
                    }
                    // remove a random tech from the list of tech you have
                    tech.removeCount += tech.tech[choose].count
                    tech.tech[choose].remove();
                    tech.totalCount -= tech.tech[choose].count
                    tech.tech[choose].count = 0;
                    tech.tech[choose].isLost = true;
                    simulation.updateTechHUD();
                    m.fieldCDcycle = m.cycle + 30; //disable field so you can't pick up the ejected tech
                    return true
                } else {
                    return false
                }
            } else if (tech.tech[choose].count && !tech.tech[choose].isInstant) {
                simulation.inGameConsole(`<span class='color-var'>tech</span>.remove("<strong class='color-text'>${tech.tech[choose].name}</strong>")`)

                for (let i = 0; i < tech.tech[choose].count; i++) {
                    powerUps.directSpawn(m.pos.x, m.pos.y, "tech");
                }
                // remove a random tech from the list of tech you have
                tech.tech[choose].remove();
                tech.totalCount -= tech.tech[choose].count
                tech.removeCount += tech.tech[choose].count
                tech.tech[choose].count = 0;
                tech.tech[choose].isLost = true;
                simulation.updateTechHUD();
                m.fieldCDcycle = m.cycle + 30; //disable field so you can't pick up the ejected tech
                return true
            } else {
                return false
            }
        }
    },
    pauseEjectTech(index) {
        if ((tech.isPauseEjectTech || simulation.testing) && !simulation.isChoosing && !tech.tech[index].isInstant) {
            // if (tech.tech[index].bonusResearch !== undefined && tech.tech[index].bonusResearch > powerUps.research.count) {
            //     tech.removeTech(index)
            // } else {
            // }
            tech.tech[index].frequency = 0 //banish tech
            powerUps.ejectTech(index)
            if (m.immuneCycle < m.cycle) m.takeDamage(tech.pauseEjectTech * 0.01, false)
            tech.pauseEjectTech *= 1.3
            document.getElementById(`${index}-pause-tech`).style.textDecoration = "line-through"
            document.getElementById(`${index}-pause-tech`).style.animation = ""
            document.getElementById(`${index}-pause-tech`).onclick = null
        }
    },
    randomize(where) { //makes a random power up convert into a random different power up
        //put 10 power ups close together
        const len = Math.min(10, powerUp.length)
        for (let i = 0; i < len; i++) { //collide the first 10 power ups
            const unit = Vector.rotate({ x: 1, y: 0 }, 6.28 * Math.random())
            Matter.Body.setPosition(powerUp[i], Vector.add(where, Vector.mult(unit, 20 + 25 * Math.random())));
            Matter.Body.setVelocity(powerUp[i], Vector.mult(unit, 20));
        }

        //count big power ups and small power ups
        let options = ["heal", "research", tech.isBoostReplaceAmmo ? "boost" : "ammo"]
        if (m.coupling) options.push("coupling")
        if (tech.isBoostPowerUps) options.push("boost")

        let bigIndexes = []
        let smallIndexes = []
        for (let i = 0; i < powerUp.length; i++) {
            if (powerUp[i].name === "tech" || powerUp[i].name === "gun" || powerUp[i].name === "field") {
                bigIndexes.push(i)
            } else {
                smallIndexes.push(i)
            }
        }

        if (smallIndexes.length > 2 && Math.random() < 0.66) {             // console.log("no big, at least 3 small can combine")
            for (let j = 0; j < 3; j++) {
                for (let i = 0; i < powerUp.length; i++) {
                    if (powerUp[i].name === "heal" || powerUp[i].name === "research" || powerUp[i].name === "ammo" || powerUp[i].name === "coupling" || powerUp[i].name === "boost") {
                        Matter.Composite.remove(engine.world, powerUp[i]);
                        powerUp.splice(i, 1);
                        break
                    }
                }
            }

            options = ["tech", "tech", "tech", "gun", "gun", "field"]
            powerUps.directSpawn(where.x, where.y, options[Math.floor(Math.random() * options.length)], false)
        } else if (bigIndexes.length > 0 && Math.random() < 0.5) { // console.log("at least 1 big can spilt")
            const index = bigIndexes[Math.floor(Math.random() * bigIndexes.length)]
            for (let i = 0; i < 3; i++) powerUps.directSpawn(where.x, where.y, options[Math.floor(Math.random() * options.length)], false)

            Matter.Composite.remove(engine.world, powerUp[index]);
            powerUp.splice(index, 1);
        } else if (smallIndexes.length > 0) { // console.log("no big, at least 1 small will swap flavors")
            const index = Math.floor(Math.random() * powerUp.length)
            options = options.filter(e => e !== powerUp[index].name); //don't repeat the current power up type
            powerUps.directSpawn(where.x, where.y, options[Math.floor(Math.random() * options.length)], false)
            Matter.Composite.remove(engine.world, powerUp[index]);
            powerUp.splice(index, 1);
        }
    },
    spawn(x, y, name, moving = true, size = powerUps[name].size()) {
        if ((!tech.isSuperDeterminism || (name !== 'research'))) {
            if (tech.isBoostReplaceAmmo && name === 'ammo') {
                name = 'boost'
                size = powerUps[name].size()
            }
            powerUps.directSpawn(x, y, name, moving, size)
            if (!level.isNextLevelPowerUps && Math.random() < tech.duplicationChance()) {
                powerUps.directSpawn(x, y, name, moving, size, true)
                powerUp[powerUp.length - 1].isDuplicated = true
                if (tech.isDupEnergy) m.energy *= 2
            }
        }
    },
    directSpawn(x, y, name, moving = true, size = powerUps[name].size(), isDuplicated = false) {
        if (level.isNextLevelPowerUps) {
            powerUps.powerUpStorage.push({ name: name, size: size })
            return
        }
        let index = powerUp.length;
        let properties = {
            density: 0.001,
            frictionAir: 0.03,
            restitution: 0.85,
            collisionFilter: {
                group: 0,
                category: cat.powerUp,
                mask: cat.map | cat.powerUp
            },
            color: powerUps[name].color,
            effect: powerUps[name].effect,
            name: powerUps[name].name,
            size: size
        }
        let polygonSides
        if (isDuplicated) {
            polygonSides = tech.isPowerUpsVanish ? 3 : Math.floor(4 + 2 * Math.random())
            properties.isDuplicated = true
        } else {
            properties.inertia = Infinity //prevents rotation for circles only
            polygonSides = 12
        }
        powerUp[index] = Matter.Bodies.polygon(x, y, polygonSides, size, properties);
        if (moving) Matter.Body.setVelocity(powerUp[index], { x: (Math.random() - 0.5) * 15, y: Math.random() * -9 - 3 });
        Composite.add(engine.world, powerUp[index]);
    },
    powerUpStorage: [],//used when power ups are sent to the next level (for the constraint, level.isNextLevelPowerUps)
};
    </script>
    <script>
        const tech = {
    totalCount: null,
    removeCount: 0,
    resetAllTech() {
        for (let i = 0, len = tech.tech.length; i < len; i++) {
            tech.tech[i].isLost = false
            tech.tech[i].isBanished = false
            tech.tech[i].remove();
            tech.tech[i].count = 0
            if (tech.tech[i].isJunk) {
                tech.tech[i].frequency = 0
            } else if (tech.tech[i].frequencyDefault) {
                tech.tech[i].frequency = tech.tech[i].frequencyDefault
            } else {
                tech.tech[i].frequency = 1
            }
            if (tech.tech[i].name === "heals" || tech.tech[i].name === "ammo" || tech.tech[i].name === "research") tech.tech[i].value = tech.tech[i].defaultValue
        }
        m.resetSkin();
        tech.removeCount = 0;
        tech.pauseEjectTech = 1; //used in paradigm shift
        lore.techCount = 0;
        tech.duplication = 0;
        m.damageDone = 1
        m.damageReduction = 1
        powerUps.difficulty.setDamageAndDefense()
        tech.junkChance = 0;
        tech.extraMaxHealth = 0;
        tech.totalCount = 0;
        simulation.updateTechHUD();
        simulation.updateGunHUD();
    },
    removeTech(index = 'random') {
        if (index === 'random') {
            const have = [] //find which tech you have
            for (let i = 0; i < tech.tech.length; i++) {
                if (tech.tech[i].count > 0 && !tech.tech[i].isInstant) have.push(i)
            }
            if (have.length) {
                index = have[Math.floor(Math.random() * have.length)]
            } else {
                return 0 //if none found don't remove any tech
            }
        } else if (isNaN(index)) { //find index by name
            let found = false;
            for (let i = 0; i < tech.tech.length; i++) {
                if (index === tech.tech[i].name) {
                    index = i;
                    found = true;
                    break;
                }
            }
            if (!found) return 0 //if name not found don't remove any tech
        }
        if (tech.tech[index].count === 0) return 0
        const totalRemoved = tech.tech[index].count
        simulation.inGameConsole(`<span class='color-var'>tech</span>.removeTech("<span class='color-text'>${tech.tech[index].name}</span>")`, 360)
        tech.tech[index].remove();
        tech.removeCount += totalRemoved
        tech.tech[index].count = 0;
        tech.totalCount -= totalRemoved
        // simulation.updateTechHUD();
        tech.tech[index].isLost = true
        simulation.updateTechHUD();
        return totalRemoved //return the total number of tech removed
    },
    junkChance: 0,
    addJunkTechToPool(percent) { //percent is number between 0-1
        tech.junkChance += percent
        if (tech.junkChance < 0.001 || tech.junkChance === undefined) tech.junkChance = 0
        if (tech.junkChance > 1) tech.junkChance = 1
        simulation.inGameConsole(`<strong>+${(100 * percent).toFixed(0)}%</strong> <span class='color-text'>JUNK</span><span class='color-var'>tech</span> chance (${(100 * tech.junkChance).toFixed(0)}% total chance)`)
        // tech.junkChance += (1 - tech.junkChance) * percent
        return percent

        //make an array for possible junk tech to add
        // let options = [];
        // for (let i = 0; i < tech.tech.length; i++) {
        //     if (tech.tech[i].count < tech.tech[i].maxCount && tech.tech[i].isJunk) options.push(i);
        // }
        // if (options.length) {
        //     let countNonJunk = 0 // count total non junk tech
        //     for (let i = 0, len = tech.tech.length; i < len; i++) {
        //         if (tech.tech[i].count < tech.tech[i].maxCount && tech.tech[i].allowed() && !tech.tech[i].isJunk) countNonJunk += tech.tech[i].frequency
        //     }
        //     const num = Math.ceil(percent * countNonJunk) //scale number added
        //     for (let i = 0; i < num; i++) tech.tech[options[Math.floor(Math.random() * options.length)]].frequency++ //add random array options to tech pool
        //     simulation.inGameConsole(`<span class='color-var'>tech</span>.tech.push(${num.toFixed(0)} <span class='color-text'>JUNK</span>)`)
        //     return num
        // } else {
        //     return 0
        // }
    },
    removeJunkTechFromPool(percent) {
        // for (let j = 0; j < num; j++) {
        //     for (let i = 0; i < tech.tech.length; i++) {
        //         if (tech.tech[i].isJunk && tech.tech[i].frequency > 0 && tech.tech[i].count < tech.tech[i].maxCount) {
        //             tech.tech[i].frequency--
        //             break
        //         }
        //     }
        // }

        // if (percent > 0) {
        //     tech.junkChance = (tech.junkChance - percent) / (1 - percent)
        //     if (tech.junkChance < 0.001 || tech.junkChance === undefined) tech.junkChance = 0
        // }
        tech.junkChance -= percent
        if (tech.junkChance < 0.001 || tech.junkChance === undefined) tech.junkChance = 0
        if (tech.junkChance > 1) tech.junkChance = 1
    },
    giveTech(index = 'random') {
        if (index === 'random') {
            let options = [];
            for (let i = 0; i < tech.tech.length; i++) {
                if (tech.tech[i].count < tech.tech[i].maxCount && tech.tech[i].allowed() && !tech.tech[i].isJunk && !tech.tech[i].isLore && !tech.tech[i].isBadRandomOption) options.push(i);
            }
            // give a random tech from the tech I don't have
            if (options.length > 0) {
                let newTech = options[Math.floor(Math.random() * options.length)]
                simulation.inGameConsole(`<span class='color-var'>tech</span>.giveTech("<strong class='color-text'>${tech.tech[newTech].name}</strong>")<em> //random tech</em>`);
                tech.giveTech(newTech)
            }
        } else {
            if (isNaN(index)) { //find index by name
                let found = false;
                for (let i = 0; i < tech.tech.length; i++) {
                    if (index === tech.tech[i].name) {
                        index = i;
                        found = true;
                        break;
                    }
                }
                if (!found) return //if name not found don't give any tech
            }
            if (tech.isMetaAnalysis && tech.tech[index].isJunk) {
                simulation.inGameConsole(`//tech: meta-analysis replaced junk tech with random tech`);
                tech.giveTech('random')
                for (let i = 0; i < 2; i++) powerUps.spawn(m.pos.x + 40 * Math.random(), m.pos.y + 40 * Math.random(), "research");
                return
            }

            if (tech.tech[index].isLost) tech.tech[index].isLost = false; //give specific tech
            if (tech.isBanish && tech.tech[index].isBanished) tech.tech[index].isBanished = false //stops the bug where you can't gets stacks of tech you take with decoherence, I think
            if (tech.isDamageFieldTech && tech.tech[index].isFieldTech) {
                m.damageDone *= 1.3
                // simulation.inGameConsole(`<strong class='color-d'>damage</strong> <span class='color-symbol'>*=</span> ${1.05}`)
                simulation.inGameConsole(`<span class='color-var'>tech</span>.damage *= ${1.1} //hidden-variable theory`);
            }
            tech.tech[index].effect(); //give specific tech
            tech.tech[index].count++
            if (!tech.tech[index].isInstant) tech.totalCount++ //used in power up randomization
            if (tech.isWiki) {
                async function getWikipediaIntro(subject) {
                    // const searchEndpoint = `https://en.wikipedia.org/w/api.php?action=query&prop=extracts&exintro&explaintext&titles=${encodeURIComponent(subject).replace(/' /g, '%27')}&format=json&origin=*`;
                    const searchEndpoint = `https://en.wikipedia.org/w/api.php?action=opensearch&search=${encodeURIComponent(subject).replace(/' /g, '%27')}&limit=1&namespace=0&format=json&origin=*`;
                    try {
                        // Perform a search to get the closest matching title
                        const searchResponse = await fetch(searchEndpoint);
                        const searchData = await searchResponse.json();
                        if (searchData[1].length === 0) throw new Error('No matching pages found');
                        const closestTitle = searchData[1][0];
                        // Use the closest matching title to get the page content
                        const contentEndpoint = `https://en.wikipedia.org/w/api.php?action=query&prop=extracts&exintro&explaintext&titles=${encodeURIComponent(closestTitle)}&format=json&origin=*`;
                        const contentResponse = await fetch(contentEndpoint);
                        const contentData = await contentResponse.json();
                        const pages = contentData.query.pages;
                        const pageId = Object.keys(pages)[0];
                        return pages[pageId].extract
                    } catch (error) {
                        console.error('Error fetching Wikipedia intro:', error);
                    }
                }
                const subject = tech.tech[index].name
                getWikipediaIntro(subject).then(intro => {
                    let tab = window.open(`https://en.wikipedia.org/w/index.php?search=${encodeURIComponent(subject).replace(/' /g, '%27')}&title=Special:Search`, "_blank");
                    if (tab) {
                        let checkInterval = setInterval(() => {
                            if (tab.closed) {
                                clearInterval(checkInterval); // Stop checking once the tab is closed

                                const introArray = intro.split(" ")
                                const wordLimit = 7
                                const wordNumber = Math.ceil(Math.random() * wordLimit)
                                const answer = prompt(`On the wikipedia page for ${subject} what is word ${wordNumber + 1}?`)
                                console.log(introArray[wordNumber])
                                if (introArray[wordNumber]) {
                                    if (answer && answer.toLowerCase() === introArray[wordNumber].toLowerCase().replace(/[^a-zA-Z]/g, '')) {
                                        powerUps.spawnDelay("research", 4)
                                        simulation.inGameConsole(`correct!`, 360)
                                    } else {
                                        simulation.inGameConsole(`<strong>${answer}</strong> is wrong, it was <strong>${introArray[wordNumber]}</strong>`, 360)
                                    }
                                    let text = `"`
                                    for (let i = 0; i < wordLimit + 3; i++) {
                                        if (i === wordNumber) {
                                            text += `<strong>${introArray[i]}</strong> `
                                        } else {
                                            text += `${introArray[i]} `
                                        }
                                    }
                                    simulation.inGameConsole(text + `..."`, 360)
                                } else {
                                    simulation.inGameConsole(`hmmm  I'm not sure the answer, so I'll say it's correct!`, 360)
                                    powerUps.spawnDelay("research", 3)
                                }
                            }
                        }, 1000); // Check every 1 second
                        setTimeout(() => {
                            tab.close();
                        }, 7000); // Close the tab after 7 seconds
                    }
                });
            }


            //move new tech to the top of the tech list
            requestAnimationFrame(() => {
                if (index > 0 && !build.isExperimentSelection) {
                    const [item] = tech.tech.splice(index, 1); // Remove the element from the array
                    tech.tech.unshift(item); // Add the element to the front of the array
                }
                simulation.updateTechHUD();
            })
        }
    },
    setCheating() {
        if (!simulation.isCheating) {
            simulation.isCheating = true;
            document.title = "n-gon:" + level.levelAnnounce();
            lore.techCount = 0;
            for (let i = 0, len = tech.tech.length; i < len; i++) {
                if (tech.tech[i].isLore) {
                    tech.tech[i].frequency = 0;
                    tech.tech[i].count = 0;
                }
            }
            console.log('cheating')
            sound.tone(250)
            sound.tone(300)
            sound.tone(375)
        }
    },
    haveGunCheck(name, needActive = true) {
        if (b.activeGun === null || b.activeGun === undefined) return false
        if (build.isExperimentSelection || !needActive) {
            for (i = 0, len = b.inventory.length; i < len; i++) {
                if (b.guns[b.inventory[i]].name === name) return true
            }
            return false
        } else { //must be holding gun, this is the standard while playing
            return b.inventory.length > 0 && b.guns[b.activeGun].name === name
        }

        // if (build.isExperimentSelection || !needActive) {
        //     for (i = 0, len = b.inventory.length; i < len; i++) {
        //         if (b.guns[b.inventory[i]].name === name) return true
        //     }
        //     return false
        // } else { //must be holding gun, this is the standard while playing
        //     return b.inventory.length > 0 && b.guns[b.activeGun].name === name
        // }
    },
    hasExplosiveDamageCheck() {
        return tech.haveGunCheck("missiles") || (m.fieldMode === 4 && simulation.molecularMode === 1) || tech.missileBotCount > 0 || tech.isBoomBotUpgrade || tech.isIncendiary || tech.isPulseLaser || tech.isTokamak || (tech.haveGunCheck("grenades") && !tech.isNeutronBomb)
    },
    damageAdjustments() {
        let dmg = m.damageDone * m.fieldDamage * powerUps.difficulty.damageDone
        if (level.isNoDamage && (m.cycle - 180 < level.noDamageCycle)) dmg *= 0.3
        if (tech.isMaxHealthDamage && (m.health === m.maxHealth || (tech.isEnergyHealth && m.energy > m.maxEnergy - 0.01))) dmg *= 2
        if (tech.isNoDeath && m.health < 0) dmg *= 2
        if (tech.noDefenseSettingDamage && m.defense() === 1) dmg *= 2.5
        if (tech.isImmunityDamage && m.immuneCycle > m.cycle) dmg *= 3
        if (tech.isPowerUpDamage) dmg *= 1 + 0.07 * powerUp.length
        if (tech.isDamageCooldown) dmg *= m.lastKillCycle + tech.isDamageCooldownTime > m.cycle ? 0.4 : 4
        if (tech.isDivisor && b.activeGun !== undefined && b.activeGun !== null && b.guns[b.activeGun].ammo % 3 === 0) dmg *= 1.9
        if (tech.offGroundDamage && !m.onGround) dmg *= tech.offGroundDamage
        if (tech.isDilate) dmg *= 1.9 + 1.1 * Math.sin(m.cycle * 0.01)
        if (tech.isGunChoice) dmg *= 1 + 0.4 * b.inventory.length
        if (powerUps.boost.endCycle > simulation.cycle) dmg *= 1 + powerUps.boost.damage
        if (m.coupling && (m.fieldMode === 0 || m.fieldMode === 5)) dmg *= 1 + 0.025 * m.coupling
        if (tech.isVerlet) dmg *= 3
        if (tech.isTechDebt) dmg *= tech.totalCount > 20 ? Math.pow(0.85, tech.totalCount - 20) : 4 - 0.15 * tech.totalCount
        if (tech.isAnthropicDamage && tech.isDeathAvoidedThisLevel) dmg *= 2.71828
        if (tech.isDupDamage) dmg *= 1 + Math.min(1, tech.duplicationChance())
        if (tech.isDamageForGuns) dmg *= 1 + 0.22 * Math.max(0, b.inventory.length - 1)
        if (tech.isOneGun && b.inventory.length < 2) dmg *= 1.3
        if ((tech.isAcidDmg && m.health > 1) || (tech.isEnergyHealth && m.energy > 1)) dmg *= 1.35;
        if (tech.isRerollDamage) dmg *= 1 + Math.max(0, 0.05 * powerUps.research.count)
        if (tech.isBotDamage) dmg *= 1 + 0.04 * b.totalBots()
        if (tech.restDamage > 1 && player.speed < 1) dmg *= tech.restDamage
        if (tech.isLowEnergyDamage) dmg *= 1 + 0.7 * Math.max(0, m.maxEnergy - m.energy)
        if (tech.energyDamage) dmg *= 1 + m.energy * 0.23 * tech.energyDamage;
        if (tech.isDamageFromBulletCount) dmg *= 1 + bullet.length * 0.01
        if (tech.isNoFireDamage && m.cycle > m.fireCDcycle + 120) dmg *= 2
        if (tech.isSpeedDamage) dmg *= 1 + Math.min(2, ((tech.speedAdded + player.speed) * 0.033))//1 + Math.min(1, (tech.speedAdded + player.speed) * 0.0193)
        if (tech.isAxion && tech.isHarmDarkMatter) dmg *= ((tech.isMoveDarkMatter || tech.isNotDarkMatter) ? 3.2 : 2)
        if (tech.isHarmDamage && m.lastHarmCycle + 240 > m.cycle) dmg *= 4;
        if (tech.lastHitDamage && m.lastHit) dmg *= 1 + tech.lastHitDamage * m.lastHit
        // if (tech.isLowHealthDmg) dmg *= 1 + 0.6 * Math.max(0, 1 - (tech.isEnergyHealth ? m.energy : m.health))
        if (tech.isLowHealthDmg) dmg *= 1 + 0.6 * Math.max(0, (tech.isEnergyHealth ? m.maxEnergy - m.energy : m.maxHealth - m.health))
        if (tech.isJunkDNA) dmg *= 1 + 2 * (tech.junkChance + level.junkAdded)
        if (tech.isDemineralize) {
            //reduce mineral percent based on time since last check
            const seconds = (simulation.cycle - tech.mineralLastCheck) / 60
            tech.mineralLastCheck = simulation.cycle
            tech.mineralDamage = 1 + (tech.mineralDamage - 1) * Math.pow(0.9, seconds);
            tech.mineralDamageReduction = 1 - (1 - tech.mineralDamageReduction) * Math.pow(0.9, seconds);
            dmg *= tech.mineralDamage
        }
        return dmg
    },
    duplicationChance() {
        if (level.isNoDuplicate) return 0
        return Math.min(1, Math.max(0, (tech.isPowerUpsVanish ? 0.13 : 0) + (tech.isStimulatedEmission ? 0.2 : 0) + tech.duplication + tech.duplicateChance + 0.05 * tech.isExtraGunField + m.duplicateChance + tech.fieldDuplicate + 0.08 * tech.isDuplicateMobs + 0.03 * tech.isMassProduction + 0.04 * tech.isHealAttract + tech.cloakDuplication + (tech.isAnthropicTech && tech.isDeathAvoidedThisLevel ? 0.6 : 0) + 0.06 * tech.isDupEnergy + tech.blockDupCount))
    },
    setTechFrequency(name, frequency) {
        for (let i = 0, len = tech.tech.length; i < len; i++) {
            if (tech.tech[i].name === name) tech.tech[i].frequency = frequency
        }
    },
    setBotTechFrequency(f = 0) {
        for (let i = 0, len = tech.tech.length; i < len; i++) {
            if (tech.tech[i].isBotTech) {
                switch (tech.tech[i].name) {
                    case "dynamo-bot":
                        tech.tech[i].frequency = f
                        break;
                    case "orbital-bot":
                        tech.tech[i].frequency = f
                        break;
                    case "laser-bot":
                        tech.tech[i].frequency = f
                        break;
                    case "boom-bot":
                        tech.tech[i].frequency = f
                        break;
                    case "foam-bot":
                        tech.tech[i].frequency = f
                        break;
                    case "nail-bot":
                        tech.tech[i].frequency = f
                        break;
                }
            }
        }
    },
    tech: [{
        name: "tungsten carbide",
        description: "<strong>+500</strong> maximum <strong class='color-h'>health</strong><br><strong>lose</strong> ~8 <strong class='color-h'>health</strong> after hard <strong>landings</strong>",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isSkin: true,
        allowed() {
            return !m.isAltSkin
        },
        requires: "not skin",
        effect() {
            tech.isFallingDamage = true;
            m.setMaxHealth();
            m.addHealth(5 / simulation.healScale)
            m.skin.tungsten()
        },
        remove() {
            tech.isFallingDamage = false;
            m.setMaxHealth();
            if (this.count) m.resetSkin();
        }
    },
    {
        name: "nitinol",
        description: "<strong>1.3x</strong> <strong>movement</strong> and <strong>jumping</strong><br><strong>0.17</strong> seconds of <strong>coyote time</strong> <em style ='float: right;'>(jumping after falling)</em>",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isSkin: true,
        allowed() {
            return !m.isAltSkin
        },
        requires: "not skinned",
        effect() {
            m.skin.mech();
            m.setMovement()
        },
        remove() {
            if (this.count) m.resetSkin();
        }
    },
    {
        name: "Higgs mechanism",
        description: "<strong>4x</strong> <em>fire rate</em><br>while <strong>firing</strong> your <strong>position</strong> is fixed",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isSkin: true,
        allowed() {
            return !m.isAltSkin && !m.isShipMode && !tech.isAlwaysFire
        },
        requires: "not skinned, ship mode, automatic",
        effect() {
            tech.isFireMoveLock = true;
            b.setFireCD();
            b.setFireMethod();
            m.skin.strokeGap();
        },
        remove() {
            if (tech.isFireMoveLock) {
                tech.isFireMoveLock = false
                b.setFireCD();
                b.setFireMethod();
                m.resetSkin();
            }
            tech.isFireMoveLock = false
        }
    },
    {
        name: "Verlet integration",
        description: "<strong>3x</strong> <strong class='color-d'>damage</strong><br>after mobs <strong>die</strong> advance time <strong>0.5</strong> seconds",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isSkin: true,
        allowed() {
            return !m.isAltSkin
        },
        requires: "not skinned",
        effect() {
            tech.isVerlet = true
            m.skin.verlet();
        },
        remove() {
            tech.isVerlet = false
            if (this.count) m.resetSkin();
        }
    },
    {
        name: "Hilbert space",
        description: "<strong>3x</strong> <strong class='color-d'>damage</strong><br>after a <strong>collision</strong> enter an <strong class='alt'>alternate reality</strong>",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isAltRealityTech: true,
        isSkin: true,
        allowed() {
            return !m.isAltSkin && !tech.isResearchReality && !tech.isSwitchReality
        },
        requires: "not skinned, Ψ(t) collapse, many-worlds",
        damage: 3,
        effect() {
            m.skin.anodize();
            m.damageDone *= this.damage
            tech.isCollisionRealitySwitch = true;
        },
        remove() {
            tech.isCollisionRealitySwitch = false;
            if (this.count && m.alive) {
                m.damageDone /= this.damage
                m.resetSkin();
            }
        }
    },
    {
        name: "aperture",
        description: "every <strong>4</strong> seconds your <strong class='color-d'>damage</strong> cycles<br>between <strong>0.8x</strong> and <strong>3x</strong> <strong class='color-d'>damage</strong>",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isSkin: true,
        allowed() {
            return !m.isAltSkin
        },
        requires: "not skinned",
        effect() {
            tech.isDilate = true
            m.skin.dilate()
        },
        remove() {
            tech.isDilate = false
            if (this.count) {
                m.resetSkin();
                if (tech.isDiaphragm) m.skin.dilate2()
            }
        }
    },
    {
        name: "diaphragm",
        description: "every <strong>4</strong> seconds your <strong class='color-defense'>damage taken</strong> cycles<br>between <strong>0.9x</strong> and <strong>0.2x</strong> <strong class='color-defense'>damage taken</strong>",
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        // isSkin: true,
        allowed() {
            return tech.isDilate
        },
        requires: "aperture",
        effect() {
            tech.isDiaphragm = true
            m.resetSkin();
            m.skin.dilate2()
        },
        remove() {
            tech.isDiaphragm = false
            if (this.count) {
                m.resetSkin();
                if (tech.isDilate) m.skin.dilate()
            }
        }
    },
    {
        name: "mass-energy equivalence",
        description: `<strong class='color-f'>energy</strong> protects you instead of <strong class='color-h'>health</strong><br><strong>1.5x</strong> <strong class='color-d'>damage</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isSkin: true,
        allowed() {
            return !m.isAltSkin && !tech.isPiezo && !tech.isRewindAvoidDeath && !tech.isAnnihilation && !tech.isNoDeath//&& !tech.isAmmoFromHealth && !tech.isRewindGun
        },
        requires: "not piezoelectricity, CPT, annihilation, quantum Zeno effect",
        damage: 1.5,
        effect() {
            m.damageDone *= this.damage

            m.health = 0
            document.getElementById("health").style.display = "none"
            document.getElementById("health-bg").style.display = "none"
            document.getElementById("dmg").style.backgroundColor = "#0cf";
            tech.isEnergyHealth = true;
            simulation.mobDmgColor = "rgba(0, 255, 255,0.6)" //"#0cf"
            m.displayHealth();
            m.lastCalculatedDefense = 0 //this triggers a redraw of the defense bar
            m.skin.energy();
        },
        remove() {
            if (this.count > 0) {
                m.damageDone /= this.damage
                tech.isEnergyHealth = false;
                if (tech.isEnergyHealth) {
                    document.getElementById("health").style.display = "none"
                    document.getElementById("health-bg").style.display = "none"
                } else if (!level.isHideHealth) {
                    document.getElementById("health").style.display = "inline"
                    document.getElementById("health-bg").style.display = "inline"
                }
                document.getElementById("dmg").style.backgroundColor = "#f67";
                m.health = Math.max(Math.min(m.maxHealth, m.energy), 0.1);
                simulation.mobDmgColor = "rgba(255,0,0,0.7)"
                m.displayHealth();
                m.lastCalculatedDefense = 0 //this triggers a redraw of the defense bar
                m.resetSkin();
            }
            tech.isEnergyHealth = false;
        }
    },
    {
        name: "1st ionization energy",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Ionization_energy' class="link">1st ionization energy</a>`,
        descriptionFunction() {
            return `convert current and future <div class="heal-circle"></div> into <div class="heal-circle" style="background-color: #ff0; border: 0.5px #000 solid;"></div><br><div class="heal-circle" style="background-color: #ff0; border: 0.5px #000 solid;"></div> give <strong>+${15 * tech.largerHeals * (tech.isHalfHeals ? 0.5 : 1)}</strong> maximum <strong class='color-f'>energy</strong>`
        },
        maxCount: 1,
        count: 0,
        frequency: 5,
        frequencyDefault: 5,
        allowed() {
            return tech.isEnergyHealth && !tech.isOverHeal
        },
        requires: "mass-energy equivalence, not quenching",
        effect() {
            powerUps.healGiveMaxEnergy = true; //tech.healMaxEnergyBonus given from heal power up
            powerUps.heal.color = "#ff0" //"#0ae"
            for (let i = 0; i < powerUp.length; i++) { //find active heal power ups and adjust color live
                if (powerUp[i].name === "heal") powerUp[i].color = powerUps.heal.color
            }
        },
        remove() {
            powerUps.healGiveMaxEnergy = false;
            // tech.healMaxEnergyBonus = 0
            powerUps.heal.color = "#0eb"
            for (let i = 0; i < powerUp.length; i++) { //find active heal power ups and adjust color live
                if (powerUp[i].name === "heal") powerUp[i].color = powerUps.heal.color
            }
        }
    },
    {
        name: "depolarization",
        descriptionFunction() {
            return `<strong>4x</strong> <strong class='color-d'>damage</strong>, but if a mob <strong>dies</strong><br><strong>0.4x</strong> <strong class='color-d'>damage</strong> for <strong>${(tech.isDamageCooldownTime / 60).toFixed(1)}</strong> seconds instead`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isSkin: true,
        allowed() {
            return !m.isAltSkin
        },
        requires: "not skinned",
        effect() {
            m.skin.polar();
            tech.isDamageCooldown = true;
        },
        remove() {
            tech.isDamageCooldown = false;
            if (this.count) m.resetSkin();
        }
    },
    {
        name: "repolarization",
        descriptionFunction() {
            return `the <strong class= 'color-d'> damage</strong> from <strong> depolarization</strong> <br>resets <strong>1.25</strong> seconds sooner after a mob <strong>dies</strong>`
        },
        maxCount: 3,
        count: 0,
        frequency: 4,
        frequencyDefault: 4,
        allowed() {
            return tech.isDamageCooldown
        },
        requires: "depolarization",
        effect() {
            tech.isDamageCooldownTime -= 75
        },
        remove() {
            tech.isDamageCooldownTime = 240
        }
    },
    {
        name: "CPT symmetry",
        descriptionFunction() {
            return `after losing <strong class='color-h'>health</strong>, if you have above <strong>${(85 * Math.min(100, m.maxEnergy)).toFixed(0)}</strong> <strong class='color-f'>energy</strong><br><strong>rewind</strong> time for <strong>20</strong> <strong class='color-f'>energy</strong> per second`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isSkin: true,
        allowed() {
            return !m.isAltSkin && m.fieldUpgrades[m.fieldMode].name !== "standing wave" && !tech.isRewindField && !tech.isEnergyHealth
        },
        requires: "not skinned, standing wave, max energy reduction, retrocausality, mass-energy",
        effect() {
            tech.isRewindAvoidDeath = true;
            m.skin.CPT()
        },
        remove() {
            tech.isRewindAvoidDeath = false;
            if (this.count) m.resetSkin();
        }
    },
    {
        name: "causality bots",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Causality' class="link">causality bots</a>`,
        description: "when you <strong class='color-rewind'>rewind</strong> build scrap <strong class='color-bot'>bots</strong><br>that protect you for about <strong>9</strong> seconds",
        maxCount: 3,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        isBotTech: true,
        allowed() {
            return tech.isRewindAvoidDeath || tech.isRewindField
        },
        requires: "CPT, retrocausality",
        effect() {
            tech.isRewindBot++;
        },
        remove() {
            tech.isRewindBot = 0;
        }
    },
    {
        name: "causality bombs",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Causality' class="link">causality bombs</a>`,
        description: "when you <strong class='color-rewind'>rewind</strong> drop several <strong>grenades</strong>", //<br>become <strong>invulnerable</strong> until they <strong class='color-e'>explode</strong>
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isRewindAvoidDeath || tech.isRewindField
        },
        requires: "CPT, retrocausality",
        effect() {
            tech.isRewindGrenade = true;
        },
        remove() {
            tech.isRewindGrenade = false;
        }
    },
    {
        name: "ternary", //"divisor",
        descriptionFunction() {
            return `<strong>1.9x</strong> <strong class='color-d'>damage</strong> while your <strong class='color-ammo'>ammo</strong><br>is evenly <strong>divisible</strong> by <strong>3</strong><em style ="float: right;">(${((b.activeGun !== undefined && b.activeGun !== null && b.guns[b.activeGun].ammo % 3 === 0) ? "1.9" : "1")}x)</em>` //if (tech.isDivisor && b.activeGun !== undefined && b.activeGun !== null && b.guns[b.activeGun].ammo % 3 === 0) dmg *= 1.9
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed: () => true,
        requires: "",
        // divisible: 3, // + Math.floor(6 * Math.random()),
        effect() {
            tech.isDivisor = true;
        },
        remove() {
            tech.isDivisor = false;
        }
    },
    {
        name: "integrated armament",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Weapon' class="link">integrated armament</a>`,
        description: `<span style='font-size:95%;'><strong>1.3x</strong> <strong class='color-d'>damage</strong>, but new ${powerUps.orb.gun()} replace<br>current ${powerUps.orb.gun()} and convert your ${powerUps.orb.gunTech()}</span>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return b.inventory.length === 1
        },
        requires: "only 1 gun",
        effect() {
            tech.isOneGun = true;
        },
        remove() {
            tech.isOneGun = false;
        }
    },
    {
        name: "ordnance",
        description: `spawn ${powerUps.orb.gun()} and get <strong>2x</strong> <em class='flicker'>frequency</em> for ${powerUps.orb.gunTech()}<br><strong>+6%</strong> chance for <strong class='color-junk'>JUNK</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isInstant: true,
        isBadRandomOption: true,
        allowed: () => tech.junkChance < 1,
        requires: "",
        effect() {
            powerUps.spawn(m.pos.x, m.pos.y, "gun");
            for (let i = 0, len = tech.tech.length; i < len; i++) {
                if (tech.tech[i].isGunTech) tech.tech[i].frequency *= 2
            }
            this.refundAmount += tech.addJunkTechToPool(0.06)
        },
        refundAmount: 0,
        remove() {
            if (this.count > 0 && this.refundAmount > 0) {
                tech.removeJunkTechFromPool(this.refundAmount)
                this.refundAmount = 0
            }
        }
    },
    {
        name: "arsenal",
        descriptionFunction() {
            return `for each unused ${powerUps.orb.gun()} in your inventory<br><strong>1.25x</strong> <strong class='color-d'>damage</strong> <em style ="float: right;">(${(1 + 0.25 * Math.max(0, b.inventory.length - 1)).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed: () => b.inventory.length > 1,
        requires: "at least 2 guns",
        effect() {
            tech.isDamageForGuns = true;
        },
        remove() {
            tech.isDamageForGuns = false;
        }
    },
    {
        name: "active cooling",
        descriptionFunction() {
            return `for each unused ${powerUps.orb.gun()} in your inventory<br><strong>1.25x</strong> <em>fire rate</em> <em style ="float: right;">(${(1 / Math.pow(0.8, Math.max(0, b.inventory.length - 1))).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed: () => b.inventory.length > 1,
        requires: "at least 2 guns",
        effect() {
            tech.isFireRateForGuns = true;
            b.setFireCD();
        },
        remove() {
            tech.isFireRateForGuns = false;
            b.setFireCD();
        }
    },
    {
        name: "pigeonhole principle",
        descriptionFunction() {
            return `<strong>1.4x</strong> <strong class='color-d'>damage</strong> per ${powerUps.orb.gun()}, but your active ${powerUps.orb.gun()}<br>cycles each level and you can't <strong>switch</strong>`
        },
        // descriptionFunction() {
        //     let info = ""
        //     if (this.count > 0 && Number.isInteger(tech.buffedGun) && b.inventory.length) {
        //         let gun = b.guns[b.inventory[tech.buffedGun]].name
        //         info = `<br>this level: <strong>${(1.3 * Math.max(0, b.inventory.length)).toFixed(2)}x</strong> <strong class='color-d'>damage</strong> for <strong class="highlight">${gun}</strong>`
        //     }
        //     return `<span style = 'font-size:95%;'>a new ${powerUps.orb.gun()} in your inventory is <strong>chosen</strong> each <strong>level</strong><br>if it's equipped, <strong>1.3x</strong> <strong class='color-d'>damage</strong> per ${powerUps.orb.gun()} in your inventory${info}</span>`
        // },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return b.inventory.length > 1
        },
        requires: "at least 2 guns",
        effect() {
            tech.isGunChoice = true
            //switches gun on new level
            //generalist uses the same chosen gun so they match
        },
        remove() {
            tech.isGunChoice = false;
        }
    },
    {
        name: "generalist",
        description: `spawn <strong>7</strong> ${powerUps.orb.gun()}, but your equipped ${powerUps.orb.gun()}<br>cycles each level and you can't <strong>switch</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isInstant: true,
        isBadRandomOption: true,
        allowed() {
            return (b.inventory.length < b.guns.length - 5) && b.inventory.length > 1
        },
        requires: "you have at least 2 guns and 5 unclaimed guns",
        effect() {
            tech.isGunCycle = true;
            for (let i = 0; i < 7; i++) powerUps.spawn(m.pos.x + 10 * Math.random(), m.pos.y + 10 * Math.random(), "gun");
        },
        remove() {
            tech.isGunCycle = false; // only set to false if you don't have this tech
        }
    },
    {
        name: "ad hoc",
        descriptionFunction() {
            return `spawn a ${powerUps.orb.heal()}, ${powerUps.orb.research()}, ${powerUps.orb.ammo()}, ${powerUps.orb.tech()}, ${powerUps.orb.gun()}, or ${powerUps.orb.field()}<br>for each ${powerUps.orb.gun()} in your inventory`
        },
        maxCount: 1, //random power up
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isInstant: true,
        allowed() {
            return b.inventory.length > 1
        },
        requires: "at least 2 guns",
        effect() {
            for (let i = 0; i < b.inventory.length; i++) {
                if (Math.random() < 1 / 6) {
                    powerUps.spawn(m.pos.x + 10 * Math.random(), m.pos.y + 10 * Math.random(), "gun");
                } else if (Math.random() < 1 / 5) {
                    powerUps.spawn(m.pos.x + 10 * Math.random(), m.pos.y + 10 * Math.random(), "tech");
                } else if (Math.random() < 1 / 4) {
                    powerUps.spawn(m.pos.x + 10 * Math.random(), m.pos.y + 10 * Math.random(), "field");
                } else if (Math.random() < 1 / 3) {
                    powerUps.spawn(m.pos.x + 10 * Math.random(), m.pos.y + 10 * Math.random(), "heal");
                } else if (Math.random() < 1 / 2) {
                    powerUps.spawn(m.pos.x + 10 * Math.random(), m.pos.y + 10 * Math.random(), "ammo");
                } else {
                    powerUps.spawn(m.pos.x + 10 * Math.random(), m.pos.y + 10 * Math.random(), "research");
                }
            }
        },
        remove() { }
    },
    {
        name: "applied science",
        description: `get a random ${powerUps.orb.gunTech()}<br>for each ${powerUps.orb.gun()} in your inventory`, //spawn ${powerUps.orb.research(1)} and
        maxCount: 1,
        count: 0,
        isInstant: true,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return b.inventory.length > 1
        },
        requires: "at least 2 guns",
        effect() {
            const delay = 30
            let i = (b.inventory.length) * delay
            let gunIndex = -1
            let cycle = () => {
                if (i > 0) {
                    if (m.alive) requestAnimationFrame(cycle);
                    if (!simulation.paused && !simulation.isChoosing) {
                        i--
                        if (!(i % delay)) {
                            gunIndex++
                            //find gun tech for this gun
                            const gunTechPool = []
                            for (let j = 0, len = tech.tech.length; j < len; j++) {
                                const originalActiveGunIndex = b.activeGun //set current gun to active so allowed works
                                b.activeGun = b.inventory[gunIndex] //to make the .allowed work for guns that aren't active
                                if (tech.tech[j].isGunTech && tech.tech[j].allowed() && !tech.tech[j].isJunk && !tech.tech[j].isBadRandomOption && tech.tech[j].count < tech.tech[j].maxCount) {
                                    const regex = tech.tech[j].requires.search(b.guns[b.inventory[gunIndex]].name) //get string index of gun name
                                    const not = tech.tech[j].requires.search(' not ') //get string index of ' not '
                                    if (regex !== -1 && (not === -1 || not > regex)) gunTechPool.push(j) //look for the gun name in the requirements, but the gun name needs to show up before the word ' not '                        
                                }
                                b.activeGun = originalActiveGunIndex
                                if (!b.guns[b.activeGun].have) {
                                    if (b.inventory.length === 0) {
                                        b.activeGun = null
                                    } else {
                                        b.activeGun = b.inventory[0]
                                    }
                                    b.inventoryGun = 0;
                                }
                            }

                            //give the tech that was found for this gun
                            if (gunTechPool.length) {
                                const index = Math.floor(Math.random() * gunTechPool.length)
                                simulation.inGameConsole(`<span class='color-var'>tech</span>.giveTech("<strong class='color-text'>${tech.tech[gunTechPool[index]].name}</strong>")`, 360)
                                tech.giveTech(gunTechPool[index]) // choose from the gun pool
                                simulation.boldActiveGunHUD();
                            }

                        }
                    }
                }
            }
            requestAnimationFrame(cycle);

            // for (let i = b.inventory.length - 1; i > -1; i--) { //backwards because some tech can remove or add guns
            //     const gunTechPool = [] //find gun tech for this gun
            //     for (let j = 0, len = tech.tech.length; j < len; j++) {
            //         // console.log(j, tech.tech[j].isGunTech, tech.tech[j].allowed(), !tech.tech[j].isJunk, !tech.tech[j].isBadRandomOption, tech.tech[j].count < tech.tech[j].maxCount)
            //         const originalActiveGunIndex = b.activeGun //set current gun to active so allowed works
            //         b.activeGun = b.inventory[i] //to make the .allowed work for guns that aren't active
            //         if (tech.tech[j].isGunTech && tech.tech[j].allowed() && !tech.tech[j].isJunk && !tech.tech[j].isBadRandomOption && tech.tech[j].count < tech.tech[j].maxCount) {
            //             const regex = tech.tech[j].requires.search(b.guns[b.inventory[i]].name) //get string index of gun name
            //             const not = tech.tech[j].requires.search(' not ') //get string index of ' not '
            //             if (regex !== -1 && (not === -1 || not > regex)) gunTechPool.push(j) //look for the gun name in the requirements, but the gun name needs to show up before the word ' not '                        
            //         }
            //         b.activeGun = originalActiveGunIndex
            //         if (!b.guns[b.activeGun].have) {
            //             if (b.inventory.length === 0) {
            //                 b.activeGun = null
            //             } else {
            //                 b.activeGun = b.inventory[0]
            //             }
            //             b.inventoryGun = 0;
            //         }
            //     }
            //     if (gunTechPool.length) {
            //         const index = Math.floor(Math.random() * gunTechPool.length)
            //         // console.log(gunTechPool, index, gunTechPool[index], tech.tech[gunTechPool[index]].name)
            //         simulation.inGameConsole(`<span class='color-var'>tech</span>.giveTech("<span class='color-text'>${tech.tech[gunTechPool[index]].name}</span>")`, 360)
            //         // tech.tech[gunTechPool[index]].isInstant = true //makes it not remove properly under paradigm shift
            //         tech.giveTech(gunTechPool[index]) // choose from the gun pool
            //         // console.log(gunTechPool, index, gunTechPool[index], tech.tech[gunTechPool[index]].name)
            //         // tech.tech[gunTechPool[index]].isFromAppliedScience = true //makes it not remove properly under paradigm shift
            //     }
            // }
            // simulation.boldActiveGunHUD();
        },
        remove() { }
    },
    {
        name: "supply chain",
        descriptionFunction() {
            return `spawn ${powerUps.orb.gun()} ${powerUps.orb.ammo(10)}`
        },
        maxCount: 9,
        count: 0,
        isInstant: true,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            // let ammoCount = 0 //count ammo
            // if (b.activeGun && b.activeGun !== undefined && b.guns[b.activeGun].have && b.guns[b.activeGun].ammo !== Infinity) {
            //     ammoCount += b.guns[b.activeGun].ammo / b.guns[b.activeGun].ammoPack
            // }
            powerUps.spawnDelay("ammo", 10)
            powerUps.spawn(m.pos.x, m.pos.y, "gun");
        },
        remove() { }
    },
    {
        name: "marginal utility",
        descriptionFunction() {
            if (this.count === 0) this.gun = Math.floor(Math.random() * (b.guns.length - 1)) //don't pick laser
            return `<strong>2x</strong> <strong class='color-ammo'>ammo</strong> per ${powerUps.orb.ammo(1)} for <strong class='color-g'>${b.guns[this.gun].name}</strong>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() { return true },
        requires: "",
        gun: undefined,
        effect() {
            if (this.gun === undefined) this.gun = Math.floor(Math.random() * (b.guns.length - 1)) //don't pick laser

            simulation.inGameConsole(`${b.guns[this.gun].ammoPack} → ${2 * b.guns[this.gun].ammoPack} average <strong class='color-ammo'>ammo</strong> per ${powerUps.orb.ammo(1)} for <strong class='color-g'>${b.guns[this.gun].name}</strong>`)
            b.guns[this.gun].ammoPack *= 2
            // simulation.inGameConsole(`${(tech.interestRate * 100).toFixed(0)}<span class='color-symbol'>%</span> <span class='color-m'>interest</span> on <span class='color-h'>health</span> <span class='color-symbol'>=</span> ${h > 20 ? h + powerUps.orb.heal(1) : powerUps.orb.heal(h)}`)

            // for (let i = 0; i < 4; i++) powerUps.spawn(m.pos.x + 10 * Math.random(), m.pos.y + 10 * Math.random(), "ammo");
        },
        remove() {
            if (this.count) {
                b.guns[this.gun].ammoPack /= 2
            }
        }
    },
    {
        name: "Pareto efficiency",
        descriptionFunction() {
            return `all your ${powerUps.orb.gun()} randomly get<br><strong>5x</strong> or <strong>0.2x</strong> <strong class='color-ammo'>ammo</strong> per ${powerUps.orb.ammo(1)}`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBadRandomOption: true,
        allowed() {
            return b.inventory.length > 2
        },
        requires: "at least 3 guns",
        effect() {

            let options = []
            for (let i = 0; i < b.inventory.length; i++) options.push(b.inventory[i])
            options.sort(() => Math.random() - 0.5);
            for (let i = 0; i < options.length; i++) {
                const index = options[i]
                const scale = (i < options.length / 2) ? 4 : 0.25
                simulation.inGameConsole(`${(b.guns[index].ammoPack).toFixed(1)} <span ${scale < 1 ? 'style="color: #f00;"' : ''}>→</span> ${(b.guns[index].ammoPack * scale).toFixed(1)} average <strong class='color-ammo'>ammo</strong> per ${powerUps.orb.ammo(1)} for <strong class='color-g'>${b.guns[index].name}</strong>`, Infinity)
                b.guns[index].ammoPack *= scale
            }
        },
        remove() { }
    },
    {
        name: "logistics",
        description: `<strong>2x</strong> <strong class='color-ammo'>ammo</strong> per ${powerUps.orb.ammo()}, but<br><strong class='color-ammo'>ammo</strong> is only added to your current ${powerUps.orb.gun()}`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isEnergyNoAmmo
        },
        requires: "not non-renewables",
        effect() {
            tech.isAmmoForGun = true;
        },
        remove() {
            tech.isAmmoForGun = false;
        }
    },
    {
        name: "cache",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Cache_(computing)' class="link">cache</a>`,
        description: `<strong>15x</strong> <strong class='color-ammo'>ammo</strong> per ${powerUps.orb.ammo()}, but<br>you can't <strong>store</strong> additional <strong class='color-ammo'>ammo</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isEnergyNoAmmo
        },
        requires: "not non-renewables",
        effect() {
            tech.ammoCap = 15;
            powerUps.ammo.effect()
        },
        remove() {
            tech.ammoCap = 0;
        }
    },
    {
        name: "catabolism",
        descriptionFunction() {
            return `if you fire while <strong>out</strong> of <strong class='color-ammo'>ammo</strong><br>spawn ${powerUps.orb.ammo(4)} and ${tech.isEnergyHealth ? "<strong>–4</strong> maximum <strong class='color-f'>energy</strong>" : "<strong>–2</strong> maximum <strong class='color-h'>health</strong>"}`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isEnergyNoAmmo
        },
        requires: "not non-renewables",
        effect() {
            tech.isAmmoFromHealth = true;
        },
        remove() {
            tech.isAmmoFromHealth = false;
        }
    },
    {
        name: "non-renewables",
        description: `<strong>2x</strong> <strong class='color-d'>damage</strong><br>you can't pickup ${powerUps.orb.ammo()}`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isAmmoFromHealth && !tech.isBoostReplaceAmmo
        },
        requires: "not catabolism, quasiparticles",
        damage: 2,
        effect() {
            m.damageDone *= this.damage
            tech.isEnergyNoAmmo = true;
            powerUps.ammo.color = "#c1c6c9"//"#abb3b8"// "#535e63"

            for (let i = 0; i < powerUp.length; i++) {
                if (powerUp[i].name === "ammo") powerUp[i].color = powerUps.ammo.color
            }

        },
        remove() {
            if (this.count && m.alive) m.damageDone /= this.damage
            tech.isEnergyNoAmmo = false;
            powerUps.ammo.color = "#467"
            for (let i = 0; i < powerUp.length; i++) {
                if (powerUp[i].name === "ammo") powerUp[i].color = powerUps.ammo.color
            }
        }
    },
    {
        name: "desublimated ammunition",
        description: `if <strong>crouching</strong><br>alternating shots cost no <strong class='color-ammo'>ammo</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed: () => true,
        requires: "",
        effect() {
            tech.crouchAmmoCount = true
        },
        remove() {
            tech.crouchAmmoCount = false;
        }
    },
    {
        name: "gun turret",
        description: "if <strong>crouching</strong><br><strong>0.3x</strong> <strong class='color-defense'>damage taken</strong>",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isTurret = true
        },
        remove() {
            tech.isTurret = false;
        }
    },
    {
        name: "dead reckoning",
        description: `if your <strong class="color-speed">speed</strong> is 0<br><strong>1.5x</strong> <strong class='color-d'>damage</strong>`,
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.restDamage += 0.5
        },
        remove() {
            tech.restDamage = 1;
        }
    },
    {
        name: "kinetic bombardment",
        description: "far away mobs take more <strong class='color-d'>damage</strong><br>up to <strong>1.3x</strong> <strong class='color-d'>damage</strong> at <strong>3000</strong> displacement",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isFarAwayDmg = true;
        },
        remove() {
            tech.isFarAwayDmg = false;
        }
    },
    {
        name: "microstates",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Microstate_(statistical_mechanics)' class="link">microstates</a>`,
        descriptionFunction() {
            return `use ${powerUps.orb.research(3)}<br><strong>1.01x</strong> <strong class='color-d'>damage</strong> per <strong>bullet</strong> or <strong class='color-bot'>bot</strong> <em style ="float: right;">(${(1 + bullet.length * 0.01).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return powerUps.research.count > 2 || build.isExperimentSelection
        },
        requires: "",
        effect() {
            tech.isDamageFromBulletCount = true
            for (let i = 0; i < 3; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
        },
        remove() {
            tech.isDamageFromBulletCount = false
            if (this.count > 0) {
                powerUps.research.changeRerolls(3)
            }
        }
    },
    {
        name: "regression",
        description: "bullet <strong>collisions</strong> increase <strong>vulnerability</strong> to<br><strong class='color-d'>damage</strong> by <strong>1.05x</strong> for mobs and <strong>+1.025x</strong> for bosses",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isLessDamageReduction = true
        },
        remove() {
            tech.isLessDamageReduction = false
        }
    },
    {
        name: "simulated annealing",
        description: "<strong>1.2x</strong> <strong class='color-d'>damage</strong><br><strong>0.8x</strong> <em>fire rate</em>",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        damage: 1.2,
        effect() {
            m.damageDone *= this.damage
            tech.slowFire = 1.25
            b.setFireCD();
        },
        remove() {
            if (this.count && m.alive) m.damageDone /= this.damage
            tech.slowFire = 1;
            b.setFireCD();
        }
    },
    {
        name: "heuristics",
        descriptionFunction() {
            let totalRate = 1
            for (let i = 0; i < this.totalRate.length; i++) totalRate *= this.totalRate[i]
            let currentRate = ""
            if (this.count) currentRate = `<em style ="float: right;">(${(totalRate).toFixed(2)}x)</em>`
            return `randomly gain between <strong>1x</strong> and <strong>2x</strong> <em>fire rate</em><br><strong>+5%</strong> chance for <strong class='color-junk'>JUNK</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong>` + currentRate
        },
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.junkChance < 1
        },
        requires: "",
        totalRate: [], //tracks the random damage upgrades so it can be removed and in descriptionFunction
        effect() {
            const rate = (Math.floor((Math.random() + 1) * 100)) / 100
            tech.fireRate /= rate
            this.totalRate.push(rate)
            b.setFireCD();
            simulation.inGameConsole(`<span class='color-var'>tech</span>.fireRate *= ${rate} //heuristics`);
            this.refundAmount += tech.addJunkTechToPool(0.05)
        },
        refundAmount: 0,
        remove() {
            if (this.count) {
                // for (let i = 0; i < this.totalRate.length; i++) tech.fireRate *= this.totalRate[i]
                if (this.refundAmount > 0) {
                    tech.removeJunkTechFromPool(this.refundAmount)
                    this.refundAmount = 0
                }
            }
            tech.fireRate = 1
            this.totalRate.length = 0
            b.setFireCD();
        }
    },
    {
        name: "mechatronics",
        descriptionFunction() {
            let damageTotal = 1
            for (let i = 0; i < this.damageSoFar.length; i++) damageTotal *= this.damageSoFar[i]
            let currentDamage = ""
            if (this.count) currentDamage = `<br><em style ="float: right;">(${(damageTotal).toFixed(2)}x)</em>`
            return `randomly gain between <strong>1x</strong> and <strong>1.3x</strong> <strong class='color-d'>damage</strong>` + currentDamage
        },
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() { return true },
        requires: "",
        damageSoFar: [], //tracks the random damage upgrades so it can be removed and in descriptionFunction
        effect() {
            const damage = (Math.floor((Math.random() * 0.3 + 1) * 100)) / 100
            m.damageDone *= damage
            this.damageSoFar.push(damage)
            simulation.inGameConsole(`<span class='color-var'>tech</span>.damage *= ${damage} //mechatronics`);
        },
        remove() {
            if (this.count && m.alive) for (let i = 0; i < this.damageSoFar.length; i++) m.damageDone /= this.damageSoFar[i]
            this.damageSoFar.length = 0
        }
    },
    {
        name: "dynamical systems",
        description: `use ${powerUps.orb.research(2)}<br><strong>1.3x</strong> <strong class='color-d'>damage</strong>`,
        // isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return powerUps.research.count > 1 || build.isExperimentSelection
        },
        requires: "",
        // allowed() {
        //     return (m.fieldMode === 5 || m.fieldMode === 7 || m.fieldMode === 8) && (build.isExperimentSelection || powerUps.research.count > 1)
        // },
        // requires: "cloaking, pilot wave, or plasma torch",
        damage: 1.3,
        effect() {
            m.damageDone *= this.damage
            tech.isCloakingDamage = true
            for (let i = 0; i < 2; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
        },
        remove() {
            tech.isCloakingDamage = false
            if (this.count && m.alive) {
                m.damageDone /= this.damage
                powerUps.research.changeRerolls(2)
            }
        }
    },
    {
        name: "anti-shear topology",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Topology' class="link">anti-shear topology</a>`,
        description: "your bullets last <strong>1.3x</strong> <strong>longer</strong>", //<br><em style = 'font-size: 83%'>drone spore worm flea missile foam wave neutron ice</em>",
        maxCount: 3,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed: () => true,
        requires: "",
        effect() {
            tech.bulletsLastLonger += 0.3
        },
        remove() {
            tech.bulletsLastLonger = 1;
        }
    },
    {
        name: "fracture analysis",
        description: "if a mob is <strong>stunned</strong> it takes<br><strong>5x</strong> <strong class='color-d'>damage</strong> from bullet impacts",
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isStunField || tech.oneSuperBall || tech.isCloakStun || tech.isOrbitBotUpgrade || tech.isStun
        },
        requires: "a stun effect",
        effect() {
            tech.isCrit = true;
        },
        remove() {
            tech.isCrit = false;
        }
    },
    {
        name: "remineralization",
        descriptionFunction() {
            //reduce mineral percent based on time since last check
            const seconds = (simulation.cycle - tech.mineralLastCheck) / 60
            tech.mineralLastCheck = simulation.cycle
            tech.mineralDamage = 1 + (tech.mineralDamage - 1) * Math.pow(0.9, seconds);
            tech.mineralDamageReduction = 1 - (1 - tech.mineralDamageReduction) * Math.pow(0.9, seconds);

            return `after <strong>mobs</strong> <strong>die</strong> gain <strong>0.85x</strong> <strong class='color-defense'>damage taken</strong><br>effects stack, but fade <strong>10%</strong> every second<em style ="float: right;">(${tech.mineralDamageReduction.toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() { return true },
        requires: "",
        effect() {
            tech.isRemineralize = true
            tech.mineralDamageReduction = 1
            tech.mineralLastCheck = simulation.cycle
        },
        remove() {
            tech.isRemineralize = false
            tech.mineralDamageReduction = 1
            tech.mineralLastCheck = simulation.cycle
        }
    },
    {
        name: "demineralization",
        descriptionFunction() {
            //reduce mineral percent based on time since last check
            const seconds = (simulation.cycle - tech.mineralLastCheck) / 60
            tech.mineralLastCheck = simulation.cycle
            tech.mineralDamage = 1 + (tech.mineralDamage - 1) * Math.pow(0.9, seconds);
            tech.mineralDamageReduction = 1 - (1 - tech.mineralDamageReduction) * Math.pow(0.9, seconds);

            return `after <strong>mobs</strong> <strong>die</strong> gain <strong>1.08x</strong> <strong class='color-d'>damage</strong><br>effects stack, but fade <strong>10%</strong> every second<em style ="float: right;">(${tech.mineralDamage.toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isDemineralize = true
            tech.mineralDamage = 1
            tech.mineralLastCheck = simulation.cycle
        },
        remove() {
            tech.isDemineralize = false
            tech.mineralDamage = 1
            tech.mineralLastCheck = simulation.cycle
        }
    },
    {
        name: "shear stress",
        description: "after mobs <strong>die</strong><br>they fire a <strong>nail</strong> at nearby mobs",
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.nailsDeathMob++
        },
        remove() {
            tech.nailsDeathMob = 0;
        }
    },
    {
        name: "thermal runaway",
        description: "after mobs <strong>die</strong> they <strong class='color-e'>explode</strong>",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isExplodeMob = true;
        },
        remove() {
            tech.isExplodeMob = false;
        }
    },
    {
        name: "zoospore vector",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Disease_vector' class="link">zoospore vector</a>`,
        descriptionFunction() {
            return `after mobs <strong>die</strong> there is a <strong>13%</strong> chance<br>they grow ${b.guns[6].nameString('s')}`
        },
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.sporesOnDeath += 0.13;
        },
        remove() {
            tech.sporesOnDeath = 0;
        }
    },
    {
        name: "exciton",
        descriptionFunction() {
            return `<span style = 'font-size:94%;'>after mobs <strong>die</strong> they have a <strong>+14%</strong> chance to<br>spawn ${powerUps.orb.boost(1)} that give <strong>${(1 + powerUps.boost.damage).toFixed(2)}x</strong> <strong class='color-d'>damage</strong> for <strong>${(powerUps.boost.duration / 60).toFixed(0)}</strong> seconds</span>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed: () => true,
        requires: "",
        effect() {
            tech.isBoostPowerUps = true
        },
        remove() {
            tech.isBoostPowerUps = false
        }
    },
    {
        name: "band gap",
        descriptionFunction() {
            // return `${powerUps.orb.boost(1)} give <em style="text-decoration: line-through;">${(1 + powerUps.boost.damage).toFixed(2)}x</em> <strong>${(1 + powerUps.boost.damage + 0.77).toFixed(2)}x</strong> <strong class='color-d'>damage</strong><br>but their duration is reduced by <strong>1</strong> second`
            // const predict = this.count === 0 ? `<em style="text-decoration: line-through;">${(1 + powerUps.boost.damage).toFixed(2)}x</em>` : ``
            return `${powerUps.orb.boost(1)} give an additional <strong>${(1 + 0.75).toFixed(2)}x</strong> <strong class='color-d'>damage</strong><br>but their <strong>duration</strong> is reduced by <strong>1</strong> second`
        },
        maxCount: 9,
        count: 1,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isBoostPowerUps || tech.isBoostReplaceAmmo || tech.isPlasmaBoost
        },
        requires: "exciton, quasiparticles, dielectric",
        effect() {
            powerUps.boost.duration -= 60
            powerUps.boost.damage += 0.75
        },
        remove() {
            powerUps.boost.duration = 600
            powerUps.boost.damage = 1.25
        }
    },
    {
        name: "polariton",
        descriptionFunction() {
            return `${powerUps.orb.boost(1)} also give <strong>0.3x</strong> <strong class='color-defense'>damage taken</strong><br>for <strong>${(powerUps.boost.duration / 60).toFixed(0)}</strong> seconds</span>`
        },
        maxCount: 1,
        count: 1,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isBoostPowerUps || tech.isBoostReplaceAmmo || tech.isPlasmaBoost
        },
        requires: "exciton, quasiparticles, dielectric",
        effect() {
            powerUps.boost.isDefense = true
        },
        remove() {
            powerUps.boost.isDefense = false
        }
    },
    {
        name: "collider",
        descriptionFunction() {
            return `after mobs <strong>die</strong> existing <strong>power ups</strong><br><strong>collide</strong> to form new <strong>power ups</strong>`
        },

        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed: () => true,
        requires: "",
        effect() {
            tech.collidePowerUps = true
        },
        remove() {
            tech.collidePowerUps = false
        }
    },
    {
        name: "bubble fusion",
        descriptionFunction() {
            return `after destroying a mob's <strong>shield</strong><br>spawn <strong>1-2</strong> ${powerUps.orb.heal()}, ${powerUps.orb.ammo()}, or ${powerUps.orb.research(1)} <em style ="float: right;">(once per mob)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isHealTech: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isShieldAmmo = true;
        },
        remove() {
            tech.isShieldAmmo = false;
        }
    },
    {
        name: "enthalpy",
        descriptionFunction() {
            return `<strong>8%</strong> chance to spawn ${powerUps.orb.heal(1)} after mobs <strong>die</strong>`
        },
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isHealTech: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.healSpawn += 0.08;
        },
        remove() {
            tech.healSpawn = 0;
        }
    },
    {
        name: "cascading failure",
        description: "<strong>3x</strong> <strong class='color-d'>damage</strong> to <strong>mobs</strong> below <strong>25%</strong> <strong>durability</strong>",
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return tech.mobSpawnWithHealth > 0
        },
        requires: "reaction inhibitor",
        effect() {
            tech.isMobLowHealth = true
        },
        remove() {
            tech.isMobLowHealth = false
        }
    },
    {
        name: "reaction inhibitor",
        description: "<strong>mobs</strong> spawn with <strong>0.88x</strong> initial <strong>durability</strong>",
        maxCount: 3,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isMobFullHealthCloak
        },
        requires: "not topological defect",
        effect() {
            tech.mobSpawnWithHealth++
            mobs.setMobSpawnHealth()
            for (let i = 0; i < mob.length; i++) {
                if (mob.health > mobs.mobSpawnWithHealth) mob.health = mobs.mobSpawnWithHealth
            }
        },
        remove() {
            tech.mobSpawnWithHealth = 0
            mobs.setMobSpawnHealth()
        }
    },
    {
        name: "scrap bots",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Scrap' class="link">scrap bots</a>`,
        description: "after mobs <strong>die</strong> you have a <strong>33%</strong> chance to<br>construct scrap <strong class='color-bot'>bots</strong> that operate for <strong>15</strong> seconds",
        maxCount: 3,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBotTech: true,
        allowed() {
            return !tech.sporesOnDeath && !tech.nailsDeathMob && !tech.isExplodeMob && !tech.isMobBlockFling && !tech.iceIXOnDeath
        },
        requires: "no other mob death tech",
        effect() {
            tech.botSpawner += 0.33;
        },
        remove() {
            tech.botSpawner = 0;
        }
    },
    {
        name: "scrap refit",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Scrap' class="link">scrap refit</a>`,
        description: "after mobs <strong>die</strong> reset scrap <strong class='color-bot'>bots</strong><br>to <strong>15</strong> seconds of operation",
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        isBotTech: true,
        allowed() {
            return tech.botSpawner
        },
        requires: "scrap bots",
        effect() {
            tech.isBotSpawnerReset = true;
        },
        remove() {
            tech.isBotSpawnerReset = false;
        }
    },
    {
        name: "nail-bot",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">nail-bot</a>`,
        description: "construct a <strong class='color-bot'>bot</strong> that fires <strong>nails</strong> at mobs",
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBot: true,
        isBotTech: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.nailBotCount++;
            b.nailBot();
        },
        remove() {
            if (this.count) {
                tech.nailBotCount -= this.count;
                b.clearPermanentBots();
                b.respawnBots();
            }
        }
    },
    {
        name: "nail-bot upgrade",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">nail-bot upgrade</a>`,
        description: "<strong>convert</strong> your <strong class='color-bot'>bots</strong> to <strong class='color-bot'>nail-bots</strong><br><strong>4x</strong> <em>fire rate</em> and <strong>1.4x</strong> nail <strong>velocity</strong>",
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        isBotTech: true,
        allowed() {
            return tech.nailBotCount > 1 && !b.hasBotUpgrade()
        },
        requires: "2 or more nail bots and no other bot upgrade",
        effect() {
            tech.isNailBotUpgrade = true
            b.convertBotsTo("nail-bot")
            for (let i = 0; i < bullet.length; i++) {
                if (bullet[i].botType === 'nail') bullet[i].isUpgraded = true
            }
            tech.setBotTechFrequency()
            tech.setTechFrequency("nail-bot", 5)
        },
        remove() {
            if (this.count) {
                for (let i = 0; i < bullet.length; i++) {
                    if (bullet[i].botType === 'nail') bullet[i].isUpgraded = false
                }
                tech.setBotTechFrequency(1)
            }
            tech.isNailBotUpgrade = false
        }
    },
    {
        name: "foam-bot",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">foam-bot</a>`,
        description: "construct a <strong class='color-bot'>bot</strong> that sprays sticky <strong>foam</strong> at mobs",
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBot: true,
        isBotTech: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.foamBotCount++;
            b.foamBot();
        },
        remove() {
            if (this.count) {
                tech.foamBotCount -= this.count;
                b.clearPermanentBots();
                b.respawnBots();
            }
        }
    },
    {
        name: "foam-bot upgrade",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">foam-bot upgrade</a>`,
        description: "<strong>convert</strong> your <strong class='color-bot'>bots</strong> to <strong class='color-bot'>foam-bots</strong><br><strong>2.5x</strong> foam <strong>size</strong> and <em>fire rate</em>",
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        isBotTech: true,
        allowed() {
            return tech.foamBotCount > 1 && !b.hasBotUpgrade()
        },
        requires: "2 or more foam bots and no other bot upgrade",
        effect() {
            tech.isFoamBotUpgrade = true
            b.convertBotsTo("foam-bot")
            for (let i = 0; i < bullet.length; i++) {
                if (bullet[i].botType === 'foam') bullet[i].isUpgraded = true
            }
            tech.setBotTechFrequency()
            tech.setTechFrequency("foam-bot", 5)
        },
        remove() {
            if (this.count) {
                for (let i = 0; i < bullet.length; i++) {
                    if (bullet[i].botType === 'foam') bullet[i].isUpgraded = false
                }
                tech.setBotTechFrequency(1)
            }
            tech.isFoamBotUpgrade = false
        }
    },
    {
        name: "sound-bot",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">sound-bot</a>`,
        description: "construct a <strong class='color-bot'>bot</strong> that emits expanding<br>arcs of <strong>sound</strong> aimed towards nearby mobs",
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBot: true,
        isBotTech: true,
        allowed() { return true },
        requires: "",
        effect() {
            tech.soundBotCount++;
            b.soundBot();
        },
        remove() {
            if (this.count) {
                tech.soundBotCount -= this.count;
                b.clearPermanentBots();
                b.respawnBots();
            }
        }
    },
    {
        name: "sound-bot upgrade",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">sound-bot upgrade</a>`,
        description: "<strong>convert</strong> your <strong class='color-bot'>bots</strong> to <strong class='color-bot'>sound-bots</strong><br><strong>6x</strong> wave <strong class='color-d'>damage</strong>",
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        isBotTech: true,
        allowed() {
            return tech.soundBotCount > 1 && !b.hasBotUpgrade()
        },
        requires: "2 or more sound bots and no other bot upgrade",
        effect() {
            tech.isSoundBotUpgrade = true
            b.convertBotsTo("sound-bot")
            for (let i = 0; i < bullet.length; i++) {
                if (bullet[i].botType === 'sound') bullet[i].isUpgraded = true
            }
            tech.setBotTechFrequency()
            tech.setTechFrequency("sound-bot", 5)
        },
        remove() {
            if (this.count) {
                for (let i = 0; i < bullet.length; i++) {
                    if (bullet[i].botType === 'sound') bullet[i].isUpgraded = false
                }
                tech.setBotTechFrequency(1)
            }
            tech.isSoundBotUpgrade = false
        }
    },
    {
        name: "boom-bot",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">boom-bot</a>`,
        description: "construct a <strong class='color-bot'>bot</strong> that <strong class='color-e'>explodes</strong> nearby mobs",
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBot: true,
        isBotTech: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.boomBotCount++;
            b.boomBot();
        },
        remove() {
            if (this.count) {
                tech.boomBotCount -= this.count;
                b.clearPermanentBots();
                b.respawnBots();
            }
        }
    },
    {
        name: "boom-bot upgrade",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">boom-bot upgrade</a>`,
        description: "<strong>convert</strong> your <strong class='color-bot'>bots</strong> to <strong class='color-bot'>boom-bots</strong><br><strong>4x</strong> <strong class='color-e'>explosion</strong> <strong class='color-d'>damage</strong> and size",
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        isBotTech: true,
        allowed() {
            return tech.boomBotCount > 1 && !b.hasBotUpgrade()
        },
        requires: "2 or more boom bots and no other bot upgrade",
        effect() {
            tech.isBoomBotUpgrade = true
            b.convertBotsTo("boom-bot")
            for (let i = 0; i < bullet.length; i++) {
                if (bullet[i].botType === 'boom') bullet[i].isUpgraded = true
            }
            tech.setBotTechFrequency()
            tech.setTechFrequency("boom-bot", 5)
        },
        remove() {
            if (this.count) {
                for (let i = 0; i < bullet.length; i++) {
                    if (bullet[i].botType === 'boom') bullet[i].isUpgraded = false
                }
                tech.setBotTechFrequency(1)
            }
            tech.isBoomBotUpgrade = false
        }
    },
    {
        name: "laser-bot",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">laser-bot</a>`,
        description: "construct a <strong class='color-bot'>bot</strong> that uses <strong class='color-f'>energy</strong> to emit<br>a <strong class='color-laser'>laser</strong> that targets mobs",
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBot: true,
        isBotTech: true,
        allowed() {
            return m.maxEnergy > 0.5
        },
        requires: "maximum energy above 50",
        effect() {
            tech.laserBotCount++;
            b.laserBot();
        },
        remove() {
            if (this.count) {
                tech.laserBotCount -= this.count;
                b.clearPermanentBots();
                b.respawnBots();
            }
        }
    },
    {
        name: "laser-bot upgrade",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">laser-bot upgrade</a>`,
        description: "<strong>convert</strong> your <strong class='color-bot'>bots</strong> to <strong class='color-bot'>laser-bots</strong><br><strong>2x</strong> <strong class='color-d'>damage</strong>, efficiency, and range",
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        isBotTech: true,
        allowed() {
            return tech.laserBotCount > 1 && !b.hasBotUpgrade()
        },
        requires: "2 or more laser bots and no other bot upgrade",
        effect() {
            tech.isLaserBotUpgrade = true
            b.convertBotsTo("laser-bot")
            for (let i = 0; i < bullet.length; i++) {
                if (bullet[i].botType === 'laser') bullet[i].isUpgraded = true
            }
            tech.setBotTechFrequency()
            tech.setTechFrequency("laser-bot", 5)
        },
        remove() {
            if (this.count) {
                for (let i = 0; i < bullet.length; i++) {
                    if (bullet[i].botType === 'laser') bullet[i].isUpgraded = false
                }
                tech.setBotTechFrequency(1)
            }
            tech.isLaserBotUpgrade = false
        }
    },
    {
        name: "orbital-bot",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">orbital-bot</a>`,
        description: "construct a <strong class='color-bot'>bot</strong> locked in <strong>orbit</strong> around you<br>that <strong>stuns</strong> and <strong class='color-d'>damages</strong> mobs",
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBot: true,
        isBotTech: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            b.orbitBot();
            tech.orbitBotCount++;
        },
        remove() {
            if (this.count) {
                tech.orbitBotCount -= this.count;
                b.clearPermanentBots();
                b.respawnBots();
            }
        }
    },
    {
        name: "orbital-bot upgrade",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">orbital-bot upgrade</a>`,
        description: "<strong>convert</strong> your <strong class='color-bot'>bots</strong> to <strong class='color-bot'>orbital-bots</strong><br><strong>4x</strong> orbital <strong class='color-d'>damage</strong> and <strong>2x</strong> <strong>radius</strong>",
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        isBotTech: true,
        allowed() {
            return tech.orbitBotCount > 1 && !b.hasBotUpgrade()
        },
        requires: "2 or more orbital bots and no other bot upgrade",
        effect() {
            tech.isOrbitBotUpgrade = true
            b.convertBotsTo("orbital-bot")
            const range = 190 + 120 * tech.isOrbitBotUpgrade
            for (let i = 0; i < bullet.length; i++) {
                if (bullet[i].botType === 'orbit') {
                    bullet[i].isUpgraded = true
                    bullet[i].range = range
                    bullet[i].orbitalSpeed = Math.sqrt(0.25 / range)
                }
            }
            tech.setBotTechFrequency()
            tech.setTechFrequency("orbital-bot", 5)
        },
        remove() {
            if (this.count) {
                const range = 190 + 100 * tech.isOrbitBotUpgrade
                for (let i = 0; i < bullet.length; i++) {
                    if (bullet[i].botType === 'orbit') {
                        bullet[i].range = range
                        bullet[i].orbitalSpeed = Math.sqrt(0.25 / range)
                    }
                }
                tech.setBotTechFrequency(1)
            }
            tech.isOrbitBotUpgrade = false
        }
    },
    {
        name: "dynamo-bot",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">dynamo-bot</a>`,
        description: "construct a <strong class='color-bot'>bot</strong> that <strong class='color-d'>damages</strong> mobs and<br>generates <strong>+8</strong> <strong class='color-f'>energy</strong> per second when nearby",
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBot: true,
        isBotTech: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.dynamoBotCount++;
            b.dynamoBot();
        },
        remove() {
            if (this.count) {
                tech.dynamoBotCount -= this.count;
                b.clearPermanentBots();
                b.respawnBots();
            }
        }
    },
    {
        name: "dynamo-bot upgrade",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">dynamo-bot upgrade</a>`,
        description: "<strong>convert</strong> your <strong class='color-bot'>bots</strong> to <strong class='color-bot'>dynamo-bots</strong><br><strong>+24</strong> <strong class='color-f'>energy</strong> per second when nearby",
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        isBotTech: true,
        allowed() {
            return tech.dynamoBotCount > 1 && !b.hasBotUpgrade()
        },
        requires: "2 or more dynamo bots and no other bot upgrade",
        effect() {
            tech.isDynamoBotUpgrade = true
            b.convertBotsTo("dynamo-bot")
            for (let i = 0; i < bullet.length; i++) {
                if (bullet[i].botType === 'dynamo') bullet[i].isUpgraded = true
            }
            tech.setBotTechFrequency()
            tech.setTechFrequency("dynamo-bot", 5)
        },
        remove() {
            if (this.count) {
                for (let i = 0; i < bullet.length; i++) {
                    if (bullet[i].botType === 'dynamo') bullet[i].isUpgraded = false
                }
                tech.setBotTechFrequency(1)
            }
            tech.isDynamoBotUpgrade = false
        }
    },
    {
        name: "perimeter defense",
        descriptionFunction() {
            return `for each permanent <strong class='color-bot'>bot</strong><br><strong>0.96x</strong> <strong class='color-defense'>damage taken</strong><em style ="float: right;">(${(0.96 ** b.totalBots()).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        isBotTech: true,
        allowed() {
            return b.totalBots() > 1
        },
        requires: "at least 2 bots",
        effect() {
            tech.isBotArmor = true
        },
        remove() {
            tech.isBotArmor = false
        }
    },
    {
        name: "network effect",
        descriptionFunction() {
            return `for each permanent <strong class='color-bot'>bot</strong><br><strong>1.04x</strong> <strong class='color-d'>damage</strong><em style ="float: right;">(${(1 + 0.04 * b.totalBots()).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        isBotTech: true,
        allowed() {
            return b.totalBots() > 1
        },
        requires: "at least 2 bots",
        effect() {
            tech.isBotDamage = true
        },
        remove() {
            tech.isBotDamage = false
        }
    },
    {
        name: "bot fabrication",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">bot fabrication</a>`,
        descriptionFunction() {
            return `after you collect ${powerUps.orb.research(2 + Math.floor(0.25 * b.totalBots()))}use them<br>to construct a random <strong class='color-bot'>bot</strong> <em style ="float: right;">(+1 cost every 3 bots)</em>`
        },
        // description: `if you collect ${powerUps.orb.research(2)}use them to build a<br>random <strong class='color-bot'>bot</strong> <em>(+1 cost every 5 bots)</em>`,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        isBotTech: true,
        allowed() {
            return powerUps.research.count > 1 || build.isExperimentSelection
        },
        requires: "at least 2 research",
        effect() {
            tech.isRerollBots = true;
            powerUps.research.changeRerolls(0)
            simulation.inGameConsole(`<span class='color-var'>m</span>.<span class='color-r'>research</span> <span class='color-symbol'>=</span> 0`)
        },
        remove() {
            tech.isRerollBots = false;
            // this.description = `if you collect ${powerUps.orb.research(2 + Math.floor(0.2 * b.totalBots()))}use them to build a<br>random <strong class='color-bot'>bot</strong>  <em>(+1 cost every 5 bots)</em>`
        }
    },
    {
        name: "open-source",
        description: `${powerUps.orb.tech()}, ${powerUps.orb.field()}, and ${powerUps.orb.gun()} have <strong>+1</strong> <strong class='color-bot'>bot</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ce</span></strong><br><strong>3x</strong> <em class='flicker'>frequency</em> for ${powerUps.orb.tech()} with <strong class='color-bot'>bots</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBotTech: true,
        allowed() {
            return b.totalBots() > 1 && !tech.isDeterminism
        },
        requires: "at least 2 bots",
        effect() {
            tech.isExtraBotOption = true
            for (let i = 0, len = tech.tech.length; i < len; i++) {
                if (tech.tech[i].isBotTech) tech.tech[i].frequency *= 3
            }
        },
        remove() {
            if (this.count > 0) {
                for (let i = 0, len = tech.tech.length; i < len; i++) {
                    if (tech.tech[i].isBotTech) tech.tech[i].frequency = Math.ceil(tech.tech[i].frequency / 3)
                }
            }
            tech.isExtraBotOption = false
        }
    },
    {
        name: "ersatz bots",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Ersatz_good' class="link">ersatz bots</a>`,
        description: `<strong>double</strong> your <strong class='color-bot'>bots</strong><br>remove <strong>all</strong> ${powerUps.orb.gun()} in your inventory`,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        isBotTech: true,
        isInstant: true,
        isBadRandomOption: true,
        numberOfGunsLost: 0,
        allowed() {
            return b.totalBots() > 3 && !build.isExperimentSelection
        },
        requires: "NOT EXPERIMENT MODE, at least 4 bots",
        effect() {
            this.numberOfGunsLost = b.inventory.length
            b.inventory = []; //removes guns and ammo  
            for (let i = 0, len = b.guns.length; i < len; ++i) {
                b.guns[i].count = 0;
                b.guns[i].have = false;
                if (b.guns[i].ammo != Infinity) b.guns[i].ammo = 0;
            }
            tech.buffedGun = 0
            b.activeGun = null;
            b.inventoryGun = 0;
            simulation.drawCursor = simulation.drawCursorBasic //set cross hairs

            simulation.makeGunHUD();
            //double bots
            for (let i = 0; i < tech.nailBotCount; i++) b.nailBot();
            tech.nailBotCount *= 2
            for (let i = 0; i < tech.laserBotCount; i++) b.laserBot();
            tech.laserBotCount *= 2
            for (let i = 0; i < tech.foamBotCount; i++) b.foamBot();
            tech.foamBotCount *= 2
            for (let i = 0; i < tech.boomBotCount; i++) b.boomBot();
            tech.boomBotCount *= 2
            for (let i = 0; i < tech.orbitBotCount; i++) b.orbitBot();
            tech.orbitBotCount *= 2
            for (let i = 0; i < tech.dynamoBotCount; i++) b.dynamoBot();
            tech.dynamoBotCount *= 2
            for (let i = 0; i < tech.soundBotCount; i++) b.soundBot();
            tech.soundBotCount *= 2
            for (let i = 0; i < tech.plasmaBotCount; i++) b.plasmaBot();
            tech.plasmaBotCount *= 2
            for (let i = 0; i < tech.missileBotCount; i++) b.missileBot();
            tech.missileBotCount *= 2
        },
        remove() {
            // if (this.count) {
            //     //return guns
            //     for (let i = 0; i < this.numberOfGunsLost; i++) powerUps.spawn(m.pos.x + 60 * (Math.random() - 0.5), m.pos.y + 60 * (Math.random() - 0.5), "gun");
            //     this.numberOfGunsLost = 0;

            //     //half all current bots
            //     tech.nailBotCount = Math.round(tech.nailBotCount / 2)
            //     tech.laserBotCount = Math.round(tech.laserBotCount / 2)
            //     tech.foamBotCount = Math.round(tech.foamBotCount / 2)
            //     tech.soundBotCount = Math.round(tech.soundBotCount / 2)
            //     tech.boomBotCount = Math.round(tech.boomBotCount / 2)
            //     tech.orbitBotCount = Math.round(tech.orbitBotCount / 2)
            //     tech.dynamoBotCount = Math.round(tech.dynamoBotCount / 2)
            //     tech.plasmaBotCount = Math.round(tech.plasmaBotCount / 2)
            //     tech.missileBotCount = Math.round(tech.missileBotCount / 2)
            //     b.clearPermanentBots();
            //     b.respawnBots();
            // }
        }
    },
    {
        name: "robotics",
        description: `construct <strong>2</strong> random <strong class='color-bot'>bots</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBotTech: true,
        isInstant: true,
        allowed() {
            return b.totalBots() > 2
        },
        requires: "at least 3 bots",
        effect() {
            for (let i = 0; i < 2; i++) b.randomBot()
        },
        remove() {
        }
    },
    {
        name: "bot manufacturing",
        description: `use ${powerUps.orb.research(2)} to construct<br><strong>3</strong> random <strong class='color-bot'>bots</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBotTech: true,
        isInstant: true,
        allowed() {
            return b.totalBots() > 3 && powerUps.research.count > 1
        },
        requires: "at least 4 bots",
        effect() {
            for (let i = 0; i < 2; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
            // m.energy = 0.01;
            b.randomBot()
            b.randomBot()
            b.randomBot()
        },
        remove() { }
    },
    {
        name: "bot prototypes",
        description: `use ${powerUps.orb.research(3)}to build <strong>2</strong> random <strong class='color-bot'>bots</strong><br>and <strong>upgrade</strong> all <strong class='color-bot'>bots</strong> to a random type`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBotTech: true,
        isInstant: true,
        allowed() {
            return b.totalBots() > 5 && powerUps.research.count > 2
        },
        requires: "at least 6 bots",
        effect() {
            requestAnimationFrame(() => {
                for (let i = 0; i < 3; i++) {
                    if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
                }
                //fill array of available bots
                const notUpgradedBots = []
                const num = 2
                notUpgradedBots.push(() => {
                    tech.giveTech("nail-bot upgrade")
                    for (let i = 0; i < num; i++) {
                        b.nailBot()
                        tech.nailBotCount++;
                    }
                    simulation.inGameConsole(`tech.isNailBotUpgrade = true`)
                })
                notUpgradedBots.push(() => {
                    tech.giveTech("foam-bot upgrade")
                    for (let i = 0; i < num; i++) {
                        b.foamBot()
                        tech.foamBotCount++;
                    }
                    simulation.inGameConsole(`tech.isFoamBotUpgrade = true`)
                })
                notUpgradedBots.push(() => {
                    tech.giveTech("sound-bot upgrade")
                    for (let i = 0; i < num; i++) {
                        b.soundBot()
                        tech.soundBotCount++;
                    }
                    simulation.inGameConsole(`tech.isSoundBotUpgrade = true`)
                })
                notUpgradedBots.push(() => {
                    tech.giveTech("boom-bot upgrade")
                    for (let i = 0; i < num; i++) {
                        b.boomBot()
                        tech.boomBotCount++;
                    }
                    simulation.inGameConsole(`tech.isBoomBotUpgrade = true`)
                })
                notUpgradedBots.push(() => {
                    tech.giveTech("laser-bot upgrade")
                    for (let i = 0; i < num; i++) {
                        b.laserBot()
                        tech.laserBotCount++;
                    }
                    simulation.inGameConsole(`tech.isLaserBotUpgrade = true`)
                })
                notUpgradedBots.push(() => {
                    tech.giveTech("orbital-bot upgrade")
                    for (let i = 0; i < num; i++) {
                        b.orbitBot()
                        tech.orbitBotCount++;
                    }
                    simulation.inGameConsole(`tech.isOrbitalBotUpgrade = true`)
                })
                notUpgradedBots.push(() => {
                    tech.giveTech("dynamo-bot upgrade")
                    for (let i = 0; i < num; i++) {
                        b.dynamoBot()
                        tech.dynamoBotCount++;
                    }
                    simulation.inGameConsole(`tech.isDynamoBotUpgrade = true`)
                })

                notUpgradedBots[Math.floor(Math.random() * notUpgradedBots.length)]() //choose random function from the array and run it
            })
        },
        remove() { }
    },
    {
        name: "decorrelation",
        description: `if your ${powerUps.orb.gun()} and ${powerUps.orb.field()} keys are <strong>unused</strong> for <strong>2</strong> seconds<br><strong>0.3x</strong> <strong class='color-defense'>damage taken</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isRewindField
        },
        requires: "not retrocausality",
        effect() {
            tech.isNoFireDefense = true
        },
        remove() {
            tech.isNoFireDefense = false
        }
    },
    {
        name: "anticorrelation",
        description: `if your ${powerUps.orb.gun()} and ${powerUps.orb.field()} keys are <strong>unused</strong> for <strong>2</strong> seconds<br><strong>2x</strong> <strong class='color-d'>damage</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isRewindField
        },
        requires: "not retrocausality",
        effect() {
            tech.isNoFireDamage = true
        },
        remove() {
            tech.isNoFireDamage = false
        }
    },
    {
        name: "mass driver",
        description: "<strong>4x</strong> <strong class='color-block'>block</strong> collision <strong class='color-d'>damage</strong>",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return m.fieldMode !== 9 && !tech.isTokamak && !tech.isReel
        },
        requires: "not wormhole, reel, tokamak",
        effect() {
            tech.blockDamage = 0.3
        },
        remove() {
            tech.blockDamage = 0.075
        }
    },
    {
        name: "Halbach array",
        description: "throwing a <strong class='color-block'>block</strong> will<br>also throw other nearby <strong class='color-block'>blocks</strong>",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return (tech.blockDamage > 0.075 || tech.isPrinter) && m.fieldMode !== 8 && m.fieldMode !== 9 && !tech.isTokamak
        },
        requires: "mass driver, printer, not wormhole, pilot wave, tokamak",
        effect() {
            tech.isGroupThrow = true
        },
        remove() {
            tech.isGroupThrow = false
        }
    },
    {
        name: "inflation",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Inflation_(cosmology)' class="link">inflation</a>`,
        description: "if <strong>holding</strong> a <strong class='color-block'>block</strong> <strong>0.1x</strong> <strong class='color-defense'>damage taken</strong><br>after <strong>throwing</strong> a <strong class='color-block'>block</strong> it expands <strong>3x</strong>",
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return (tech.blockDamage > 0.075 || tech.isPrinter) && m.fieldMode !== 8 && m.fieldMode !== 9 && !tech.isTokamak
        },
        requires: "mass driver, printer, not pilot wave, tokamak, wormhole",
        effect() {
            tech.isAddBlockMass = true
        },
        remove() {
            tech.isAddBlockMass = false
        }
    },
    {
        name: "restitution",
        description: "<strong>2.5x</strong> <strong class='color-block'>block</strong> collision <strong class='color-d'>damage</strong><br>after <strong>throwing</strong> a <strong class='color-block'>block</strong> it becomes very <strong>bouncy</strong>",
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return (tech.blockDamage > 0.075 || tech.isPrinter) && m.fieldUpgrades[m.fieldMode].name !== "pilot wave" && m.fieldUpgrades[m.fieldMode].name !== "wormhole" && !tech.isTokamak
        },
        requires: "mass driver, printer, not pilot wave, tokamak, wormhole",
        effect() {
            tech.isBlockRestitution = true
        },
        remove() {
            tech.isBlockRestitution = false
        }
    },
    {
        name: "flywheel",
        description: "<strong>2.5x</strong> <strong class='color-block'>block</strong> collision <strong class='color-d'>damage</strong><br>after a mob <strong>dies</strong> its <strong class='color-block'>block</strong> is <strong>flung</strong> at mobs",
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return (tech.blockDamage > 0.075 || tech.isPrinter)
        },
        requires: "mass driver, printer",
        effect() {
            tech.isMobBlockFling = true
        },
        remove() {
            tech.isMobBlockFling = false
        }
    },
    {
        name: "buckling",
        descriptionFunction() {
            return `if a <strong class='color-block'>block</strong> kills a mob there's a <strong>50%</strong> chance<br>to spawn either ${powerUps.orb.coupling(1)}, ${powerUps.orb.boost(1)}, ${powerUps.orb.heal()}, ${powerUps.orb.ammo()}, or ${powerUps.orb.research(1)}`
        },
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return (tech.blockDamage > 0.075 || tech.isPrinter) && !tech.isTokamak
        },
        requires: "mass driver, printer, not pilot wave, tokamak",
        effect() {
            tech.isBlockPowerUps = true
        },
        remove() {
            tech.isBlockPowerUps = false
        }
    },

    {
        name: "first derivative",
        descriptionFunction() {
            return `<strong>0.85x</strong> <strong class='color-defense'>damage taken</strong> per ${powerUps.orb.gun()} in your inventory<br>while the <strong>1st</strong> ${powerUps.orb.gun()} in your inventory is equipped<em style ="float: right;">(${(0.85 ** b.inventory.length).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isFirstDer = true
        },
        remove() {
            tech.isFirstDer = false;
        }
    },
    {
        name: "dark matter",
        //a MAssive Compact Halo Object follows you<br>
        descriptionFunction() {
            return `<strong class='color-dark-matter'>dark matter</strong> slowly gravitates <strong>towards</strong> you<br><strong>0.4x</strong> <strong class='color-defense'>damage taken</strong> <strong>${tech.isNotDarkMatter ? "outside" : "inside"}</strong> <strong class='color-dark-matter'>dark matter</strong>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isDarkMatter = true; //this harm reduction comes from the particle toggling  tech.isHarmDarkMatter
            spawn.darkMatter()
        },
        remove() {
            tech.isDarkMatter = false;
            tech.isHarmDarkMatter = false;
            for (let i = 0, len = mob.length; i < len; i++) {
                if (mob[i].isDarkMatter) mob[i].alive = false;
            }
        }
    },
    {
        name: "axion",
        descriptionFunction() {
            return `while <strong>${tech.isNotDarkMatter ? "outside" : "inside"}</strong> <strong class='color-dark-matter'>dark matter</strong><br> <strong>2x</strong> <strong class='color-d'>damage</strong>`
        },
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isDarkMatter
        },
        requires: "dark matter",
        effect() {
            tech.isAxion = true
        },
        remove() {
            tech.isAxion = false
        }
    },
    {
        name: "dark energy",
        descriptionFunction() {
            return `while <strong>${tech.isNotDarkMatter ? "outside" : "inside"}</strong> <strong class='color-dark-matter'>dark matter</strong><br>generate <strong>10</strong> <strong class='color-f'>energy</strong> per second`
        },
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isDarkMatter
        },
        requires: "dark matter",
        effect() {
            tech.isDarkEnergy = true
        },
        remove() {
            tech.isDarkEnergy = false
        }
    },
    {
        name: "MACHO",
        description: "<span style = 'font-size:93%;'><strong class='color-dark-matter'>dark matter's</strong> effects are only active <strong>outside</strong> it's range<br><strong>1.6x</strong> to all <strong class='color-dark-matter'>dark matter</strong> effects</span>",
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isDarkMatter && !tech.isMoveDarkMatter && !tech.isDarkStar
        },
        requires: "dark matter, not entropic gravity, dark star",
        effect() {
            tech.isNotDarkMatter = true
        },
        remove() {
            tech.isNotDarkMatter = false
        }
    },
    {
        name: "entropic gravity",
        description: "<strong>crouching</strong> pulls <strong class='color-dark-matter'>dark matter</strong> towards you<br><strong>1.6x</strong> to all <strong class='color-dark-matter'>dark matter</strong> effects",
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isDarkMatter && !tech.isNotDarkMatter
        },
        requires: "dark matter, not MACHO",
        effect() {
            tech.isMoveDarkMatter = true
        },
        remove() {
            tech.isMoveDarkMatter = false
        }
    },
    {
        name: "dark star",
        description: `mobs <strong>inside</strong> <strong class='color-dark-matter'>dark matter</strong> are <strong class='color-d'>damaged</strong><br><strong>1.3x</strong> <strong class='color-dark-matter'>dark matter</strong> radius`,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isDarkMatter && !tech.isNotDarkMatter
        },
        requires: "dark matter, not MACHO",
        effect() {
            tech.isDarkStar = true
        },
        remove() {
            tech.isDarkStar = false
        }
    },
    {
        name: "non-Newtonian armor",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Non-Newtonian_fluid' class="link">non-Newtonian armor</a>`,
        description: "after mob <strong>collisions</strong><br><strong>0.4x</strong> <strong class='color-defense'>damage taken</strong> for <strong>10</strong> seconds",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isHarmArmor = true;
        },
        remove() {
            tech.isHarmArmor = false;
        }
    },
    {
        name: "tessellation",
        description: `use ${powerUps.orb.research(2)}<br><strong>0.6x</strong> <strong class='color-defense'>damage taken</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return powerUps.research.count > 1 || build.isExperimentSelection
        },
        requires: "",
        effect() {
            tech.isFieldHarmReduction = true
            m.damageReduction *= 0.6
            for (let i = 0; i < 2; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
        },
        remove() {
            tech.isFieldHarmReduction = false
            if (this.count > 0) {
                m.damageReduction /= 0.6
                powerUps.research.changeRerolls(2)
            }
        }
    },
    {
        name: "Pauli exclusion",
        description: `for <strong>7</strong> seconds after mob <strong>collisions</strong><br>gain <strong class="color-invulnerable">invulnerbility</strong> and <em style="opacity: 0.3;">blocked <strong class='color-f'>energy</strong> regen</em>`,
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            m.collisionImmuneCycles += 420;
            if (m.immuneCycle < m.cycle + m.collisionImmuneCycles) m.immuneCycle = m.cycle + m.collisionImmuneCycles; //player is immune to damage
        },
        remove() {
            m.collisionImmuneCycles = 30;
        }
    },
    {
        name: "spin-statistics theorem",
        description: `for <strong>1.9</strong> seconds out of every <strong>7</strong> seconds<br>gain <strong class="color-invulnerable">invulnerbility</strong> and <em style="opacity: 0.3;">blocked <strong class='color-f'>energy</strong> regen</em>`,
        maxCount: 3,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true //m.collisionImmuneCycles > 30
        },
        requires: "",
        effect() {
            tech.cyclicImmunity += 114;
        },
        remove() {
            tech.cyclicImmunity = 0;
        }
    },
    {
        name: "fermion",
        description: `if a mob has <strong>died</strong> in the last <strong>5</strong> seconds<br>gain <strong class="color-invulnerable">invulnerbility</strong> and <em style="opacity: 0.3;">blocked <strong class='color-f'>energy</strong> regen</em>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isMobDeathImmunity = true;
        },
        remove() {
            tech.isMobDeathImmunity = false;
        }
    },
    {
        name: "abelian group",
        description: `<strong>3x</strong> <strong class='color-d'>damage</strong> while <strong class="color-invulnerable">invulnerable</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isMobDeathImmunity || tech.cyclicImmunity || m.collisionImmuneCycles > 30
        },
        requires: "invincibility tech",
        effect() {
            tech.isImmunityDamage = true;
        },
        remove() {
            tech.isImmunityDamage = false;
        }
    },
    {
        name: "refrigerant",
        descriptionFunction() {
            return `after losing at least <strong>5</strong> ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong>" : "<strong class='color-h'>health</strong>"}<br><strong class='color-s'>freeze</strong> all mobs for <strong>7</strong> seconds`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isHarmFreeze = true;
        },
        remove() {
            tech.isHarmFreeze = false;
        }
    },
    {
        name: "piezoelectricity",
        description: "if you <strong>collide</strong> with a mob<br>generate <strong>+2048</strong> <strong class='color-f'>energy</strong>",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isEnergyHealth
        },
        requires: "not mass-energy",
        effect() {
            tech.isPiezo = true;
        },
        remove() {
            tech.isPiezo = false;
        }
    },
    {
        name: "ground state",
        description: "<strong>+300</strong> maximum <strong class='color-f'>energy</strong><br><strong>0.66x</strong> passive <strong class='color-f'>energy</strong> generation",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isTimeCrystals
        },
        requires: "not time crystals",
        effect() {
            tech.isGroundState = true
            m.setFieldRegen()
            m.setMaxEnergy()
        },
        remove() {
            tech.isGroundState = false
            m.setFieldRegen()
            m.setMaxEnergy()
        }
    },
    {
        name: "heat engine",
        description: `<strong>1.4x</strong> <strong class='color-d'>damage</strong><br><strong>–50</strong> maximum <strong class='color-f'>energy</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed: () => true,
        requires: "not CPT",
        damage: 1.4,
        effect() {
            m.damageDone *= this.damage
            tech.isMaxEnergyTech = true;
            m.setMaxEnergy()
        },
        remove() {
            if (this.count && m.alive) m.damageDone /= this.damage
            tech.isMaxEnergyTech = false;
            m.setMaxEnergy()
        }
    },
    {
        name: "exothermic process",
        description: "<strong>1.6x</strong> <strong class='color-d'>damage</strong><br>after mobs <strong>die</strong> <strong>–5</strong> <strong class='color-f'>energy</strong>",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        damage: 1.6,
        effect() {
            m.damageDone *= this.damage
            tech.isEnergyLoss = true;
        },
        remove() {
            if (this.count && m.alive) m.damageDone /= this.damage
            tech.isEnergyLoss = false;
        }
    },
    {
        name: "Gibbs free energy",
        descriptionFunction() {
            return `<strong>1.007x</strong> <strong class='color-d'>damage</strong> for each missing <strong class='color-f'>energy</strong><br><strong>+6%</strong> chance for <strong class='color-junk'>JUNK</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong><em style ="float: right;">(${(1 + 0.5 * Math.max(0, m.maxEnergy - m.energy)).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isLowEnergyDamage = true;
            this.refundAmount += tech.addJunkTechToPool(0.06)

        },
        remove() {
            tech.isLowEnergyDamage = false;
            if (this.count > 0 && this.refundAmount > 0) {
                tech.removeJunkTechFromPool(this.refundAmount)
                this.refundAmount = 0
            }
        }
    },
    {
        name: "overcharge",
        description: "<strong>+100</strong> maximum <strong class='color-f'>energy</strong><br><strong>+5%</strong> chance for <strong class='color-junk'>JUNK</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong>",
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.junkChance < 1
        },
        requires: "",
        effect() {
            tech.bonusEnergy += 1
            m.setMaxEnergy()
            this.refundAmount += tech.addJunkTechToPool(0.05)
        },
        refundAmount: 0,
        remove() {
            tech.bonusEnergy = 0;
            m.setMaxEnergy()
            if (this.count > 0 && this.refundAmount > 0) {
                tech.removeJunkTechFromPool(this.refundAmount)
                this.refundAmount = 0
            }
        }
    },
    {
        name: "Maxwells demon",
        description: "<strong class='color-f'>energy</strong> above maximum decays <strong>30x</strong> slower<br><strong>+5%</strong> chance for <strong class='color-junk'>JUNK</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong>",
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (m.energy > m.maxEnergy || build.isExperimentSelection) && tech.junkChance < 1
        },
        requires: "energy above your max",
        effect() {
            tech.overfillDrain = 0.99 //70% = 1-(1-0.75)/(1-0.15) //92% = 1-(1-0.75)/(1-0.87)
            this.refundAmount += tech.addJunkTechToPool(0.05)
        },
        refundAmount: 0,
        remove() {
            tech.overfillDrain = 0.7
            if (this.count > 0 && this.refundAmount > 0) {
                tech.removeJunkTechFromPool(this.refundAmount)
                this.refundAmount = 0
            }
        }
    },
    {
        name: "inductive charging",
        description: "if <strong>crouched</strong> <strong>7x</strong> passive <strong class='color-f'>energy</strong> generation<br>otherwise <strong>0x</strong> passive <strong class='color-f'>energy</strong> generation",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isCrouchRegen = true; //only used to check for requirements
            m.regenEnergy = function () {
                if (m.immuneCycle < m.cycle && m.crouch && m.fieldCDcycle < m.cycle) m.energy += 7 * m.fieldRegen * level.isReducedRegen;
                if (m.energy < 0) m.energy = 0
            }
        },
        remove() {
            tech.isCrouchRegen = false;
            m.regenEnergy = m.regenEnergyDefault
        }
    },
    {
        name: "energy conservation",
        description: "doing <strong class='color-d'>damage</strong> to mobs generates <strong class='color-f'>energy</strong>",
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.energySiphon += 0.04;
        },
        remove() {
            tech.energySiphon = 0;
        }
    },
    {
        name: "waste heat recovery",
        description: "if a mob has <strong>died</strong> in the last <strong>5</strong> seconds<br>generate <strong>0.05x</strong> maximum <strong class='color-f'>energy</strong> every second",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isEnergyRecovery = true;
        },
        remove() {
            tech.isEnergyRecovery = false;
        }
    },
    {
        name: "recycling",
        descriptionFunction() {
            return `if a mob has <strong>died</strong> in the last <strong>5</strong> seconds<br>recover <strong>0.005x</strong> maximum ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong>" : "<strong class='color-h'>health</strong>"} every second`
        },
        description: "",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isHealTech: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isHealthRecovery = true;
        },
        remove() {
            tech.isHealthRecovery = false;
        }
    },
    {
        name: "fluoroantimonic acid",
        descriptionFunction() {
            return `if your ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong>" : "<strong class='color-h'>health</strong>"} is above <strong>100</strong><br><strong>1.35x</strong> <strong class='color-d'>damage</strong>`
        },
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.maxHealth > 1 || tech.isEnergyHealth;
        },
        requires: "maximum health above 100",
        effect() {
            tech.isAcidDmg = true;
        },
        remove() {
            tech.isAcidDmg = false;
        }
    },
    {
        name: "control theory",
        descriptionFunction() {
            return `<strong>2x</strong> <strong class='color-d'>damage</strong><br>while your ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong>" : "<strong class='color-h'>health</strong>"} is at maximum`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isMaxHealthDamage = true;
        },
        remove() {
            tech.isMaxHealthDamage = false;
        }
    },
    {
        name: "stability",
        descriptionFunction() {
            return `<strong>0.1x</strong> <strong class='color-defense'>damage taken</strong><br>while your ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong>" : "<strong class='color-h'>health</strong>"} is full`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isMaxHealthDefense = true;
        },
        remove() {
            tech.isMaxHealthDefense = false;
        }
    },
    {
        name: "instability",
        descriptionFunction() {
            return `<strong>2.5x</strong> <strong class='color-d'>damage</strong> while your <strong class='color-defense'>damage taken</strong> is <strong>1.00x</strong><br><em style ="float: right;">(current damage taken = ${(m.defense()).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.noDefenseSettingDamage = true;
        },
        remove() {
            tech.noDefenseSettingDamage = false;
        }
    },
    {
        name: "torpor",
        description: "if a mob has <strong>not died</strong> in the last <strong>5</strong> seconds<br><strong>0.3x</strong> <strong class='color-defense'>damage taken</strong>",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isHarmReduceNoKill = true;
        },
        remove() {
            tech.isHarmReduceNoKill = false;
        }
    },
    {
        name: "homeostasis",
        descriptionFunction() {
            // return `<strong>0.9x</strong> <strong class='color-defense'>damage taken</strong> for each ${name} missing<br><em>(${(Math.pow(0.1 * max, Math.max(0, max - h))).toFixed(2)}x)</em>`
            const scale = 0.2 //adjust this to control the strength of this effect
            return `missing ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong>" : "<strong class='color-h'>health</strong>"} reduces <strong class='color-defense'>damage taken</strong><br>down to <strong>${scale}x</strong> at <strong>0</strong> ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong>" : "<strong class='color-h'>health</strong>"}<em style ="float: right;">(${(Math.pow(scale, Math.max(0, 1 - (tech.isEnergyHealth ? m.energy / m.maxEnergy : m.health / m.maxHealth)))).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return m.health < 0.9 || build.isExperimentSelection
        },
        requires: "health below 60",
        effect() {
            tech.isLowHealthDefense = true;
        },
        remove() {
            tech.isLowHealthDefense = false;
        }
    },
    {
        name: "negative feedback",
        descriptionFunction() {
            return `<strong>1.006x</strong> <strong class='color-d'>damage</strong> for each missing ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong>" : "<strong class='color-h'>health</strong>"}<br><em style ="float: right;">(${(1 + 0.6 * Math.max(0, (tech.isEnergyHealth ? m.maxEnergy - m.energy : m.maxHealth - m.health))).toFixed(2)}x)</em>` //1 + 0.6 * Math.max(0, (tech.isEnergyHealth ? m.maxEnergy - m.energy : m.maxHealth - m.health))
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return m.health < 0.9 || build.isExperimentSelection
        },
        requires: "health below 90",
        effect() {
            tech.isLowHealthDmg = true; //used in mob.damage()
        },
        remove() {
            tech.isLowHealthDmg = false;
        }
    },
    {
        name: "Zenos paradox",
        descriptionFunction() {
            return `<strong>0.3x</strong> <strong class='color-defense'>damage taken</strong><br><strong>–5%</strong> of current ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong>" : "<strong class='color-h'>health</strong>"} every <strong>5</strong> seconds`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isZeno = true;
            m.damageReduction *= 0.3
        },
        remove() {
            tech.isZeno = false;
            if (this.count > 0) {
                m.damageReduction /= 0.3
            }
        }
    },
    {
        name: "quantum Zeno effect",
        descriptionFunction() {
            return `you can only <strong>die</strong> if you <strong>end</strong> a level with <strong class='color-h'>health</strong> < <strong>0</strong><br><strong>2x</strong> <strong class='color-d'>damage</strong> while <strong class='color-h'>health</strong> < <strong>0</strong>`
            // return `you don't <strong>die</strong> when you go below <strong>0</strong> <strong class='color-h'>health</strong>, but<br>you need <strong class='color-h'>health</strong> above <strong>0</strong> to <strong>exit</strong> the level`
            // return `you can't <strong>die</strong> if <strong class='color-h'>health</strong> < <strong>0</strong>, but<br>you need <strong class='color-h'>health</strong> > <strong>0</strong> to <strong>exit</strong> the level`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isEnergyHealth
        },
        requires: "not mass-energy",
        effect() {
            tech.isNoDeath = true;
        },
        remove() {
            tech.isNoDeath = false;
        }
    },
    {
        name: "quantum Darwinism",
        descriptionFunction() {
            return `once per level if <strong class='color-h'>health</strong> < <strong>0</strong><br>spawn ${powerUps.orb.tech()} and <strong>+2%</strong> chance for <strong class='color-junk'>JUNK</strong>`
        },
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return tech.isNoDeath
        },
        requires: "quantum Zeno effect",
        effect() {
            tech.isDeathTech = true;
            tech.isDeathTechTriggered = false
        },
        remove() {
            tech.isDeathTech = false;
            tech.isDeathTechTriggered = false
        }
    },
    {
        name: "antiscience",
        descriptionFunction() {
            return `<strong>–10</strong> ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong>" : "<strong class='color-h'>health</strong>"} after picking up ${powerUps.orb.tech()}<br><strong>1.7x</strong> <strong class='color-d'>damage</strong>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBadRandomOption: true,
        allowed() {
            return true
        },
        requires: "",
        damage: 1.7,
        effect() {
            m.damageDone *= this.damage
            tech.isTechDamage = true;
        },
        remove() {
            if (this.count && m.alive) m.damageDone /= this.damage
            tech.isTechDamage = false;
        }
    },
    {
        name: "ergodicity",
        descriptionFunction() {
            return `<strong>0.5x</strong> <strong class='color-h'>healing</strong> from ${powerUps.orb.heal()}<br><strong>1.7x</strong> <strong class='color-d'>damage</strong>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        damage: 1.7,
        effect() {
            m.damageDone *= this.damage
            tech.isHalfHeals = true;
            for (let i = 0; i < powerUp.length; i++) {
                if (powerUp[i].name === "heal") {
                    const scale = Math.sqrt(0.5)
                    powerUp[i].size *= scale
                    Matter.Body.scale(powerUp[i], scale, scale); //grow    
                }
            }
        },
        remove() {
            if (this.count && m.alive) {
                m.damageDone /= this.damage
                for (let i = 0; i < powerUp.length; i++) {
                    if (powerUp[i].name === "heal") {
                        const scale = 1 / Math.sqrt(0.5)
                        powerUp[i].size *= scale
                        Matter.Body.scale(powerUp[i], scale, scale); //grow    
                    }
                }
            }
            tech.isHalfHeals = false;
        }
    },
    {
        name: "induction brake",
        descriptionFunction() {
            return `after using ${powerUps.orb.heal()}<br><strong class='color-s'>slow</strong> nearby mobs for <strong>17</strong> seconds`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isPerfectBrake
        },
        requires: "not eddy current brake",
        effect() {
            tech.isHealBrake = true;
        },
        remove() {
            tech.isHealBrake = false;
        }
    },
    {
        name: "adiabatic healing",
        descriptionFunction() {
            return `<strong>2x</strong> <strong class='color-h'>healing</strong> from ${powerUps.orb.heal()}<br><strong>+4%</strong> chance for <strong class='color-junk'>JUNK</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong>`
        },
        maxCount: 3,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isHealTech: true,
        allowed() {
            return ((m.health / m.maxHealth) < 0.7 || build.isExperimentSelection) && tech.junkChance < 1
        },
        requires: "under 70% health",
        effect() {
            tech.largerHeals++;
            for (let i = 0; i < powerUp.length; i++) {
                if (powerUp[i].name === "heal") {
                    const oldSize = powerUp[i].size
                    powerUp[i].size = powerUps.heal.size() //update current heals
                    const scale = powerUp[i].size / oldSize
                    Matter.Body.scale(powerUp[i], scale, scale); //grow    
                }
            }
            this.refundAmount += tech.addJunkTechToPool(0.04)
        },
        refundAmount: 0,
        remove() {
            tech.largerHeals = 1;
            for (let i = 0; i < powerUp.length; i++) {
                if (powerUp[i].name === "heal") {
                    const oldSize = powerUp[i].size
                    powerUp[i].size = powerUps.heal.size() //update current heals
                    const scale = powerUp[i].size / oldSize
                    Matter.Body.scale(powerUp[i], scale, scale); //grow    
                }
            }
            if (this.count > 0 && this.refundAmount > 0) {
                tech.removeJunkTechFromPool(this.refundAmount)
                this.refundAmount = 0
            }
        }
    },
    {
        name: "quenching",
        descriptionFunction() {
            return `<strong>0.5x</strong> of ${powerUps.orb.heal()} over<strong class='color-h'>healing</strong><br>is added to <strong>maximum</strong> <strong class='color-h'>health</strong>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isHealTech: true,
        allowed() {
            return !tech.isEnergyHealth
        },
        requires: "not mass-energy",
        effect() {
            tech.isOverHeal = true;
        },
        remove() {
            tech.isOverHeal = false;
        }
    },
    {
        name: "accretion",
        descriptionFunction() {
            return `${powerUps.orb.heal(1)} follow you, even between levels<br><strong>+4%</strong> chance to <strong class='color-dup'>duplicate</strong> spawned <strong>power ups</strong>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isHealTech: true,
        allowed() {
            return m.fieldMode !== 9
        },
        requires: "not wormhole",
        effect() {
            tech.isHealAttract = true
            powerUps.setPowerUpMode();
            if (!build.isExperimentSelection && !simulation.isTextLogOpen) simulation.circleFlare(0.04);
        },
        remove() {
            tech.isHealAttract = false
            powerUps.setPowerUpMode();
        },
    },
    {
        name: "accretion disk",
        descriptionFunction() {
            return `<strong>1.07x</strong> <strong class='color-d'>damage</strong> for each <strong>power up</strong> on this <strong>level</strong><br><strong>+5%</strong> chance for <strong class='color-junk'>JUNK</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong> <em style ="float: right;">(${(1 + 0.07 * powerUp.length).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        isHealTech: true,
        allowed() {
            return tech.isHealAttract
        },
        requires: "accretion",
        effect() {
            tech.isPowerUpDamage = true
            this.refundAmount += tech.addJunkTechToPool(0.05)
        },
        refundAmount: 0,
        remove() {
            tech.isPowerUpDamage = false
            if (this.count > 0 && this.refundAmount > 0) {
                tech.removeJunkTechFromPool(this.refundAmount)
                this.refundAmount = 0
            }
        },
    },
    {
        name: "maintenance",
        descriptionFunction() {
            return `<strong>2x</strong> <em class='flicker'>frequency</em> for ${powerUps.orb.tech()} with <strong class='color-h'>healing</strong><br>spawn ${powerUps.orb.heal(13)}`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isInstant: true,
        isBadRandomOption: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            for (let i = 0; i < 13; i++) powerUps.spawn(m.pos.x + 60 * (Math.random() - 0.5), m.pos.y + 60 * (Math.random() - 0.5), "heal");
            for (let i = 0, len = tech.tech.length; i < len; i++) {
                if (tech.tech[i].isHealTech) tech.tech[i].frequency *= 2
            }
        },
        remove() { }
    },
    {
        name: "self-assembly",
        descriptionFunction() {
            return `at the start of each <strong>level</strong><br>for every <strong>20</strong> missing ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong>" : "<strong class='color-h'>health</strong>"} spawn ${powerUps.orb.heal()}`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isHealTech: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isHealLowHealth = true;
        },
        remove() {
            tech.isHealLowHealth = false;
        }
    },
    {
        name: "interest",
        descriptionFunction() {
            const r = Math.ceil(this.rate * powerUps.research.count)
            const c = Math.ceil(this.rate * m.coupling)
            return `at the start of each <strong>level</strong><br>spawn <strong>${(100 * this.rate).toFixed(0)}%</strong> of your ${powerUps.orb.research(1)} and ${powerUps.orb.coupling(1)} <em style ="float: right;">(get ${r} ${powerUps.orb.research(1)}, ${c} ${powerUps.orb.coupling(1)})</em>`
        },
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return true
        },
        requires: "",
        rate: 0.15,
        effect() {
            tech.interestRate += this.rate;
        },
        remove() {
            tech.interestRate = 0;
        }
    },
    {
        name: "anthropic principle",
        // nameInfo: "<span id = 'tech-anthropic'></span>",
        // addNameInfo() {
        //     setTimeout(function () {
        //         powerUps.research.changeRerolls(0)
        //     }, 1000);
        // },
        descriptionFunction() {
            // return `once per level, instead of <strong>dying</strong> use ${powerUps.orb.research(1)} and<br>spawn ${powerUps.orb.heal(22)}`
            return `once per level, if <strong class='color-h'>health</strong> < <strong>0</strong> use ${powerUps.orb.research(1)} to survive<br>and spawn ${powerUps.orb.heal(22)}<em style ="float: right;">(${(!tech.isDeathAvoidedThisLevel && powerUps.research.count > 0) ? "on" : "off"})</em>`

        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isHealTech: true,
        allowed() {
            return powerUps.research.count > 0 || build.isExperimentSelection
        },
        requires: "at least 1 research",
        effect() {
            tech.isDeathAvoid = true;
            tech.isDeathAvoidedThisLevel = false;
            setTimeout(function () {
                powerUps.research.changeRerolls(0)
            }, 1000);
        },
        remove() {
            tech.isDeathAvoid = false;
        }
    },
    {
        name: "weak anthropic principle",
        description: "after <strong>anthropic principle</strong> prevents your <strong>death</strong><br><strong>+60%</strong> <strong class='color-dup'>duplication</strong> chance for that level",
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return tech.isDeathAvoid
        },
        requires: "anthropic principle",
        effect() {
            tech.isAnthropicTech = true
            powerUps.setPowerUpMode(); //needed after adjusting duplication chance
        },
        remove() {
            tech.isAnthropicTech = false
            powerUps.setPowerUpMode(); //needed after adjusting duplication chance
        }
    },
    {
        name: "strong anthropic principle",
        description: "after <strong>anthropic principle</strong> prevents your <strong>death</strong><br><strong>2.71828x</strong> <strong class='color-d'>damage</strong> for that level",
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return tech.isDeathAvoid
        },
        requires: "anthropic principle",
        effect() {
            tech.isAnthropicDamage = true
        },
        remove() {
            tech.isAnthropicDamage = false
        }
    },
    {
        name: "quantum immortality",
        description: "<strong>0.7x</strong> <strong class='color-defense'>damage taken</strong><br>after <strong>dying</strong>, continue in an <strong class='alt'>alternate reality</strong>",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isAltRealityTech: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isImmortal = true;
            m.damageReduction *= 0.7
        },
        remove() {
            tech.isImmortal = false;
            if (this.count > 0) m.damageReduction /= 0.7
        }
    },
    {
        name: "many-worlds",
        description: `at the start of each <strong>level</strong> spawn ${powerUps.orb.tech()}<br>and enter an <strong class='alt'>alternate reality</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isAltRealityTech: true,
        allowed() {
            return !tech.isResearchReality && !tech.isCollisionRealitySwitch
        },
        requires: "not Ψ(t) collapse, Hilbert space",
        effect() {
            tech.isSwitchReality = true;
        },
        remove() {
            tech.isSwitchReality = false;
        }
    },
    {
        name: "Ψ(t) collapse",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Wave_function_collapse' class="link">Ψ(t) collapse</a>`,
        description: `after a <strong>boss</strong> <strong>dies</strong> spawn ${powerUps.orb.research(4)}<br>if you <strong class='color-r'>research</strong> enter an <strong class='alt'>alternate reality</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isAltRealityTech: true,
        allowed() {
            return !tech.isSwitchReality && !tech.isCollisionRealitySwitch && !tech.isJunkResearch
        },
        requires: "not many-worlds, Hilbert space, pseudoscience",
        bonusResearch: 21,
        effect() {
            tech.isResearchReality = true;
            // for (let i = 0; i < this.bonusResearch; i++) powerUps.spawn(m.pos.x + Math.random() * 60, m.pos.y + Math.random() * 60, "research", false);
        },
        remove() {
            tech.isResearchReality = false;
            // if (this.count > 0) powerUps.research.changeRerolls(-this.bonusResearch)
        }
    },
    {
        name: "decoherence",
        description: `after a <strong>boss</strong> <strong>dies</strong> spawn ${powerUps.orb.research(3)}<br>${powerUps.orb.tech()} options you don't <strong class='color-choice'><span>ch</span><span>oo</span><span>se</span></strong> won't <strong>reoccur</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isSuperDeterminism
        },
        requires: "not, superdeterminism",
        effect() {
            tech.isBanish = true
        },
        remove() {
            if (tech.isBanish) {
                tech.isBanish = false
                //reset banish list
                for (let i = 0; i < tech.tech.length; i++) {
                    if (tech.tech[i].isBanished) tech.tech[i].isBanished = false
                }
            }
            tech.isBanish = false
        }
    },
    {
        name: "coherence",
        description: `after observing a ${powerUps.orb.tech()} <strong class='color-choice'><span>ch</span><span>oi</span><span>ce</span></strong><br>that <strong class='color-choice'><span>ch</span><span>oi</span><span>ce</span></strong> is available for all <strong>all</strong> future ${powerUps.orb.tech()}`,
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return tech.isBanish
        },
        requires: "decoherence",
        effect() {
            tech.isRetain = true
        },
        remove() {
            tech.isRetain = false
        }
    },
    {
        name: "peer review",
        description: `after you <strong class='color-r'>research</strong> gain <strong>1.05x</strong> <strong class='color-d'>damage</strong><br>and <strong>+1%</strong> chance for <strong class='color-junk'>JUNK</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return (powerUps.research.count > 0 || build.isExperimentSelection) && !tech.isSuperDeterminism
        },
        requires: "at least 1 research, not superdeterminism",
        effect() {
            tech.isResearchDamage = true;
        },
        remove() {
            tech.isResearchDamage = false;
        }
    },
    {
        name: "pseudoscience",
        description: "<strong class='color-r'>research</strong> <strong>2</strong> times</span> for <strong>free</strong>, but<br><strong>+1%</strong> chance for <strong class='color-junk'>JUNK</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong> each time",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isResearchReality && !tech.isSuperDeterminism
        },
        requires: "not Ψ(t) collapse, superdeterminism",
        effect() {
            tech.isJunkResearch = true;
        },
        remove() {
            tech.isJunkResearch = false;
        }
    },
    {
        name: "renormalization",
        description: `<strong>47%</strong> chance to spawn ${powerUps.orb.research(1)} after consuming ${powerUps.orb.research(1)}<br><strong>+5%</strong> chance for <strong class='color-junk'>JUNK</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong>`,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (powerUps.research.count > 3 || build.isExperimentSelection) && !tech.isSuperDeterminism && tech.junkChance < 1
        },
        requires: "at least 4 research, not superdeterminism",
        effect() {
            tech.renormalization = true;
            this.refundAmount += tech.addJunkTechToPool(0.05)

        },
        refundAmount: 0,
        remove() {
            tech.renormalization = false;
            if (this.count > 0 && this.refundAmount > 0) {
                tech.removeJunkTechFromPool(this.refundAmount)
                this.refundAmount = 0
            }
        }
    },
    {
        name: "perturbation theory",
        description: `if you have no ${powerUps.orb.research(1)} in your inventory<br><strong>2x</strong> <em>fire rate</em>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return powerUps.research.count === 0
        },
        requires: "no research",
        effect() {
            tech.isRerollHaste = true;
            powerUps.research.changeRerolls(0)
            b.setFireCD();
        },
        remove() {
            tech.isRerollHaste = false;
            tech.researchHaste = 1;
            b.setFireCD();
        }
    },
    {
        name: "Bayesian statistics",
        descriptionFunction() {
            return `<strong>1.05x</strong> <strong class='color-d'>damage</strong> per ${powerUps.orb.research(1)} in your inventory<br><em style ="float: right;">(${(1 + Math.max(0, 0.05 * powerUps.research.count)).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return powerUps.research.count > 1 || build.isExperimentSelection
        },
        requires: "at least 2 research",
        effect() {
            tech.isRerollDamage = true;
        },
        remove() {
            tech.isRerollDamage = false;
        }
    },
    {
        name: "ansatz",
        description: `after <strong class='color-choice'><span>ch</span><span>oos</span><span>ing</span></strong> ${powerUps.orb.field()}, ${powerUps.orb.tech()}, or ${powerUps.orb.gun()}<br>if you have no ${powerUps.orb.research(1)} in your inventory spawn ${powerUps.orb.research(3)}`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return powerUps.research.count < 1 && !tech.isSuperDeterminism && !tech.isRerollHaste
        },
        requires: "no research, not superdeterminism, Ψ(t) collapse, perturbation theory",
        effect() {
            tech.isAnsatz = true;
        },
        remove() {
            tech.isAnsatz = false;
        }
    },
    {
        name: "unified field theory",
        description: `when <strong>paused</strong> you can click to <strong>change</strong> your ${powerUps.orb.field()}<br><strong>2x</strong> frequency for <em class='flicker'>${powerUps.orb.fieldTech()}</em>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isSuperDeterminism
        },
        requires: "not superdeterminism",
        effect() {
            tech.isPauseSwitchField = true;
            for (let i = 0, len = tech.tech.length; i < len; i++) {
                if (tech.tech[i].isFieldTech) tech.tech[i].frequency *= 2
            }
        },
        remove() {
            tech.isPauseSwitchField = false;
            if (this.count > 1) {
                for (let i = 0, len = tech.tech.length; i < len; i++) {
                    if (tech.tech[i].isFieldTech) tech.tech[i].frequency /= 2
                }
            }
        }
    },
    {
        name: "eternalism",
        description: `<strong>1.3x</strong> <strong class='color-d'>damage</strong>, but <strong>time</strong> doesn't <strong>pause</strong><br>while <strong class='color-choice'><span>ch</span><span>oos</span><span>ing</span></strong> ${powerUps.orb.field()}, ${powerUps.orb.tech()}, or ${powerUps.orb.gun()}`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isPauseSwitchField && !tech.isPauseEjectTech && !tech.isWormHolePause
        },
        requires: "not unified field theory, paradigm shift, invariant",
        damage: 1.3,
        effect() {
            m.damageDone *= this.damage
            tech.isNoDraftPause = true
        },
        remove() {
            if (this.count && m.alive) m.damageDone /= this.damage
            tech.isNoDraftPause = false
        }
    },
    {
        name: "brainstorming",
        description: `<strong>randomize</strong> ${powerUps.orb.tech()} <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong><br>every <strong>1.5</strong> seconds for <strong>10</strong> seconds`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isSuperDeterminism
        },
        requires: "not superdeterminism",
        effect() {
            tech.isBrainstorm = true
            tech.isBrainstormActive = false
            tech.brainStormDelay = 2000 - simulation.difficultyMode * 100
        },
        remove() {
            tech.isBrainstorm = false
            tech.isBrainstormActive = false
        }
    },
    {
        name: "cross-disciplinary",
        description: `${powerUps.orb.tech()} have an extra ${powerUps.orb.field()} or ${powerUps.orb.gun()} <strong class='color-choice'><span>ch</span><span>oi</span><span>ce</span></strong><br><strong>+5%</strong> chance to <strong class='color-dup'>duplicate</strong> spawned <strong>power ups</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isDeterminism
        },
        requires: "not determinism",
        effect() {
            tech.isExtraGunField = true;
            powerUps.setPowerUpMode(); //needed after adjusting duplication chance
            if (!build.isExperimentSelection && !simulation.isTextLogOpen) simulation.circleFlare(0.05);
        },
        remove() {
            tech.isExtraGunField = false;
            if (this.count) powerUps.setPowerUpMode(); //needed after adjusting duplication chance
        }
    },
    {
        name: "emergence",
        description: `${powerUps.orb.field()}, ${powerUps.orb.tech()}, and ${powerUps.orb.gun()} have <strong>+1</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ce</span></strong><br><strong>1.1x</strong> <strong class='color-d'>damage</strong>`,
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isDeterminism
        },
        requires: "not determinism",
        damage: 1.1,
        effect() {
            tech.extraChoices += 1;
            m.damageDone *= this.damage
        },
        refundAmount: 0,
        remove() {
            tech.extraChoices = 0;
            if (this.count && m.alive) m.damageDone /= this.damage
        }
    },
    {
        name: "path integral",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Path_integral_formulation' class="link">path integral</a>`,
        description: `your next ${powerUps.orb.tech()} has all possible <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong><br><strong>+4%</strong> chance for <strong class='color-junk'>JUNK</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isInstant: true,
        // isJunk: true,
        allowed() {
            return !tech.isDeterminism && !tech.isBrainstorm && tech.junkChance < 1
        },
        requires: "not determinism, brainstorm",
        effect() {
            tech.tooManyTechChoices = 1
            // for (let i = 0; i < this.bonusResearch; i++) powerUps.spawn(m.pos.x + 40 * (Math.random() - 0.5), m.pos.y + 40 * (Math.random() - 0.5), "research", false);
            this.refundAmount += tech.addJunkTechToPool(0.04)
        },
        refundAmount: 0,
        remove() {
            tech.tooManyTechChoices = 0
            if (this.count > 0 && this.refundAmount > 0) {
                tech.removeJunkTechFromPool(this.refundAmount)
                this.refundAmount = 0
            }
        }
    },
    {
        name: "determinism",
        description: `spawn ${powerUps.orb.tech()}${powerUps.orb.tech()}${powerUps.orb.tech()}${powerUps.orb.tech()}${powerUps.orb.tech()}<br>${powerUps.orb.field()}, ${powerUps.orb.tech()}, and ${powerUps.orb.gun()} have only <strong>1</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ce</span></strong>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBadRandomOption: true,
        isInstant: true,
        allowed() {
            return !tech.extraChoices && !tech.isExtraGunField && !tech.isExtraBotOption
        },
        requires: "not emergence, cross-disciplinary, integrated circuit",
        effect() {
            tech.isDeterminism = true;
            //if you change the number spawned also change it in Born rule
            for (let i = 0; i < 5; i++) powerUps.spawn(m.pos.x + 60 * (Math.random() - 0.5), m.pos.y + 60 * (Math.random() - 0.5), "tech");
        },
        remove() {
            tech.isDeterminism = false;
        }
    },
    {
        name: "superdeterminism",
        description: `spawn ${powerUps.orb.tech()}${powerUps.orb.tech()}${powerUps.orb.tech()}${powerUps.orb.tech()}${powerUps.orb.tech()}<br>you can't <strong class='color-cancel'>cancel</strong> and ${powerUps.orb.research(1)} no longer <strong>spawn</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        isBadRandomOption: true,
        isInstant: true,
        allowed() {
            return tech.isDeterminism && !tech.isAnsatz && !tech.isJunkResearch && !tech.isBrainstorm
        },
        requires: "determinism, not ansatz, pseudoscience, brainstorming",
        effect() {
            tech.isSuperDeterminism = true;
            //if you change the number spawned also change it in Born rule
            for (let i = 0; i < 5; i++) powerUps.spawn(m.pos.x + 60 * (Math.random() - 0.5), m.pos.y + 60 * (Math.random() - 0.5), "tech");
        },
        remove() {
            tech.isSuperDeterminism = false;
        }
    },
    {
        name: "technical debt",
        descriptionFunction() {
            return `increase <strong class='color-d'>damage</strong> by <strong>4x</strong>, but reduce <strong class='color-d'>damage</strong><br>by <strong>0.15x</strong> for each ${powerUps.orb.tech()} you have<em style ="float: right;">(${(tech.totalCount > 20 ? (Math.pow(0.85, tech.totalCount - 20)) : (4 - 0.15 * tech.totalCount)).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBadRandomOption: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isTechDebt = true;
        },
        remove() {
            tech.isTechDebt = false;
        }
    },
    {
        name: "meta-analysis",
        description: `if you <strong class='color-choice'><span>ch</span><span>oo</span><span>se</span></strong> <strong class='color-junk'>JUNK</strong><br>you get a random <strong class='color-choice'><span>ch</span><span>oi</span><span>ce</span></strong> and ${powerUps.orb.research(2)} instead`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.junkChance > 0.1
        },
        requires: "some JUNK tech",
        effect() {
            tech.isMetaAnalysis = true
        },
        remove() {
            tech.isMetaAnalysis = false
        }
    },
    {
        name: "dark patterns",
        description: "<strong>1.3x</strong> <strong class='color-d'>damage</strong><br><strong>+15%</strong> chance for <strong class='color-junk'>JUNK</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong>",
        maxCount: 3,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.junkChance < 1
        },
        requires: "",
        damage: 1.3,
        effect() {
            m.damageDone *= this.damage
            this.refundAmount += tech.addJunkTechToPool(0.15)
        },
        refundAmount: 0,
        remove() {
            if (this.count && m.alive) {
                m.damageDone /= this.damage
                if (this.refundAmount > 0) tech.removeJunkTechFromPool(this.refundAmount)
            }
        }
    },
    {
        name: "junk DNA",
        descriptionFunction() {
            return `increase <strong class='color-d'>damage</strong> by twice your<br><strong class='color-junk'>JUNK</strong> chance <em style ="float: right;">(${(1 + 2 * (tech.junkChance + level.junkAdded)).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.junkChance > 0
        },
        requires: "JUNK in tech pool",
        effect() {
            tech.isJunkDNA = true
        },
        remove() {
            tech.isJunkDNA = false
        }
    },
    {
        name: "mass production",
        descriptionFunction() {
            return `${powerUps.orb.tech()} have extra <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong> to spawn ${powerUps.orb.ammo(1)},&nbsp; ${powerUps.orb.heal(1)}, &nbsp;or&nbsp; ${powerUps.orb.research(1)}<br><strong>+3%</strong> chance to <strong class='color-dup'>duplicate</strong> spawned <strong>power ups</strong>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() { return true },
        requires: "",
        effect() {
            tech.isMassProduction = true
            powerUps.setPowerUpMode(); //needed after adjusting duplication chance
            if (!build.isExperimentSelection && !simulation.isTextLogOpen) simulation.circleFlare(0.03);
        },
        remove() {
            tech.isMassProduction = false
            if (this.count) powerUps.setPowerUpMode(); //needed after adjusting duplication chance

        }
    },
    {
        name: "research",
        descriptionFunction() {
            return `spawn ${this.value > 36 ? this.value + powerUps.orb.research(1) : powerUps.orb.research(this.value)} <br>next time increase amount spawned by +4${powerUps.orb.research(1)}`
        },
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isInstant: true,
        isMassProduction: true,
        allowed() { return true },
        requires: "",
        value: 8,
        defaultValue: 8,
        effect() {
            powerUps.spawnDelay("research", this.value);
            this.value += 4
        },
        remove() { }
    },
    {
        name: "ammo",
        descriptionFunction() {
            return `spawn ${this.value > 33 ? this.value + powerUps.orb.ammo(1) : powerUps.orb.ammo(this.value)}<br>next time increase amount spawned by +7${powerUps.orb.ammo(1)}`
        },
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isInstant: true,
        isMassProduction: true,
        allowed() { return true },
        requires: "",
        value: 10,
        defaultValue: 10,
        effect() {
            powerUps.spawnDelay("ammo", this.value);
            this.value += 7
        },
        remove() { }
    },
    {
        name: "heals",
        descriptionFunction() {
            return `spawn ${this.value > 30 ? this.value + powerUps.orb.heal(1) : powerUps.orb.heal(this.value)}<br>next time increase amount spawned by +7${powerUps.orb.heal(1)}`
        },
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isInstant: true,
        isMassProduction: true,
        allowed() { return true },
        requires: "",
        value: 10,
        defaultValue: 10,
        effect() {
            powerUps.spawnDelay("heal", this.value);
            this.value += 7
        },
        remove() { }
    },
    {
        name: "field coupling",
        descriptionFunction() {
            return `spawn ${powerUps.orb.coupling(10)}<br><em>${m.couplingDescription(1)} per ${powerUps.orb.coupling(1)}</em>`
        },
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isInstant: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            powerUps.spawnDelay("coupling", 10)
        },
        remove() {
            // if (this.count) m.couplingChange(-this.count * 10)
        }
    },
    {
        name: "quintessence",
        descriptionFunction() {
            if (this.count) {
                converted = this.researchUsed * this.couplingToResearch
                let orbText
                if (converted > 15) {
                    orbText = `${converted} ${powerUps.orb.coupling()}`
                } else {
                    orbText = powerUps.orb.coupling(converted)
                }
                return `convert ${this.researchUsed} ${powerUps.orb.research(1)} into <strong>${orbText}</strong><br><em>${m.couplingDescription(1)} per ${powerUps.orb.coupling(1)}</em>`
            } else {
                let converted = powerUps.research.count * this.couplingToResearch
                let orbText
                if (converted > 15) {
                    orbText = `${converted} ${powerUps.orb.coupling()}`
                } else {
                    orbText = powerUps.orb.coupling(converted)
                }
                return `convert ${powerUps.research.count} ${powerUps.orb.research(1)} into <strong>${orbText}</strong><br><em>${m.couplingDescription(1)} per ${powerUps.orb.coupling(1)}</em>`
            }
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isInstant: true,
        allowed() {
            return powerUps.research.count > 3
        },
        requires: "",
        researchUsed: 0,
        couplingToResearch: 3,
        effect() {
            // let count = 0
            // while (powerUps.research.count > 0 && powerUps.research.count !== Infinity) {
            //     powerUps.research.changeRerolls(-1)
            //     count += 2.5
            //     this.researchUsed++
            // }
            // powerUps.spawnDelay("coupling", Math.floor(count))

            let cycle = () => {
                if (powerUps.research.count > 0 && powerUps.research.count !== Infinity) {
                    if (m.alive) requestAnimationFrame(cycle);
                    if (!simulation.paused && !simulation.isChoosing) { //&& !(simulation.cycle % 2)
                        powerUps.research.changeRerolls(-1)
                        this.researchUsed++
                        powerUps.spawnDelay("coupling", this.couplingToResearch)
                    }
                }  // else exit delay loop

            }
            requestAnimationFrame(cycle);
        },
        remove() {
            if (this.count) {
                m.couplingChange(-this.researchUsed * this.couplingToResearch)
                powerUps.research.changeRerolls(this.researchUsed)
                this.researchUsed = 0
            }
        }
    },
    {
        name: "virtual particles",
        descriptionFunction() {
            return `<strong>17%</strong> chance after mobs <strong>die</strong> to spawn ${powerUps.orb.coupling(1)}<br><em>${m.couplingDescription(1)} per ${powerUps.orb.coupling(1)}</em>`
            // return `<strong>17%</strong> chance after mobs <strong>die</strong> to spawn ${powerUps.orb.coupling(1)} that each give <strong>+0.1</strong> <strong class='color-coupling'>coupling</strong>` //<br>${m.couplingDescription(1)} ${m.fieldMode === 0 ? "" : "per <strong class='color-coupling'>coupling</strong>"}
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed: () => true,
        requires: "",
        effect() {
            tech.isCouplingPowerUps = true //about 20-30 mobs per level so at 16% and 0.1 coupling that's about 25 * 0.16 * 0.1 = 0.4 coupling per level with out duplication
        },
        remove() {
            tech.isCouplingPowerUps = false
        }
    },
    {
        name: "fine-structure constant",
        descriptionFunction() {
            // return `spawn ${this.value} ${powerUps.orb.coupling(1)} that each give <strong>+0.1</strong> <strong class='color-coupling'>coupling</strong><br><strong>-0.5</strong> <strong class='color-coupling'>coupling</strong> after mob <strong>collisions</strong>`//<br>${m.couplingDescription(1)} ${m.fieldMode === 0 ? "" : "per <strong class='color-coupling'>coupling</strong>"}
            return `after a <strong>boss</strong> <strong>dies</strong> spawn ${powerUps.orb.coupling(9)}<br><strong>lose</strong> ${powerUps.orb.coupling(3)} after mob <strong>collisions</strong>`//<br><em>${m.couplingDescription(1)} per ${powerUps.orb.coupling(1)}</em>
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        // isInstant: true,
        allowed: () => true,
        requires: "",
        value: 60,
        effect() {
            tech.isCouplingNoHit = true
            // powerUps.spawnDelay("coupling", this.value)
        },
        remove() {
            // if (this.count) m.couplingChange(-this.value)
            tech.isCouplingNoHit = false
        }
    },
    {
        name: "residual dipolar coupling",
        descriptionFunction() {
            return `clicking <strong class='color-cancel'>cancel</strong> spawns ${powerUps.orb.coupling(10)}<br><em>${m.couplingDescription(1)} per ${powerUps.orb.coupling(1)}</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isSuperDeterminism
        },
        requires: "not superdeterminism",
        effect() {
            tech.isCancelCouple = true
        },
        remove() {
            tech.isCancelCouple = false
        }
    },
    {
        name: "commodities exchange",
        descriptionFunction() {
            return `clicking <strong class='color-cancel'>cancel</strong> for ${powerUps.orb.field()}, ${powerUps.orb.tech()}, or ${powerUps.orb.gun()}<br>spawns <strong>10-14</strong> ${powerUps.orb.heal()}, ${powerUps.orb.ammo()}, or ${powerUps.orb.research(1)}`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isSuperDeterminism
        },
        requires: "not superdeterminism",
        effect() {
            tech.isCancelRerolls = true
        },
        remove() {
            tech.isCancelRerolls = false
        }
    },
    {
        name: "options exchange",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Option_(finance)' class="link">options exchange</a>`,
        description: `clicking <strong class='color-cancel'>cancel</strong> for ${powerUps.orb.field()}, ${powerUps.orb.tech()}, or ${powerUps.orb.gun()}<br>will <strong>randomize</strong> with <strong>3x</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong>, once a level`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isSuperDeterminism //&& (tech.isCancelRerolls || tech.isCancelDuplication || tech.isCancelCouple)
        },
        requires: "not superdeterminism", //residual dipolar coupling, commodities exchange, futures exchange,
        effect() {
            tech.isCancelTech = true
            tech.cancelTechCount = 0
        },
        remove() {
            tech.isCancelTech = false
            tech.cancelTechCount = 0
        }
    },
    {
        name: "futures exchange",
        description: `clicking <strong class='color-cancel'>cancel</strong> for ${powerUps.orb.field()}, ${powerUps.orb.tech()}, or ${powerUps.orb.gun()}<br>gives <strong>+7%</strong> power up <strong class='color-dup'>duplication</strong> chance`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.duplicationChance() < 1 && !tech.isSuperDeterminism
        },
        requires: "below 100% duplication chance, not superdeterminism",
        effect() {
            tech.isCancelDuplication = true //search for tech.duplication  to balance
            powerUps.setPowerUpMode(); //needed after adjusting duplication chance
        },
        remove() {
            tech.isCancelDuplication = false
            if (this.count) powerUps.setPowerUpMode(); //needed after adjusting duplication chance
        }
    },
    {
        name: "replication",
        description: "<strong>+10%</strong> chance to <strong class='color-dup'>duplicate</strong> spawned <strong>power ups</strong><br><strong>+10%</strong> chance for <strong class='color-junk'>JUNK</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong>",
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.duplicationChance() < 1 && tech.junkChance < 1
        },
        requires: "below 100% duplication chance",
        effect() {
            tech.duplicateChance += 0.1
            powerUps.setPowerUpMode(); //needed after adjusting duplication chance
            if (!build.isExperimentSelection && !simulation.isTextLogOpen) simulation.circleFlare(0.1);
            this.refundAmount += tech.addJunkTechToPool(0.10)
        },
        refundAmount: 0,
        remove() {
            tech.duplicateChance = 0
            powerUps.setPowerUpMode(); //needed after adjusting duplication chance
            if (this.count > 0 && this.refundAmount > 0) {
                tech.removeJunkTechFromPool(this.refundAmount)
                this.refundAmount = 0
            }
        }
    },
    {
        name: "metastability",
        description: "<strong>+13%</strong> chance to <strong class='color-dup'>duplicate</strong> spawned <strong>power ups</strong><br><strong class='color-dup'>duplicates</strong> <strong class='color-e'>explode</strong> with a <strong>4</strong> second <strong>half-life</strong>",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.duplicationChance() < 1
        },
        requires: "below 100% duplication chance",
        effect() {
            tech.isPowerUpsVanish = true
            powerUps.setPowerUpMode(); //needed after adjusting duplication chance
            if (!build.isExperimentSelection && !simulation.isTextLogOpen) simulation.circleFlare(0.11);
        },
        remove() {
            tech.isPowerUpsVanish = false
            if (this.count) powerUps.setPowerUpMode(); //needed after adjusting duplication chance        }
        }
    },
    {
        name: "correlated damage",
        descriptionFunction() {
            return `<strong class='color-dup'>duplication</strong> increases <strong class='color-d'>damage</strong><br><em style ="float: right;">(${(1 + Math.min(1, tech.duplicationChance())).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.duplicationChance() > 0.03
        },
        requires: "duplication chance > 3%",
        effect() {
            tech.isDupDamage = true;
        },
        remove() {
            tech.isDupDamage = false;
        }
    },
    {
        name: "parthenogenesis",
        description: "<strong>+8%</strong> chance to <strong class='color-dup'>duplicate</strong> spawned <strong>power ups</strong><br><strong class='color-dup'>duplication</strong> also <strong class='color-dup'>duplicates</strong> <strong>mobs</strong>",
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.duplicationChance() > 0
        },
        requires: "some duplication chance",
        effect() {
            tech.isDuplicateMobs = true;
            powerUps.setPowerUpMode(); //needed after adjusting duplication chance
            if (!build.isExperimentSelection && !simulation.isTextLogOpen) simulation.circleFlare(0.08);
        },
        remove() {
            tech.isDuplicateMobs = false;
            if (this.count) powerUps.setPowerUpMode(); //needed after adjusting duplication chance
        }
    },
    {
        name: "stimulated emission",
        description: `<strong>+20%</strong> chance to <strong class='color-dup'>duplicate</strong> spawned <strong>power ups</strong>,<br><strong>collisions</strong> <span class='color-remove'>eject</span> a random ${powerUps.orb.tech()}`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.duplicationChance() < 1
        },
        requires: "below 1% duplication chance",
        effect() {
            tech.isStimulatedEmission = true
            powerUps.setPowerUpMode(); //needed after adjusting duplication chance
            if (!build.isExperimentSelection && !simulation.isTextLogOpen) simulation.circleFlare(0.20);
        },
        remove() {
            tech.isStimulatedEmission = false
            if (this.count) powerUps.setPowerUpMode(); //needed after adjusting duplication chance
        }
    },
    {
        name: "strange attractor",
        descriptionFunction() {
            return `<strong>1.1x</strong> <strong class='color-d'>damage</strong><br><span class='color-remove'>removing</span> this increases <strong class='color-dup'>duplication</strong> by <strong>+11%</strong>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBadRandomOption: true,
        allowed() {
            return true
        },
        requires: "",
        damage: 1.1,
        effect() {
            m.damageDone *= this.damage
        },
        isRemoveBenefit: true,
        remove() {
            if (this.count > 0 && m.alive) {
                tech.duplication += 0.11
                powerUps.setPowerUpMode(); //needed after adjusting duplication chance
                if (!build.isExperimentSelection && !simulation.isTextLogOpen) simulation.circleFlare(0.11);
                m.damageDone /= this.damage
                this.frequency = 0
            }
        }
    },
    {
        name: "strange loop",
        description: `<strong>1.1x</strong> <strong class='color-d'>damage</strong><br><span class='color-remove'>removing</span> this gives a random ${powerUps.orb.tech()} with <span class='color-remove'>remove</span>`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBadRandomOption: true,
        allowed() {
            return true
        },
        requires: "",
        damage: 1.1,
        effect() {
            m.damageDone *= this.damage
        },
        isRemoveBenefit: true,
        remove() {
            if (this.count > 0 && m.alive) {
                m.damageDone /= this.damage
                this.frequency = 0

                requestAnimationFrame(() => {
                    const options = []
                    for (let i = 0, len = tech.tech.length; i < len; i++)    if (tech.tech[i].isRemoveBenefit && tech.tech[i].count === 0) options.push(i)
                    const index = options[Math.floor(Math.random() * options.length)]
                    tech.giveTech(tech.tech[index].name)
                });
            }
        }
    },
    {
        name: "null hypothesis",
        description: `<strong>1.1x</strong> <strong class='color-d'>damage</strong><br><span class='color-remove'>removing</span> this spawns ${powerUps.orb.research(15)}`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBadRandomOption: true,
        allowed() {
            return true
        },
        requires: "",
        damage: 1.1,
        effect() {
            m.damageDone *= this.damage
        },
        isRemoveBenefit: true,
        remove() {
            if (this.count > 0 && m.alive) {
                m.damageDone /= this.damage
                requestAnimationFrame(() => { powerUps.spawnDelay("research", 15) });
                this.frequency = 0
            }
        }
    },
    {
        name: "martingale",
        descriptionFunction() {
            return `<span style = 'font-size:95%;'><strong>${(1 + this.damage).toFixed(1)}x</strong> <strong class='color-d'>damage</strong>. <span class='color-remove'>removing</span> this has a <strong>50%</strong><br>chance return with <strong>2x</strong> its <strong class='color-d'>damage</strong> <em style ="float: right;">(${(1 + this.damage).toFixed(1)}x→${(1 + 2 * this.damage).toFixed(1)}x)</em></span>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBadRandomOption: true,
        allowed() {
            return true
        },
        requires: "",
        damage: 0.1,
        effect() {
            m.damageDone *= 1 + this.damage
        },
        isRemoveBenefit: true,
        remove() {
            if (this.count > 0 && m.alive) {
                m.damageDone /= 1 + this.damage
                if (Math.random() < 0.5) {
                    this.damage *= 2
                    requestAnimationFrame(() => { tech.giveTech("martingale") });
                }
                this.frequency = 0
            }
        }
    },
    {
        name: "externality",
        descriptionFunction() {
            return `<strong>1.1x</strong> <strong class='color-d'>damage</strong><br><span class='color-remove'>removing</span> this spawns <strong>${this.ammo}</strong> ${powerUps.orb.ammo()}`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBadRandomOption: true,
        allowed() {
            return true
        },
        requires: "",
        damage: 1.1,
        ammo: 50,
        effect() {
            m.damageDone *= this.damage
        },
        isRemoveBenefit: true,
        remove() {
            if (this.count > 0 && m.alive) {
                m.damageDone /= this.damage
                this.frequency = 0
                requestAnimationFrame(() => { powerUps.spawnDelay("ammo", this.ammo) });
            }
        }
    },
    {
        name: "deprecated",
        scale: 0.08,
        descriptionFunction() {
            return `after <span class='color-remove'>removing</span> this gain <strong>${1 + this.scale}x</strong> <strong class='color-d'>damage</strong><br>per ${powerUps.orb.tech()} <span class='color-remove'>removed</span> this game<em style ="float: right;">(${(1 + this.scale * ((this.frequency === 0 ? 0 : 1) + tech.removeCount)).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBadRandomOption: true,
        allowed() {
            return true
        },
        requires: "",
        damage: 1.1,
        effect() {
        },
        isRemoveBenefit: true,
        remove() {
            if (this.count > 0 && m.alive) {
                m.damageDone *= 1 + this.scale * (1 + tech.removeCount)
                this.frequency = 0
            }
        }
    },
    {
        name: "planned obsolescence",
        descriptionFunction() {
            return `at the start of each <strong>level</strong> <span class='color-remove'>eject</span> your oldest ${powerUps.orb.tech()}<br>and gain <strong>1.1x</strong> <strong class='color-d'>damage</strong> each time` //<em style ="float: right;">(${(tech.isEjectOld).toFixed(2)}x)</em>
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBadRandomOption: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isEjectOld = true
        },
        remove() {
            tech.isEjectOld = false
        }
    },
    {
        name: "paradigm shift",
        descriptionFunction() {
            return `when <strong>paused</strong> clicking your ${powerUps.orb.tech()} <span class='color-remove'>ejects</span> them<br>costs <strong>${tech.pauseEjectTech.toFixed(1)}</strong> ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong>" : "<strong class='color-h'>health</strong>"} <em style ="float: right;">(1.3x cost each use)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isSuperDeterminism
        },
        requires: "not superdeterminism",
        effect() {
            tech.isPauseEjectTech = true;
        },
        remove() {
            tech.isPauseEjectTech = false;

        }
    },
    {
        name: "Born rule",
        description: `<span class='color-remove'>eject</span> all your ${powerUps.orb.tech()}`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isInstant: true,
        isBadRandomOption: true,
        allowed() {
            return (tech.totalCount > 6)
        },
        requires: "more than 6 tech",
        effect() {
            let count = 0 //count tech
            for (let i = 0, len = tech.tech.length; i < len; i++) { // spawn new tech power ups
                if (!tech.tech[i].isInstant && tech.tech[i].count) {
                    count += tech.tech[i].count
                    tech.removeTech(i)
                    // powerUps.ejectTech(index)
                }
            }
            powerUps.spawnDelay("tech", count);
            // for (let i = 0; i < count; i++) powerUps.spawn(m.pos.x + 100 * (Math.random() - 0.5), m.pos.y + 100 * (Math.random() - 0.5), "tech"); // spawn new tech power ups
        },
        remove() { }
    },

    {
        name: "Occams razor",
        descriptionFunction() {
            return `randomly <span class='color-remove'>remove</span> <strong>half</strong> your ${powerUps.orb.tech()}<br>for each removed <strong>${(1 + this.damagePerRemoved).toFixed(2)}x</strong> <strong class='color-d'>damage</strong> <em style ="float: right;">(~${((this.count === 0) ? 1 + this.damagePerRemoved * 0.5 * tech.totalCount : this.damage).toFixed(2)}x)</em>`
        },
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isInstant: true,
        isBadRandomOption: true,
        allowed() {
            return (tech.totalCount > 6)
        },
        requires: "more than 6 tech",
        damagePerRemoved: 0.5,
        damage: null,
        effect() {
            let pool = []
            for (let i = 0, len = tech.tech.length; i < len; i++) { // spawn new tech power ups
                if (tech.tech[i].count && !tech.tech[i].isInstant) pool.push(i)
            }
            pool.sort(() => Math.random() - 0.5);
            let removeCount = 0
            for (let i = 0, len = pool.length * 0.5; i < len; i++) removeCount += tech.removeTech(pool[i])
            this.damage = this.damagePerRemoved * removeCount
            m.damageDone *= (1 + this.damage)
            simulation.inGameConsole(`<span class='color-var'>tech</span>.damage *= ${(1 + this.damage).toFixed(2)} <em>//from Occam's razor</em>`);
        },
        remove() {
            if (this.count && m.alive) m.damageDone /= (1 + this.damage)
        }
    },
    {
        name: "exchange symmetry",
        description: `<span class='color-remove'>remove</span> a random ${powerUps.orb.tech()}<br>spawn ${powerUps.orb.gun()}${powerUps.orb.gun()}`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isInstant: true,
        isBadRandomOption: true,
        allowed() {
            return (tech.totalCount > 3) && !tech.isSuperDeterminism
        },
        requires: "at least 4 tech, not superdeterminism",
        effect() {
            const have = [] //find which tech you have
            for (let i = 0; i < tech.tech.length; i++) {
                if (tech.tech[i].count > 0 && !tech.tech[i].isInstant) have.push(i)
            }
            const choose = have[Math.floor(Math.random() * have.length)]
            for (let i = 0; i < tech.tech[choose].count; i++) {
                powerUps.spawn(m.pos.x, m.pos.y, "gun");
            }
            powerUps.spawn(m.pos.x, m.pos.y, "gun");
            tech.removeTech(choose)
        },
        remove() { }
    },
    {
        name: "Monte Carlo method",
        description: `<span class='color-remove'>remove</span> a random ${powerUps.orb.tech()}<br>spawn ${powerUps.orb.tech()}${powerUps.orb.tech()}`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isInstant: true,
        isBadRandomOption: true,
        allowed() {
            return (tech.totalCount > 3) && tech.duplicationChance() > 0 && !tech.isSuperDeterminism
        },
        requires: "some duplication, at least 4 tech, not superdeterminism",
        effect() {
            const removeTotal = tech.removeTech()
            for (let i = 0; i < removeTotal + 1; i++) powerUps.spawn(m.pos.x + 60 * (Math.random() - 0.5), m.pos.y + 60 * (Math.random() - 0.5), "tech");
        },
        remove() { }
    },
    //************************************************** 
    //************************************************** gun
    //************************************************** tech
    //**************************************************
    {
        name: "needle ice",
        description: `after <strong>needles</strong> impact walls<br>they chip off <strong>1-2</strong> freezing <strong class='color-s'>ice IX</strong> crystals`,
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.isNeedles || tech.isNeedles) && !tech.needleTunnel
        },
        requires: "nail gun, needle gun, not nanowires",
        effect() {
            tech.isNeedleIce = true
        },
        remove() {
            tech.isNeedleIce = false
        }
    },
    {
        name: "nanowires",
        description: `<strong>needles</strong> tunnel through <strong class='color-block'>blocks</strong> and <strong>map</strong><br><strong>1.2x</strong> needle <strong class='color-d'>damage</strong>`,
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return ((tech.haveGunCheck("nail gun") && tech.isNeedles) || (tech.isNeedles && tech.haveGunCheck("shotgun"))) && !tech.isNeedleIce
        },
        requires: "nail gun, needle gun, not needle ice",
        effect() {
            tech.needleTunnel = true
        },
        remove() {
            tech.needleTunnel = false
        }
    },
    {
        name: "ceramics",
        descriptionFunction() {
            return `<strong>needles</strong> and ${b.guns[9].harpoonName()} pierce <strong>shields</strong><br>directly <strong class='color-d'>damaging</strong> shielded mobs`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (!tech.isLargeHarpoon && tech.haveGunCheck("harpoon")) || tech.isNeedles || tech.isHookDefense
        },
        requires: "needle gun, harpoon, not Bessemer process",
        effect() {
            tech.isShieldPierce = true
        },
        remove() {
            tech.isShieldPierce = false
        }
    },
    {
        name: "needle gun",
        description: "<strong>nail gun</strong> and <strong>shotgun</strong> fire mob piercing <strong>needles</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return ((tech.haveGunCheck("nail gun") && !tech.nailInstantFireRate && !tech.nailRecoil && !tech.isRicochet) || (tech.haveGunCheck("shotgun") && !tech.isNailShot && !tech.isFoamShot && !tech.isSporeWorm && !tech.isSporeFlea)) && !tech.isRivets && !tech.isIncendiary && !tech.isIceCrystals && !tech.isIceShot
        },
        requires: "nail gun, shotgun, not ice crystal, rivets, rotary cannon, pneumatic, incendiary, nail-shot, foam-shot, worm-shot, ice-shot",
        effect() {
            tech.isNeedles = true
            for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                if (b.guns[i].name === "nail gun") {
                    b.guns[i].ammo = Math.ceil(b.guns[i].ammo / this.ammoScale);
                    b.guns[i].ammoPack = b.guns[i].defaultAmmoPack / this.ammoScale;
                    b.guns[i].chooseFireMethod()
                    simulation.updateGunHUD();
                    break
                }
            }
        },
        ammoScale: 3,
        remove() {
            if (tech.isNeedles) {
                tech.isNeedles = false
                for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                    if (b.guns[i].name === "nail gun") {
                        b.guns[i].chooseFireMethod()
                        b.guns[i].ammo = Math.ceil(b.guns[i].ammo * this.ammoScale);
                        b.guns[i].ammoPack = b.guns[i].ammo * this.ammoScale;
                        simulation.updateGunHUD();
                        break
                    }
                }
            }
        }
    },
    {
        name: "stress concentration",
        description: "mobs below <strong>half</strong> durability <strong>die</strong> after you shoot<br>them near their <strong>center</strong> with <strong>needles</strong> or <strong>rivets</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.isNeedles || tech.isRivets) && !tech.isNailCrit && !tech.isIncendiary
        },
        requires: "needles, rivets, not incendiary, supercritical fission",
        effect() {
            tech.isCritKill = true
        },
        remove() {
            tech.isCritKill = false
        }
    },
    {
        name: "rivet gun",
        description: "<strong>nail gun</strong> and <strong>shotgun</strong> slowly lob a heavy <strong>rivet</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return ((tech.haveGunCheck("nail gun") && !tech.nailInstantFireRate && !tech.isRicochet) || (tech.haveGunCheck("shotgun") && !tech.isNailShot && !tech.isFoamShot && !tech.isSporeWorm && !tech.isSporeFlea)) && !tech.isNeedles && !tech.isIceCrystals && !tech.isIceShot
        },
        requires: "nail gun, shotgun, not ice crystal, needles, or pneumatic actuator",
        effect() {
            tech.isRivets = true
            for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                if (b.guns[i].name === "nail gun") {
                    b.guns[i].chooseFireMethod()
                    break
                }
            }
        },
        remove() {
            if (tech.isRivets) {
                tech.isRivets = false
                for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                    if (b.guns[i].name === "nail gun") {
                        b.guns[i].chooseFireMethod()
                        break
                    }
                }
            }
            tech.isRivets = false
        }
    },
    {
        name: "pneumatic actuator",
        description: "<strong>nail gun</strong> takes <strong>no</strong> time to ramp up<br>to its fastest <em>fire rate</em>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("nail gun") && !tech.isRivets && !tech.isNeedles && !tech.nailRecoil
        },
        requires: "nail gun, not rotary cannon, rivets, or needles",
        effect() {
            tech.nailInstantFireRate = true
            for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                if (b.guns[i].name === "nail gun") b.guns[i].chooseFireMethod()
            }
        },
        remove() {
            if (tech.nailInstantFireRate) {
                tech.nailInstantFireRate = false
                for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                    if (b.guns[i].name === "nail gun") b.guns[i].chooseFireMethod()
                }
            }
        }
    },
    {
        name: "ice crystal nucleation",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Nucleation' class="link">ice crystal nucleation</a>`,
        description: "<strong>nail gun</strong> uses <strong class='color-f'>energy</strong> instead of <strong class='color-ammo'>ammo</strong><br>to condense <strong class='color-s'>freezing</strong> <strong>ice nails</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("nail gun") && !tech.isRivets && !tech.isNeedles // && !tech.isNailRadiation && !tech.isNailCrit
        },
        requires: "nail gun, not rivets, needles",
        effect() {
            tech.isIceCrystals = true;
            b.guns[0].ammoPack = Infinity
            b.guns[0].recordedAmmo = b.guns[0].ammo
            b.guns[0].ammo = Infinity
            simulation.updateGunHUD();
        },
        remove() {
            if (tech.isIceCrystals) {
                tech.isIceCrystals = false;
                b.guns[0].ammoPack = b.guns[0].defaultAmmoPack;
                if (b.guns[0].recordedAmmo) b.guns[0].ammo = b.guns[0].recordedAmmo
                simulation.updateGunHUD();
                if (this.count) requestAnimationFrame(() => { simulation.updateGunHUD(); });
            }
            tech.isIceCrystals = false;
            if (b.guns[0].ammo === Infinity) b.guns[0].ammo = 0
        }
    },
    {
        name: "rotary cannon",
        description: `<strong>nail gun</strong> has increased muzzle <strong class="color-speed">speed</strong>,<br>maximum <em>fire rate</em>, <strong>accuracy</strong>, and <strong>recoil</strong>`,
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("nail gun") && !tech.nailInstantFireRate && !tech.isNeedles
        },
        requires: "nail gun, not pneumatic actuator, needle gun",
        effect() {
            tech.nailRecoil = true
            for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                if (b.guns[i].name === "nail gun") b.guns[i].chooseFireMethod()
            }
        },
        remove() {
            if (tech.nailRecoil) {
                tech.nailRecoil = false
                for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                    if (b.guns[i].name === "nail gun") b.guns[i].chooseFireMethod()
                }
            }
        }
    },
    {
        name: "gauge",
        description: `<strong>rivets</strong>, <strong>needles</strong>, <strong>super balls</strong>, and <strong>nails</strong><br>have <strong>1.3x</strong> mass and physical <strong class='color-d'>damage</strong>`,
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.hookNails + tech.isMineDrop + tech.isNailBotUpgrade + tech.fragments + tech.nailsDeathMob + (tech.haveGunCheck("super balls") + (tech.haveGunCheck("mine") && !tech.isFoamMine) + (tech.haveGunCheck("nail gun")) + tech.isNeedles + tech.isNailShot + tech.isRivets) * 2 > 1
        },
        requires: "nails, nail gun, rivets, shotgun, super balls, mine",
        effect() {
            tech.bulletSize = 1 + 0.25 * Math.pow(this.count + 1, 0.5)
        },
        remove() {
            tech.bulletSize = 1;
        }
    },
    {
        name: "supercritical fission",
        description: "if <strong>nails</strong>, <strong>needles</strong>, or <strong>rivets</strong> strike mobs<br>near their <strong>center</strong> they trigger an <strong class='color-e'>explosion</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.isNailShot || tech.isNeedles || tech.isNailBotUpgrade || tech.haveGunCheck("nail gun") || tech.isRivets || ((tech.isMineDrop || tech.haveGunCheck("mine")) && !(tech.isFoamMine || tech.isSuperMine))) && !tech.isIncendiary && !tech.isCritKill
        },
        requires: "nail gun, mine, needles, nails, rivets, not incendiary, stress concentration",
        effect() {
            tech.isNailCrit = true
        },
        remove() {
            tech.isNailCrit = false
        }
    },
    {
        name: "irradiated nails",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Irradiation' class="link">irradiated nails</a>`,
        description: "<strong>nails</strong>, <strong>needles</strong>, and <strong>rivets</strong> are <strong class='color-p'>radioactive</strong><br><strong>2x</strong> <strong class='color-p'>radioactive</strong> <strong class='color-d'>damage</strong> over <strong>3</strong> seconds",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isNailBotUpgrade || tech.hookNails || tech.fragments || tech.nailsDeathMob || ((tech.isMineDrop || tech.haveGunCheck("mine")) && !(tech.isFoamMine || tech.isSuperMine)) || (tech.haveGunCheck("nail gun") && !tech.isShieldPierce) || (tech.haveGunCheck("shotgun") && (tech.isNeedles || tech.isNailShot))
        },
        requires: "nail gun, nails, rivets, mine, not ceramic needles",
        effect() {
            tech.isNailRadiation = true;
        },
        remove() {
            tech.isNailRadiation = false;
        }
    },
    {
        name: "6s half-life",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Half-life' class="link">6s half-life</a>`,
        description: "<span style = 'font-size:90%;'><strong>nails</strong>, <strong>needles</strong>, <strong>rivets</strong> are made of <strong class='color-p'>plutonium-238</strong></span><br><strong class='color-p'>radioactive</strong> <strong class='color-d'>damage</strong> lasts <strong>+3</strong> seconds",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isNailRadiation && !tech.isFastRadiation
        },
        requires: "nail gun, mine, irradiated nails, not 1s half-life",
        effect() {
            tech.isSlowRadiation = true;
        },
        remove() {
            tech.isSlowRadiation = false;
        }
    },
    {
        name: "1s half-life",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Half-life' class="link">1s half-life</a>`,
        description: "<span style = 'font-size:95%;'><strong>nails</strong>, <strong>needles</strong>, <strong>rivets</strong> are made of <strong class='color-p'>lithium-8</strong><br><strong>4x</strong> <strong class='color-p'>radioactive</strong> <strong class='color-d'>damage</strong> for <strong>1</strong> second</span>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isNailRadiation && !tech.isSlowRadiation
        },
        requires: "nail gun, mine, irradiated nails, not 6s half-life",
        effect() {
            tech.isFastRadiation = true;
        },
        remove() {
            tech.isFastRadiation = false;
        }
    },
    {
        name: "spin-statistics",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Spin%E2%80%93statistics_theorem' class="link">spin-statistics</a>`,
        description: `after firing the <strong>shotgun</strong> you are <strong class="color-invulnerable">invulnerable</strong><br>shotgun has <strong>0.7x</strong> bullets per ${powerUps.orb.ammo(1)}`,
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("shotgun")
        },
        requires: "shotgun",
        effect() {
            tech.isShotgunImmune = true;

            //cut current ammo by 1/2
            for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                if (b.guns[i].name === "shotgun") {
                    b.guns[i].ammo = Math.ceil(b.guns[i].ammo * 0.7);
                    b.guns[i].ammoPack *= 0.7
                    break;
                }
            }
            simulation.updateGunHUD();
        },
        remove() {
            tech.isShotgunImmune = false;
            if (this.count > 0) {
                for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                    if (b.guns[i].name === "shotgun") {
                        b.guns[i].ammoPack /= 0.7
                        b.guns[i].ammo = Math.ceil(b.guns[i].ammo / 0.7);
                        simulation.updateGunHUD();
                        break;
                    }
                }
            }
        }
    },
    {
        name: "Newtons 3rd law",
        description: "<strong>1.7x</strong> <strong>shotgun</strong> <em>fire rate</em> and <strong>recoil</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("shotgun") && !tech.isShotgunReversed
        },
        requires: "shotgun, not Noether violation",
        effect() {
            tech.isShotgunRecoil = true;
        },
        remove() {
            tech.isShotgunRecoil = false;
        }
    },
    {
        name: "Noether violation",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Noether%27s_theorem' class="link">Noether violation</a>`,
        description: "<strong>1.5x</strong> <strong>shotgun</strong> <strong class='color-d'>damage</strong><br><strong>shotgun</strong> <strong>recoil</strong> is reversed",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return (tech.haveGunCheck("shotgun")) && !tech.isShotgunRecoil
        },
        requires: "shotgun, not Newtons 3rd law",
        effect() {
            tech.isShotgunReversed = true;
        },
        remove() {
            tech.isShotgunReversed = false;
        }
    },
    {
        name: "repeater",
        description: "<strong>shotgun</strong> immediately fires again for no <strong class='color-ammo'>ammo</strong><br>reduced <strong>0.5x</strong> <strong>shotgun</strong> <em>fire rate</em>",
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.haveGunCheck("shotgun"))
        },
        requires: "shotgun, not Newtons 3rd law",
        effect() {
            tech.shotgunExtraShots++;
        },
        remove() {
            tech.shotgunExtraShots = 0
        }
    },
    {
        name: "nail-shot",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Nail_(fastener)' class="link">nail-shot</a>`,
        description: "<strong>shotgun</strong> drives a long clip of <strong>nails</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("shotgun") && !tech.isIncendiary && !tech.isRivets && !tech.isIceShot && !tech.isFoamShot && !tech.isSporeWorm && !tech.isSporeFlea && !tech.isNeedles
        },
        requires: "shotgun, not incendiary, rivets, foam-shot, worm-shot, ice-shot, needles",
        effect() {
            tech.isNailShot = true;
        },
        remove() {
            tech.isNailShot = false;
        }
    },
    {
        name: "foam-shot",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Foam' class="link">foam-shot</a>`,
        description: "<strong>shotgun</strong> sprays sticky <strong>foam</strong> bubbles",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("shotgun") && !tech.isNailShot && !tech.isIncendiary && !tech.isRivets && !tech.isIceShot && !tech.isSporeWorm && !tech.isSporeFlea && !tech.isNeedles
        },
        requires: "shotgun, not incendiary, nail-shot, rivet, worm-shot, ice-shot, needle",
        effect() {
            tech.isFoamShot = true;
        },
        remove() {
            tech.isFoamShot = false;
        }
    },
    {
        name: "ice-shot",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Ice-nine_(disambiguation)' class="link">ice-shot</a>`,
        description: "<strong>shotgun</strong> condenses <strong class='color-s'>ice IX</strong> crystals<br>that <strong class='color-s'>freeze</strong> mobs",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("shotgun") && !tech.isNailShot && !tech.isIncendiary && !tech.isRivets && !tech.isFoamShot && !tech.isSporeWorm && !tech.isSporeFlea && !tech.isNeedles
        },
        requires: "shotgun, not incendiary, nail-shot, rivet, foam-shot, worm-shot",
        effect() {
            tech.isIceShot = true;
        },
        remove() {
            tech.isIceShot = false;
        }
    },
    {
        name: "freezer burn",
        description: "mobs <strong class='color-s'>frozen</strong> while below <strong>33%</strong> durability <strong>die</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isIceCrystals || tech.isSporeFreeze || (m.fieldMode === 4 && simulation.molecularMode === 2) || tech.isIceShot || tech.isNeedleIce || (m.coupling && (m.fieldMode === 2 || m.fieldMode === 0))
        },
        requires: "a freeze effect",
        effect() {
            tech.isIceKill = true
        },
        remove() {
            tech.isIceKill = false
        }
    },
    {
        name: "flash freeze",
        description: "mobs <strong class='color-s'>frozen</strong> while above <strong>66%</strong> durability<br>have their durability reduced to <strong>66%</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isIceCrystals || tech.isSporeFreeze || (m.fieldMode === 4 && simulation.molecularMode === 2) || tech.isIceShot || tech.isNeedleIce || (m.coupling && (m.fieldMode === 2 || m.fieldMode === 0))
        },
        requires: "a freeze effect",
        effect() {
            tech.isIceMaxHealthLoss = true
        },
        remove() {
            tech.isIceMaxHealthLoss = false
        }
    },
    {
        name: "crystallizer",
        description: "after <strong class='color-s'>frozen</strong> mobs <strong>die</strong> they<br>shatter into <strong class='color-s'>ice IX</strong> crystals",
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.isIceCrystals || tech.isSporeFreeze || (m.fieldMode === 4 && simulation.molecularMode === 2) || tech.isIceShot || tech.isNeedleIce || (m.coupling && (m.fieldMode === 2 || m.fieldMode === 0))) && !tech.sporesOnDeath && !tech.isExplodeMob && !tech.botSpawner && !tech.isMobBlockFling && !tech.nailsDeathMob
        },
        requires: "a localized freeze effect, no other mob death tech",
        effect() {
            tech.iceIXOnDeath++
        },
        remove() {
            tech.iceIXOnDeath = 0
        }
    },
    {
        name: "thermoelectric effect",
        description: "after <strong>killing</strong> mobs with <strong class='color-s'>ice IX</strong><br><strong>+100</strong> <strong class='color-f'>energy</strong>",
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (m.fieldMode === 4 && simulation.molecularMode === 2) || tech.isNeedleIce || (m.coupling && (m.fieldMode === 2 || m.fieldMode === 0)) || tech.iceIXOnDeath || tech.isIceShot
        },
        requires: "ice IX",
        effect() {
            tech.iceEnergy++
        },
        remove() {
            tech.iceEnergy = 0;
        }
    },
    {
        name: "superfluidity",
        description: "<strong class='color-s'>freeze</strong> effects are applied<br>to a small <strong>area</strong> around the target",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isIceCrystals || tech.isSporeFreeze || (m.fieldMode === 4 && simulation.molecularMode === 2) || tech.isNeedleIce || (m.coupling && (m.fieldMode === 2 || m.fieldMode === 0)) || tech.iceIXOnDeath || tech.isIceShot
        },
        requires: "a localized freeze effect",
        effect() {
            tech.isAoESlow = true
        },
        remove() {
            tech.isAoESlow = false
        }
    },
    {
        name: "triple point",
        descriptionFunction() {
            return `<strong>+5</strong> second <strong class='color-s'>freeze</strong> duration`
        },
        isGunTech: true,
        maxCount: 3,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        // allowed() {
        //     return (m.fieldMode === 2 && m.coupling > 0) || (tech.haveGunCheck("shotgun") && tech.isIceShot)
        // },
        // requires: "perfect diamagnetism",
        allowed() {
            return (tech.isIceCrystals || tech.isSporeFreeze || (m.fieldMode === 4 && simulation.molecularMode === 2) || tech.isIceShot || tech.isNeedleIce || (m.coupling && (m.fieldMode === 2 || m.fieldMode === 0)))
        },
        requires: "a localized freeze effect",
        effect() {
            tech.iceIXFreezeTime += 5 * 60
            // powerUps.spawnDelay("coupling", 10)
        },
        remove() {
            tech.iceIXFreezeTime = 150
            // if (this.count) m.couplingChange(-10 * this.count)
        }
    },
    {
        name: "incendiary ammunition",
        description: "<strong>shotgun</strong>, <strong>rivets</strong>, <strong>super balls</strong>, and <strong>drones</strong><br>are loaded with <strong class='color-e'>explosives</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return (tech.haveGunCheck("shotgun") && !tech.isNailShot && !tech.isIceShot && !tech.isRivets && !tech.isFoamShot && !tech.isSporeWorm && !tech.isSporeFlea && !tech.isNeedles) || ((tech.haveGunCheck("super balls") || tech.isSuperMine) && !tech.isSuperBounce && !tech.isFoamBall && !tech.isSuperHarm) || (tech.isRivets && !tech.isNailCrit) || (m.fieldMode === 4 && simulation.molecularMode === 3) || (tech.haveGunCheck("drones") && !tech.isForeverDrones && !tech.isDroneRadioactive && !tech.isDroneTeleport)
        },
        requires: "shotgun, super balls, rivets, drones, not irradiated drones, burst drones, polyurethane, Zectron",
        effect() {
            tech.isIncendiary = true
        },
        remove() {
            tech.isIncendiary = false;
        }
    },
    {
        name: "rebound",
        description: `after they collide with a mob, <strong>super balls</strong><br>gain <strong class="color-speed">speed</strong>, <strong>duration</strong>, and <strong>1.3x</strong> <strong class='color-d'>damage</strong>`,
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.haveGunCheck("super balls") || tech.isSuperMine) && !tech.isIncendiary && !tech.isFoamBall
        },
        requires: "super balls, not incendiary",
        effect() {
            tech.isSuperBounce = true
        },
        remove() {
            tech.isSuperBounce = false
        }
    },
    {
        name: "Zectron",
        description: `<strong>2x</strong> <strong>super ball</strong> <strong class='color-d'>damage</strong>, but<br>after you collide with <strong>super balls</strong> they stop`,
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.haveGunCheck("super balls") || tech.isSuperMine) && !tech.isIncendiary && !tech.isBulletTeleport
        },
        requires: "super balls not incendiary ammunition, uncertainty principle",
        effect() {
            tech.isSuperHarm = true
        },
        remove() {
            tech.isSuperHarm = false
        }
    },
    {
        name: "polyurethane foam",
        descriptionFunction() {
            return `<strong>super balls</strong> and ${b.guns[9].harpoonName()} colliding with <strong>mobs</strong><br>catalyzes a reaction that yields <strong>foam</strong> bubbles`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return ((tech.haveGunCheck("super balls") || tech.isSuperMine) && !tech.isSuperBounce) || (tech.haveGunCheck("harpoon") && !tech.fragments) || tech.isHookDefense
        },
        requires: "super balls, harpoon, not fragmentation",
        effect() {
            tech.isFoamBall = true;
        },
        remove() {
            tech.isFoamBall = false;
        }
    },
    {
        name: "autocannon",
        description: "fire <strong>+2</strong> <strong>super balls</strong> in a line<br><strong>1.4x</strong> <strong>super ball</strong> velocity and gravity",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("super balls") && !tech.oneSuperBall
        },
        requires: "super balls, but not the tech super ball",
        effect() {
            tech.superBallDelay = true
            for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                if (b.guns[i].name === "super balls") b.guns[i].chooseFireMethod()
            }
        },
        remove() {
            if (tech.superBallDelay) {
                tech.superBallDelay = false;
                for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                    if (b.guns[i].name === "super balls") b.guns[i].chooseFireMethod()
                }
            }
        }
    },
    {
        name: "super duper",
        description: `randomly fire <strong>+0</strong>, <strong>+1</strong>, <strong>+2</strong>, or <strong>+3</strong> extra <strong>super balls</strong>`,
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.haveGunCheck("super balls") || tech.isSuperMine) && !tech.oneSuperBall
        },
        requires: "super balls, not super ball",
        effect() {
            tech.extraSuperBalls += 4
        },
        remove() {
            tech.extraSuperBalls = 0;
        }
    },
    {
        name: "super ball",
        description: "fire just <strong>1 large</strong> super <strong>ball</strong><br>that <strong>stuns</strong> mobs for <strong>2</strong> seconds",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.haveGunCheck("super balls") || tech.isSuperMine) && !tech.extraSuperBalls && !tech.superBallDelay
        },
        requires: "super balls, not super duper or autocannon",
        effect() {
            tech.oneSuperBall = true;
            for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                if (b.guns[i].name === "super balls") b.guns[i].chooseFireMethod()
            }
        },
        remove() {
            if (tech.oneSuperBall) {
                tech.oneSuperBall = false;
                for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                    if (b.guns[i].name === "super balls") b.guns[i].chooseFireMethod()
                }
            }
        }
    },
    {
        name: "phase velocity",
        description: "wave particles <strong>propagate</strong> faster as <strong>solids</strong><br><strong>1.5x</strong> wave <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("wave") && !tech.isLongitudinal
        },
        requires: "wave, not phonon",
        effect() {
            tech.isPhaseVelocity = true;
        },
        remove() {
            tech.isPhaseVelocity = false;
        }
    },
    {
        name: "amplitude",
        description: "<strong>1.4x</strong> wave <strong class='color-d'>damage</strong><br><strong>1.4x</strong> wave bullet <strong>amplitude</strong>",
        isGunTech: true,
        maxCount: 3,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("wave") || tech.isSoundBotUpgrade
        },
        requires: "wave",
        effect() {
            tech.waveFrequency *= 0.66
            tech.wavePacketDamage *= 1.4
        },
        remove() {
            tech.waveFrequency = 0.2  //adjust this to make the waves much larger
            tech.wavePacketDamage = 1
        }
    },
    {
        name: "propagation",
        description: `<strong>0.75x</strong> wave propagation <strong class="color-speed">speed</strong><br><strong>1.4x</strong> wave <strong class='color-d'>damage</strong>`,
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("wave") || tech.isSoundBotUpgrade
        },
        requires: "wave",
        effect() {
            tech.waveBeamSpeed *= 0.75;
            tech.waveBeamDamage *= 1.4 //this sets base  wave damage
        },
        remove() {
            tech.waveBeamSpeed = 11;
            tech.waveBeamDamage = 0.4 //this sets base  wave damage
        }
    },
    {
        name: "bound state",
        description: "wave packets <strong>reflect</strong> backwards <strong>2</strong> times<br><strong>0.7x</strong> wave <strong>range</strong>",
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("wave") && !tech.isLongitudinal
        },
        requires: "wave, not phonon",
        effect() {
            tech.waveReflections += 2
        },
        remove() {
            tech.waveReflections = 1
        }
    },
    {
        name: "frequency",
        description: `<strong>wave</strong> has unlimited <strong class='color-ammo'>ammo</strong><br><strong>0.75x</strong> wave <strong class='color-d'>damage</strong>`,
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed: () => tech.haveGunCheck("wave"),
        requires: "wave",
        effect() {
            tech.isInfiniteWaveAmmo = true
            b.guns[3].savedAmmo = b.guns[3].ammo
            b.guns[3].ammo = Infinity
            simulation.updateGunHUD();
        },
        remove() {
            tech.isInfiniteWaveAmmo = false
            if (this.count > 0 && b.guns[3].savedAmmo !== undefined) {
                b.guns[3].ammo = b.guns[3].savedAmmo
                simulation.updateGunHUD();
                requestAnimationFrame(() => { simulation.updateGunHUD(); });
            } else if (b.guns[3].ammo === Infinity) {
                b.guns[3].ammo = 0
            }
        }
    },
    {
        name: "phonon",
        description: "waves are low <strong>frequency</strong>, high <strong class='color-d'>damage</strong><br><strong>expanding arcs</strong> that propagate through <strong>solids</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return tech.haveGunCheck("wave") && !tech.isPhaseVelocity && tech.waveReflections === 1
        },
        requires: "wave, not phase velocity, bound state",
        ammoScale: 6,
        effect() {
            tech.isLongitudinal = true;
            b.guns[3].chooseFireMethod()
            b.guns[3].ammoPack /= this.ammoScale
            if (tech.isInfiniteWaveAmmo) {
                b.guns[3].savedAmmo = Math.ceil(b.guns[3].savedAmmo / this.ammoScale); //used with low frequency
            } else {
                b.guns[3].ammo = Math.ceil(b.guns[3].ammo / this.ammoScale);
            }
            simulation.updateGunHUD();
        },
        remove() {
            tech.isLongitudinal = false;
            if (this.count > 0) {
                b.guns[3].chooseFireMethod()
                b.guns[3].ammoPack *= this.ammoScale
                if (tech.isInfiniteWaveAmmo) {
                    b.guns[3].savedAmmo = Math.ceil(b.guns[3].savedAmmo * this.ammoScale); //used with low frequency
                } else {
                    b.guns[3].ammo = Math.ceil(b.guns[3].ammo * this.ammoScale);
                }
                simulation.updateGunHUD();
            }
        }
    },
    {
        name: "isotropic",
        description: "<strong>waves</strong> expand in <strong>all</strong> directions<br><strong>0.6x</strong> <strong>range</strong> and <strong>1.5x</strong> <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return tech.isLongitudinal && tech.haveGunCheck("wave") && !tech.isBulletTeleport
        },
        requires: "wave, phonon, not uncertainty principle",
        effect() {
            tech.is360Longitudinal = true;
            b.guns[3].chooseFireMethod()
        },
        remove() {
            tech.is360Longitudinal = false;
            b.guns[3].chooseFireMethod()
        }
    },
    {
        name: "mechanical resonance",
        description: "after a <strong class='color-block'>block</strong> gets vibrated by a <strong>phonon</strong><br>there is a chance it's <strong>flung</strong> at nearby mobs",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.isLongitudinal && tech.haveGunCheck("wave")) || tech.isSoundBotUpgrade
        },
        requires: "wave, phonon",
        effect() {
            tech.isPhononBlock = true
        },
        remove() {
            tech.isPhononBlock = false
        }
    },
    {
        name: "sympathetic resonance",
        description: "after a <strong>mob</strong> gets vibrated by a <strong>phonon</strong><br>a new <strong>resonance wave</strong> expands",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.isLongitudinal && tech.haveGunCheck("wave")) || tech.isSoundBotUpgrade
        },
        requires: "wave, phonon",
        effect() {
            tech.isPhononWave = true
        },
        remove() {
            tech.isPhononWave = false
        }
    },
    {
        name: "missile-bot",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">missile-bot</a>`,
        description: `use ${powerUps.orb.research(1)}to trade your <strong>missile</strong> ${powerUps.orb.gun()}<br>for a <strong class='color-bot'>bot</strong> that fires <strong>missiles</strong>`,
        // isGunTech: true,
        isRemoveGun: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBot: true,
        isBotTech: true,
        isInstant: true,
        allowed() {
            return tech.haveGunCheck("missiles", false) && tech.missileFireCD === 45 && (build.isExperimentSelection || powerUps.research.count > 0)
        },
        requires: "missiles, not launch system",
        effect() {
            tech.missileBotCount++;
            b.missileBot();
            if (tech.haveGunCheck("missiles", false)) b.removeGun("missiles") //remove your last gun
            for (let i = 0; i < 1; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
        },
        remove() {
            // if (this.count) {
            //     tech.missileBotCount = 0;
            //     b.clearPermanentBots();
            //     b.respawnBots();
            //     if (!tech.haveGunCheck("missiles", false)) b.giveGuns("missiles")
            //     powerUps.research.changeRerolls(1)
            // }
        }
    },
    {
        name: "cruise missile",
        description: "<strong>2x</strong> <strong>missile</strong> <strong class='color-e'>explosive</strong> <strong class='color-d'>damage</strong>, radius<br><strong>0.5x</strong> <strong>missile</strong> speed",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.haveGunCheck("missiles") && tech.missileFireCD === 45) || (m.fieldMode === 4 && simulation.molecularMode === 1) || tech.missileBotCount
        },
        requires: "missiles, not launch system",
        effect() {
            tech.isMissileBig = true
        },
        remove() {
            tech.isMissileBig = false
        }
    },
    {
        name: "ICBM",
        description: "<strong>1.75x</strong> <strong>missile</strong> <strong class='color-e'>explosive</strong> <strong class='color-d'>damage</strong>, radius<br><strong>0.5x</strong> <strong>missile</strong> speed",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.haveGunCheck("missiles") || (m.fieldMode === 4 && simulation.molecularMode === 1)) && tech.isMissileBig
        },
        requires: "missiles, cruise missile",
        effect() {
            tech.isMissileBiggest = true
        },
        remove() {
            tech.isMissileBiggest = false
        }
    },
    {
        name: "launch system",
        description: `<strong>5x</strong> <strong>missile</strong> <em>fire rate</em><br><strong>1.3x</strong> missile <strong class='color-ammo'>ammo</strong> per ${powerUps.orb.ammo(1)}`,
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("missiles") && !tech.isMissileBig
        },
        requires: "missiles, not cruise missile",
        ammoBonus: 1.3,
        effect() {
            tech.missileFireCD = 10
            for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                if (b.guns[i].name === "missiles") {
                    b.guns[i].ammoPack *= this.ammoBonus;
                    b.guns[i].ammo = Math.ceil(b.guns[i].ammo * this.ammoBonus);
                    simulation.updateGunHUD();
                    break
                }
            }
        },
        remove() {
            tech.missileFireCD = 45;
            if (this.count > 0) {
                for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                    if (b.guns[i].name === "missiles") {
                        b.guns[i].ammoPack /= this.ammoBonus;
                        b.guns[i].ammo = Math.ceil(b.guns[i].ammo / this.ammoBonus);
                        simulation.updateGunHUD();
                        break
                    }
                }
            }
        }
    },
    {
        name: "missile guidance",
        description: `while <strong>crouching</strong> your <strong>missiles</strong> target your mouse<br><strong>1.5x</strong> missile <strong class='color-ammo'>ammo</strong> per ${powerUps.orb.ammo(1)}`,
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("missiles") && !tech.isMissileBig
        },
        requires: "missiles, not cruise missile",
        ammoBonus: 1.5,
        effect() {
            tech.isTargeting = true
            for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                if (b.guns[i].name === "missiles") {
                    b.guns[i].ammoPack *= this.ammoBonus;
                    b.guns[i].ammo = Math.ceil(b.guns[i].ammo * this.ammoBonus);
                    simulation.updateGunHUD();
                    break
                }
            }
        },
        remove() {
            tech.isTargeting = false;
            if (this.count > 0) {
                for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                    if (b.guns[i].name === "missiles") {
                        b.guns[i].ammoPack /= this.ammoBonus;
                        b.guns[i].ammo = Math.ceil(b.guns[i].ammo / this.ammoBonus);
                        simulation.updateGunHUD();
                        break
                    }
                }
            }
        }
    },
    {
        name: "iridium-192",
        description: "<strong class='color-e'>explosions</strong> release <strong class='color-p'>gamma radiation</strong><br><strong>2x</strong> <strong class='color-e'>explosion</strong> <strong class='color-d'>damage</strong> over <strong>4</strong> seconds",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isImmuneExplosion && tech.explosiveRadius === 1 && !tech.isSmallExplosion && !tech.isBlockExplode && !tech.fragments && (tech.haveGunCheck("missiles") || tech.missileBotCount || tech.isIncendiary || (tech.haveGunCheck("grenades") && !tech.isNeutronBomb) || tech.isPulseLaser || (m.fieldMode === 4 && simulation.molecularMode === 1) || tech.isBoomBotUpgrade || tech.isTokamak)
        },
        requires: "an explosive damage source, not ammonium nitrate, nitroglycerin, chain reaction, fragmentation, electric armor",
        effect() {
            tech.isExplodeRadio = true; //iridium-192
        },
        remove() {
            tech.isExplodeRadio = false;
        }
    },
    {
        name: "fragmentation",
        description: "some <strong class='color-e'>detonations</strong> and collisions eject <strong>nails</strong><br><em style = 'font-size: 90%'>blocks, grenades, missiles, rivets, harpoon</em>",
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return !tech.isExplodeRadio && ((tech.haveGunCheck("harpoon") && !tech.isFoamBall) || (tech.haveGunCheck("grenades") && !tech.isNeutronBomb) || tech.haveGunCheck("missiles") || (m.fieldMode === 4 && simulation.molecularMode === 1) || tech.missileBotCount || tech.isRivets || tech.blockDamage > 0.075 || tech.isHookDefense)
        },
        requires: "grenades, missiles, rivets, harpoon, or mass driver, not iridium-192, not polyurethane foam",
        effect() {
            tech.fragments++
        },
        remove() {
            tech.fragments = 0
        }
    },
    {
        name: "ammonium nitrate",
        description: "<strong>1.25x</strong> <strong class='color-e'>explosive</strong> <strong class='color-d'>damage</strong>, radius",
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return !tech.isExplodeRadio && tech.hasExplosiveDamageCheck()
        },
        requires: "an explosive damage source, not iridium-192",
        effect() {
            tech.explosiveRadius += 0.25;
        },
        remove() {
            tech.explosiveRadius = 1;
        }
    },
    {
        name: "nitroglycerin",
        description: "<strong>1.7x</strong> <strong class='color-e'>explosive</strong> <strong class='color-d'>damage</strong><br><strong>0.7x</strong> smaller <strong class='color-e'>explosive</strong> <strong>radius</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return !tech.isExplodeRadio && tech.hasExplosiveDamageCheck() && !tech.isExplosionHarm
        },
        requires: "an explosive damage source, not iridium-192, acetone peroxide",
        effect() {
            tech.isSmallExplosion = true;
        },
        remove() {
            tech.isSmallExplosion = false;
        }
    },
    {
        name: "acetone peroxide",
        description: "<strong>1.7x</strong> <strong class='color-e'>explosive</strong> <strong>radius</strong><br><strong>1.4x</strong> <strong class='color-e'>explosive</strong> <strong class='color-defense'>damage taken</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        isBadRandomOption: true,
        allowed() {
            return tech.hasExplosiveDamageCheck() && !tech.isSmallExplosion
        },
        requires: "an explosive damage source, not nitroglycerin",
        effect() {
            tech.isExplosionHarm = true;
        },
        remove() {
            tech.isExplosionHarm = false;
        }
    },
    {
        name: "shock wave",
        description: "<strong>mines</strong> and <strong class='color-p' style='letter-spacing: 2px;'>sporangium</strong> <strong>stun</strong> for <strong>3-5</strong> seconds<br><strong class='color-e'>explosions</strong> <strong>stun</strong> for <strong>0.5</strong> seconds",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.haveGunCheck("spores") || tech.haveGunCheck("mine") || (!tech.isExplodeRadio && tech.hasExplosiveDamageCheck())
        },
        requires: "mine, spores, an explosive damage source, not iridium-192",
        effect() {
            tech.isStun = true;
        },
        remove() {
            tech.isStun = false;
        }
    },
    {
        name: "shaped charge",
        description: `use ${powerUps.orb.research(2)} to dynamically <strong>reduce</strong><br>all <strong class='color-e'>explosions</strong> to prevent <strong class='color-h'>health</strong> loss`,
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return !tech.isImmuneExplosion && (build.isExperimentSelection || powerUps.research.count > 1) && (tech.haveGunCheck("missiles") || (m.fieldMode === 4 && simulation.molecularMode === 1) || tech.missileBotCount > 0 || tech.isIncendiary || tech.isPulseLaser || tech.isTokamak || (tech.haveGunCheck("grenades") && !tech.isNeutronBomb))
        },
        requires: "an explosive damage source, not rocket propelled grenade",
        effect() {
            tech.isSmartRadius = true;
            for (let i = 0; i < 2; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
        },
        remove() {
            tech.isSmartRadius = false;
            if (this.count > 0) powerUps.research.changeRerolls(3)
        }
    },
    {
        name: "MIRV",
        description: "fire <strong>+1</strong> <strong>missile</strong> or <strong>grenade</strong> per shot<br><strong>0.88x</strong> <strong class='color-e'>explosion</strong> <strong class='color-d'>damage</strong> and <strong>radius</strong>",
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("missiles") || tech.missileBotCount || tech.haveGunCheck("grenades")
        },
        requires: "missiles, grenades",
        effect() {
            tech.missileCount++;
        },
        remove() {
            tech.missileCount = 1;
        }
    },
    {
        name: "rocket-propelled grenade",
        description: "<strong>grenades</strong> <strong class='color-e'>explode</strong> on map <strong>collisions</strong><br><strong class='color-e'>explosions</strong> drain <strong class='color-f'>energy</strong>, not <strong class='color-h'>health</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("grenades") && !tech.isVacuumBomb && !tech.isSmartRadius && !tech.isEnergyHealth
        },
        requires: "grenades, not vacuum bomb, shaped charges, mass-energy",
        effect() {
            tech.isImmuneExplosion = true;
            tech.isRPG = true;
            b.setGrenadeMode()
        },
        remove() {
            tech.isImmuneExplosion = false;
            tech.isRPG = false;
            b.setGrenadeMode()
        }
    },
    {
        name: "vacuum bomb",
        description: "<strong>grenades</strong> fire slower, <strong class='color-e'>explode</strong> bigger,<br>and <strong>suck</strong> everything towards them",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("grenades") && !tech.isNeutronBomb && !tech.isBlockExplode && !tech.isRPG
        },
        requires: "grenades, not neutron bomb, chain reaction, RPG",
        effect() {
            tech.isVacuumBomb = true;
            b.setGrenadeMode()
        },
        remove() {
            tech.isVacuumBomb = false;
            b.setGrenadeMode()
        }
    },
    {
        name: "chain reaction",
        description: "<strong>1.3x</strong> <strong>grenade</strong> radius and <strong class='color-d'>damage</strong><br><strong class='color-block'>blocks</strong> caught in <strong class='color-e'>explosions</strong> also <strong class='color-e'>explode</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("grenades") && !tech.isExplodeRadio && !tech.isNeutronBomb && !tech.isVacuumBomb
        },
        requires: "grenades, not iridium-192, neutron bomb, vacuum bomb",
        effect() {
            tech.isBlockExplode = true; //chain reaction
        },
        remove() {
            tech.isBlockExplode = false;
        }
    },
    {
        name: "flame test",
        description: "after <strong>grenades</strong> detonate they trigger<br>a colorful <strong>cluster</strong> of small <strong class='color-e'>explosions</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("grenades") && !tech.isNeutronBomb && !tech.isCircleExplode && !tech.isPetalsExplode
        },
        requires: "grenades, not neutron bomb, pyrotechnics, fireworks",
        effect() {
            tech.isClusterExplode = true;
        },
        remove() {
            tech.isClusterExplode = false;
        }
    },
    {
        name: "pyrotechnics",
        description: "after <strong>grenades</strong> detonate they trigger<br>a colorful <strong>circle</strong> of <strong class='color-e'>explosions</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("grenades") && !tech.isNeutronBomb && !tech.isClusterExplode && !tech.isPetalsExplode
        },
        requires: "grenades, not neutron bomb, flame test, fireworks",
        effect() {
            tech.isCircleExplode = true;
        },
        remove() {
            tech.isCircleExplode = false;
        }
    },
    {
        name: "fireworks",
        description: "after <strong>grenades</strong> detonate they trigger<br>colorful <strong>petals</strong> of <strong class='color-e'>explosions</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("grenades") && !tech.isNeutronBomb && !tech.isClusterExplode && !tech.isCircleExplode
        },
        requires: "grenades, not neutron bomb, pyrotechnics, flame test",
        effect() {
            tech.isPetalsExplode = true;
        },
        remove() {
            tech.isPetalsExplode = false;
        }
    },
    {
        name: "neutron bomb",
        description: "<strong>grenades</strong> are <strong class='color-p'>irradiated</strong> with <strong class='color-p'>Cf-252</strong><br>does <strong class='color-p'>radioactive</strong> <strong class='color-d'>damage</strong> over time",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("grenades") && !tech.fragments && !tech.isVacuumBomb && !tech.isExplodeRadio && !tech.isBlockExplode && !tech.isClusterExplode && !tech.isPetalsExplode && !tech.isCircleExplode
        },
        requires: "grenades, not fragmentation, vacuum bomb, iridium-192, pyrotechnics, fireworks, flame test, chain reaction",
        effect() {
            tech.isNeutronBomb = true;
            b.setGrenadeMode()
        },
        remove() {
            tech.isNeutronBomb = false;
            b.setGrenadeMode()
        }
    },
    {
        name: "vacuum permittivity",
        description: "<strong>1.2x</strong> <strong class='color-p'>radioactive</strong> range<br>objects in range of the bomb are <strong>slowed</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isNeutronBomb
        },
        requires: "grenades, neutron bomb",
        effect() {
            tech.isNeutronSlow = true
        },
        remove() {
            tech.isNeutronSlow = false
        }
    },
    {
        name: "radioactive contamination",
        description: "after a mob or shield <strong>dies</strong>,<br>leftover <strong class='color-p'>radiation</strong> <strong>spreads</strong> to a nearby mob",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isNailRadiation || tech.isWormholeDamage || tech.isNeutronBomb || tech.isExplodeRadio || tech.isBlockRadiation
        },
        requires: "radiation damage source",
        effect() {
            tech.isRadioactive = true
        },
        remove() {
            tech.isRadioactive = false
        }
    },
    {
        name: "nuclear transmutation",
        description: "<strong>1.5x</strong> <strong class='color-p'>radiation</strong> <strong class='color-d'>damage</strong><br><em style = 'font-size:93%;'>nail, drone, neutron bomb, iridium, cosmic string, deflect</em>",
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isNailRadiation || tech.isWormholeDamage || tech.isNeutronBomb || tech.isExplodeRadio || tech.isBlockRadiation || tech.isDroneRadioactive
        },
        requires: "radiation damage source",
        effect() {
            tech.radioactiveDamage += 1.5
        },
        remove() {
            tech.radioactiveDamage = 1
        }
    },
    {
        name: "water shielding",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Radiation_protection#Radiation_shielding' class="link">water shielding</a>`,
        description: "reduce <strong class='color-p'>radioactive</strong> effects on you by <strong>0.2x</strong><br><em>neutron bomb, drones, explosions, slime</em>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.isNeutronBomb && tech.haveGunCheck("grenades")) || (tech.isDroneRadioactive && tech.haveGunCheck("drones")) || tech.isExplodeRadio
        },
        requires: "neutron bomb, irradiated drones, iridium-192",
        effect() {
            tech.isRadioactiveResistance = true
        },
        remove() {
            tech.isRadioactiveResistance = false
        }
    },
    {
        name: "ricochet",
        description: "after <strong>nails</strong> hit a mob they <strong>rebound</strong> towards<br>a new mob with <strong>2.8x</strong> <strong class='color-d'>damage</strong> per bounce",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            // return (tech.haveGunCheck("nail gun") && !tech.isRivets && !tech.isNeedles) || (tech.haveGunCheck("mines"))
            return tech.isMineDrop || tech.isNailBotUpgrade || tech.hookNails || tech.fragments || tech.nailsDeathMob || (tech.haveGunCheck("mine") && !(tech.isLaserMine || tech.isFoamMine || tech.isSuperMine)) || (tech.haveGunCheck("nail gun") && !tech.isRivets && !tech.isNeedles) || (tech.haveGunCheck("shotgun") && (tech.isNeedles || tech.isNailShot) && !tech.isRivets && !tech.isNeedles)
        },
        //
        requires: "nail gun, not rotary cannon, rivets, or needles",
        effect() {
            tech.isRicochet = true
        },
        remove() {
            tech.isRicochet = false
        }
    },
    {
        name: "booby trap",
        description: "<strong>50%</strong> chance to drop a <strong>mine</strong> from <strong>power ups</strong><br><strong>+15%</strong> chance for <strong class='color-junk'>JUNK</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("mine") && tech.junkChance < 1
        },
        requires: "mines",
        effect() {
            tech.isMineDrop = true;
            if (tech.isMineDrop) b.mine(m.pos, { x: 0, y: 0 }, 0)
            this.refundAmount += tech.addJunkTechToPool(0.15)
        },
        refundAmount: 0,
        remove() {
            tech.isMineDrop = false;
            if (this.count > 0 && this.refundAmount > 0) {
                tech.removeJunkTechFromPool(this.refundAmount)
                this.refundAmount = 0
            }
        }
    },
    {
        name: "elephants toothpaste",
        description: "instead of nails <strong>mines</strong> catalyze a reaction<br>that yields <strong>foam</strong> bubbles",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("mine") && !tech.isSuperMine && !tech.isRicochet && !tech.isNailRadiation && !tech.isNailCrit
        },
        requires: "mines, not blast ball, ricochet, irradiated nails, supercritical fission",
        effect() {
            tech.isFoamMine = true;
        },
        remove() {
            tech.isFoamMine = false;
        }
    },
    {
        name: "blast ball",
        descriptionFunction() {
            return `<strong>mines</strong> fire <strong>bouncy balls</strong> instead of nails`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("mine") && !tech.isFoamMine && !tech.isRicochet && !tech.isNailRadiation && !tech.isNailCrit
        },
        requires: "mines, not elephants toothpaste, ricochet, irradiated nails, supercritical fission",
        effect() {
            tech.isSuperMine = true;
        },
        remove() {
            tech.isSuperMine = false;
        }
    },
    {
        name: "laser-mines",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Laser' class="link">laser-mines</a>`,
        description: "<strong>mines</strong> laid while you are <strong>crouched</strong><br>use <strong class='color-f'>energy</strong> to emit <strong>3</strong> unaimed <strong class='color-laser'>lasers</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("mine")
        },
        requires: "mines",
        effect() {
            tech.isLaserMine = true;
        },
        remove() {
            tech.isLaserMine = false;
        }
    },
    {
        name: "sentry",
        descriptionFunction() {
            return `<strong>mines</strong> fire one ${b.guns[10].nameString()} at a time<br><strong>mines</strong> fire <strong>2x</strong> more ${b.guns[10].nameString('s')}`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("mine")
        },
        requires: "mines, not elephants toothpaste",
        effect() {
            tech.isMineSentry = true;
        },
        remove() {
            tech.isMineSentry = false;
        }
    },
    {
        name: "extended magazine",
        descriptionFunction() {
            return `sentry <strong>mines</strong> fire <strong>2x</strong> more ${b.guns[10].nameString('s')}`
        },
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("mine") && tech.isMineSentry
        },
        requires: "mines, sentry",
        effect() {
            tech.sentryAmmo += 22;
        },
        remove() {
            tech.sentryAmmo = 44;
        }
    },
    {
        name: "mycelial fragmentation",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Fungus' class="link">mycelial fragmentation</a>`,
        description: "during their <strong>growth</strong> phase<br><strong>1.7x</strong> <strong class='color-p' style='letter-spacing: 2px;'>sporangium</strong> discharge",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("spores")
        },
        requires: "spores",
        effect() {
            tech.isSporeGrowth = true
        },
        remove() {
            tech.isSporeGrowth = false
        }
    },
    {
        name: "cordyceps",
        // descriptionFunction() {
        //     return `mobs infected by ${b.guns[6].nameString('s')} have a <strong>5%</strong> chance<br>to <strong>resurrect</strong> and attack other mobs`
        // },
        description: "<strong class='color-p' style='letter-spacing: 2px;'>sporangium</strong> <strong>infect</strong> mobs they attach to<br><strong>infected</strong> mobs <strong>resurrect</strong> and attack other mobs",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("spores")
        },
        requires: "spores",
        effect() {
            tech.isZombieMobs = true
        },
        remove() {
            tech.isZombieMobs = false
        }
    },
    {
        name: "colony",
        description: "<strong>1.6x</strong> <strong class='color-p' style='letter-spacing: 2px;'>sporangium</strong> discharge<br><strong>33%</strong> chance to discharge something different",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Colony_(biology)' class="link">colony</a>`,
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("spores")
        },
        requires: "spores",
        effect() {
            tech.isSporeColony = true
        },
        remove() {
            tech.isSporeColony = false
        }
    },
    {
        name: "cryodesiccation",
        descriptionFunction() {
            return `<strong>1.25x</strong> <strong class='color-p' style='letter-spacing: 2px;'>sporangium</strong> discharge<br> ${b.guns[6].nameString('s')} <strong class='color-s'>freeze</strong> mobs for <strong>1.5</strong> second`
        },
        // description: "<strong>+25%</strong> <strong class='color-p' style='letter-spacing: 2px;'>sporangium</strong> discharge<br><strong class='color-p' style='letter-spacing: 2px;'>spores</strong> <strong class='color-s'>freeze</strong> mobs for <strong>1.5</strong> second",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("spores") || tech.sporesOnDeath > 0 || (m.fieldMode === 4 && simulation.molecularMode === 0) || tech.isSporeWorm || tech.isSporeFlea
        },
        requires: "spores",
        effect() {
            tech.isSporeFreeze = true
        },
        remove() {
            tech.isSporeFreeze = false
        }
    },
    {
        name: "flagella",
        descriptionFunction() {
            return `<strong>2x</strong> ${b.guns[6].nameString()} acceleration<br>if they can't find a target ${b.guns[6].nameString('s')} follow you`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("spores") || tech.sporesOnDeath > 0 || (m.fieldMode === 4 && simulation.molecularMode === 0) || tech.isSporeWorm || tech.isSporeFlea
        },
        requires: "spores",
        effect() {
            tech.isSporeFollow = true
        },
        remove() {
            tech.isSporeFollow = false
        }
    },
    {
        name: "mutualism",
        descriptionFunction() {
            return `<strong>3x</strong> ${b.guns[6].nameString()} <strong class='color-d'>damage</strong><br>${b.guns[6].nameString('s')} borrow <strong>1</strong> <strong class='color-h'>health</strong> until they <strong>die</strong>`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.haveGunCheck("spores") || tech.sporesOnDeath > 0 || (m.fieldMode === 4 && simulation.molecularMode === 0)) || tech.isSporeWorm || tech.isSporeFlea
        },
        requires: "spores",
        effect() {
            tech.isMutualism = true
        },
        remove() {
            tech.isMutualism = false
        }
    },
    {
        name: "necrophage",
        description: "if <strong>foam</strong>, <strong class='color-p' style='letter-spacing: -0.8px;'>fleas</strong>, or <strong class='color-p' style='letter-spacing: -0.8px;'>worms</strong> <strong>kill</strong> their target<br>they grow 3 <strong>copies</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("foam") || tech.isFoamBall || tech.isFoamBotUpgrade || tech.isFoamShot || tech.isSporeWorm || tech.isSporeFlea || tech.isFoamMine
        },
        requires: "foam, spores, worms, fleas",
        effect() {
            tech.isSpawnBulletsOnDeath = true
        },
        remove() {
            tech.isSpawnBulletsOnDeath = false;
        }
    },
    {
        name: "siphonaptera",
        description: "<strong class='color-p' style='letter-spacing: 2px;'>spores</strong> metamorphose into <strong class='color-p' style='letter-spacing: -0.8px;'>fleas</strong><br><strong>shotgun</strong> fires <strong class='color-p' style='letter-spacing: -0.8px;'>fleas</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return (tech.haveGunCheck("spores") || tech.sporesOnDeath > 0 || (m.fieldMode === 4 && simulation.molecularMode === 0) || (tech.haveGunCheck("shotgun") && !tech.isIncendiary && !tech.isRivets && !tech.isIceShot && !tech.isFoamShot && !tech.isNeedles && !tech.isNailShot)) && !tech.isSporeWorm
        },
        requires: "spores, not worms",
        effect() {
            tech.isSporeFlea = true
        },
        remove() {
            tech.isSporeFlea = false

        }
    },
    {
        name: "nematodes",
        description: "<strong class='color-p' style='letter-spacing: 2px;'>spores</strong> metamorphose into <strong class='color-p' style='letter-spacing: -0.8px;'>worms</strong><br><strong>shotgun</strong> fires <strong class='color-p' style='letter-spacing: -0.8px;'>worms</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return (tech.haveGunCheck("spores") || tech.sporesOnDeath > 0 || (m.fieldMode === 4 && simulation.molecularMode === 0) || (tech.haveGunCheck("shotgun") && !tech.isIncendiary && !tech.isRivets && !tech.isIceShot && !tech.isFoamShot && !tech.isNeedles && !tech.isNailShot)) && !tech.isSporeFlea
        },
        requires: "spores, not fleas",
        effect() {
            tech.isSporeWorm = true
        },
        remove() {
            tech.isSporeWorm = false
        }
    },
    {
        name: "K-selection",
        description: "<strong>1.37x</strong> <strong class='color-p' style='letter-spacing: -0.8px;'>worm</strong> and <strong class='color-p' style='letter-spacing: -0.8px;'>flea</strong> <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 3,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isSporeWorm || tech.isSporeFlea
        },
        requires: "spores, shotgun, worms, fleas",
        effect() {
            tech.wormSize++
        },
        remove() {
            tech.wormSize = 0
        }
    },
    {
        name: "path integration",
        descriptionFunction() {
            return `<strong>drones</strong> and ${b.guns[6].nameString("s")}<br>travel with you through <strong>levels</strong>`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.isSporeFollow && (tech.haveGunCheck("spores") || (tech.haveGunCheck("shotgun") && tech.isSporeWorm))) || tech.haveGunCheck("drones") || (m.fieldMode === 4 && (simulation.molecularMode === 0 || simulation.molecularMode === 3))
        },
        requires: "spores, worms, flagella, drones",
        effect() {
            tech.isDronesTravel = true
        },
        remove() {
            tech.isDronesTravel = false
        }
    },
    {
        name: "fault tolerance",
        description: `use ${powerUps.orb.research(2)}to trade your <strong>drone</strong> ${powerUps.orb.gun()}<br>for <strong>5</strong> <strong>drones</strong> that last <strong>forever</strong>`,
        // isGunTech: true,
        isRemoveGun: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isInstant: true,
        allowed() {
            return tech.haveGunCheck("drones", false) && !tech.isDroneRespawn && tech.bulletsLastLonger === 1 && !tech.isDronesTravel && (build.isExperimentSelection || powerUps.research.count > 1)
        },
        requires: "drones, not drone repair, anti-shear topology, autonomous navigation, ",
        effect() {
            const num = 5
            tech.isForeverDrones += num
            if (tech.haveGunCheck("drones", false)) b.removeGun("drones")
            //spawn drones
            if (tech.isDroneRadioactive) {
                for (let i = 0; i < num * 0.25; i++) {
                    b.droneRadioactive({
                        x: m.pos.x + 30 * (Math.random() - 0.5),
                        y: m.pos.y + 30 * (Math.random() - 0.5)
                    }, 5)
                    bullet[bullet.length - 1].endCycle = Infinity
                }
            } else {
                for (let i = 0; i < num; i++) {
                    b.drone({
                        x: m.pos.x + 30 * (Math.random() - 0.5),
                        y: m.pos.y + 30 * (Math.random() - 0.5)
                    }, 5)
                    bullet[bullet.length - 1].endCycle = Infinity
                }
            }
            for (let i = 0; i < 2; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
        },
        remove() {
            tech.isForeverDrones = 0
            // if (this.count && !tech.haveGunCheck("drones", false)) b.giveGuns("drones")
            // if (this.count > 0) powerUps.research.changeRerolls(2)
        }
    },
    {
        name: "ablative drones",
        descriptionFunction() {
            return `after losing ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong>" : "<strong class='color-h'>health</strong>"} there is a chance<br>to rebuild your broken parts as <strong>drones</strong>`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return (tech.haveGunCheck("drones") && !tech.isForeverDrones && !tech.isDroneRadioactive) || (m.fieldMode === 4 && simulation.molecularMode === 3)
        },
        requires: "drones, not fault tolerance, irradiated drones",
        effect() {
            tech.isDroneOnDamage = true;
        },
        remove() {
            tech.isDroneOnDamage = false;
        }
    },
    {
        name: "reduced tolerances",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Engineering_tolerance' class="link">reduced tolerances</a>`,
        description: `<strong>2x</strong> <strong>drones</strong> per ${powerUps.orb.ammo()} and <strong class='color-f'>energy</strong><br><strong>0.6x</strong> drone <strong>duration</strong>`,
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return !tech.isDroneRadioactive && (tech.haveGunCheck("drones") || (m.fieldMode === 4 && simulation.molecularMode === 3))
        },
        requires: "drones, not irradiated drones",
        effect() {
            tech.droneCycleReduction = 0.6
            tech.droneEnergyReduction = 0.3
            for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                if (b.guns[i].name === "drones") b.guns[i].ammoPack *= 2
            }
        },
        remove() {
            tech.droneCycleReduction = 1
            tech.droneEnergyReduction = 1
            if (this.count > 0) {
                for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                    if (b.guns[i].name === "drones") b.guns[i].ammoPack /= 2
                }
            }
        }
    },
    {
        name: "delivery drone",
        description: "if a <strong>drone</strong> picks up a <strong>power up</strong>,<br>it becomes <strong>larger</strong>, <strong>faster</strong>, and more <strong>durable</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("drones") || tech.isForeverDrones || (m.fieldMode === 4 && simulation.molecularMode === 3)
        },
        requires: "drones",
        effect() {
            tech.isDroneGrab = true
        },
        remove() {
            tech.isDroneGrab = false
        }
    },
    {
        name: "von Neumann probe",  //"drone repair",
        description: "after a <strong>drone</strong> expires it will use <strong>-4</strong> <strong class='color-f'>energy</strong><br>and a nearby <strong class='color-block'>block</strong> to <strong>replicate</strong> itself",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("drones") || (m.fieldMode === 4 && simulation.molecularMode === 3)
        },
        requires: "drones",
        effect() {
            tech.isDroneRespawn = true
        },
        remove() {
            tech.isDroneRespawn = false
        }
    },
    {
        name: "brushless motor",
        description: "<strong>drones</strong> rapidly <strong>rush</strong> towards their target<br><strong>1.33x</strong> <strong>drone</strong> collision <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return (tech.haveGunCheck("drones") || tech.isForeverDrones || (m.fieldMode === 4 && simulation.molecularMode === 3)) && !tech.isDroneRadioactive && !tech.isIncendiary
        },
        requires: "drones, molecular assembler, not irradiated drones, incendiary",
        effect() {
            tech.isDroneTeleport = true
        },
        remove() {
            tech.isDroneTeleport = false
        }
    },
    {
        name: "axial flux motor",
        description: "<strong>1.66x</strong> <strong>drones</strong> <strong>rush</strong> frequency<br><strong>1.44x</strong> <strong>drone</strong> collision <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isDroneTeleport
        },
        requires: "drones, brushless motor",
        effect() {
            tech.isDroneFastLook = true
        },
        remove() {
            tech.isDroneFastLook = false
        }
    },
    {
        name: "irradiated drones",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Irradiation' class="link">irradiated drones</a>`,
        description: `the space around <strong>drones</strong> is <strong class='color-p'>irradiated</strong><br><strong>0.25x</strong> <strong>drones</strong> per ${powerUps.orb.ammo()} and <strong class='color-f'>energy</strong>`,
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.droneCycleReduction === 1 && !tech.isDroneOnDamage && !tech.isIncendiary && !tech.isDroneTeleport && (tech.haveGunCheck("drones") || tech.isForeverDrones || (m.fieldMode === 4 && simulation.molecularMode === 3))
        },
        requires: "drones, not reduced tolerances, incendiary, torque bursts, ablative drones",
        effect() {
            tech.isDroneRadioactive = true
            for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                if (b.guns[i].name === "drones") {
                    b.guns[i].ammoPack *= 0.25
                    b.guns[i].ammo = Math.ceil(b.guns[i].ammo * 0.25)
                    simulation.makeGunHUD();
                }
            }
        },
        remove() {
            tech.isDroneRadioactive = false
            if (this.count > 0) {
                for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                    if (b.guns[i].name === "drones") {
                        b.guns[i].ammoPack /= 0.25
                        b.guns[i].ammo = b.guns[i].ammo * 4
                        simulation.makeGunHUD();
                    }
                }
            }
        }
    },
    {
        name: "beta radiation", //"control rod ejection",
        description: "<strong>0.5x</strong> <strong>drone</strong> duration<br><strong>2x</strong> <strong>drone</strong> <strong class='color-p'>radiation</strong> <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isDroneRadioactive
        },
        requires: "drones, irradiated drones",
        effect() {
            tech.droneRadioDamage = 2
        },
        remove() {
            tech.droneRadioDamage = 1
        }
    },
    {
        name: "orthocyclic winding",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Coil_winding_technology' class="link">orthocyclic winding</a>`,
        description: "<strong>1.66x</strong> <strong>drone</strong> acceleration<br><strong>1.33x</strong> <strong class='color-p'>radiation</strong> <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isDroneRadioactive
        },
        requires: "drones, irradiated drones",
        effect() {
            tech.isFastDrones = true
        },
        remove() {
            tech.isFastDrones = false
        }
    },
    {
        name: "electrostatic induction",
        description: "<strong>foam</strong> bubbles are electrically charged<br>causing <strong>attraction</strong> to nearby <strong>mobs</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.haveGunCheck("foam") || tech.isFoamBotUpgrade || tech.isFoamShot || tech.isFoamBall || tech.isFoamMine
        },
        requires: "foam",
        effect() {
            tech.isFoamAttract = true
        },
        remove() {
            tech.isFoamAttract = false
        }
    },
    {
        name: "uncertainty principle",
        description: "<strong>foam</strong>, <strong>wave</strong>, and <strong>super ball</strong> positions are erratic<br><strong>1.5x</strong> <strong>foam</strong>, <strong>wave</strong>, and <strong>super ball</strong> <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return (tech.haveGunCheck("foam") || tech.isFoamBotUpgrade || tech.isFoamShot || tech.isFoamBall || tech.isFoamMine) || (tech.haveGunCheck("wave") && !tech.is360Longitudinal) || (tech.haveGunCheck("super balls") && !tech.isSuperHarm) || tech.isSoundBotUpgrade
        },
        requires: "foam, wave, super balls, not isotropic, Zectron",
        effect() {
            tech.isBulletTeleport = true
        },
        remove() {
            tech.isBulletTeleport = false;
        }
    },
    {
        name: "surfactant",
        description: `use ${powerUps.orb.research(2)}to trade your <strong>foam</strong> ${powerUps.orb.gun()}<br>for <strong>2</strong> <strong class='color-bot'>foam-bots</strong> and <strong class='color-bot'>foam-bot upgrade</strong>`,
        // isGunTech: true,
        isRemoveGun: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        isBot: true,
        isBotTech: true,
        isInstant: true,
        requires: "foam gun, not bot upgrades, fractionation, pressure vessel",
        allowed() {
            return tech.haveGunCheck("foam", false) && !b.hasBotUpgrade() && !tech.isAmmoFoamSize && !tech.isFoamPressure && (build.isExperimentSelection || powerUps.research.count > 1)
        },
        effect() {

            requestAnimationFrame(() => { tech.giveTech("foam-bot upgrade") })
            for (let i = 0; i < 2; i++) {
                b.foamBot()
                tech.foamBotCount++;
            }
            simulation.inGameConsole(`tech.isFoamBotUpgrade = true`)
            if (tech.haveGunCheck("foam", false)) b.removeGun("foam")
            for (let i = 0; i < 2; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
        },
        remove() {
            // if (this.count) {
            //     b.clearPermanentBots();
            //     b.respawnBots();
            //     if (!tech.haveGunCheck("foam")) b.giveGuns("foam")
            // }
            // if (this.count > 0) powerUps.research.changeRerolls(2)
        }
    },
    {
        name: "aerogel",
        description: "<strong>foam</strong> bubbles <strong>float</strong> with <strong>0.5x</strong> <strong>foam</strong> duration<br><strong>2.8x</strong> <strong>foam</strong> <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("foam") || tech.isFoamBotUpgrade || tech.isFoamShot || tech.isFoamBall || tech.isFoamMine
        },
        requires: "foam",
        effect() {
            tech.isFastFoam = true
            tech.foamGravity = -0.0003
        },
        remove() {
            tech.isFastFoam = false;
            tech.foamGravity = 0.00008
        }
    },
    {
        name: "surface tension",
        description: "<strong>1.4x</strong> <strong>foam</strong> <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("foam") || tech.isFoamBotUpgrade || tech.isFoamShot || tech.isFoamBall || tech.isFoamMine
        },
        requires: "foam",
        effect() {
            tech.foamDamage += 0.01 * 0.4
        },
        remove() {
            tech.foamDamage = 0.01;
        }
    },
    {
        name: "cavitation",
        description: "<strong>25%</strong> chance to discharge a huge <strong>foam</strong> bubble<br><strong>2x</strong> <strong>foam</strong> gun <strong>recoil</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("foam") || tech.isFoamBotUpgrade || tech.isFoamShot || tech.isFoamBall || tech.isFoamMine
        },
        requires: "foam",
        effect() {
            tech.isFoamCavitation = true;
            b.guns[8].knockBack = 0.001
        },
        remove() {
            tech.isFoamCavitation = false;
            b.guns[8].knockBack = 0.0005
        }
    },
    {
        name: "foam fractionation",
        description: "if you have below <strong>300</strong> <strong class='color-ammo'>ammo</strong><br><strong>2x</strong> <strong>foam</strong> bubble <strong>size</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("foam")
        },
        requires: "foam",
        effect() {
            tech.isAmmoFoamSize = true
        },
        remove() {
            tech.isAmmoFoamSize = false;
        }
    },
    {
        name: "ideal gas law",
        description: `<strong>6x</strong> <strong>foam</strong> <strong class='color-ammo'>ammo</strong> per ${powerUps.orb.ammo(1)}`, //remove <strong>all</strong> current <strong>foam</strong> <strong class='color-ammo'>ammo</strong><br>
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("foam") && !tech.isEnergyNoAmmo
        },
        requires: "foam, not non-renewables",
        // ammoLost: 0,
        effect() {
            b.guns[8].ammoPack *= 6;
            // this.ammoLost = b.guns[8].ammo
            // b.guns[8].ammo = 0
            simulation.updateGunHUD()
        },
        remove() {
            if (this.count) {
                b.guns[8].ammoPack /= 8
                // b.guns[8].ammo += this.ammoLost
                simulation.updateGunHUD()
            }
        }
    },
    {
        name: "pressure vessel",
        description: "build up <strong>charge</strong> while firing <strong>foam</strong><br>after firing <strong>discharge</strong> <strong>foam</strong> bubbles",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("foam")
        },
        requires: "foam",
        effect() {
            tech.isFoamPressure = true;
            b.guns[8].chooseFireMethod()
        },
        remove() {
            tech.isFoamPressure = false;
            b.guns[8].chooseFireMethod()
        }
    },
    {
        name: "capacitor bank",
        descriptionFunction() {
            return `<strong>charge</strong> effects build up almost <strong>instantly</strong><br><em style = 'font-size:93%;'><strong class='color-block'>blocks</strong>, ${tech.haveGunCheck("foam", false) ? "<strong>foam</strong>" : "foam"}, ${tech.isPlasmaBall ? "<strong>plasma ball</strong>" : "plasma ball"}, ${tech.isRailGun ? "<strong>railgun</strong>" : "railgun"}, ${tech.isPulseLaser ? "<strong>pulse</strong>" : "pulse"}, ${tech.isTokamak ? "<strong>tokamak</strong>" : "tokamak"}</em>`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.blockDamage > 0.075 || tech.isRailGun || (tech.haveGunCheck("foam") && tech.isFoamPressure) || tech.isTokamak || tech.isPulseLaser || tech.isPlasmaBall
        },
        requires: "mass driver, railgun, foam, pressure vessel, pulse, tokamak, plasma ball",
        effect() {
            tech.isCapacitor = true;
        },
        remove() {
            tech.isCapacitor = false;
        }
    },
    {
        name: "Bitter electromagnet",
        descriptionFunction() {
            return `<strong>0.66x</strong> <strong>railgun</strong> charge rate<br><strong>2x</strong> ${b.guns[9].harpoonName()} density and <strong class='color-d'>damage</strong>`
        },
        isGunTech: true,
        maxCount: 3,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("harpoon") && tech.isRailGun
        },
        requires: "harpoon, railgun",
        effect() {
            tech.railChargeRate *= 1.06
            tech.harpoonDensity += 0.007
        },
        remove() {
            tech.railChargeRate = 0.97;
            tech.harpoonDensity = tech.isRailGun ? 0.007 : 0.004
        }
    },
    {
        name: "railgun",
        descriptionFunction() {
            return `<strong>hold</strong> and <strong>release</strong> fire to launch ${b.guns[9].harpoonName()}<br>but, ${b.guns[9].harpoonName()} can't <strong>retract</strong>`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("harpoon") && !tech.isFilament && !tech.isHarpoonPowerUp && !tech.isBoostReplaceAmmo && !tech.isBreakHarpoon
        },
        requires: "harpoon, not UHMWPE, induction furnace, quasiparticles, wear",
        ammoBonus: 9,
        effect() {
            tech.isRailGun = true;
            tech.harpoonDensity = tech.isRailGun ? 0.007 : 0.004
            b.guns[9].chooseFireMethod()
            b.guns[9].ammoPack *= 3;
            b.guns[9].ammo = b.guns[9].ammo * 6;
            simulation.updateGunHUD();
        },
        remove() {
            tech.isRailGun = false;
            if (this.count > 0) {
                tech.harpoonDensity = tech.isRailGun ? 0.007 : 0.004
                b.guns[9].chooseFireMethod()
                b.guns[9].ammoPack /= 3;
                b.guns[9].ammo = Math.ceil(b.guns[9].ammo / 6);
                simulation.updateGunHUD();
            }
        }
    },
    {
        name: "alternator",
        descriptionFunction() {
            return `<strong>0.05x</strong> ${b.guns[9].harpoonName()} <strong class='color-f'>energy</strong> cost`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("harpoon")
        },
        requires: "harpoon",
        effect() {
            tech.isRailEnergy = true;
        },
        remove() {
            tech.isRailEnergy = false;
        }
    },
    {
        name: "autonomous defense",
        descriptionFunction() {
            return `if you <strong>collide</strong> with a <strong>mob</strong><br>fire ${b.guns[9].harpoonName()} at nearby <strong>mobs</strong>`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("harpoon")
        },
        requires: "harpoon",
        effect() {
            tech.isHarpoonDefense = true
        },
        remove() {
            tech.isHarpoonDefense = false
        }
    },
    {
        name: "rebar",
        descriptionFunction() {
            return `use ${this.removeAmmo} <strong class='color-ammo'>ammo</strong> to forge your <strong>harpoon</strong> into <strong>rebar</strong><br><strong>2x</strong> <strong class='color-d'>damage</strong> and mass`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        removeAmmo: 10,
        allowed() {
            return tech.haveGunCheck("harpoon") && (build.isExperimentSelection || b.guns[9].ammo >= this.removeAmmo)
        },
        requires: "harpoon",
        effect() {
            tech.isRebar = true;
            for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                if (b.guns[i].name === "harpoon") {
                    b.guns[i].ammo -= this.removeAmmo
                    if (b.guns[i].ammo < 0) b.guns[i].ammo = 0
                    simulation.updateGunHUD();
                    break
                }
            }
        },
        remove() {
            tech.isRebar = false;
            if (this.count) {
                for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                    if (b.guns[i].name === "harpoon") {
                        b.guns[i].ammo += this.removeAmmo
                        simulation.updateGunHUD();
                        break
                    }
                }
            }
        }
    },
    {
        name: "maul",
        descriptionFunction() {
            return `use ${this.removeAmmo} <strong class='color-ammo'>ammo</strong> to forge <strong>rebar</strong> into a <strong>maul</strong><br><strong>2x</strong> <strong class='color-d'>damage</strong> and mass`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 4,
        frequencyDefault: 4,
        removeAmmo: 10,
        allowed() {
            return tech.haveGunCheck("harpoon") && (build.isExperimentSelection || b.guns[9].ammo >= this.removeAmmo) && tech.isRebar
        },
        requires: "harpoon, rebar",
        effect() {
            tech.isMaul = true;
            for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                if (b.guns[i].name === "harpoon") {
                    b.guns[i].ammo -= this.removeAmmo
                    if (b.guns[i].ammo < 0) b.guns[i].ammo = 0
                    simulation.updateGunHUD();
                    break
                }
            }
        },
        remove() {
            tech.isMaul = false;
            if (this.count) {
                for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                    if (b.guns[i].name === "harpoon") {
                        b.guns[i].ammo += this.removeAmmo
                        simulation.updateGunHUD();
                        break
                    }
                }
            }
        }
    },
    {
        name: "wear",
        descriptionFunction() {
            //<strong>2x</strong> ${b.guns[9].harpoonName()} <strong class='color-d'>damage</strong>
            return `<strong>2x</strong> ${b.guns[9].harpoonName()} <em>fire rate</em><br><strong>10%</strong> chance to <strong>break</strong> on hitting mobs, <strong>-1</strong> <strong class='color-ammo'>ammo</strong>`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("harpoon") && !tech.isRailGun
        },
        requires: "harpoon, not railgun",
        effect() {
            tech.isBreakHarpoon = true;
        },
        remove() {
            tech.isBreakHarpoon = false;
        }
    },
    {
        name: "spalling",
        descriptionFunction() {
            return `if your ${b.guns[9].harpoonName()} <strong>breaks</strong> after hitting mobs<br>spawn metal <strong>fragments</strong> and ${powerUps.orb.research(2)}${powerUps.orb.boost(1)}`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 4,
        frequencyDefault: 4,
        allowed() {
            return tech.haveGunCheck("harpoon") && tech.isBreakHarpoon
        },
        requires: "harpoon, wear",
        effect() {
            tech.isBreakHarpoonGain = true;
        },
        remove() {
            tech.isBreakHarpoonGain = false;
        }
    },
    {
        name: "Bessemer process",
        descriptionFunction() {
            return `<strong>${(1 + 0.1 * Math.sqrt(b.guns[9].ammo)).toFixed(2)}x</strong> ${b.guns[9].harpoonName()} size and <strong class='color-d'>damage</strong><br><em>(effect scales by 1/10 √<strong class='color-ammo'>ammo</strong>)</em>`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("harpoon") && !tech.isShieldPierce
        },
        requires: "harpoon, not ceramics",
        effect() {
            tech.isLargeHarpoon = true;
        },
        remove() {
            tech.isLargeHarpoon = false;
        }
    },
    {
        name: "smelting",
        descriptionFunction() {
            return `forge <strong>${this.removeAmmo()}</strong> <strong class='color-ammo'>ammo</strong> into a new ${b.guns[9].harpoonName()}<br>fire <strong>+1</strong> ${b.guns[9].harpoonName()} with each shot`
        },
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        ammoRemoved: 0,
        removeAmmo() {
            return (tech.isRailGun ? 5 : 1) * (2 + 2 * this.count)
        },
        allowed() {
            return tech.haveGunCheck("harpoon") && b.guns[9].ammo >= this.removeAmmo()
        },
        requires: "harpoon",
        effect() {
            for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                if (b.guns[i].name === "harpoon") {
                    const removeAmmo = this.removeAmmo()
                    this.ammoRemoved += removeAmmo
                    b.guns[i].ammo -= removeAmmo
                    if (b.guns[i].ammo < 0) b.guns[i].ammo = 0
                    simulation.updateGunHUD();
                    tech.extraHarpoons++;
                    break
                }
            }
        },
        remove() {
            if (tech.extraHarpoons) {
                for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                    if (b.guns[i].name === "harpoon") {
                        b.guns[i].ammo += this.ammoRemoved
                        simulation.updateGunHUD();
                        break
                    }
                }
            }
            this.ammoRemoved = 0
            tech.extraHarpoons = 0;
        }
    },
    {
        name: "UHMWPE",
        descriptionFunction() {
            return `<strong>${(1 + b.guns[9].ammo * 0.0125).toFixed(2)}x</strong> ${b.guns[9].harpoonName()} rope length<br><em>(effect scales by 1/80 of <strong class='color-ammo'>ammo</strong>)</em>`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("harpoon") && !tech.isRailGun
        },
        requires: "harpoon, not railgun",
        effect() {
            tech.isFilament = true;
        },
        remove() {
            tech.isFilament = false;
        }
    },
    {
        name: "induction furnace",
        descriptionFunction() {
            return `after using ${b.guns[9].harpoonName()}/<strong>grapple</strong> to collect <strong>power ups</strong><br><strong>1.8x</strong> ${b.guns[9].harpoonName()} or <strong>grapple</strong> <strong class='color-d'>damage</strong> for <strong>8</strong> seconds`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return ((tech.haveGunCheck("harpoon") && !tech.isRailGun) || m.fieldMode === 10) && !tech.isHarpoonFullHealth
        },
        requires: "harpoon, grappling hook, not railgun, brittle",
        effect() {
            tech.isHarpoonPowerUp = true
        },
        remove() {
            tech.isHarpoonPowerUp = false
            tech.harpoonPowerUpCycle = 0
        }
    },
    {
        name: "brittle",
        descriptionFunction() {
            return `<strong>2.2x</strong> ${b.guns[9].harpoonName()}/<strong>grapple</strong> <strong class='color-d'>damage</strong><br>to <strong>mobs</strong> at maximum <strong>durability</strong>`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.haveGunCheck("harpoon") || m.fieldMode === 10) && !tech.isHarpoonPowerUp
        },
        requires: "harpoon, grappling hook, not induction furnace",
        effect() {
            tech.isHarpoonFullHealth = true
        },
        remove() {
            tech.isHarpoonFullHealth = false
        }
    },
    {
        name: "quasiparticles",
        descriptionFunction() {
            return `convert current and future ${powerUps.orb.ammo(1)} into ${powerUps.orb.boost(1)}<br>that give <strong>${(1 + powerUps.boost.damage).toFixed(2)}x</strong> <strong class='color-d'>damage</strong> for <strong>${(powerUps.boost.duration / 60).toFixed(0)}</strong> seconds</span>`
        },
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return ((tech.haveGunCheck("wave") && tech.isInfiniteWaveAmmo) || tech.haveGunCheck("laser") || (tech.haveGunCheck("harpoon") && !tech.isRailGun))
        },
        requires: "harpoon, laser, wave, frequency, not railgun, non-renewables",
        effect() {
            tech.isBoostReplaceAmmo = true
            for (let i = powerUp.length - 1; i > -1; i--) {
                if (powerUp[i].name === "ammo") {
                    powerUps.spawn(powerUp[i].position.x + 50 * (Math.random() - 0.5), powerUp[i].position.y + 50 * (Math.random() - 0.5), "boost");
                    Matter.Composite.remove(engine.world, powerUp[i]);
                    powerUp.splice(i, 1);
                }
            }

        },
        remove() {
            tech.isBoostReplaceAmmo = false
        }
    },
    {
        name: "optical amplifier",
        description: `gain <strong>3</strong> random <strong class='color-laser'>laser</strong> ${powerUps.orb.tech()}<br><strong class='color-laser'>laser</strong> only turns <strong>off</strong> if you have no <strong class='color-f'>energy</strong>`,
        // isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        isInstant: true,
        allowed() {
            return tech.haveGunCheck("laser") && !tech.isPulseLaser
        },
        requires: "laser gun, not pulse",
        effect() {
            requestAnimationFrame(() => {
                let techGiven = 0
                for (let j = 0; j < 3; j++) {
                    const names = ["quasiparticles", "lens", "compound lens", "arc length", "infrared diode", "free-electron laser", "dye laser", "relativistic momentum", "specular reflection", "diffraction grating", "diffuse beam", "output coupler", "slow light", "laser-bot", "laser-bot upgrade", "collimator"]
                    //convert names into indexes
                    const options = []
                    for (let i = 0; i < names.length; i++) {
                        for (let k = 0; k < tech.tech.length; k++) {
                            if (tech.tech[k].name === names[i]) {
                                options.push(k)
                                break
                            }
                        }
                    }
                    //remove options that don't meet requirements
                    for (let i = options.length - 1; i > -1; i--) {
                        const index = options[i]
                        if (!(tech.tech[index].count < tech.tech[index].maxCount) || !tech.tech[index].allowed()) {
                            options.splice(i, 1);
                        }
                    }
                    //pick one option
                    if (options.length) {
                        const index = options[Math.floor(Math.random() * options.length)]
                        simulation.inGameConsole(`<span class='color-var'>tech</span>.giveTech("<span class='color-text'>${tech.tech[index].name}</span>") <em>//optical amplifier</em>`, 360);
                        tech.giveTech(index)
                        techGiven++
                    }
                }
                if (techGiven > 0) {
                    tech.isStuckOn = true
                } else { //eject if none found
                    simulation.inGameConsole(`0 <span class='color-var'>tech</span> found <em>//optical amplifier</em>`);
                    const loop = () => {
                        if (!simulation.paused && m.alive) {
                            for (let i = 0; i < tech.tech.length; i++) {
                                if (tech.tech[i].name === this.name) powerUps.ejectTech(i)
                            }
                            return
                        }
                        requestAnimationFrame(loop);
                    }
                    requestAnimationFrame(loop);
                }
            });
        },
        remove() {
            tech.isStuckOn = false
        }
    },
    {
        name: "relativistic momentum",
        description: "<strong class='color-laser'>lasers</strong> push <strong>mobs</strong> and <strong class='color-block'>blocks</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.haveGunCheck("laser") && !tech.isPulseLaser) || tech.isLaserBotUpgrade || tech.isLaserField
        },
        requires: "laser, not pulse",
        effect() {
            tech.isLaserPush = true;
        },
        remove() {
            tech.isLaserPush = false;
        }
    },
    {
        name: "iridescence",
        description: "if <strong class='color-laser'>laser</strong> beams hit mobs near their <strong>center</strong><br><strong>2x</strong> <strong class='color-laser'>laser</strong> <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (tech.haveGunCheck("laser") && !tech.isPulseLaser) || tech.isLaserBotUpgrade || tech.isLaserMine
        },
        requires: "laser, not pulse",
        effect() {
            tech.laserCrit += 1;
        },
        remove() {
            tech.laserCrit = 0;
        }
    },
    {
        name: "lens",
        description: "<strong>2.5x</strong> <strong class='color-laser'>laser</strong> <strong class='color-d'>damage</strong> if it passes<br>through a revolving <strong>90°</strong> arc circular lens", //<span style='font-size: 125%;'>π</span> / 2</strong>
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("laser")
        },
        requires: "laser",
        effect() {
            tech.isLaserLens = true
            b.guns[11].chooseFireMethod()
            // if (this.count > 0) b.guns[11].lensDamageOn += 20 * Math.PI / 180
            // b.guns[11].arcRange = 0.78
        },
        remove() {
            tech.isLaserLens = false
            b.guns[11].chooseFireMethod()
            // b.guns[11].lensDamageOn = 2.5 // 100% + 150%
            // b.guns[11].arcRange = 0
        }
    },
    {
        name: "compound lens",
        description: "<strong>1.4x</strong> <strong class='color-laser'>laser</strong> lens <strong class='color-d'>damage</strong><br><strong>+30°</strong> lens arc",
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("laser") && tech.isLaserLens
        },
        requires: "lens",
        effect() {
            b.guns[11].arcRange += 30 * Math.PI / 180 / 2
            b.guns[11].lensDamageOn += 0.4
        },
        remove() {
            b.guns[11].arcRange = 90 * Math.PI / 180 / 2 //0.78 divded by 2 because of how it's drawn
            b.guns[11].lensDamageOn = 2.5
        }
    },
    {
        name: "specular reflection",
        description: "<strong>+2</strong> <strong class='color-laser'>laser</strong> beam reflections",
        isGunTech: true,
        maxCount: 3,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return (tech.haveGunCheck("laser") || tech.isLaserMine || tech.isLaserBotUpgrade || tech.isLaserField) && !tech.isWideLaser && !tech.isPulseLaser && !tech.historyLaser
        },
        requires: "laser, not diffuse beam, pulse, slow light",
        effect() {
            tech.laserReflections += 2;
        },
        remove() {
            tech.laserReflections = 2;
        }
    },
    {
        name: "diffraction grating",
        description: `<strong>+1</strong> diverging <strong class='color-laser'>laser</strong> beam`,
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.haveGunCheck("laser") && !tech.isWideLaser && !tech.historyLaser
        },
        requires: "laser gun, not diffuse beam, slow light",
        effect() {
            tech.beamSplitter++
            b.guns[11].chooseFireMethod()
        },
        remove() {
            if (tech.beamSplitter !== 0) {
                tech.beamSplitter = 0
                b.guns[11].chooseFireMethod()
            }
        }
    },
    {
        name: "collimator",
        description: `<strong>+1</strong> <strong class='color-laser'>laser</strong> beam<br>align your diverging <strong class='color-laser'>laser</strong> beams to be <strong>parallel</strong>`,
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.haveGunCheck("laser") && !tech.isWideLaser && !tech.historyLaser && tech.beamSplitter > 0 && !tech.isPulseLaser
        },
        requires: "laser gun, diffraction, not diffuse beam, slow light, pulse",
        effect() {
            tech.beamSplitter++
            tech.beamCollimator = true
            b.guns[11].chooseFireMethod()
        },
        remove() {
            tech.beamCollimator = false
            if (tech.beamSplitter > 0) tech.beamSplitter--
            b.guns[11].chooseFireMethod()
        }
    },
    {
        name: "diffuse beam",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Diffuser_(optics)' class="link">diffuse beam</a>`,
        description: "your <strong class='color-laser'>laser</strong> beam is <strong>wider</strong>, but it doesn't <strong>reflect</strong><br><strong>3.2x</strong> <strong class='color-laser'>laser</strong> <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("laser") && tech.laserReflections < 3 && !tech.beamSplitter && !tech.isPulseLaser && !tech.historyLaser
        },
        requires: "laser gun, not specular reflection, diffraction grating, slow light, pulse",
        effect() {
            if (tech.wideLaser === 0) tech.wideLaser = 3
            tech.isWideLaser = true;
            b.guns[11].chooseFireMethod()
        },
        remove() {
            if (tech.isWideLaser) {
                // tech.wideLaser = 0
                tech.isWideLaser = false;
                b.guns[11].chooseFireMethod()
            }
        }
    },
    {
        name: "output coupler",
        description: "<strong>1.3x</strong> <strong class='color-laser'>laser</strong> beam <strong>width</strong><br><strong>1.3x</strong> <strong class='color-laser'>laser</strong> <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("laser") && tech.isWideLaser
        },
        requires: "laser gun, diffuse beam",
        effect() {
            tech.wideLaser += 2
            b.guns[11].chooseFireMethod()
        },
        remove() {
            if (tech.isWideLaser) {
                tech.wideLaser = 3
            } else {
                tech.wideLaser = 0
            }
            b.guns[11].chooseFireMethod()
        }
    },
    {
        name: "delayed-choice",
        description: "your <strong class='color-laser'>laser</strong> fires a <strong>0.4</strong> second <strong>delayed</strong> beam<br>that does <strong>0.7x</strong> <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 9,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return tech.haveGunCheck("laser") && !tech.beamSplitter && !tech.isWideLaser
        },
        requires: "laser gun, not diffraction grating, diffuse beam",
        effect() {
            tech.historyLaser++
            b.guns[11].chooseFireMethod()
        },
        remove() {
            if (tech.historyLaser) {
                tech.historyLaser = 0
                b.guns[11].chooseFireMethod()
            }
        }
    },
    {
        name: "infrared diode",
        description: "<strong>0.4x</strong> <strong class='color-laser'>laser</strong> <strong class='color-f'>energy</strong> cost<br><em>infrared light is outside visual perception</em>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return (tech.haveGunCheck("laser") || tech.isLaserBotUpgrade || tech.isLaserMine || tech.isLaserField) && !tech.isPulseLaser && tech.laserDrain === 0.003
        },
        requires: "laser, not free-electron, pulse",
        effect() {
            tech.laserDrain *= 0.4; //100%-50%
            tech.laserColor = "transparent" //"rgb(255,0,20,0.02)"
            // tech.laserColorAlpha = "rgba(255,0,20,0.05)"
        },
        remove() {
            tech.laserDrain = 0.003;
            tech.laserColor = "#f02"
            tech.laserColorAlpha = "rgba(255, 0, 0, 0.5)"
        }
    },
    {
        name: "dye laser",
        description: "<strong>0.75x</strong> <strong class='color-laser'>laser</strong> <strong class='color-f'>energy</strong> cost<br><strong>1.25x</strong> <strong class='color-laser'>laser</strong> <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return (tech.haveGunCheck("laser") || tech.isLaserMine || tech.isLaserBotUpgrade || tech.isLaserField) && !tech.isPulseLaser && tech.laserDrain === 0.003
        },
        requires: "laser, not pulse, infrared diode",
        effect() {
            tech.laserDrain *= 0.75
            tech.laserDamage *= 1.25
            tech.laserColor = "rgb(0, 40, 255)"
            tech.laserColorAlpha = "rgba(0, 40, 255,0.5)"
        },
        remove() {
            tech.laserDrain = 0.003;
            tech.laserDamage = 0.18; //used in check on pulse and diode: tech.laserDamage === 0.18
            tech.laserColor = "#f00"
            tech.laserColorAlpha = "rgba(255, 0, 0, 0.5)"
        }
    },
    {
        name: "free-electron laser",
        description: "<strong>3x</strong> <strong class='color-laser'>laser</strong> <strong class='color-f'>energy</strong> cost<br><strong>3x</strong> <strong class='color-laser'>laser</strong> <strong class='color-d'>damage</strong>",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return (tech.haveGunCheck("laser") || tech.isLaserMine || tech.isLaserBotUpgrade || tech.isLaserField) && !tech.isPulseLaser && tech.laserDrain === 0.003
        },
        requires: "laser, not pulse, infrared diode",
        effect() {
            tech.laserDrain *= 3
            tech.laserDamage *= 3
            tech.laserColor = "#83f"
            tech.laserColorAlpha = "rgba(136, 51, 255,0.5)"
        },
        remove() {
            tech.laserDrain = 0.003;
            tech.laserDamage = 0.18; //used in check on pulse and diode: tech.laserDamage === 0.18
            tech.laserColor = "#f00"
            tech.laserColorAlpha = "rgba(255, 0, 0, 0.5)"
        }
    },
    {
        name: "pulse",
        description: "charge your <strong class='color-f'>energy</strong> and release it as a<br><strong class='color-laser'>laser</strong> pulse that initiates an <strong class='color-e'>explosion</strong> cluster",
        isGunTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.haveGunCheck("laser") && tech.laserReflections < 3 && !tech.isWideLaser && tech.laserDrain === 0.003 && !tech.isStuckOn && !tech.beamCollimator
        },
        requires: "laser gun, not specular reflection, diffuse, free-electron laser, optical amplifier, collimator",
        effect() {
            tech.isPulseLaser = true;
            b.guns[11].chooseFireMethod()
        },
        remove() {
            if (tech.isPulseLaser) {
                tech.isPulseLaser = false;
                b.guns[11].chooseFireMethod()
            }
        }
    },
    //************************************************** 
    //************************************************** field
    //************************************************** tech
    //**************************************************
    {
        name: "spherical harmonics",
        description: "<strong>1.5x</strong> <strong>standing wave</strong> deflection <strong class='color-f'>energy</strong> efficiency<br>shield deflection <strong>radius</strong> is stable", //<strong>standing wave</strong> oscillates in a 3rd dimension<br>
        isFieldTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 1 && !tech.isLaserField
        },
        requires: "standing wave, not surface plasmons",
        effect() {
            tech.harmonics++
            m.fieldShieldingScale = 1.6 * Math.pow(0.5, (tech.harmonics - 2))
            m.harmonicShield = m.harmonicAtomic
        },
        remove() {
            tech.harmonics = 2
            m.fieldShieldingScale = 1.6 * Math.pow(0.5, (tech.harmonics - 2))
            m.harmonicShield = m.harmonic3Phase
        }
    },
    {
        name: "superposition",
        descriptionFunction() {
            return `<strong>0.1x</strong> <strong class='color-defense'>damage taken</strong><br>while you have above <strong>200</strong> <strong class='color-f'>energy</strong>`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 1
        },
        requires: "standing wave",
        effect() {
            tech.energyDefense = true
        },
        remove() {
            tech.energyDefense = false
        }
    },
    {
        name: "surface plasmons",
        description: "if <strong>deflecting</strong> drains all your <strong class='color-f'>energy</strong><br>emit <strong class='color-laser'>laser</strong> beams that scale with max <strong class='color-f'>energy</strong>",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 1 && tech.harmonics === 2
        },
        requires: "standing wave",
        effect() {
            tech.isLaserField = true
        },
        remove() {
            tech.isLaserField = false
        }
    },
    {
        name: "zero point energy",
        description: `use ${powerUps.orb.research(2)}<br><strong>+166</strong> maximum <strong class='color-f'>energy</strong>`,
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return (m.fieldMode === 1 || m.fieldMode === 8 || m.fieldMode === 6) && (build.isExperimentSelection || powerUps.research.count > 1)
        },
        requires: "standing wave, pilot wave, time dilation",
        effect() {
            tech.harmonicEnergy = 1.66
            m.setMaxEnergy()
            for (let i = 0; i < 2; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
        },
        remove() {
            tech.harmonicEnergy = 0;
            m.setMaxEnergy()
            if (this.count > 0) powerUps.research.changeRerolls(2)
        }
    },
    {
        name: "expansion",
        description: "using standing wave <strong>expands</strong> its <strong>radius</strong><br><strong>+77</strong> maximum <strong class='color-f'>energy</strong>",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 1
        },
        requires: "standing wave",
        effect() {
            tech.isStandingWaveExpand = true
            m.setMaxEnergy()
            // m.fieldShieldingScale = (tech.isStandingWaveExpand ? 0.9 : 1.6) * Math.pow(0.6, (tech.harmonics - 2))
        },
        remove() {
            tech.isStandingWaveExpand = false
            m.setMaxEnergy()
            // m.fieldShieldingScale = (tech.isStandingWaveExpand ? 0.9 : 1.6) * Math.pow(0.6, (tech.harmonics - 2))
            m.harmonicRadius = 1
        }
    },
    {
        name: "electronegativity",
        descriptionFunction() {
            return `<strong>1.0023x</strong> <strong class='color-d'>damage</strong> per <strong class='color-f'>energy</strong><br><em style ="float: right;">(${(1 + 0.23 * m.energy).toFixed(2)}x, ${(1 + 0.23 * m.maxEnergy).toFixed(2)}x at max energy)</em>`
        },
        // description: "<strong>+1%</strong> <strong class='color-d'>damage</strong> per <strong>8</strong> stored <strong class='color-f'>energy</strong>",
        isFieldTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 1 || m.fieldMode === 9 || m.fieldMode === 8
        },
        requires: "standing wave, wormhole, pilot wave",
        effect() {
            tech.energyDamage++
        },
        remove() {
            tech.energyDamage = 0;
        }
    },
    {
        name: "bremsstrahlung",
        description: "<strong>deflecting</strong> with your <strong class='color-f'>field</strong> and thrown <strong class='color-block'>blocks</strong><br>do extra <strong class='color-d'>damage</strong> to mobs",
        isFieldTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 1 || m.fieldMode === 2 || m.fieldMode === 8
        },
        requires: "standing wave, perfect diamagnetism, pilot wave",
        effect() {
            tech.blockDmg += 5 //if you change this value also update the for loop in the electricity graphics in m.pushMass
        },
        remove() {
            tech.blockDmg = 0;
        }
    },
    {
        name: "cherenkov radiation", //<strong>deflecting</strong> and <strong class='color-block'>blocks</strong>
        description: "bremsstrahlung's effects are <strong class='color-p'>radioactive</strong><br><strong>3.5x</strong> <strong class='color-d'>damage</strong> over <strong>3</strong> seconds",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (m.fieldMode === 1 || m.fieldMode === 2 || m.fieldMode === 8) && tech.blockDmg
        },
        requires: "bremsstrahlung",
        effect() {
            tech.isBlockRadiation = true
        },
        remove() {
            tech.isBlockRadiation = false;
        }
    },
    {
        name: "flux pinning",
        description: `mobs <strong>deflected</strong> by your ${powerUps.orb.field()}<br>are <strong>stunned</strong> for <strong>4</strong> seconds`,
        isFieldTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 2 || m.fieldMode === 1 || m.fieldMode === 4
        },
        requires: "a field that can block",
        effect() {
            tech.isStunField += 240;
        },
        remove() {
            tech.isStunField = 0;
        }
    },
    {
        name: "eddy current brake",
        description: "perfect diamagnetism <strong class='color-s'>slows</strong> nearby mobs<br>effect <strong>radius</strong> scales with stored <strong class='color-f'>energy</strong>",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 2 && !tech.isHealBrake
        },
        requires: "perfect diamagnetism, not induction brake",
        effect() {
            tech.isPerfectBrake = true;
        },
        remove() {
            tech.isPerfectBrake = false;
        }
    },
    {
        name: "Meissner effect",
        description: "<strong>1.55x</strong> perfect diamagnetism <strong>radius</strong><br><strong>+22°</strong> perfect diamagnetism circular <strong>arc</strong>",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 2
        },
        requires: "perfect diamagnetism",
        effect() {
            tech.isBigField = true;
        },
        remove() {
            tech.isBigField = false;
        }
    },
    {
        name: "radiative equilibrium",
        descriptionFunction() {
            return `after losing ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong> from collisions" : "<strong class='color-h'>health</strong>"}<br><strong>4x</strong> <strong class='color-d'>damage</strong> for <strong>4</strong> seconds`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 8 || m.fieldMode === 3
        },
        requires: "negative mass, pilot wave",
        effect() {
            tech.isHarmDamage = true;
        },
        remove() {
            tech.isHarmDamage = false;
        }
    },
    {
        name: "dynamic equilibrium",
        descriptionFunction() {
            return `increase <strong class='color-d'>damage</strong> by your most recent ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong>" : "<strong class='color-h'>health</strong>"} loss<br> <em style ="float: right;">(${(1 + (tech.lastHitDamage === 0 ? 6 : tech.lastHitDamage) * m.lastHit).toFixed(2)}x)</em>`
        },
        isFieldTech: true,
        maxCount: 3,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 8 || m.fieldMode === 3
        },
        requires: "negative mass, pilot wave",
        effect() {
            tech.lastHitDamage += 8;
        },
        remove() {
            tech.lastHitDamage = 0;
        }
    },
    {
        name: "neutronium",
        description: `<strong>0.8x</strong> <strong>move</strong> and <strong>jump</strong>, but <br>while your ${powerUps.orb.field()} is active <strong>0.05x</strong> <strong class='color-defense'>damage taken</strong>`,
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 3 && tech.negativeMassCost !== 0
        },
        requires: "negative mass, not equivalence principle",
        effect() {
            tech.isNeutronium = true
            tech.baseFx *= 0.86
            tech.baseJumpForce *= 0.87
            m.setMovement()
        },
        //also removed in m.setHoldDefaults() if player switches into a bad field
        remove() {
            tech.isNeutronium = false
            if (!tech.isFreeWormHole) {
                tech.baseFx = 0.08
                tech.baseJumpForce = 10.5
                m.setMovement()
            }
        }
    },
    {
        name: "equivalence principle",
        description: `<strong>negative mass</strong> field doesn't cost <strong class='color-f'>energy</strong><br>`,
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 3 && !tech.isNeutronium
        },
        requires: "negative mass, not neutronium",
        effect() {
            tech.negativeMassCost = 0
        },
        //also removed in m.setHoldDefaults() if player switches into a bad field
        remove() {
            tech.negativeMassCost = 0.00035
        }
    },
    {
        name: "aerostat",
        descriptionFunction() {
            const damage = m.onGround ? 1 : (tech.offGroundDamage)
            const infoText = this.count ? `<br><em style ="float: right;">(${damage.toFixed(0)}x)</em>` : ""
            return `<strong>2x</strong> <strong class='color-d'>damage</strong> while <strong>off</strong> the <strong>ground</strong>${infoText}`
        },
        isFieldTech: true,
        maxCount: 3,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 3 || m.fieldMode === 10
        },
        requires: "negative mass, grappling hook",
        effect() {
            tech.offGroundDamage++
        },
        remove() {
            tech.offGroundDamage = 1
        }
    },
    {
        name: "annihilation",
        description: "<strong>mobs</strong> you <strong>collide</strong> with are <strong>annihilated</strong><br><strong>–8</strong> <strong class='color-f'>energy</strong> each time",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 3 && !tech.isEnergyHealth
        },
        requires: "negative mass, not mass-energy",
        effect() {
            tech.isAnnihilation = true
        },
        remove() {
            tech.isAnnihilation = false;
        }
    },
    {
        name: "inertial mass",
        description: "<strong>negative mass</strong> is larger and <strong>faster</strong>",  //<br><strong class='color-block'>blocks</strong> also move <strong>horizontally</strong> with the field
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 3
        },
        requires: "negative mass",
        effect() {
            tech.isFlyFaster = true
        },
        remove() {
            tech.isFlyFaster = false;
        }
    }, {
        name: "Newtons 1st law",
        descriptionFunction() {
            return `<strong class='color-defense'>damage taken</strong> reduces as your <strong class="color-speed">speed</strong> increases<br>up to <strong>0.05x</strong> <strong class='color-defense'>damage taken</strong> at <strong>60</strong> <strong class="color-speed">speed</strong> <em style ="float: right;">(${(1 - Math.min((tech.speedAdded + player.speed) * 0.01583, 0.95)).toFixed(2)}x)</em>`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return m.fieldMode === 3 || m.fieldMode === 10
        },
        requires: "negative mass, grappling hook",
        effect() {
            tech.isSpeedHarm = true //max at speed = 40
        },
        remove() {
            tech.isSpeedHarm = false
        }
    },
    {
        name: "Newtons 2nd law",
        descriptionFunction() {
            return `<strong class='color-d'>damage</strong> increases proportional to your <strong class="color-speed">speed</strong><br>up to <strong>3x</strong> <strong class='color-d'>damage</strong> at <strong>60</strong> <strong class="color-speed">speed</strong> <em style ="float: right;">(${(1 + Math.min(2, ((tech.speedAdded + player.speed) * 0.033))).toFixed(2)}x)</em>`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return m.fieldMode === 3 || m.fieldMode === 10
        },
        requires: "negative mass, grappling hook",
        effect() {
            tech.isSpeedDamage = true //max at speed = 40
        },
        remove() {
            tech.isSpeedDamage = false
        }
    },
    {
        name: "MOND",
        descriptionFunction() {
            return `your <strong class="color-speed">speed</strong> counts as <strong>+20</strong> higher<br><em>(for Newton's 1st and 2nd laws)</em>`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return tech.isSpeedDamage || tech.isSpeedHarm
        },
        requires: "Newtons 1st or 2nd law",
        effect() {
            tech.speedAdded = 20
        },
        remove() {
            tech.speedAdded = 0
        }
    },
    {
        name: "additive manufacturing",
        description: `hold <strong>crouch</strong> and use ${powerUps.orb.field()} to <strong class='color-print'>print</strong> a <strong class='color-block'>block</strong><br> with <strong>1.8x</strong> density, <strong class='color-d'>damage</strong>, and launch speed`,
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (m.fieldMode === 4 || m.fieldMode === 8) && !tech.isTokamak
        },
        requires: "molecular assembler, pilot wave, not tokamak",
        effect() {
            tech.isPrinter = true;
        },
        remove() {
            if (this.count > 0) m.holdingTarget = null;
            tech.isPrinter = false;
        }
    },
    {
        name: "working mass",
        // description: "molecular assembler <strong class='color-print'>prints</strong> one <strong class='color-block'>block</strong><br>to <strong>jump</strong> off while midair",
        descriptionFunction() {
            const fieldName = m.fieldMode === 8 ? "pilot wave" : "molecular assembler"
            return `pressing <strong>jump</strong> in <strong>midair</strong><br>will <strong class='color-print'>print</strong> a <strong class='color-block'>block</strong> to <strong>jump</strong> off`
            // return `${fieldName} <strong class='color-print'>prints</strong> a <strong class='color-block'>block</strong><br>to <strong>jump</strong> off while midair`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (m.fieldMode === 4 || m.fieldMode === 8)
        },
        requires: "molecular assembler, pilot wave",
        effect() {
            simulation.ephemera.push({
                name: "blockJump",
                blockJumpPhase: 0,
                do() {
                    if (m.onGround && m.buttonCD_jump + 10 < m.cycle && !(m.lastOnGroundCycle + m.coyoteCycles > m.cycle)) this.blockJumpPhase = 0 //reset after touching ground or block
                    if (this.blockJumpPhase === 0 && !m.onGround && !input.up && m.buttonCD_jump + 10 < m.cycle) { //not pressing jump
                        this.blockJumpPhase = 1
                    } else if (this.blockJumpPhase === 1 && input.up && m.buttonCD_jump + 10 < m.cycle) { //2nd jump
                        this.blockJumpPhase = 2
                        let horizontalVelocity = 8 * (- input.left + input.right)  //ive player and block horizontal momentum

                        const radius = 25 + Math.floor(15 * Math.random())
                        body[body.length] = Matter.Bodies.polygon(m.pos.x, m.pos.y + 60 + radius, 4, radius, {
                            friction: 0.05,
                            frictionAir: 0.001,
                            collisionFilter: {
                                category: cat.body,
                                mask: cat.player | cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet
                            },
                            classType: "body",
                        });
                        const block = body[body.length - 1]
                        //mess with the block shape (this code is horrible)
                        Composite.add(engine.world, block); //add to world
                        const r1 = radius * (1 + 0.4 * Math.random())
                        const r2 = radius * (1 + 0.4 * Math.random())
                        let angle = Math.PI / 4
                        const vertices = []
                        for (let i = 0, len = block.vertices.length; i < len; i++) {
                            angle += 2 * Math.PI / len
                            vertices.push({ x: block.position.x + r1 * Math.cos(angle), y: block.position.y + r2 * Math.sin(angle) })
                        }
                        Matter.Body.setVertices(block, vertices)
                        // Matter.Body.setAngle(block, Math.PI / 4)
                        Matter.Body.setVelocity(block, { x: 0.9 * player.velocity.x - horizontalVelocity, y: 10 });
                        Matter.Body.applyForce(block, m.pos, { x: 0, y: m.jumpForce * 0.12 * Math.min(m.standingOn.mass, 5) });
                        if (tech.isBlockRestitution) {
                            block.restitution = 0.999 //extra bouncy
                            block.friction = block.frictionStatic = block.frictionAir = 0.001
                        }
                        if (tech.isAddBlockMass) {
                            const expand = function (that, massLimit) {
                                if (that.mass < massLimit) {
                                    const scale = 1.04;
                                    Matter.Body.scale(that, scale, scale);
                                    setTimeout(expand, 20, that, massLimit);
                                }
                            };
                            expand(block, Math.min(20, block.mass * 3))
                        }
                        //jump
                        m.buttonCD_jump = m.cycle; //can't jump again until 20 cycles pass
                        Matter.Body.setVelocity(player, { x: player.velocity.x + horizontalVelocity, y: -7.5 + 0.25 * player.velocity.y });
                        player.force.y = -m.jumpForce; //player jump force
                    }
                },
            })
        },
        remove() {
            if (this.count) simulation.removeEphemera("blockJump")
        }
    },
    {
        name: "pair production",
        description: "after picking up a <strong>power up</strong><br><strong>+200</strong> <strong class='color-f'>energy</strong>",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 4 || m.fieldMode === 1 || m.fieldMode === 8
        },
        requires: "molecular assembler, pilot wave, standing wave",
        effect() {
            tech.isMassEnergy = true // used in m.grabPowerUp
            m.energy += 2 * level.isReducedRegen
        },
        remove() {
            tech.isMassEnergy = false;
        }
    },
    {
        name: "electric generator",
        description: "after <strong>deflecting</strong> mobs<br><strong>molecular assembler</strong> generates <strong>+50</strong> <strong class='color-f'>energy</strong>",
        isFieldTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 4
        },
        requires: "molecular assembler",
        effect() {
            tech.deflectEnergy += 0.5;
        },
        remove() {
            tech.deflectEnergy = 0;
        }
    },
    {
        name: "combinatorial optimization",
        description: "<strong>1.4x</strong> <strong class='color-d'>damage</strong><br><strong>0.7x</strong> <em>fire rate</em>",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 6 || m.fieldMode === 7 || m.fieldMode === 8
        },
        requires: "time dilation, cloaking, pilot wave",
        damage: 1.4,
        effect() {
            m.damageDone *= this.damage
            tech.slowFireDamage = 1.42
            b.setFireCD();
        },
        remove() {
            if (this.count && m.alive) m.damageDone /= this.damage
            tech.slowFireDamage = 1
            b.setFireCD();
        }
    },
    {
        name: "tokamak",
        description: "<strong class='color-tokamak'>tokamak</strong> converts thrown <strong class='color-block'>blocks</strong> into <strong class='color-f'>energy</strong><br>and a pulsed fusion <strong class='color-e'>explosion</strong>",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (m.fieldMode === 5 || m.fieldMode === 4 || m.fieldMode === 10) && !tech.isPrinter && !tech.isReel && !tech.hookNails
        },
        requires: "plasma torch, molecular assembler, grappling hook, not printer, reel, swarf",
        effect() {
            tech.isTokamak = true;
        },
        remove() {
            tech.isTokamak = false;
        }
    },
    {
        name: "stellarator",
        descriptionFunction() {
            return `the first <strong>5</strong> <strong class='color-block'>blocks</strong> detonated by <strong class='color-tokamak'>tokamak</strong><br>spawn ${powerUps.orb.heal(1)} proportional to <strong class='color-block'>block</strong> size`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return tech.isTokamak && (m.fieldMode === 5 || m.fieldMode === 4 || m.fieldMode === 10)
        },
        requires: "tokamak",
        effect() {
            tech.isTokamakHeal = true;
            tech.tokamakHealCount = 0
        },
        remove() {
            tech.isTokamakHeal = false;
        }
    },
    {
        name: "inertial confinement",
        description: "while holding a <strong class='color-block'>block</strong> charged with <strong class='color-tokamak'>tokamak</strong><br>you can use <strong class='color-f'>energy</strong> to <strong>fly</strong>",  //and invulnerable?
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return tech.isTokamak && (m.fieldMode === 5 || m.fieldMode === 4 || m.fieldMode === 10)
        },
        requires: "tokamak",
        effect() {
            tech.isTokamakFly = true;
        },
        remove() {
            tech.isTokamakFly = false;
        }
    },
    {
        name: "degenerate matter",
        description: `if your ${powerUps.orb.field()} is active<br><strong>0.1x</strong> <strong class='color-defense'>damage taken</strong>`,
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (m.fieldMode === 10 || m.fieldMode === 5 || m.fieldMode === 8) && !tech.isNoPilotCost
        },
        requires: "plasma torch, grappling hook, pilot wave, not Bells theorem",
        effect() {
            tech.isHarmReduce = true
        },
        remove() {
            tech.isHarmReduce = false;
        }
    },
    {
        name: "plasma-bot",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Robot' class="link">plasma-bot</a>`,
        description: `use ${powerUps.orb.research(2)}to trade your ${powerUps.orb.field()}<br>for a <strong class='color-bot'>bot</strong> that uses <strong class='color-f'>energy</strong> to emit <strong class='color-plasma'>plasma</strong>`,
        // isFieldTech: true,
        isInstant: true,
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        isBot: true,
        isBotTech: true,
        allowed() {
            return m.fieldMode === 5 && !tech.isPlasmaBall && !tech.isExtruder && (build.isExperimentSelection || powerUps.research.count > 1)
        },
        requires: "plasma torch, not extruder, plasma ball",
        effect() {
            tech.plasmaBotCount++;
            b.plasmaBot();
            if (build.isExperimentSelection) {
                document.getElementById("field-" + m.fieldMode).classList.remove("build-field-selected");
                document.getElementById("field-0").classList.add("build-field-selected");
            }
            m.setField("field emitter")
            for (let i = 0; i < 2; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
        },
        remove() {
            if (this.count > 0) {
                tech.plasmaBotCount = 0;
                b.clearPermanentBots();
                b.respawnBots();
                if (m.fieldMode === 0) {
                    m.setField("plasma torch")
                    if (build.isExperimentSelection) {
                        document.getElementById("field-0").classList.remove("build-field-selected");
                        document.getElementById("field-" + m.fieldMode).classList.add("build-field-selected");
                    }
                }
                powerUps.research.changeRerolls(2)
            }
        }
    },
    {
        name: "dielectric",
        descriptionFunction() {
            return `use ${powerUps.orb.research(2)}<em style ="float: right;">(${(1 + powerUps.boost.damage).toFixed(2)}x</strong> <strong class='color-d'>damage</strong>)</em><br>activate ${powerUps.orb.boost(1)} while <strong class='color-plasma'>plasma</strong> ${powerUps.orb.field()} is active`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return (m.fieldMode === 5) && (build.isExperimentSelection || powerUps.research.count > 1)
        },
        requires: "plasma torch",
        effect() {
            tech.isPlasmaBoost = true;
            for (let i = 0; i < 2; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
        },
        remove() {
            tech.isPlasmaBoost = false;
            if (this.count > 0) powerUps.research.changeRerolls(2)
        }
    },
    {
        name: "plasma jet",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Plasma_(physics)' class="link">plasma jet</a>`,
        descriptionFunction() {
            if (tech.isPlasmaBall) {
                return `use ${powerUps.orb.research(1)}<br><strong>1.5x</strong> <strong class='color-plasma'>plasma</strong> <strong>ball</strong> radius`
            } else {
                return `use ${powerUps.orb.research(1)}<br><strong>1.5x</strong> <strong class='color-plasma'>plasma</strong> <strong>torch</strong> range`
            }
        },
        isFieldTech: true,
        maxCount: 3,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return (tech.plasmaBotCount || m.fieldMode === 5) && (build.isExperimentSelection || powerUps.research.count > 0)
        },
        requires: "plasma torch",
        effect() {
            tech.isPlasmaRange += 0.5;
            for (let i = 0; i < 1; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
        },
        remove() {
            tech.isPlasmaRange = 1;
            if (this.count > 0) powerUps.research.changeRerolls(this.count)
        }
    },
    {
        name: "extruder",
        description: "<strong>extrude</strong> a thin hot wire of <strong class='color-plasma'>plasma</strong><br>increases <strong class='color-d'>damage</strong> and <strong class='color-f'>energy</strong> cost",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 5 && !tech.isPlasmaBall
        },
        requires: "plasma torch, not plasma ball",
        effect() {
            tech.isExtruder = true;
            m.fieldUpgrades[m.fieldMode].set()
        },
        remove() {
            tech.isExtruder = false;
            if (this.count && m.fieldMode === 5) m.fieldUpgrades[m.fieldMode].set()
        }
    },
    {
        name: "refractory metal",
        description: "<strong class='color-plasma'>extrude</strong> metals at a higher <strong class='color-plasma'>temperature</strong><br>increases effective <strong>radius</strong> and <strong class='color-d'>damage</strong>",
        isFieldTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 5 && tech.isExtruder
        },
        requires: "extruder",
        effect() {
            tech.extruderRange += 55
        },
        remove() {
            tech.extruderRange = 15
        }
    },
    {
        name: "plasma ball",
        description: "<strong>grow</strong> an expanding <strong>ball</strong> of <strong class='color-plasma'>plasma</strong><br>increases <strong>buoyancy</strong>, <strong class='color-d'>damage</strong>, and <strong class='color-f'>energy</strong> cost",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 5 && !tech.isExtruder
        },
        requires: "plasma torch, not extruder",
        effect() {
            tech.isPlasmaBall = true;
            m.fieldUpgrades[m.fieldMode].set()
        },
        remove() {
            tech.isPlasmaBall = false;
            if (this.count && m.fieldMode === 5) m.fieldUpgrades[m.fieldMode].set()
        }
    },
    {
        name: "corona discharge",
        description: "increase the <strong>range</strong> and <strong>frequency</strong><br>of <strong class='color-plasma'>plasma</strong> ball's <strong>electric arc</strong> ",
        isFieldTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 5 && tech.isPlasmaBall
        },
        requires: "plasma ball",
        effect() {
            tech.plasmaDischarge += 0.03
        },
        remove() {
            tech.plasmaDischarge = 0.01 //default chance per cycle of a discharge
        }
    },
    {
        name: "cyclotron",
        description: "<strong class='color-plasma'>plasma</strong> ball curves towards your mouse<br><strong>2x</strong> <strong class='color-plasma'>plasma</strong> ball <strong class='color-d'>damage</strong> after you <strong>release</strong> it.",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 5 && tech.isPlasmaBall
        },
        requires: "plasma ball",
        effect() {
            tech.isControlPlasma = true
        },
        remove() {
            tech.isControlPlasma = false;
        }
    },
    {
        name: "retrocausality",
        description: "<strong>time dilation</strong> uses <strong class='color-f'>energy</strong> to <strong>rewind</strong> your<br><strong class='color-h'>health</strong>, <strong>velocity</strong>, and <strong>position</strong> up to <strong>10</strong> seconds",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return m.fieldMode === 6 && !m.isShipMode && !tech.isRewindAvoidDeath && !tech.isTimeSkip
        },
        requires: "time dilation, not CPT symmetry",
        effect() {
            tech.isRewindField = true;
            m.fieldUpgrades[6].set()
            m.wakeCheck();
        },
        remove() {
            tech.isRewindField = false;
            if (this.count) m.fieldUpgrades[6].set()
        }
    },
    {
        name: "frame-dragging", //"non-inertial frame",
        description: "when not <strong>moving</strong> time dilation <strong style='letter-spacing: 2px;'>stops time</strong><br><strong>0.6x</strong> <strong class='color-defense'>damage taken</strong>",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return m.fieldMode === 6
        },
        requires: "time dilation",
        effect() {
            tech.isTimeStop = true;
            m.fieldHarmReduction = 0.66; //33% reduction
        },
        remove() {
            tech.isTimeStop = false;
            if (m.fieldMode === 6) m.fieldHarmReduction = 1;
        }
    },
    {
        name: "Lorentz transformation",
        description: `use ${powerUps.orb.research(3)}<br><strong>1.5x</strong> movement, jumping, and <em>fire rate</em>`,
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return (m.fieldMode === 6 || m.fieldMode === 8) && (build.isExperimentSelection || powerUps.research.count > 2)
        },
        requires: "time dilation or pilot wave",
        effect() {
            tech.isFastTime = true
            m.setMovement();
            b.setFireCD();
            for (let i = 0; i < 3; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
        },
        remove() {
            tech.isFastTime = false
            m.setMovement();
            b.setFireCD();
            if (this.count > 0) powerUps.research.changeRerolls(3)
        }
    },
    {
        name: "time crystals",
        descriptionFunction() {
            return `<strong>2.5x</strong> passive <strong class='color-f'>energy</strong> generation<br><em style ="float: right;">(+${(150 * m.fieldRegen * 60).toFixed(1)} energy per second)</em>`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return !tech.isGroundState && (m.fieldMode === 6 || m.fieldMode === 8)
        },
        requires: "time dilation or pilot wave, not ground state",
        effect() {
            tech.isTimeCrystals = true
            m.setFieldRegen()
            this.descriptionFunction = function () {
                return `<strong>2.5x</strong> passive <strong class='color-f'>energy</strong> generation<br><em style ="float: right;">(+${(60 * m.fieldRegen * 60).toFixed(1)} energy per second)</em>`
            }
        },
        remove() {
            tech.isTimeCrystals = false
            m.setFieldRegen()
            this.descriptionFunction = function () {
                return `<strong>2.5x</strong> passive <strong class='color-f'>energy</strong> generation<br><em style ="float: right;">(+${(150 * m.fieldRegen * 60).toFixed(1)} energy per second)</em>`
            }
        }
    },
    {
        name: "no-cloning theorem",
        description: `<strong>+40%</strong> chance to <strong class='color-dup'>duplicate</strong> spawned <strong>power ups</strong><br>after a mob <strong>dies</strong> <strong>–1%</strong> <strong class='color-dup'>duplication</strong>`,
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (m.fieldMode === 6 || m.fieldMode === 7)
        },
        requires: "cloaking, time dilation",
        effect() {
            tech.cloakDuplication = 0.4
            powerUps.setPowerUpMode(); //needed after adjusting duplication chance
            if (!build.isExperimentSelection && !simulation.isTextLogOpen) simulation.circleFlare(0.4);
        },
        remove() {
            tech.cloakDuplication = 0
            if (this.count) powerUps.setPowerUpMode(); //needed after adjusting duplication chance
        }
    },
    {
        name: "metamaterial absorber",  //quantum eraser
        descriptionFunction() {
            return `for each mob left <strong>alive</strong> after you exit a <strong>level</strong><br>there is a <strong>40%</strong> chance to spawn a random <strong>power up</strong>`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return (m.fieldMode === 7) && !tech.cloakDuplication
        },
        requires: "cloaking",
        effect() {
            tech.isQuantumEraser = true
        },
        remove() {
            tech.isQuantumEraser = false
        }
    },
    {
        name: "symbiosis",
        descriptionFunction() {
            return `after a <strong>boss</strong> <strong>dies</strong> spawn ${powerUps.orb.research(4)}${powerUps.orb.heal(3)}${powerUps.orb.tech()}<br>after a <strong>mob</strong> <strong>dies</strong> <strong>–0.25</strong> maximum ${tech.isEnergyHealth ? "<strong class='color-f'>energy</strong>" : "<strong class='color-h'>health</strong>"}`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 7 //|| m.fieldMode === 6
        },
        requires: "cloaking",
        effect() {
            tech.isAddRemoveMaxHealth = true
        },
        remove() {
            tech.isAddRemoveMaxHealth = false
        }
    },
    {
        name: "boson composite",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Boson' class="link">boson composite</a>`,
        description: "while <strong class='color-cloaked'>cloaked</strong> you are <strong>intangible</strong><br>to <strong class='color-block'>blocks</strong> and mobs, but <strong>mobs</strong> drain <strong class='color-f'>energy</strong>",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 7
        },
        requires: "metamaterial cloaking",
        effect() {
            tech.isIntangible = true;
        },
        remove() {
            if (tech.isIntangible) {
                tech.isIntangible = false;
                player.collisionFilter.mask = cat.body | cat.map | cat.mob | cat.mobBullet | cat.mobShield //normal collisions
            }
        }
    },
    {
        name: "patch",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Patch_(computing)' class="link">patch</a>`,
        description: "after <strong class='color-cloaked'>cloaking</strong> recover <strong>0.75x</strong><br>of your last <strong class='color-h'>health</strong> lost",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 7 && !tech.isEnergyHealth
        },
        requires: "metamaterial cloaking, not mass-energy",
        effect() {
            tech.isCloakHealLastHit = true;
        },
        remove() {
            tech.isCloakHealLastHit = false;
        }
    },
    {
        name: "dazzler",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Dazzler_(weapon)' class="link">dazzler</a>`,
        description: "after <strong class='color-cloaked'>decloaking</strong><br><strong>stun</strong> nearby mobs for 2 seconds",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 7
        },
        requires: "metamaterial cloaking",
        effect() {
            tech.isCloakStun = true;
        },
        remove() {
            tech.isCloakStun = false;
        }
    },
    {
        name: "topological defect",
        description: "<strong>2.1x</strong> <strong class='color-d'>damage</strong><br>to <strong>mobs</strong> at maximum <strong>durability</strong>",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return (m.fieldMode === 8 || m.fieldMode === 7) && tech.mobSpawnWithHealth === 0
        },
        requires: "cloaking, pilot wave, not reaction inhibitor",
        effect() {
            tech.isMobFullHealthCloak = true
        },
        remove() {
            tech.isMobFullHealthCloak = false
        }
    },
    {
        name: "hidden-variable theory",
        description: `<strong>1.3x</strong> <strong class='color-d'>damage</strong> after you <strong class='color-choice'><span>ch</span><span>oo</span><span>se</span></strong> ${powerUps.orb.fieldTech()}`,
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 4,
        frequencyDefault: 4,
        allowed() {
            return m.fieldMode === 8
        },
        requires: "pilot wave",
        effect() {
            tech.isDamageFieldTech = true
        },
        remove() {
            tech.isDamageFieldTech = false
        }
    },
    {
        name: "Bells theorem",
        description: `<strong>pilot wave</strong> is always <strong>on</strong><br>and has no <strong class='color-f'>energy</strong> cost`,
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 4,
        frequencyDefault: 4,
        allowed() {
            return m.fieldMode === 8 && !tech.isHarmReduce
        },
        requires: "pilot wave, not degenerate matter",
        effect() {
            tech.isNoPilotCost = true
            m.fieldUpgrades[8].drain = 0
            if (m.fieldMode === 8) m.fieldFire = true;

        },
        remove() {
            tech.isNoPilotCost = false
            m.fieldUpgrades[8].drain = 1
            if (m.fieldMode === 8) m.fieldFire = false
        }
    },
    {
        name: "principle of locality",
        description: `<strong>0.1x</strong> <strong class='color-defense'>damage taken</strong> while inside <strong>pilot wave</strong><br><div class="circle-grid tech"></div>, <div class="circle-grid gun"></div>, and <div class="circle-grid field"></div> have <strong>-2</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong>`,
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 4,
        frequencyDefault: 4,
        allowed() {
            return m.fieldMode === 8
        },
        requires: "pilot wave",
        effect() {
            tech.isInPilot = true
        },
        remove() {
            tech.isInPilot = false
        }
    },
    {
        name: "WIMPs",
        description: `at the exit to each <strong>level</strong> spawn ${powerUps.orb.research(7)}<br>and a dangerous particle that slowly <strong>chases</strong> you`,
        isFieldTech: true,
        maxCount: 9,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 9 || m.fieldMode === 8
        },
        requires: "wormhole, pilot wave",
        effect() {
            tech.wimpCount++
            spawn.WIMP()
            for (let j = 0, len = 7; j < len; j++) powerUps.spawn(level.exit.x + 100 * (Math.random() - 0.5), level.exit.y - 100 + 100 * (Math.random() - 0.5), "research", false)
        },
        remove() {
            tech.wimpCount = 0
        }
    },
    {
        name: "vacuum fluctuation",
        description: `use ${powerUps.orb.research(2)}<br><strong>+11%</strong> chance to <strong class='color-dup'>duplicate</strong> spawned <strong>power ups</strong>`,
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 3,
        frequencyDefault: 3,
        allowed() {
            return (m.fieldMode === 8 || m.fieldMode === 9) && (build.isExperimentSelection || powerUps.research.count > 2)
        },
        requires: "wormhole, pilot wave",
        effect() {
            tech.fieldDuplicate = 0.11
            powerUps.setPowerUpMode(); //needed after adjusting duplication chance
            if (!build.isExperimentSelection && !simulation.isTextLogOpen) simulation.circleFlare(0.11);
            for (let i = 0; i < 2; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
        },
        remove() {
            tech.fieldDuplicate = 0
            if (this.count) {
                powerUps.setPowerUpMode(); //needed after adjusting duplication chance
                powerUps.research.changeRerolls(2)
            }
        }
    },
    {
        name: "anyon",
        descriptionFunction() {
            return `<strong>+2%</strong> <strong class='color-dup'>duplication</strong> chance until you exit the <strong>level</strong><br>after a <strong class='color-block'>block</strong> falls into a <strong class='color-worm'>wormhole</strong> <em style ="float: right;">(up to 40%)</em>`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 9
        },
        requires: "wormhole",
        effect() {
            tech.isBlockDup = true
            tech.blockDupCount = 0
        },
        remove() {
            tech.isBlockDup = false
            tech.blockDupCount = 0
        }
    },
    {
        name: "transdimensional worms",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Dimension' class="link">transdimensional worms</a>`,
        description: "after a <strong class='color-block'>block</strong> falls into a <strong class='color-worm'>wormhole</strong><br>spawn <strong>1-4</strong> <strong class='color-p' style='letter-spacing: 2px;'>worms</strong>",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 9
        },
        requires: "wormhole",
        effect() {
            tech.isWormholeWorms = true
        },
        remove() {
            tech.isWormholeWorms = false
        }
    },
    {
        name: "Penrose process",
        descriptionFunction() {
            return `<strong>2x</strong> stored <strong class='color-f'>energy</strong> after <strong class='color-dup'>duplicating</strong> power ups<br><strong>+6%</strong> chance to <strong class='color-dup'>duplicate</strong> spawned <strong>power ups</strong>`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return m.fieldMode === 9 || m.fieldMode === 1
        },
        requires: "wormhole, standing wave",
        effect() {
            tech.isDupEnergy = true;
            powerUps.setPowerUpMode(); //needed after adjusting duplication chance
            if (!build.isExperimentSelection && !simulation.isTextLogOpen) simulation.circleFlare(0.06);
        },
        remove() {
            tech.isDupEnergy = false;
            if (this.count) powerUps.setPowerUpMode(); //needed after adjusting duplication chance        }
        }
    },
    {
        name: "holographic principle",
        cost: 2,
        descriptionFunction() {
            return `making <strong class='color-worm'>wormholes</strong> costs <strong>2</strong> <strong class='color-f'>energy</strong><br><em style ="float: right;">(originally 16 energy)</em>`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 9 && (build.isExperimentSelection || powerUps.research.count > this.cost - 1)
        },
        requires: "wormhole",
        effect() {
            for (let i = 0; i < this.cost; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
            tech.isFreeWormHole = true
        },
        remove() {
            tech.isFreeWormHole = false
            if (this.count) powerUps.research.changeRerolls(this.cost)
        }
    },
    {
        name: "manifold",
        descriptionFunction() {
            return `after each new <strong class='color-worm'>wormhole</strong><br><strong>1.5x</strong> <strong class='color-d'>damage</strong> for <strong>5</strong> seconds`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 9
        },
        requires: "wormhole",
        effect() {
            tech.isNewWormHoleDamage = true
        },
        remove() {
            tech.isNewWormHoleDamage = false
        }
    },
    {
        name: "geodesics",
        description: `your <strong>bullets</strong> can traverse <strong class='color-worm'>wormholes</strong><br><strong>1.5x</strong> <strong class='color-d'>damage</strong>`,
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 9
        },
        requires: "wormhole",
        damage: 1.5,
        effect() {
            m.damageDone *= this.damage
            tech.isWormHoleBullets = true
            // for (let i = 0; i < 2; i++) powerUps.spawn(m.pos.x + 200 * (Math.random() - 0.5), m.pos.y + 200 * (Math.random() - 0.5), "gun");
            // for (let i = 0; i < 4; i++) powerUps.spawn(m.pos.x + 200 * (Math.random() - 0.5), m.pos.y + 200 * (Math.random() - 0.5), "ammo");
        },
        remove() {
            // if (tech.isWormHoleBullets) {
            //     for (let i = 0; i < 2; i++) {
            //         if (b.inventory.length) b.removeGun(b.guns[b.inventory[b.inventory.length - 1]].name) //remove your last gun
            //     }
            // }
            if (this.count && m.alive) m.damageDone /= this.damage
            tech.isWormHoleBullets = false;
        }
    },
    {
        name: "cosmic string",
        description: "after <strong>tunneling</strong> through mobs with a <strong class='color-worm'>wormhole</strong><br><strong>stun</strong> them and do <strong class='color-p'>radioactive</strong> <strong class='color-d'>damage</strong>",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 9
        },
        requires: "wormhole",
        effect() {
            tech.isWormholeDamage = true
        },
        remove() {
            tech.isWormholeDamage = false
        }
    },
    {
        name: "invariant",
        cost: 1,
        descriptionFunction() {
            return `use ${powerUps.orb.research(this.cost)}<br><strong>pause</strong> time while placing your <strong class='color-worm'>wormhole</strong>`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 9 && !tech.isNoDraftPause && (build.isExperimentSelection || powerUps.research.count > this.cost - 1)
        },
        requires: "wormhole, not eternalism",
        effect() {
            tech.isWormHolePause = true
            for (let i = 0; i < this.cost; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
        },
        remove() {
            if (tech.isWormHolePause && m.isTimeDilated) m.wakeCheck();
            tech.isWormHolePause = false
            if (this.count) {
                powerUps.research.changeRerolls(this.cost)
            }
        }
    },
    {
        name: "affine connection",
        cost: 2,
        descriptionFunction() {
            return `use ${powerUps.orb.research(this.cost)}<br><strong class='color-worm'>wormholes</strong> can tunnel through <strong>anything</strong>`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 9 && (build.isExperimentSelection || powerUps.research.count > this.cost - 1)
        },
        requires: "wormhole",
        effect() {
            for (let i = 0; i < this.cost; i++) {
                if (powerUps.research.count > 0) powerUps.research.changeRerolls(-1)
            }
            tech.isWormholeMapIgnore = true
        },
        remove() {
            tech.isWormholeMapIgnore = false
            if (this.count) powerUps.research.changeRerolls(this.cost)
        }
    },
    {
        name: "CIWS",
        descriptionFunction() {
            return `<strong>grappling hook</strong> uses <strong>10</strong> <strong class='color-f'>energy</strong><br> to fire ${b.guns[9].harpoonName()}<strong>s</strong> at nearby mobs`
        },
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 10
        },
        requires: "grappling hook",
        effect() {
            tech.isHookDefense = true
        },
        remove() {
            tech.isHookDefense = false
        }
    },
    {
        name: "swarf",
        // description: "after <strong>grappling hook</strong> impacts solid objects generate an <strong class='color-e'>explosion</strong> and become briefly <strong>invulnerable</strong>",
        description: "after <strong>grappling hook</strong> impacts something<br>eject <strong>nails</strong> splinters towards nearby mobs",
        isFieldTech: true,
        maxCount: 3,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        allowed() {
            return m.fieldMode === 10 && !tech.isReel && !tech.isTokamak
        },
        requires: "grappling hook, not reel, tokamak",
        effect() {
            tech.hookNails += 4
        },
        remove() {
            tech.hookNails = 0
        }
    },
    {
        name: "reel",
        description: "<strong>5x</strong> <strong class='color-block'>block</strong> collision <strong class='color-d'>damage</strong><br>up to <strong>+100</strong> <strong class='color-f'>energy</strong> after reeling in <strong class='color-block'>blocks</strong>",
        isFieldTech: true,
        maxCount: 1,
        count: 0,
        frequency: 1,
        frequencyDefault: 1,
        allowed() {
            return m.fieldMode === 10 && !tech.isTokamak && tech.blockDamage === 0.075 && !tech.hookNails
        },
        requires: "grappling hook, not mass driver, swarf, tokamak",
        effect() {
            tech.blockDamage = 0.375
            tech.isReel = true
        },
        remove() {
            tech.blockDamage = 0.075
            tech.isReel = false
        }
    },

    //************************************************** 
    //************************************************** JUNK
    //************************************************** tech
    //************************************************** 
    // {
    //     name: "junk",
    //     description: "",
    //     maxCount: 9,
    //     count: 0,
    //     frequency: 0,
    //     isInstant: true,
    //     isJunk: true,
    //     allowed() {
    //         return true
    //     },
    //     requires: "",
    //     effect() {

    //     },
    //     remove() {}
    // },
    {
        name: "swap meet",
        description: `normal ${powerUps.orb.tech()} become <strong class='color-junk'>JUNK</strong><br>and <strong class='color-junk'>JUNK</strong> become normal`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        isInstant: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            for (let i = 0, len = tech.tech.length; i < len; i++) {
                tech.tech[i].isJunk = !tech.tech[i].isJunk
                if (tech.tech[i].isJunk) { } else { }

                if (tech.tech[i].frequency > 0) {
                    tech.tech[i].frequency = 0
                } else {
                    tech.tech[i].frequency = 2
                }
            }
        },
        remove() { }
    },
    // {
    //     name: "pocket dimension",
    //     description: "rotate tech descriptions into a higher spacial dimension",
    //     maxCount: 1,
    //     count: 0,
    //     frequency: 0,
    //     isJunk: true,
    //     isInstant: true,
    //     allowed() {
    //         return true
    //     },
    //     requires: "",
    //     effect() {
    // document.getElementById("choose-grid").classList.add("flipX");
    //     },
    //     remove() {}
    // },
    {
        name: "random",
        link: `<a target="_blank" href='https://en.wikipedia.org/wiki/Special:Random' class="link">random</a>`,
        delay: 333,
        descriptionFunction() {
            const delay = 333
            const loop = () => {
                if ((simulation.isChoosing) && m.alive && !build.isExperimentSelection) {
                    const dmg = Math.floor(27 * Math.random()) * 0.01
                    this.text = `<strong style = "font-family: 'Courier New', monospace;">+${(1 + dmg).toFixed(2).padStart(2, '0')}x</strong> <strong class='color-d'>damage</strong>`
                    this.damage = 1 + dmg
                    if (document.getElementById(`damage-JUNK-id${this.id}`)) document.getElementById(`damage-JUNK-id${this.id}`).innerHTML = this.text
                    setTimeout(() => {
                        loop()
                    }, delay);
                }
            }
            setTimeout(() => {
                loop()
            }, delay);
            this.id++
            return `<span id = "damage-JUNK-id${this.id}">${this.text}</span>`
        },
        maxCount: 3,
        count: 0,
        frequency: 1,
        isJunk: true,
        allowed() {
            return !build.isExperimentSelection
        },
        requires: "NOT EXPERIMENT MODE",
        damage: 0,
        effect() {
            m.damageDone *= this.damage
        },
        remove() {
            if (this.count && m.alive) m.damageDone /= this.damage
        }
    },
    {
        name: "boost",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        isInstant: true,
        allowed() {
            return !build.isExperimentSelection
        },
        requires: "NOT EXPERIMENT MODE",
        effect() {
            powerUps.spawnDelay("boost", this.spawnCount)
        },
        remove() { },
        id: 0,
        text: "",
        delay: 100,
        spawnCount: 0,
        descriptionFunction() {
            let count = 9999 * Math.random()
            const loop = () => {
                if ((simulation.isChoosing) && m.alive && !build.isExperimentSelection) { //&& (!simulation.isChoosing || this.count === 0) //simulation.paused ||
                    count += 4.5
                    const waves = 2 * Math.sin(count * 0.0133) + Math.sin(count * 0.013) + 0.5 * Math.sin(count * 0.031) + 0.33 * Math.sin(count * 0.03)
                    this.spawnCount = Math.floor(100 * Math.abs(waves))
                    this.text = `spawn <strong style = "font-family: 'Courier New', monospace;">${this.spawnCount.toLocaleString(undefined, { minimumIntegerDigits: 3 })}</strong> ${powerUps.orb.boost(1)}<br>that give <strong>${(1 + powerUps.boost.damage).toFixed(2)}x</strong> <strong class='color-d'>damage</strong> for <strong>${(powerUps.boost.duration / 60).toFixed(0)}</strong> seconds</span>`
                    if (document.getElementById(`boost-JUNK-id${this.id}`)) document.getElementById(`boost-JUNK-id${this.id}`).innerHTML = this.text
                    setTimeout(() => {
                        loop()
                    }, this.delay);
                }
            }
            setTimeout(() => {
                loop()
            }, this.delay);
            this.id++
            return `<span id = "boost-JUNK-id${this.id}">${this.text}</span>`
        },
    },
    {
        name: "placebo",
        description: "<strong>7.77x</strong> <strong class='color-d'>damage</strong>",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed: () => true,
        requires: "",
        effect() {
            if (Math.random() < 0.07) m.damageDone *= 7.77
        },
        remove() { }
    },
    {
        name: "universal healthcare",
        description: "make your <strong class='color-d'>damage</strong> negative",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed: () => true,
        requires: "",
        effect() {
            m.damageDone *= -1
        },
        remove() { }
    },
    {
        name: "defunct",
        description: "build <strong>100</strong> scrap <strong class='color-bot'>bots</strong><br><strong class='color-bot'>bots</strong> break after about <strong>30</strong> seconds",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed: () => true,
        requires: "",
        effect() {
            for (let i = 0; i < 100; i++) {
                b.randomBot(m.pos, false)
                bullet[bullet.length - 1].endCycle = simulation.cycle + 800 + 1000 * Math.random() //15 seconds
            }
        },
        remove() { }
    },
    // {
    //     name: "synchrotron",
    //     descriptionFunction() {
    //         return `<strong>power ups</strong> change into a different <strong>flavor</strong> after a boss dies`
    //     },
    //     maxCount: 3,
    //     count: 0,
    //     frequency: 1,
    //     frequencyDefault: 1,
    //     allowed: () => true,
    //     requires: "",
    //     effect() {
    //     },
    //     remove() {
    //     }
    // },
    {
        name: "return",
        description: "return to the start of the game",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        isInstant: true,
        allowed: () => true,
        requires: "",
        effect() {
            level.onLevel = 0
            simulation.clearNow = true //end current level
        },
        remove() { }
    },
    {
        name: "panpsychism",
        description: "awaken all <strong class='color-block'>blocks</strong><br><strong class='color-block'>blocks</strong> have a chance to spawn power ups",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        isInstant: true,
        allowed: () => true,
        requires: "",
        effect() {
            setInterval(() => {
                for (let i = body.length - 1; i > -1; i--) {
                    if (!body[i].isNotHoldable) {
                        Matter.Composite.remove(engine.world, body[i]);
                        spawn.blockMob(body[i].position.x, body[i].position.y, body[i], 0);
                        if (!body[i].isAboutToBeRemoved) mob[mob.length - 1].isDropPowerUp = true
                        body.splice(i, 1);
                    }
                }
            }, 6000);
        },
        remove() { }
    },
    {
        name: "meteor shower",
        description: "take a shower, but meteors instead of water",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        isInstant: true,
        allowed: () => true,
        requires: "",
        effect() {
            setInterval(() => {

                fireBlock = function (xPos, yPos) {
                    const index = body.length
                    spawn.bodyRect(xPos, yPos, 20 + 50 * Math.random(), 20 + 50 * Math.random());
                    const bodyBullet = body[index]
                    Matter.Body.setVelocity(bodyBullet, {
                        x: 5 * (Math.random() - 0.5),
                        y: 10 * (Math.random() - 0.5)
                    });
                    bodyBullet.isAboutToBeRemoved = true
                    setTimeout(() => { //remove block
                        for (let i = 0; i < body.length; i++) {
                            if (body[i] === bodyBullet) {
                                Matter.Composite.remove(engine.world, body[i]);
                                body.splice(i, 1);
                            }
                        }
                    }, 4000 + Math.floor(9000 * Math.random()));
                }
                fireBlock(player.position.x + 600 * (Math.random() - 0.5), player.position.y - 500 - 500 * Math.random());
                // for (let i = 0, len =  Math.random(); i < len; i++) {
                // }

            }, 1000);
        },
        remove() { }
    },
    {
        name: "reinforcement learning",
        description: `<strong>10x</strong> <em class='flicker'>frequency</em> for current ${powerUps.orb.tech()}`,
        maxCount: 1,
        count: 0,
        frequency: 1,
        isJunk: true,
        allowed() {
            return tech.totalCount > 9
        },
        requires: "at least 10 tech",
        effect() {
            for (let i = 0, len = tech.tech.length; i < len; i++) {
                if (tech.tech[i].count > 0) tech.tech[i].frequency *= 10
            }
        },
        remove() {
            if (this.count) {
                for (let i = 0, len = tech.tech.length; i < len; i++) {
                    if (tech.tech[i].count > 0 && tech.tech[i].frequency > 1) tech.tech[i].frequency /= 10
                }
            }
        }
    },
    {
        name: "startle response",
        description: `if a threat is nearby, activate a ${powerUps.orb.boost(1)}<br>and lock your mouse until you press escape`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        isInstant: true,
        allowed: () => true,
        requires: "",
        effect() {
            setInterval(() => {
                if (powerUps.boost.endCycle < simulation.cycle && !simulation.paused && m.alive) {
                    for (let i = 0; i < mob.length; i++) {
                        if (mob[i].distanceToPlayer2() < 400000) { //650
                            canvas.requestPointerLock();
                            powerUps.boost.effect();
                            break
                        }
                    }
                }
            }, 2000);
        },
        remove() { }
    },
    {
        name: "closed timelike curve",
        description: `spawn ${powerUps.orb.field()}${powerUps.orb.field()}${powerUps.orb.field()}${powerUps.orb.field()}${powerUps.orb.field()}, but every 12 seconds<br>teleport a second into your future or past`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        isInstant: true,
        allowed: () => true,
        requires: "",
        effect() {
            for (let i = 0; i < 5; i++) powerUps.spawn(m.pos.x + 10 * Math.random(), m.pos.y + 10 * Math.random(), "field");

            function loop() {
                if (!simulation.paused && m.alive) {
                    if (!(simulation.cycle % 720)) {
                        requestAnimationFrame(() => {
                            if ((simulation.cycle % 1440) > 720) { //kinda alternate between each option
                                m.rewind(60)
                                m.energy += 0.4 * level.isReducedRegen//to make up for lost energy
                            } else {
                                simulation.timePlayerSkip(60)
                            }
                        }); //wrapping in animation frame prevents errors, probably
                    }
                }
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        },
        remove() { }
    },
    // {
    //     name: "translate",
    //     description: "translate n-gon into a random language",
    //     maxCount: 1,
    //     count: 0,
    //     frequency: 0,
    //     isJunk: true,
    //     isInstant: true,
    //     allowed() {
    //         return true
    //     },
    //     requires: "",
    //     effect() {
    //         // generate a container 
    //         const gtElem = document.createElement('div')
    //         gtElem.id = "gtElem"
    //         gtElem.style.visibility = 'hidden' // make it invisible
    //         document.body.append(gtElem)

    //         // generate a script to run after creation
    //         function initGT() {
    //             // create a new translate element
    //             new google.translate.TranslateElement({ pageLanguage: 'en', layout: google.translate.TranslateElement.InlineLayout.HORIZONTAL }, 'gtElem')
    //             // ok now since it's loaded perform a funny hack to make it work
    //             const langSelect = document.getElementsByClassName("goog-te-combo")[0]
    //             // select a random language. It takes a second for all langauges to load, so wait a second.
    //             setTimeout(() => {
    //                 langSelect.selectedIndex = Math.round(langSelect.options.length * Math.random())
    //                 // simulate a click
    //                 langSelect.dispatchEvent(new Event('change'))
    //                 // now make it go away
    //                 const bar = document.getElementById(':1.container')
    //                 bar.style.display = 'none'
    //                 bar.style.visibility = 'hidden'
    //             }, 1000)

    //         }

    //         // add the google translate script
    //         const translateScript = document.createElement('script')
    //         translateScript.src = '//translate.google.com/translate_a/element.js?cb=initGT'
    //         document.body.append(translateScript)
    //     },
    //     remove() {}
    // },
    {
        name: "discount",
        description: `get 3 random <strong class='color-junk'>JUNK</strong>${powerUps.orb.tech()} for the price of 1!`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        isInstant: true,
        allowed: () => true,
        requires: "",
        effect() {
            for (let i = 0; i < 3; i++) {
                const list = []
                for (let i = 0; i < tech.tech.length; i++) {
                    if (tech.tech[i].isJunk) list.push(tech.tech[i].name)
                }
                let name = list[Math.floor(Math.random() * list.length)]
                simulation.inGameConsole(`<span class='color-var'>tech</span>.giveTech("<span class='color-text'>${name}</span>")`);
                tech.giveTech(name)
            }
        },
        remove() { }
    },
    // {
    //     name: "hi",
    //     description: `spawn to seed <strong>616</strong> `,
    //     maxCount: 1,
    //     count: 0,
    //     frequency: 0,
    //     isInstant: true,
    //     isJunk: true,
    //     allowed() {
    //         return true
    //     },
    //     requires: "",
    //     effect() {
    //         document.getElementById("seed").placeholder = Math.initialSeed = String(616)
    //         Math.seed = Math.abs(Math.hash(Math.initialSeed)) //update randomizer seed in case the player changed it
    //     },
    //     remove() {}
    // },
    {
        name: "Higgs phase transition",
        description: `instantly spawn ${powerUps.orb.tech()}${powerUps.orb.tech()}${powerUps.orb.tech()}${powerUps.orb.tech()}${powerUps.orb.tech()}, but add a chance to<br>remove everything with a 5 minute <strong>half-life</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        frequencyDefault: 0,
        isJunk: true,
        isInstant: true,
        allowed: () => true,
        requires: "",
        effect() {
            powerUps.spawn(m.pos.x, m.pos.y, "tech");
            powerUps.spawn(m.pos.x + 30, m.pos.y, "tech");
            powerUps.spawn(m.pos.x + 60, m.pos.y, "tech");
            powerUps.spawn(m.pos.x, m.pos.y - 30, "tech");
            powerUps.spawn(m.pos.x + 30, m.pos.y - 60, "tech");

            function loop() {
                // (1-X)^cycles = chance to be removed //Math.random() < 0.000019  10 min
                if (!simulation.paused && m.alive) {
                    if (Math.random() < 0.000038) {
                        simulation.clearMap();
                        simulation.draw.setPaths();
                        return
                    }
                }
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        },
        remove() { }
    },
    {
        name: "harvest",
        description: "convert all the mobs on this level into <strong class='color-ammo'>ammo</strong>",
        maxCount: 1,
        count: 0,
        frequency: 0,
        frequencyDefault: 0,
        isJunk: true,
        isInstant: true,
        allowed: () => true,
        requires: "",
        effect() {
            for (let i = 0, len = mob.length; i < len; i++) {
                if (mob[i].isDropPowerUp) {
                    powerUps.spawn(mob[i].position.x, mob[i].position.y, "ammo");
                    mob[i].death();
                }
            }
        },
        remove() { }
    },
    {
        name: "brainstorm",
        description: `${powerUps.orb.tech()} <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong> <strong>randomize</strong><br>every <strong>0.5</strong> seconds for <strong>10</strong> seconds`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        frequencyDefault: 0,
        isJunk: true,
        allowed: () => true,
        requires: "",
        effect() {
            tech.isBrainstorm = true
            tech.isBrainstormActive = false
            tech.brainStormDelay = 500 //show each option for 0.5 seconds
        },
        remove() {
            tech.isBrainstorm = false
            tech.isBrainstormActive = false
        }
    },
    {
        name: "catabolysis",
        description: `set your maximum <strong class='color-h'>health</strong> to <strong>1</strong><br><strong>double</strong> your current <strong class='color-ammo'>ammo</strong> <strong>10</strong> times`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return !tech.isFallingDamage && !tech.isOverHeal && !tech.isEnergyHealth
        },
        requires: "not quenching, tungsten carbide, mass-energy",
        effect() {
            m.baseHealth = 0.01
            m.setMaxHealth();
            for (let i = 0; i < b.guns.length; i++) b.guns[i].ammo = b.guns[i].ammo * Math.pow(2, 10)
            simulation.updateGunHUD();
        },
        remove() { }
    },
    {
        name: "palantír",
        description: `see far away lands`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        // isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            m.look = () => {
                //always on mouse look
                m.angle = Math.atan2(
                    simulation.mouseInGame.y - m.pos.y,
                    simulation.mouseInGame.x - m.pos.x
                );
                //smoothed mouse look translations
                const scale = 2;
                m.transSmoothX = canvas.width2 - m.pos.x - (simulation.mouse.x - canvas.width2) * scale;
                m.transSmoothY = canvas.height2 - m.pos.y - (simulation.mouse.y - canvas.height2) * scale;
                m.transX += (m.transSmoothX - m.transX) * m.lookSmoothing;
                m.transY += (m.transSmoothY - m.transY) * m.lookSmoothing;
            }
        },
        remove() {
            if (this.count) m.look = m.lookDefault
        }
    },
    {
        name: "motion sickness",
        description: `disable camera smoothing`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        // isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            m.look = () => {
                //always on mouse look
                m.angle = Math.atan2(
                    simulation.mouseInGame.y - m.pos.y,
                    simulation.mouseInGame.x - m.pos.x
                );
                //smoothed mouse look translations
                const scale = 1.2;
                m.transSmoothX = canvas.width2 - m.pos.x - (simulation.mouse.x - canvas.width2) * scale;
                m.transSmoothY = canvas.height2 - m.pos.y - (simulation.mouse.y - canvas.height2) * scale;
                m.transX = canvas.width2 - m.pos.x - (simulation.mouse.x - canvas.width2) * scale;
                m.transY = canvas.height2 - m.pos.y - (simulation.mouse.y - canvas.height2) * scale;
                // m.transX += (m.transSmoothX - m.transX) * m.lookSmoothing;
                // m.transY += (m.transSmoothY - m.transY) * m.lookSmoothing;
            }
        },
        remove() {
            if (this.count) m.look = m.lookDefault
        }
    },
    // {
    //     name: "facsimile",
    //     description: `inserts a copy of your current level into the level list`,
    //     maxCount: 1,
    //     count: 0,
    //     frequency: 0,
    //     isInstant: true,
    //     isJunk: true,
    //     allowed() {
    //         return true
    //     },
    //     requires: "",
    //     effect() {
    //         const index = Math.min(level.levels.length - 1, level.onLevel)
    //         level.levels.splice(index, 0, level.levels[index]);
    //     },
    //     remove() { }
    // },
    {
        name: "negative friction",
        description: "when you touch walls you speed up instead of slowing down. It's kinda fun.",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            player.friction = -0.4
        },
        remove() {
            if (this.count) player.friction = 0.002
        }
    },
    {
        name: "bounce",
        description: "you bounce off things.  It's annoying, but not that bad.",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            player.restitution = 0.9
        },
        remove() {
            if (this.count) player.restitution = 0
        }
    },
    {
        name: "mouth",
        description: "mobs have a non functional mouth",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            mobs.draw = () => {
                ctx.lineWidth = 2;
                let i = mob.length;
                while (i--) {
                    ctx.beginPath();
                    const vertices = mob[i].vertices;
                    ctx.moveTo(vertices[0].x, vertices[0].y);
                    for (let j = 1, len = vertices.length; j < len; ++j) ctx.lineTo(vertices[j].x, vertices[j].y);
                    ctx.quadraticCurveTo(mob[i].position.x, mob[i].position.y, vertices[0].x, vertices[0].y);
                    ctx.fillStyle = mob[i].fill;
                    ctx.strokeStyle = mob[i].stroke;
                    ctx.fill();
                    ctx.stroke();
                }
            }
        },
        remove() {
            mobs.draw = mobs.drawDefault
        }
    },
    {
        name: "all-stars",
        description: "make all mobs look like stars",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            mobs.draw = () => {
                ctx.lineWidth = 2;
                let i = mob.length;
                while (i--) {
                    ctx.beginPath();
                    const vertices = mob[i].vertices;
                    ctx.moveTo(vertices[0].x, vertices[0].y);
                    for (let j = 1, len = vertices.length; j < len; ++j) ctx.quadraticCurveTo(mob[i].position.x, mob[i].position.y, vertices[j].x, vertices[j].y);
                    ctx.quadraticCurveTo(mob[i].position.x, mob[i].position.y, vertices[0].x, vertices[0].y);
                    ctx.fillStyle = mob[i].fill;
                    ctx.strokeStyle = mob[i].stroke;
                    ctx.fill();
                    ctx.stroke();
                }
            }
        },
        remove() {
            mobs.draw = mobs.drawDefault
        }
    },
    // draw() {
    //     ctx.lineWidth = 2;
    //     let i = mob.length;
    //     while (i--) {
    //         ctx.beginPath();
    //         const vertices = mob[i].vertices;
    //         ctx.moveTo(vertices[0].x, vertices[0].y);
    //         for (let j = 1, len = vertices.length; j < len; ++j) ctx.lineTo(vertices[j].x, vertices[j].y);
    //         ctx.lineTo(vertices[0].x, vertices[0].y);
    //         ctx.fillStyle = mob[i].fill;
    //         ctx.strokeStyle = mob[i].stroke;
    //         ctx.fill();
    //         ctx.stroke();
    //     }
    // },
    {
        name: "true colors",
        description: `set all power ups to their real world colors`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        isInstant: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            const colors = [powerUps.research.color, powerUps.heal.color, powerUps.ammo.color, powerUps.ammo.color, powerUps.field.color, powerUps.gun.color]
            colors.sort(() => Math.random() - 0.5);
            powerUps.research.color = colors[0]
            powerUps.heal.color = colors[1]
            powerUps.ammo.color = colors[2]
            powerUps.field.color = colors[3]
            powerUps.tech.color = colors[4]
            powerUps.gun.color = colors[5]
            for (let i = 0; i < powerUp.length; i++) {
                switch (powerUp[i].name) {
                    case "research":
                        powerUp[i].color = colors[0]
                        break;
                    case "heal":
                        powerUp[i].color = colors[1]
                        break;
                    case "ammo":
                        powerUp[i].color = colors[2]
                        break;
                    case "field":
                        powerUp[i].color = colors[3]
                        break;
                    case "tech":
                        powerUp[i].color = colors[4]
                        break;
                    case "gun":
                        powerUp[i].color = colors[5]
                        break;
                }
            }
        },
        remove() { }
    },
    {
        name: "emergency broadcasting",
        description: "emit 2 sine waveforms at 853 Hz and 960 Hz<br><em>lower your volume</em>",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        isInstant: true,
        allowed() {
            return true
        },
        requires: "",
        effect: () => {
            //setup audio context
            function tone(frequency) {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator1 = audioCtx.createOscillator();
                const gainNode1 = audioCtx.createGain();
                gainNode1.gain.value = 0.5; //controls volume
                oscillator1.connect(gainNode1);
                gainNode1.connect(audioCtx.destination);
                oscillator1.type = "sine"; // 'sine' 'square', 'sawtooth', 'triangle' and 'custom'
                oscillator1.frequency.value = frequency; // value in hertz
                oscillator1.start();
                return audioCtx
            }
            // let sound = tone(1050)

            function EBS() {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

                const oscillator1 = audioCtx.createOscillator();
                const gainNode1 = audioCtx.createGain();
                gainNode1.gain.value = 0.3; //controls volume
                oscillator1.connect(gainNode1);
                gainNode1.connect(audioCtx.destination);
                oscillator1.type = "sine"; // 'sine' 'square', 'sawtooth', 'triangle' and 'custom'
                oscillator1.frequency.value = 850; // value in hertz
                oscillator1.start();

                const oscillator2 = audioCtx.createOscillator();
                const gainNode2 = audioCtx.createGain();
                gainNode2.gain.value = 0.3; //controls volume
                oscillator2.connect(gainNode2);
                gainNode2.connect(audioCtx.destination);
                oscillator2.type = "sine"; // 'sine' 'square', 'sawtooth', 'triangle' and 'custom'
                oscillator2.frequency.value = 957; // value in hertz
                oscillator2.start();
                return audioCtx
            }
            let sound = EBS()

            delay = 1000
            setTimeout(() => {
                sound.suspend()
                powerUps.spawn(m.pos.x + 160 * (Math.random() - 0.5), m.pos.y + 160 * (Math.random() - 0.5), "heal");
                setTimeout(() => {
                    sound.resume()
                    setTimeout(() => {
                        sound.suspend()
                        powerUps.spawn(m.pos.x + 160 * (Math.random() - 0.5), m.pos.y + 160 * (Math.random() - 0.5), "heal");
                        setTimeout(() => {
                            sound.resume()
                            setTimeout(() => {
                                sound.suspend()
                                powerUps.spawn(m.pos.x + 160 * (Math.random() - 0.5), m.pos.y + 160 * (Math.random() - 0.5), "heal");
                                setTimeout(() => {
                                    sound.resume()
                                    setTimeout(() => {
                                        sound.suspend()
                                        powerUps.spawn(m.pos.x + 160 * (Math.random() - 0.5), m.pos.y + 160 * (Math.random() - 0.5), "heal");
                                        setTimeout(() => {
                                            sound.resume()
                                            setTimeout(() => {
                                                sound.suspend()
                                                powerUps.spawn(m.pos.x + 160 * (Math.random() - 0.5), m.pos.y + 160 * (Math.random() - 0.5), "heal");
                                                setTimeout(() => {
                                                    sound.resume()
                                                    setTimeout(() => {
                                                        sound.suspend()
                                                        sound.close()
                                                        powerUps.spawn(m.pos.x + 160 * (Math.random() - 0.5), m.pos.y + 160 * (Math.random() - 0.5), "heal");
                                                    }, delay);
                                                }, delay);
                                            }, delay);
                                        }, delay);
                                    }, delay);
                                }, delay);
                            }, delay);
                        }, delay);
                    }, delay);
                }, delay);
            }, delay);
        },
        remove() { }
    },
    {
        name: "automatic",
        description: "you can't fire when moving<br>always <strong>fire</strong> when at <strong>rest</strong>",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed() {
            return !tech.isFireMoveLock
        },
        requires: "not Higgs mechanism",
        effect() {
            tech.isAlwaysFire = true;
            b.setFireMethod();
        },
        remove() {
            if (tech.isAlwaysFire) {
                tech.isAlwaysFire = false
                b.setFireMethod();
            }
        }
    },
    {
        name: "hidden variable",
        descriptionFunction() {
            return `spawn ${powerUps.orb.heal(20)}<br>but hide your <strong class='color-h'>health</strong> bar`
        },
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            document.getElementById("health").style.display = "none"
            document.getElementById("health-bg").style.display = "none"
            document.getElementById("defense-bar").style.display = "none"
            for (let i = 0; i < 20; i++) powerUps.spawn(m.pos.x + 160 * (Math.random() - 0.5), m.pos.y + 160 * (Math.random() - 0.5), "heal");
        },
        remove() { }
    },
    {
        name: "not a bug",
        description: "initiate a totally safe game crash for 10 seconds",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            const savedfunction = simulation.drawCircle
            simulation.drawCircle = () => {
                const a = mob[Infinity].position //crashed the game in a visually interesting way, because of the ctx.translate command is never reverted in the main game loop
            }
            setTimeout(() => {
                simulation.drawCircle = savedfunction
                canvas.width = canvas.width //clears the canvas // works on chrome at least
                powerUps.spawn(m.pos.x, m.pos.y, "tech");
            }, 10000);

            // for (;;) {} //freezes the tab
        },
        remove() { }
    },
    {
        name: "what the block?",
        description: "throwing a <strong class='color-block'>block</strong> throws <strong>you</strong> instead",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return m.fieldMode !== 8 && m.fieldMode !== 9 && !tech.isTokamak
        },
        requires: "not pilot wave, tokamak, wormhole",
        effect() {
            m.throwBlock = m.throwSelf
        },
        remove() {
            m.throwBlock = m.throwBlockDefault
        }
    },
    {
        name: "stationary",
        description: "thrown <strong class='color-block'>blocks</strong> can't move,<br>but somehow they still have momentum...",
        maxCount: 1,
        count: 0,
        frequency: 0,
        // isInstant: true,
        isJunk: true,
        allowed() {
            return m.fieldMode !== 8 && m.fieldMode !== 9 && !tech.isTokamak
        },
        requires: "not pilot wave, tokamak, wormhole",
        effect() {
            tech.isStaticBlock = true
        },
        remove() {
            tech.isStaticBlock = false
        }
    },
    {
        name: "spinor",
        description: "the direction you aim is determined by your position",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return !m.isShipMode
        },
        requires: "",
        effect() {
            m.look = function () {
                //always on mouse look
                m.angle = (((m.pos.x + m.pos.y) / 100 + Math.PI) % Math.PI * 2) - Math.PI
                //smoothed mouse look translations
                const scale = 0.8;
                m.transSmoothX = canvas.width2 - m.pos.x - (simulation.mouse.x - canvas.width2) * scale;
                m.transSmoothY = canvas.height2 - m.pos.y - (simulation.mouse.y - canvas.height2) * scale;

                m.transX += (m.transSmoothX - m.transX) * 0.07;
                m.transY += (m.transSmoothY - m.transY) * 0.07;
            }
        },
        remove() {
            if (this.count) m.look = m.lookDefault
        }
    },
    {
        name: "p-zombie",
        description: "set your <strong class='color-h'>health</strong> to <strong>1</strong><br>all mobs, not bosses, die and <strong>resurrect</strong> as zombies",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() { return true },
        requires: "",
        effect() {
            m.health = 0.01 //set health to 1
            m.displayHealth();
            for (let i = mob.length - 1; i > -1; i--) { //replace mobs with zombies
                if (mob[i].isDropPowerUp && !mob[i].isBoss && mob[i].alive) {
                    mob[i].isSoonZombie = true
                    mob[i].death()
                }
            }
        },
        remove() { }
    },
    {
        name: "decomposers",
        description: "after they die <strong>mobs</strong> leave behind <strong>spawns</strong>",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return tech.deathSpawns === 0
        },
        requires: "",
        effect() {
            tech.deathSpawns = 0.2
        },
        remove() {
            tech.deathSpawns = 0
        }
    },
    {
        name: "panopticon",
        description: "<strong>mobs</strong> can always see you",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            setInterval(() => {
                for (let i = 0; i < mob.length; i++) {
                    if (!mob[i].shield && mob[i].isDropPowerUp) {
                        mob[i].locatePlayer()
                        mob[i].seePlayer.yes = true;
                    }
                }
            }, 1000); //every 1 seconds
        },
        remove() { }
    },
    // {
    //     name: "inverted mouse",
    //     description: "your mouse is scrambled<br>it's fine, just rotate it 90 degrees",
    //     maxCount: 1,
    //     count: 0,
    //     frequency: 0,
    //     isExperimentHide: true,
    //     isInstant: true,
    //     isJunk: true,
    //     allowed() {
    //         return !m.isShipMode
    //     },
    //     requires: "not ship",
    //     effect() {
    //         document.body.addEventListener("mousemove", (e) => {
    //             const ratio = window.innerWidth / window.innerHeight
    //             simulation.mouse.x = e.clientY * ratio
    //             simulation.mouse.y = e.clientX / ratio;
    //         });
    //     },
    //     remove() {
    //         // m.look = m.lookDefault
    //     }
    // },
    {
        name: "Fourier analysis",
        description: "your aiming is now controlled by this equation:<br><span style = 'font-size:80%;'>2sin(0.0133t) + sin(0.013t) + 0.5sin(0.031t)+ 0.33sin(0.03t)</span>",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed() {
            return !m.isShipMode
        },
        requires: "not ship",
        effect() {
            m.look = () => {
                m.angle = 2 * Math.sin(m.cycle * 0.0133) + Math.sin(m.cycle * 0.013) + 0.5 * Math.sin(m.cycle * 0.031) + 0.33 * Math.sin(m.cycle * 0.03)
                const scale = 0.8;
                simulation.mouse.y
                m.transSmoothX = canvas.width2 - m.pos.x - (simulation.mouse.x - canvas.width2) * scale;
                m.transSmoothY = canvas.height2 - m.pos.y - (simulation.mouse.y - canvas.height2) * scale;
                m.transX += (m.transSmoothX - m.transX) * 0.07;
                m.transY += (m.transSmoothY - m.transY) * 0.07;
            }
        },
        remove() {
            if (this.count) m.look = m.lookDefault
        }
    },
    {
        name: "disintegrated armament",
        description: `spawn ${powerUps.orb.gun()}<br><strong>remove</strong> your active ${powerUps.orb.gun()}`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return b.inventory.length > 0
        },
        requires: "at least 1 gun",
        effect() {
            if (b.inventory.length > 0) b.removeGun(b.guns[b.activeGun].name)
            simulation.makeGunHUD()
            powerUps.spawn(m.pos.x + 60 * (Math.random() - 0.5), m.pos.y + 60 * (Math.random() - 0.5), "gun");
        },
        remove() { }
    },
    {
        name: "probability",
        description: `<strong>100x</strong> <em class='flicker'>frequency</em> for<br>a random ${powerUps.orb.tech()}`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            let options = []; //find what tech I could get
            for (let i = 0, len = tech.tech.length; i < len; i++) {
                if (
                    tech.tech[i].count < tech.tech[i].maxCount &&
                    tech.tech[i].allowed() &&
                    !tech.tech[i].isJunk &&
                    !tech.tech.isLore
                ) {
                    options.push(i);
                }
            }
            if (options.length) {
                const index = options[Math.floor(Math.random() * options.length)]
                tech.tech[index].frequency = 100
            }
        },
        remove() { }
    },
    {
        name: "encryption",
        description: `secure information`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            String.prototype.shuf = function () {
                var a = this.split(""),
                    n = a.length;

                for (var i = n - 1; i > 0; i--) {
                    var j = Math.floor(Math.random() * (i + 1));
                    var tmp = a[i];
                    a[i] = a[j];
                    a[j] = tmp;
                }
                return a.join("");
            }

            for (let i = 0, len = tech.tech.length; i < len; i++) tech.tech[i].name = tech.tech[i].name.shuf()
        },
        remove() { }
    },
    {
        name: "quantum leap",
        description: "become an <strong class='alt'>alternate</strong> version of yourself<br>every <strong>20</strong> seconds",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            setInterval(() => {
                const unit = {
                    x: 1,
                    y: 0
                }
                for (let i = 0; i < 5; i++) {
                    const where = Vector.add(m.pos, Vector.mult(Vector.rotate(unit, Math.random() * 2 * Math.PI), 2000 + 2000 * Math.random()))
                    spawn.sucker(where.x, where.y, 140)
                    const who = mob[mob.length - 1]
                    who.locatePlayer()
                    // who.damageReduction = 0.2
                }

                m.switchWorlds()
                simulation.trails()

            }, 20000); //every 20 seconds
        },
        remove() { }
    },
    {
        name: "score",
        description: "Add a score to n-gon!",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            setInterval(() => {
                let score = Math.ceil(1000 * Math.random() * Math.random() * Math.random() * Math.random() * Math.random())
                simulation.inGameConsole(`simulation.score <span class='color-symbol'>=</span> ${score.toFixed(0)}`);
            }, 10000); //every 10 seconds
        },
        remove() { }
    },
    {
        name: "aerodynamics",
        description: "reduce air friction for all power ups",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            const styleEl = document.createElement('style');
            document.head.appendChild(styleEl);
            const myStyle = styleEl.sheet;
            myStyle.insertRule(".choose-grid-no-images {border-radius: 50%;}", 0);
        },
        remove() { }
    },
    {
        name: "pop-ups",
        description: "sign up to learn endless easy ways to win n-gon<br>that Landgreen doesn't want you to know!!!1!!",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            setInterval(() => {
                alert(`The best combo is ${tech.tech[Math.floor(Math.random() * tech.tech.length)].name} with ${tech.tech[Math.floor(Math.random() * tech.tech.length)].name}!`);
            }, 30000); //every 30 seconds
        },
        remove() { }
    },
    {
        name: "music",
        description: "add music to n-gon",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            window.open('https://www.youtube.com/watch?v=lEbHeSdmS-k&list=PL9Z5wjoBiPKEDhwCW2RN-VZoCpmhIojdn', '_blank')
        },
        remove() { }
    },
    {
        name: "performance",
        description: "display performance stats to n-gon",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            (function () {
                var script = document.createElement('script');
                script.onload = function () {
                    var stats = new Stats();
                    document.body.appendChild(stats.dom);
                    requestAnimationFrame(function loop() {
                        stats.update();
                        requestAnimationFrame(loop)
                    });
                };
                script.src = 'https://unpkg.com/stats.js@0.17.0/build/stats.min.js';
                document.head.appendChild(script);
            })()
            //move health to the right
            document.getElementById("health").style.left = "86px"
            document.getElementById("health-bg").style.left = "86px"
            document.getElementById("defense-bar").style.left = "86px"
            document.getElementById("damage-bar").style.left = "86px"
        },
        remove() { }
    },
    {
        name: "repartitioning",
        description: `set the <strong class='color-junk'>JUNK</strong> chance to <strong>100%</strong><br>spawn ${powerUps.orb.tech()}${powerUps.orb.tech()}${powerUps.orb.tech()}${powerUps.orb.tech()}${powerUps.orb.tech()}`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.addJunkTechToPool(1)
            for (let i = 0; i < 5; i++) powerUps.spawn(m.pos.x, m.pos.y, "tech");
        },
        remove() { }
    },
    {
        name: "defragment",
        description: "set the <em class='flicker'>frequency</em> of finding <strong class='color-junk'>JUNK</strong> to zero",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.junkChance = 0;
        },
        remove() { }
    },
    // {
    //     name: "lubrication",
    //     description: "reduce block density and friction for this level",
    //     maxCount: 9,
    //     count: 0,
    //     frequency: 0,
    //     isInstant: true,
    //     isExperimentHide: true,
    //     isJunk: true,
    //     allowed() {
    //         return true
    //     },
    //     requires: "",
    //     effect() {
    //         for (let i = 0; i < body.length; i++) {
    //             Matter.Body.setDensity(body[i], 0.0001) // 0.001 is normal
    //             body[i].friction = 0.01
    //         }
    //     },
    //     remove() {}
    // },
    {
        name: "pitch",
        description: "oscillate the pitch of your world",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            setInterval(() => {
                if (!simulation.paused) ctx.rotate(0.001 * Math.sin(simulation.cycle * 0.01))
            }, 16);
        },
        remove() { }
    },
    // {
    //     name: "flatland",
    //     description: "map blocks line of sight",
    //     maxCount: 1,
    //     count: 0,
    //     frequency: 0,
    //     isInstant: true,
    //     isJunk: true,
    //     allowed() { return true },
    //     requires: "",
    //     effect() {
    //         simulation.draw.lineOfSightPrecalculation() //required precalculation for line of sight
    //         simulation.draw.drawMapPath = simulation.draw.drawMapSight

    //         simulation.ephemera.push({
    //             name: "LoS", count: 0, do() {
    //                 const pos = m.pos
    //                 const radius = 3000
    //                 if (!simulation.isTimeSkipping) {
    //                     const vertices = simulation.sight.circleLoS(pos, radius);
    //                     if (vertices.length) {
    //                         ctx.beginPath();
    //                         ctx.moveTo(vertices[0].x, vertices[0].y);
    //                         for (var i = 1; i < vertices.length; i++) {
    //                             var currentDistance = Math.sqrt((vertices[i - 1].x - pos.x) ** 2 + (vertices[i - 1].y - pos.y) ** 2);
    //                             var newDistance = Math.sqrt((vertices[i].x - pos.x) ** 2 + (vertices[i].y - pos.y) ** 2);
    //                             if (Math.abs(currentDistance - radius) < 1 && Math.abs(newDistance - radius) < 1) {
    //                                 const currentAngle = Math.atan2(vertices[i - 1].y - pos.y, vertices[i - 1].x - pos.x);
    //                                 const newAngle = Math.atan2(vertices[i].y - pos.y, vertices[i].x - pos.x);
    //                                 ctx.arc(pos.x, pos.y, radius, currentAngle, newAngle);
    //                             } else {
    //                                 ctx.lineTo(vertices[i].x, vertices[i].y)
    //                             }
    //                         }
    //                         newDistance = Math.sqrt((vertices[0].x - pos.x) ** 2 + (vertices[0].y - pos.y) ** 2);
    //                         currentDistance = Math.sqrt((vertices[vertices.length - 1].x - pos.x) ** 2 + (vertices[vertices.length - 1].y - pos.y) ** 2);
    //                         if (Math.abs(currentDistance - radius) < 1 && Math.abs(newDistance - radius) < 1) {
    //                             const currentAngle = Math.atan2(vertices[vertices.length - 1].y - pos.y, vertices[vertices.length - 1].x - pos.x);
    //                             const newAngle = Math.atan2(vertices[0].y - pos.y, vertices[0].x - pos.x);
    //                             ctx.arc(pos.x, pos.y, radius, currentAngle, newAngle);
    //                         } else {
    //                             ctx.lineTo(vertices[0].x, vertices[0].y)
    //                         }

    //                         //stroke the map, so it looks different form the line of sight 
    //                         ctx.strokeStyle = "#234";
    //                         ctx.lineWidth = 9;
    //                         ctx.stroke(simulation.draw.mapPath); //this has a pretty large impact on performance, maybe 5% worse performance

    //                         ctx.globalCompositeOperation = "destination-in";
    //                         ctx.fillStyle = "#000";
    //                         ctx.fill();
    //                         ctx.globalCompositeOperation = "source-over";
    //                         // also see the map
    //                         // ctx.fill(simulation.draw.mapPath);
    //                         // ctx.fillStyle = "#000";
    //                         ctx.clip();
    //                     }
    //                 }
    //             },
    //         })
    //     },
    //     remove() { }
    // },
    {
        name: "umbra",
        description: "produce a blue glow around everything<br>and probably some simulation lag",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            ctx.shadowColor = '#06f';
            ctx.shadowBlur = 25;
        },
        remove() { }
    },
    {
        name: "lighter",
        description: `ctx.globalCompositeOperation = "lighter"`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            ctx.globalCompositeOperation = "lighter";
        },
        remove() { }
    },
    {
        name: "the upside down",
        description: `Flip the universe until the end of the level.<br>I'll give you 1.1x <strong class='color-d'>damage</strong> as well.`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            simulation.flipCameraVertical(900)
            m.damageDone *= 1.1
        },
        remove() { }
    },
    {
        name: "rewind",
        description: "every 10 seconds <strong class='color-rewind'>rewind</strong> <strong>2</strong> seconds",
        maxCount: 9,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            setInterval(() => {
                m.rewind(120)
                m.energy += 0.4 * level.isReducedRegen
            }, 10000);
            // for (let i = 0; i < 24; i++) {
            //     setTimeout(() => { m.rewind(120) }, i * 5000);
            // }
        },
        remove() { }
    },
    {
        name: "undo",
        description: "every 4 seconds <strong class='color-rewind'>rewind</strong> <strong>1/2</strong> a second",
        maxCount: 9,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            setInterval(() => {
                m.rewind(30)
                m.energy += 0.2 * level.isReducedRegen
            }, 4000);
        },
        remove() { }
    },
    {
        name: "energy to mass conversion",
        description: "convert your <strong class='color-f'>energy</strong> into <strong class='color-block'>blocks</strong>",
        maxCount: 9,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            for (let i = 0, len = 40; i < len; i++) {
                setTimeout(() => {
                    m.energy -= 1 / len
                    where = Vector.add(m.pos, { x: 400 * (Math.random() - 0.5), y: 400 * (Math.random() - 0.5) })
                    spawn.bodyRect(where.x, where.y, Math.floor(15 + 100 * Math.random()), Math.floor(15 + 100 * Math.random()));
                }, i * 100);
            }

        },
        remove() { }
    },
    {
        name: "level.nextLevel()",
        description: "advance to the next level",
        maxCount: 9,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            level.nextLevel();
        },
        remove() { }
    },
    {
        name: "reincarnation",
        description: "kill all mobs and spawn new ones<br>(also spawn a few extra mobs for fun)",
        maxCount: 3,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            for (let i = 0, len = mob.length; i < len; i++) {
                if (mob[i].alive && !mob[i].shield && !mob[i].isBadTarget) {
                    spawn.randomMobByLevelsCleared(mob[i].position.x, mob[i].position.y)
                    if (Math.random() < 0.5) spawn.randomMobByLevelsCleared(mob[i].position.x, mob[i].position.y)
                    mob[i].death();
                }
            }
        },
        remove() { }
    },
    {
        name: "expert system",
        description: `spawn ${powerUps.orb.tech()}<br><strong>+50%</strong> chance for <strong class='color-junk'>JUNK</strong> <strong class='color-choice'><span>ch</span><span>oi</span><span>ces</span></strong>`,
        maxCount: 9,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return tech.junkChance < 1
        },
        requires: "",
        effect() {
            powerUps.spawn(m.pos.x, m.pos.y, "tech");
            tech.addJunkTechToPool(0.5)
        },
        remove() { }
    },
    {
        name: "energy investment",
        description: "every 10 seconds drain your <strong class='color-f'>energy</strong><br>return it doubled 5 seconds later",
        maxCount: 9,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            setInterval(() => {
                if (!simulation.paused) {
                    const energy = m.energy
                    m.energy = 0
                    setTimeout(() => { //return energy
                        m.energy += 2 * energy
                    }, 5000);
                }
            }, 10000);
        },
        remove() { }
    },
    {
        name: "missile launching system",
        description: "fire missiles for the next 120 seconds",
        maxCount: 9,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            for (let i = 0; i < 120; i++) {
                setTimeout(() => {
                    const where = {
                        x: m.pos.x,
                        y: m.pos.y - 40
                    }
                    b.missile(where, -Math.PI / 2 + 0.2 * (Math.random() - 0.5) * Math.sqrt(tech.missileCount), -2)
                }, i * 1000);
            }
        },
        remove() { }
    },
    {
        name: "grenade production",
        description: "drop a grenade every 2 seconds",
        maxCount: 9,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            setInterval(() => {
                if (!simulation.paused && document.visibilityState !== "hidden") {
                    b.grenade(Vector.add(m.pos, {
                        x: 10 * (Math.random() - 0.5),
                        y: 10 * (Math.random() - 0.5)
                    }), -Math.PI / 2) //fire different angles for each grenade
                    const who = bullet[bullet.length - 1]
                    Matter.Body.setVelocity(who, {
                        x: who.velocity.x * 0.1,
                        y: who.velocity.y * 0.1
                    });
                }
            }, 2000);
        },
        remove() { }
    },
    {
        name: "wall jump",
        description: "no knees or toes are drawn on the player<br>you can wall climb though",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        isInstant: true,
        allowed() {
            return !m.isShipMode
        },
        requires: "",
        effect() {
            m.skin.stubs()
            jumpSensor.vertices[0].x += -22
            jumpSensor.vertices[3].x += -22
            jumpSensor.vertices[1].x += 22
            jumpSensor.vertices[2].x += 22
        },
        remove() { }
    },
    {
        name: "Sleipnir",
        description: "grow more legs",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed() {
            return !m.isShipMode
        },
        requires: "",
        effect() {
            m.skin.Sleipnir()
        },
        remove() {
            if (this.count) m.resetSkin();
        }
    },
    {
        name: "diegesis",
        description: "indicate fire cooldown</strong><br>through a rotation of your head",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed() {
            return !m.isShipMode
        },
        requires: "",
        effect() {
            m.skin.diegesis()
        },
        remove() {
            if (this.count) m.resetSkin();
        }
    },
    {
        name: "🐱",
        description: "🐈",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed() {
            return !m.isShipMode
        },
        requires: "",
        effect() {
            m.skin.cat();
        },
        remove() {
            if (this.count) m.resetSkin();
        }
    },
    {
        name: "n-gone",
        description: "become invisible to yourself<br><em>mobs can still see you</em>",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            m.draw = () => { }
        },
        remove() {
            if (this.count) m.resetSkin();
        }
    },
    {
        name: "pareidolia",
        description: "don't",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return !m.isShipMode
        },
        requires: "",
        effect() {
            m.skin.pareidolia()
        },
        remove() {
            if (this.count) m.resetSkin();
        }
    },
    {
        name: "posture",
        description: "stand a bit taller",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed() {
            return !m.isShipMode
        },
        requires: "",
        effect() {
            m.yOffWhen.stand = 70
        },
        remove() {
            m.yOffWhen.stand = 49
        }
    },
    {
        name: "rhythm",
        description: "you oscillate up and down<br>also you look like an egg",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        isInstant: true,
        allowed() {
            return !m.isShipMode
        },
        requires: "",
        effect() {
            m.skin.egg();
            setInterval(() => {
                m.yOffWhen.stand = 53 + 28 * Math.sin(simulation.cycle * 0.2)
                if (m.onGround && !m.crouch) m.yOffGoal = m.yOffWhen.stand
            }, 100);
        },
        remove() { }
    },
    {
        name: "prism",
        description: "you cycle through different <strong>colors</strong>",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            m.color = {
                hue: 0,
                sat: 100,
                light: 50
            }
            setInterval(function () {
                m.color.hue++
                m.setFillColors()
            }, 10);
        },
        remove() { }
    },
    {
        name: "ship",
        description: "fly around with no legs",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return !m.isShipMode && !m.isAltSkin && m.fieldUpgrades[m.fieldMode].name !== "negative mass"
        },
        requires: "",
        effect() {
            m.isAltSkin = true
            m.shipMode()
            //unlock relativistic rotation
            for (let i = 0; i < tech.tech.length; i++) {
                if (tech.tech[i].name === "relativistic rotation") tech.tech[i].frequency = 10
            }
        },
        remove() { }
    },
    {
        name: "circular symmetry",
        description: "turning the ship rotates the universe instead<br><strong>2x</strong> <strong class='color-d'>damage</strong>",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return m.isShipMode
        },
        requires: "",
        effect() {
            m.damageDone *= 3

            m.look = () => {
                // const scale = 0;
                m.transSmoothX = canvas.width2 - m.pos.x // - (simulation.mouse.x - canvas.width2) * scale;
                m.transSmoothY = canvas.height2 - m.pos.y // - (simulation.mouse.y - canvas.height2) * scale;
                m.transX += (m.transSmoothX - m.transX) * m.lookSmoothing;
                m.transY += (m.transSmoothY - m.transY) * m.lookSmoothing;
                ctx.restore();
                ctx.save();
                ctx.translate(canvas.width2, canvas.height2); //center
                ctx.rotate(-m.angle)
                ctx.translate(-canvas.width2, -canvas.height2); //center
            }
        },
        remove() { }
    },
    {
        name: "pet bots",
        description: "pet your <strong class='color-bot'>bots</strong>",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        isInstant: true,
        allowed() {
            return b.totalBots()
        },
        requires: "",
        effect() {
            simulation.ephemera.push({
                name: "pet",
                count: 0,
                do() {
                    this.count++
                    if (!(this.count % 420)) {
                        for (let i = 0; i < bullet.length; i++) {
                            if (bullet[i].botType && Math.random() < 0.3) {
                                simulation.inGameConsole(`${bullet[i].botType}<span class='color-symbol'>-</span>bot.pet<span class='color-symbol'>()</span>`)
                                if (m.onGround && !m.crouch) {
                                    m.yOffGoal = m.yOffWhen.crouch;
                                    setTimeout(() => {
                                        if (!m.crouch) m.yOffGoal = m.yOffWhen.stand;
                                    }, 1000);
                                    if (m.immuneCycle < m.cycle + 90) m.immuneCycle = m.cycle + 90
                                }
                                if (Math.random() < 0.3) break
                            }
                        }

                    }
                }
            })
        },
        remove() {
        }
    },
    {
        name: "assimilation",
        description: "all your <strong class='color-bot'>bots</strong> are converted to the <strong>same</strong> random model",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isBotTech: true,
        isInstant: true,
        isJunk: true,
        allowed() {
            return b.totalBots() > 2
        },
        requires: "at least 3 bots",
        effect() {
            const total = b.totalBots();
            tech.dynamoBotCount = 0;
            tech.nailBotCount = 0;
            tech.laserBotCount = 0;
            tech.orbitBotCount = 0;
            tech.foamBotCount = 0;
            tech.soundBotCount = 0;
            tech.boomBotCount = 0;
            tech.plasmaBotCount = 0;
            tech.missileBotCount = 0;
            for (let i = 0; i < bullet.length; i++) {
                if (bullet[i].botType) bullet[i].endCycle = 0
            }

            const bots = [
                () => {
                    b.nailBot();
                    tech.nailBotCount++;
                },
                () => {
                    b.foamBot();
                    tech.foamBotCount++;
                },
                () => {
                    b.soundBot();
                    tech.soundBotCount++;
                },
                () => {
                    b.boomBot();
                    tech.boomBotCount++;
                },
                () => {
                    b.laserBot();
                    tech.laserBotCount++;
                },
                () => {
                    b.orbitBot();
                    tech.orbitBotCount++
                },
                () => {
                    b.dynamoBot();
                    tech.dynamoBotCount++
                }
            ]
            const index = Math.floor(Math.random() * bots.length)
            for (let i = 0; i < total; i++) bots[index]()
        },
        remove() { }
    },
    {
        name: "stun",
        description: "<strong>stun</strong> all mobs for up to <strong>8</strong> seconds",
        maxCount: 9,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            for (let i = 0; i < mob.length; i++) mobs.statusStun(mob[i], 480)
        },
        remove() { }
    },
    {
        name: "translucent",
        description: `spawn ${powerUps.orb.gun()}${powerUps.orb.gun()}${powerUps.orb.gun()}<br>your <strong class='color-g'>bullets</strong> and <strong class='color-bot'>bots</strong> are transparent`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            for (let i = 0; i < 3; i++) powerUps.spawn(m.pos.x + 60 * (Math.random() - 0.5), m.pos.y + 60 * (Math.random() - 0.5), "gun");

            // //removes guns and ammo  
            // b.inventory = [];
            // b.activeGun = null;
            // b.inventoryGun = 0;
            // for (let i = 0, len = b.guns.length; i < len; ++i) {
            //     b.guns[i].have = false;
            //     if (b.guns[i].ammo !== Infinity) b.guns[i].ammo = 0;
            // }
            // simulation.makeGunHUD(); //update gun HUD
            b.bulletDraw = () => { }; //make bullets invisible
        },
        remove() { }
    },
    {
        name: "difficulty",
        description: "spawn a power up that lets you<br>adjust the simulation <strong>difficulty</strong> parameters",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return (level.levelsCleared < 5)
        },
        requires: "before level 5",
        effect() {
            powerUps.spawn(m.pos.x, m.pos.y, "difficulty");
        },
        remove() { }
    },
    {
        name: "re-research",
        description: `<strong>eject</strong> all your ${powerUps.orb.research(1)}`,
        maxCount: 9,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return powerUps.research.count > 3
        },
        requires: "at least 4 research",
        effect() {
            powerUps.spawnDelay("research", powerUps.research.count);
            powerUps.research.count = 0
        },
        remove() { }
    },
    {
        name: "black hole",
        description: `use your <strong class='color-f'>energy</strong> and ${powerUps.orb.research(4)} to <strong>spawn</strong><br>inside the event horizon of a huge <strong>black hole</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return powerUps.research.count > 3
        },
        requires: "at least 4 research",
        effect() {
            m.energy = 0
            spawn.suckerBoss(m.pos.x, m.pos.y - 700)
            powerUps.research.changeRerolls(-4)
            simulation.inGameConsole(`<span class='color-var'>m</span>.<span class='color-r'>research</span> <span class='color-symbol'>--</span><br>${powerUps.research.count}`)
        },
        remove() { }
    },
    {
        name: "apomixis",
        description: `spawn <strong>11 bosses</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        isInstant: true,
        isJunk: true,
        allowed() {
            return tech.duplicationChance() > 0.99
        },
        requires: "duplication chance above 99%",
        effect() {
            const range = 1300
            for (let i = 0, len = 9; i < len; i++) {
                const angle = 2 * Math.PI * i / len
                spawn.randomLevelBoss(m.pos.x + range * Math.cos(angle), m.pos.y + range * Math.sin(angle), ["cellBossCulture", "bomberBoss", "powerUpBoss", "growBossCulture", "snakeBoss"]);
            }
            spawn.historyBoss(0, 0)
            spawn.pulsarBoss(level.exit.x, level.exit.y, 70, true)
            spawn.blockBoss(level.enter.x, level.enter.y)
        },
        remove() { }
    },
    {
        name: "mobs!",
        descriptionFunction() {
            if (this.mobType === "") this.mobType = spawn.fullPickList[Math.floor(Math.random() * spawn.fullPickList.length)]
            return `spawn 20 <strong>${this.mobType}</strong> mobs`
        },
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() { return true },
        requires: "",
        mobType: "",
        effect() {
            if (this.mobType === "") this.mobType = spawn.fullPickList[Math.floor(Math.random() * spawn.fullPickList.length)]
            for (let i = 0; i < 20; i++) {
                spawn[this.mobType](m.pos.x, m.pos.y - 700)
            }
            simulation.inGameConsole(`spawn<span class='color-symbol'>.</span>${this.mobType}<span class='color-symbol'>(</span>x<span class='color-symbol'>,</span>y<span class='color-symbol'>)</span>`)

        },
        remove() { }
    },
    {
        name: "black hole cluster",
        description: `spawn <strong>30</strong> nearby <strong>black holes</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            const unit = {
                x: 1,
                y: 0
            }
            for (let i = 0; i < 30; i++) {
                const where = Vector.add(m.pos, Vector.mult(Vector.rotate(unit, Math.random() * 2 * Math.PI), 2000 + 1200 * Math.random()))
                spawn.sucker(where.x, where.y, 140)
                const who = mob[mob.length - 1]
                who.locatePlayer()
                // who.damageReduction = 0.2
            }
        },
        remove() { }
    },
    {
        name: "rule 30",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed() {
            return !build.isExperimentSelection
        },
        requires: "NOT EXPERIMENT MODE",
        effect() { },
        remove() { },
        state: [
            [false, false, false, Math.random() > 0.8, false, false, false, Math.random() > 0.8, false, false, false, false, false, false, false, false, false, true, false, false, false, Math.random() > 0.8, false, false, false, Math.random() > 0.8, false, false, false, false, Math.random() > 0.8, false, Math.random() > 0.8, false, false, false, Math.random() > 0.8, false, false, false, false, false, false, false, false, false]
        ],
        rule(state, a, b, c) {
            //30
            if (state[a] && state[b] && state[c]) return false; // TTT => F
            if (state[a] && state[b] && !state[c]) return false; // TTF => F
            if (state[a] && !state[b] && state[c]) return false; //TFT => F 
            if (state[a] && !state[b] && !state[c]) return true; //TFF => T
            if (!state[a] && state[b] && state[c]) return true; //FTT => T
            if (!state[a] && state[b] && !state[c]) return true; //FTF => T
            if (!state[a] && !state[b] && state[c]) return true; //FFT => T
            if (!state[a] && !state[b] && !state[c]) return false; //FFF => F
        },
        id: 0,
        researchSpawned: 0,
        descriptionFunction() {
            const loop = () => {
                if ((simulation.paused || simulation.isChoosing) && m.alive && !build.isExperimentSelection) { //&& (!simulation.isChoosing || this.count === 0)
                    let b = []; //produce next row
                    b.push(this.rule(this.state[this.state.length - 1], this.state[this.state.length - 1].length - 1, 0, 1)); //left edge wrap around
                    for (let i = 1; i < this.state[this.state.length - 1].length - 1; i++) { //apply rule to the rest of the array
                        b.push(this.rule(this.state[this.state.length - 1], i - 1, i, i + 1));
                    }
                    b.push(this.rule(this.state[this.state.length - 1], this.state[this.state.length - 1].length - 2, this.state[this.state.length - 1].length - 1, 0)); //right edge wrap around
                    this.state.push(b)
                    if (document.getElementById(`cellular-rule-id${this.id}`)) document.getElementById(`cellular-rule-id${this.id}`).innerHTML = this.outputText() //convert to squares and send HTML
                    if (this.count && this.researchSpawned < 12 && !(this.state.length % 10)) {
                        this.researchSpawned++
                        powerUps.spawn(m.pos.x - 50 + 100 * (Math.random() - 0.5), m.pos.y + 100 * (Math.random() - 0.5), "research");
                        sound.portamento(300, 600, 100, 0.03)//portamento(frequency, end = 1000, shiftRate = 10, gain = 0.05) {
                    }
                    setTimeout(() => {
                        loop()
                    }, 300 + 5 * this.state.length);
                }
            }
            setTimeout(() => {
                loop()
            }, 300);
            this.id++
            return `<span id = "cellular-rule-id${this.id}" style = "letter-spacing: -0.5px;font-size: 100%;line-height: normal;font-family: 'Courier New', monospace;">${this.outputText()}</span>`
        },
        outputText() {
            let text = "<pre>"
            for (let j = 0; j < this.state.length; j++) {
                // text += "<p style = 'margin-bottom: -12px;'>"
                text += "<p style = 'margin-top: -7px;margin-bottom: -7px;'>"
                for (let i = 0; i < this.state[j].length; i++) {
                    if (this.state[j][i]) {
                        text += "■" //"☻" //"⬛" //"█" //"■"
                    } else {
                        text += " " //"□" //"☺" //"⬜" //"&nbsp;&nbsp;&nbsp;&nbsp;" //"□"
                    }
                }
                text += "</p>"
            }
            text += "</pre>"
            return text
        },
    },
    {
        name: "rule 90",
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed() {
            return !build.isExperimentSelection
        },
        requires: "NOT EXPERIMENT MODE",
        effect() { },
        remove() { },
        state: [
            [false, false, false, Math.random() > 0.8, false, false, false, Math.random() > 0.8, false, false, false, false, false, false, false, false, false, true, true, false, false, false, Math.random() > 0.8, false, false, false, Math.random() > 0.8, false, false, false, false, Math.random() > 0.8, false, Math.random() > 0.8, false, false, false, Math.random() > 0.8, false, false, false, false, false, false, false, false]
        ],
        rule(state, a, b, c) { //90
            if (state[a] && state[b] && state[c]) return false; // TTT => F
            if (state[a] && state[b] && !state[c]) return true; // TTF => T
            if (state[a] && !state[b] && state[c]) return false; //TFT => F 
            if (state[a] && !state[b] && !state[c]) return true; //TFF => T
            if (!state[a] && state[b] && state[c]) return true; //FTT => T
            if (!state[a] && state[b] && !state[c]) return false; //FTF => F
            if (!state[a] && !state[b] && state[c]) return true; //FFT => T
            if (!state[a] && !state[b] && !state[c]) return false; //FFF => F
        },
        id: 90,
        researchSpawned: 0,
        descriptionFunction() {
            const loop = () => {
                if ((simulation.paused || simulation.isChoosing) && m.alive && !build.isExperimentSelection) { //&& (!simulation.isChoosing || this.count === 0)
                    let b = []; //produce next row
                    b.push(this.rule(this.state[this.state.length - 1], this.state[this.state.length - 1].length - 1, 0, 1)); //left edge wrap around
                    for (let i = 1; i < this.state[this.state.length - 1].length - 1; i++) { //apply rule to the rest of the array
                        b.push(this.rule(this.state[this.state.length - 1], i - 1, i, i + 1));
                    }
                    b.push(this.rule(this.state[this.state.length - 1], this.state[this.state.length - 1].length - 2, this.state[this.state.length - 1].length - 1, 0)); //right edge wrap around
                    this.state.push(b)
                    if (document.getElementById(`cellular-rule-id${this.id}`)) document.getElementById(`cellular-rule-id${this.id}`).innerHTML = this.outputText() //convert to squares and send HTML
                    if (this.count && this.researchSpawned < 12 && !(this.state.length % 10)) {
                        this.researchSpawned++
                        powerUps.spawn(m.pos.x - 50 + 100 * (Math.random() - 0.5), m.pos.y + 100 * (Math.random() - 0.5), "research");
                        sound.portamento(300, 600, 100, 0.03)//portamento(frequency, end = 1000, shiftRate = 10, gain = 0.05) {
                    }
                    setTimeout(() => {
                        loop()
                    }, 300 + 5 * this.state.length);
                }
            }
            setTimeout(() => {
                loop()
            }, 300);
            this.id++
            return `<span id = "cellular-rule-id${this.id}" style = "letter-spacing: -0.5px;font-size: 100%;line-height: normal;font-family: 'Courier New', monospace;">${this.outputText()}</span>`
        },
        outputText() {
            let text = "<pre>"
            for (let j = 0; j < this.state.length; j++) {
                // text += "<p style = 'margin-bottom: -12px;'>"
                text += "<p style = 'margin-top: -7px;margin-bottom: -7px;'>"
                for (let i = 0; i < this.state[j].length; i++) {
                    if (this.state[j][i]) {
                        text += "■" //"☻" //"⬛" //"█" //"■"
                    } else {
                        text += " " //"□" //"☺" //"⬜" //"&nbsp;&nbsp;&nbsp;&nbsp;" //"□"
                    }
                }
                text += "</p>"
            }
            text += "</pre>"
            return text
        },
    },
    {
        name: "wikipedia",
        description: `After you get ${powerUps.orb.tech()} you have 7 seconds to study for a quiz.  If you ace the quiz you get ${powerUps.orb.research(4)}`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            tech.isWiki = true;
        },
        remove() {
            tech.isWiki = false;
        }
    },
    {
        name: "cosmogonic myth",
        description: `<span style = "opacity: 9%;">open a portal to a primordial version of reality<br>in 5 minutes close the portal, spawn 1 of each power up</span>`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            const urls = ["https://scratch.mit.edu/projects/14005697/fullscreen/", "https://scratch.mit.edu/projects/22573757/fullscreen/", "https://scratch.mit.edu/projects/41429974/fullscreen/", "https://scratch.mit.edu/projects/43690666/fullscreen/", "https://codepen.io/lilgreenland/full/ozXNWZ", "https://codepen.io/lilgreenland/full/wzARJY", "classic/7-1-2017/", "classic/4-15-2018/", "classic/7-11-2019/", "classic/9-8-2019/", "classic/7-15-2020/", "classic/6-1-2021/"]
            const choose = urls[Math.floor(Math.random() * urls.length)]
            console.log(`opening new tab" ${choose}`)
            let tab = window.open(choose, "_blank");
            setTimeout(() => {
                tab.close();
                powerUps.spawn(m.pos.x, m.pos.y, "gun");
                setTimeout(() => {
                    powerUps.spawn(m.pos.x, m.pos.y - 50, "ammo")
                }, 250);
                setTimeout(() => {
                    powerUps.spawn(m.pos.x + 50, m.pos.y, "field");
                }, 500);
                setTimeout(() => {
                    powerUps.spawn(m.pos.x + 50, m.pos.y - 50, "heal");
                }, 750);
                setTimeout(() => {
                    powerUps.spawn(m.pos.x - 50, m.pos.y, "tech");
                }, 1000);
                setTimeout(() => {
                    powerUps.spawn(m.pos.x - 50, m.pos.y - 50, "research");
                }, 1250);
            }, 1000 * 5 * 60);
        },
        remove() { }
    },
    {
        name: "beforeunload",
        description: "<strong>75%</strong> of the time when you attempt to <strong>exit</strong> n-gon<br>you are prompted to <strong>cancel</strong> or continue.<br>Each time you <strong>cancel</strong> gain <strong>1.25x</strong> <strong class='color-d'>damage</strong>.",
        maxCount: 1,
        count: 0,
        frequency: 1,
        isJunk: true,
        allowed() {
            return tech.totalCount > 9
        },
        requires: "at least 10 tech",
        effect() {
            tech.isExitPrompt = true
            addEventListener('beforeunload', beforeUnloadEventListener);
        },
        remove() {
            tech.isExitPrompt = false
            if (this.count > 0) removeEventListener('beforeunload', beforeUnloadEventListener);
        }
    },
    {
        name: "planetesimals",
        description: `play <strong>planetesimals</strong> <em style = 'font-size:80%;'>(an asteroids-like game)</em><br>clear <strong>levels</strong> in <strong>planetesimals</strong> to spawn ${powerUps.orb.tech()}<br>if you <strong style="color:red;">die</strong> in <strong>planetesimals</strong> you <strong style="color:red;">die</strong> in <strong>n-gon</strong>`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        isInstant: true,
        isJunk: true,
        allowed() {
            return true
        },
        requires: "",
        effect() {
            window.open('../../planetesimals/index.html', '_blank')
            // powerUps.spawn(m.pos.x, m.pos.y, "tech");

            // for communicating to other tabs, like planetesimals
            // Connection to a broadcast channel
            const bc = new BroadcastChannel('planetesimals');
            bc.activated = false

            bc.onmessage = function (ev) {
                if (ev.data === 'tech') powerUps.spawn(m.pos.x, m.pos.y, "tech");
                if (ev.data === 'death') {
                    m.death()
                    bc.close(); //end session
                }
                if (ev.data === 'ready' && !bc.activated) {
                    bc.activated = true //prevents n-gon from activating multiple copies of planetesimals
                    bc.postMessage("activate");
                }
            }
        },
        remove() { }
    },
    {
        name: "tinker",
        description: `<strong>permanently</strong> unlock <strong class='color-junk'>JUNK</strong>${powerUps.orb.tech()} in experiment mode<br><em>this effect is stored for future visits</em>`,
        maxCount: 1,
        count: 0,
        frequency: 0,
        frequencyDefault: 0,
        isJunk: true,
        isInstant: true,
        allowed() {
            return !localSettings.isJunkExperiment
        },
        requires: "",
        effect() {
            localSettings.isJunkExperiment = true
            if (localSettings.isAllowed) localStorage.setItem("localSettings", JSON.stringify(localSettings)); //update local storage
        },
        remove() { }
    },
    {
        name: "NFT",
        descriptionFunction() {
            return `buy your current game seed: <strong style = 'font-size:120%;'>${Math.initialSeed}</strong><br><em>no one is allowed to use your seeds<br>if they use them they are gonna get in trouble</em><br>your seeds: <span style = 'font-size:80%;'>${localSettings.personalSeeds.join(", ")}</span>`
        },
        maxCount: 1,
        count: 0,
        frequency: 0,
        isJunk: true,
        isInstant: true,
        allowed: () => true,
        requires: "",
        effect() {
            localSettings.personalSeeds.push(Math.initialSeed)
            if (localSettings.isAllowed) localStorage.setItem("localSettings", JSON.stringify(localSettings)); //update local storage
        },
        remove() { }
    },
    // {
    //     name: "rule 90",
    //     maxCount: 1,
    //     count: 0,
    //     frequency: 0,
    //     isJunk: true,
    //     allowed() {
    //         return true
    //     },
    //     requires: "",
    //     effect() {},
    //     remove() {},
    //     state: [
    //         [false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false]
    //     ],
    //     rule(state, a, b, c) {
    //         if (state[a] && state[b] && state[c]) return false; // TTT => F
    //         if (state[a] && state[b] && !state[c]) return true; // TTF => T
    //         if (state[a] && !state[b] && state[c]) return false; //TFT => F 
    //         if (state[a] && !state[b] && !state[c]) return true; //TFF => T
    //         if (!state[a] && state[b] && state[c]) return true; //FTT => T
    //         if (!state[a] && state[b] && !state[c]) return false; //FTF => F
    //         if (!state[a] && !state[b] && state[c]) return true; //FFT => T
    //         if (!state[a] && !state[b] && !state[c]) return false; //FFF => F
    //     },
    //     id: 0,
    //     descriptionFunction() {
    //         const loop = () => {
    //             if ((simulation.paused || simulation.isChoosing) && m.alive && !build.isExperimentSelection) { //&& (!simulation.isChoosing || this.count === 0)
    //                 let b = []; //produce next row
    //                 b.push(this.rule(this.state[this.state.length - 1], this.state[this.state.length - 1].length - 1, 0, 1)); //left edge wrap around
    //                 for (let i = 1; i < this.state[this.state.length - 1].length - 1; i++) { //apply rule to the rest of the array
    //                     b.push(this.rule(this.state[this.state.length - 1], i - 1, i, i + 1));
    //                 }
    //                 b.push(this.rule(this.state[this.state.length - 1], this.state[this.state.length - 1].length - 2, this.state[this.state.length - 1].length - 1, 0)); //right edge wrap around
    //                 this.state.push(b)
    //                 if (document.getElementById(`cellular-rule-id${this.id}`)) document.getElementById(`cellular-rule-id${this.id}`).innerHTML = this.outputText() //convert to squares and send HTML
    //                 if (this.count && this.state.length < 120 && !(this.state.length % 10)) powerUps.spawn(m.pos.x - 50 + 100 * (Math.random() - 0.5), m.pos.y + 100 * (Math.random() - 0.5), "research");
    //                 setTimeout(() => { loop() }, 400);
    //             }
    //         }
    //         setTimeout(() => { loop() }, 400);
    //         // if (this.id === 0) {
    //         //     for (let i = 0; i < 29; i++) this.state[0][i] = Math.random() < 0.5 //randomize seed
    //         // }
    //         this.id++
    //         return `<span id = "cellular-rule-id${this.id}" style = "letter-spacing: 0px;font-size: 50%;line-height: normal;">${this.outputText()}</span>`
    //     },
    //     outputText() {
    //         let text = ""
    //         for (let j = 0; j < this.state.length; j++) {
    //             text += "<p style = 'margin-bottom: -11px;'>"
    //             for (let i = 0; i < this.state[j].length; i++) {
    //                 if (this.state[j][i]) {
    //                     text += "⬛" //"█" //"■"
    //                 } else {
    //                     text += "⬜" //"&nbsp;&nbsp;&nbsp;&nbsp;" //"□"
    //                 }
    //             }
    //             text += "</p>"
    //         }
    //         return text
    //     },
    // },

    //************************************************** 
    //************************************************** undefined / lore
    //************************************************** tech
    //************************************************** 
    {
        name: `undefined`,
        description: `<strong class="lore-text">this</strong><br> &nbsp;`,
        maxCount: 1,
        count: 0,
        frequency: 2,
        frequencyDefault: 2,
        isLore: true,
        // isExperimentHide: true,
        allowed() { return !build.isExperimentSelection },
        requires: "NOT EXPERIMENT MODE",
        effect() {
            if (localSettings.loreCount > lore.conversation.length - 1) { //reward for people done with lore chapters (or on the final chapter)
                for (let i = mob.length - 1; i > -1; i--) { //replace mobs with starters
                    if (!mob[i].isBoss && mob[i].isDropPowerUp && mob[i].alive) {
                        spawn.starter(mob[i].position.x, mob[i].position.y)
                        mob[i].leaveBody = false
                        mob[i].isDropPowerUp = false
                        mob[i].death()

                        //spawn a random power up
                        // if (Math.random() < 1 / 5) {
                        //     powerUps.spawn(mob[i].position.x, mob[i].position.y, "research")
                        // } else 
                        if (Math.random() < 1 / 4) {
                            powerUps.spawn(mob[i].position.x, mob[i].position.y, "ammo")
                        } else if (Math.random() < 1 / 3) {
                            powerUps.spawn(mob[i].position.x, mob[i].position.y, "heal")
                        } else if (Math.random() < 1 / 2) {
                            powerUps.spawn(mob[i].position.x, mob[i].position.y, "boost")
                        } else {
                            powerUps.spawn(mob[i].position.x, mob[i].position.y, "coupling")
                        }
                    }
                }
            }

            setTimeout(() => { //a short delay, I can't remember why
                lore.techCount++
                if (lore.techCount === lore.techGoal) {
                    // tech.removeLoreTechFromPool();
                    this.frequency = 0;
                    this.description = `<strong class="lore-text">null</strong> is open at level.final() <br> &nbsp;`
                } else {
                    this.frequency += lore.techGoal * 2
                    this.description = `<em>uncaught error:</em><br><strong>${Math.max(0, lore.techGoal - lore.techCount)}</strong> more required for access to <strong class="lore-text">null</strong>`
                }
            }, 1);
        },
        remove() {
            lore.techCount = 0;
            this.maxCount = lore.techGoal;
            this.description = `<strong class="lore-text">this</strong> <br> &nbsp;`
        }
    }
    ],
    //variables use for gun tech upgrades
    fireRate: 1, //initializes to 1
    bulletSize: null,
    energySiphon: null,
    healSpawn: null,
    crouchAmmoCount: null,
    bulletsLastLonger: null,
    isImmortal: null,
    sporesOnDeath: null,
    isImmuneExplosion: null,
    isExplodeMob: null,
    isDroneOnDamage: null,
    isAcidDmg: null,
    isAnnihilation: null,
    largerHeals: null,
    isCrit: null,
    isLowHealthDmg: null,
    isLowHealthDefense: null,
    isLowHealthFireRate: null,
    isFarAwayDmg: null,
    isFirstDer: null,
    isMassEnergy: null,
    extraChoices: null,
    laserBotCount: null,
    dynamoBotCount: null,
    nailBotCount: null,
    foamBotCount: null,
    soundBotCount: null,
    boomBotCount: null,
    plasmaBotCount: null,
    missileBotCount: null,
    orbitBotCount: null,
    blockDmg: null,
    isBlockRadiation: null,
    isPiezo: null,
    isFastDrones: null,
    oneSuperBall: null,
    laserReflections: null,
    laserDamage: null,
    isAmmoFromHealth: null,
    mobSpawnWithHealth: null,
    isEnergyRecovery: null,
    isHealthRecovery: null,
    isEnergyLoss: null,
    isDeathAvoid: null,
    isDeathAvoidedThisLevel: null,
    isPlasmaRange: null,
    isFreezeMobs: null,
    isIceCrystals: null,
    blockDamage: null,
    isBlockStun: null,
    isStunField: null,
    isHarmDamage: null,
    isVacuumBomb: null,
    renormalization: null,
    fragments: null,
    energyDamage: null,
    botSpawner: null,
    isBotSpawnerReset: null,
    isSporeFollow: null,
    isNailRadiation: null,
    isEnergyHealth: null,
    isStun: null,
    restDamage: null,
    isRPG: null,
    missileCount: null,
    isDeterminism: null,
    isSuperDeterminism: null,
    isHarmReduce: null,
    nailsDeathMob: null,
    isSlowFPS: null,
    isNeutronStun: null,
    isAnsatz: null,
    isDamageFromBulletCount: null,
    laserDrain: null,
    isNailShot: null,
    slowFire: null,
    fastTime: null,
    isFastRadiation: null,
    isAmmoForGun: null,
    isRapidPulse: null,
    isSporeFreeze: null,
    isShotgunRecoil: null,
    isHealLowHealth: null,
    isAoESlow: null,
    isHarmArmor: null,
    isTurret: null,
    isRerollDamage: null,
    isHarmFreeze: null,
    isBotArmor: null,
    isRerollHaste: null,
    researchHaste: null,
    isMineDrop: null,
    isRerollBots: null,
    isNailBotUpgrade: null,
    isFoamBotUpgrade: null,
    isSoundBotUpgrade: null,
    isLaserBotUpgrade: null,
    isBoomBotUpgrade: null,
    isOrbitBotUpgrade: null,
    isDroneGrab: null,
    isOneGun: null,
    isDamageForGuns: null,
    isGunCycle: null,
    isFastFoam: null,
    isSporeGrowth: null,
    isStimulatedEmission: null,
    // nailGun: null,
    nailInstantFireRate: null,
    isCapacitor: null,
    isEnergyNoAmmo: null,
    // isFreezeHarmImmune: null,
    isSmallExplosion: null,
    isExplosionHarm: null,
    extraMaxHealth: null,
    // bonusHealth: null,
    isIntangible: null,
    isCloakStun: null,
    bonusEnergy: null,
    // healGiveMaxEnergy: null,
    healMaxEnergyBonus: 0, //not null
    slowFireDamage: null,
    isNoFireDefense: null,
    isNoFireDamage: null,
    duplicateChance: null,
    beamSplitter: null,
    iceEnergy: null,
    isPerfectBrake: null,
    explosiveRadius: null,
    // isWormholeEnergy: null,
    isWormholeDamage: null,
    isNailCrit: null,
    isFlechetteExplode: null,
    isWormholeWorms: null,
    isWormHoleBullets: null,
    isWideLaser: null,
    wideLaser: null,
    isPulseLaser: null,
    isRadioactive: null,
    radioactiveDamage: null,
    isRailEnergy: null,
    isMineSentry: null,
    isIncendiary: null,
    overfillDrain: null,
    isNeutronSlow: null,
    // isRailAreaDamage: null,
    historyLaser: null,
    isSpeedHarm: null,
    isSpeedDamage: null,
    speedAdded: null,
    isTimeSkip: null,
    isCancelDuplication: null,
    duplication: null,
    isCancelRerolls: null,
    isCancelTech: null,
    cancelTechCount: null,
    isBotDamage: null,
    isBanish: null,
    isRetain: null,
    isMaxEnergyTech: null,
    isLowEnergyDamage: null,
    isRewindBot: null,
    isRewindGrenade: null,
    isExtruder: null,
    isEndLevelPowerUp: null,
    isMissileBig: null,
    isMissileBiggest: null,
    isLaserMine: null,
    isFoamMine: null,
    isAmmoFoamSize: null,
    isIceIX: null,
    isDupDamage: null,
    isDupEnergy: null,
    isFireRateForGuns: null,
    cyclicImmunity: null,
    isTechDamage: null,
    isRestHarm: null,
    isFireMoveLock: null,
    isRivets: null,
    isNeedles: null,
    isExplodeRadio: null,
    isPauseSwitchField: null,
    isPauseEjectTech: null,
    pauseEjectTech: null,
    isShieldPierce: null,
    isDuplicateMobs: null,
    isDynamoBotUpgrade: null,
    isBlockPowerUps: null,
    isHarmReduceNoKill: null,
    isSwitchReality: null,
    isResearchReality: null,
    isAnthropicDamage: null,
    isMetaAnalysis: null,
    isFoamAttract: null,
    droneCycleReduction: null,
    droneEnergyReduction: null,
    isHalfHeals: null,
    isAlwaysFire: null,
    isDroneRespawn: null,
    deathSpawns: null,
    isMobBlockFling: null,
    isPhaseVelocity: null,
    waveBeamSpeed: null,
    wavePacketAmplitude: null,
    isCollisionRealitySwitch: null,
    iceIXOnDeath: null,
    wimpCount: null,
    isAddBlockMass: null,
    isDarkMatter: null,
    isHarmDarkMatter: null,
    isMoveDarkMatter: null,
    isNotDarkMatter: null,
    isSneakAttack: null,
    isFallingDamage: null,
    harmonics: null,
    isStandingWaveExpand: null,
    isTokamak: null,
    isTokamakHeal: null,
    tokamakHealCount: null,
    isTokamakFly: null,
    deflectEnergy: null,
    superBallDelay: null,
    isBlockExplode: null,
    isOverHeal: null,
    isDroneRadioactive: null,
    droneRadioDamage: null,
    isDroneTeleport: null,
    isDroneFastLook: null,
    isBulletTeleport: null,
    isJunkResearch: null,
    laserColor: null,
    laserColorAlpha: null,
    isLongitudinal: null,
    is360Longitudinal: null,
    isShotgunReversed: null,
    fieldDuplicate: null,
    isCloakingDamage: null,
    harmonicEnergy: null,
    isFieldHarmReduction: null,
    isFastTime: null,
    isAnthropicTech: null,
    isSporeWorm: null,
    isSporeFlea: null,
    isFoamShot: null,
    isIceShot: null,
    isBlockRestitution: null,
    isZeno: null,
    isFieldFree: null,
    isExtraGunField: null,
    isBigField: null,
    isSmartRadius: null,
    isFilament: null,
    isLargeHarpoon: null,
    extraHarpoons: null,
    ammoCap: null,
    isHarpoonPowerUp: null,
    harpoonDensity: null,
    isAddRemoveMaxHealth: null,
    cloakDuplication: null,
    extruderRange: null,
    isForeverDrones: null,
    nailRecoil: null,
    baseJumpForce: null,
    baseFx: null,
    isNeutronium: null,
    isFreeWormHole: null,
    isRewindField: null,
    isCrouchRegen: null,
    isAxion: null,
    isDarkEnergy: null,
    isDarkStar: null,
    isWormholeMapIgnore: null,
    isLessDamageReduction: null,
    needleTunnel: null,
    isBrainstorm: null,
    isBrainstormActive: null,
    brainStormDelay: null,
    wormSize: null,
    extraSuperBalls: null,
    isTimeCrystals: null,
    isGroundState: null,
    isRailGun: null,
    isDronesTravel: null,
    isTechDebt: null,
    isPlasmaBall: null,
    plasmaDischarge: null,
    missileFireCD: null,
    isBotField: null,
    isFoamBall: null,
    isNoDraftPause: null,
    isFoamPressure: null,
    foamDamage: null,
    isClusterExplode: null,
    isCircleExplode: null,
    isPetalsExplode: null,
    isVerlet: null,
    isIceMaxHealthLoss: null,
    isIceKill: null,
    isCritKill: null,
    isQuantumEraser: null,
    isPhononBlock: null,
    isPhononWave: null,
    isLaserLens: null,
    laserCrit: null,
    isSporeColony: null,
    isExtraBotOption: null,
    isLastHitDamage: null,
    isCloakHealLastHit: null,
    isRicochet: null,
    isCancelCouple: null,
    isCouplingPowerUps: null,
    isBoostPowerUps: null,
    isBoostReplaceAmmo: null,
    isInfiniteWaveAmmo: null,
    isJunkDNA: null,
    buffedGun: 0,
    isGunChoice: null,
    railChargeRate: null,
    isSuperHarm: null,
    isZombieMobs: null,
    isSuperMine: null,
    sentryAmmo: null,
    collidePowerUps: null,
    isDilate: null,
    isDiaphragm: null,
    offGroundDamage: null,
    isSuperBounce: null,
    isDivisor: null,
    isFoamCavitation: null,
    isHealAttract: null,
    isLaserField: null,
    isHealBrake: null,
    isMassProduction: null,
    isPrinter: null,
    isHookDefense: null,
    hookNails: null,
    isHarpoonDefense: null,
    isReel: null,
    harpoonPowerUpCycle: null,
    isHarpoonFullHealth: null,
    isMobFullHealthCloak: null,
    isMobLowHealth: null,
    isDamageCooldown: null,
    isDamageCooldownTime: null,
    isPowerUpDamage: null,
    isExitPrompt: null,
    isResearchDamage: null,
    interestRate: null,
    isImmunityDamage: null,
    isMobDeathImmunity: null,
    isMaxHealthDefense: null,
    noDefenseSettingDamage: null,
    isMaxHealthDamage: null,
    isEjectOld: null,
    isWiki: null,
    isStaticBlock: null,
    isDamageFieldTech: null,
    isRemineralize: null,
    mineralDamageReduction: null,
    isDemineralize: null,
    mineralDamage: null,
    negativeMassCost: null,
    beamCollimator: null,
    isInPilot: null,
    isNoPilotCost: null,
    isPlasmaBoost: null,
    isControlPlasma: null,
    energyDefense: null,
    isNewWormHoleDamage: null,
    isNoDeath: null,
    isDeathTech: null,
    isDeathTechTriggered: null,
    isRebar: null,
    isMaul: null,
    isTargeting: null,
    isBreakHarpoon: null,
    isBreakHarpoonGain: null,
}
    </script>
    <script>
        let bullet = [];

const b = {
    gravity: 0.0006, //most other bodies have   gravity = 0.001
    activeGun: null, //current gun in use by player
    inventoryGun: 0,
    inventory: [], //list of what guns player has  // 0 starts with basic gun
    setFireMethod() {
        if (tech.isFireMoveLock) {
            b.fire = b.fireFloat
            // } else if (tech.isFireNotMove) {
            //     if (tech.isAlwaysFire) {
            //         b.fire = b.fireAlwaysFire
            //     } else {
            //         b.fire = b.fireNotMove
            //     }
        } else if (tech.isAlwaysFire) {
            b.fire = b.fireAlwaysFire
        } else {
            b.fire = b.fireNormal
        }
    },
    fire() { },
    fireNormal() {
        if (b.inventory.length && (b.activeGun !== null && b.activeGun !== undefined)) {
            if (input.fire && m.fireCDcycle < m.cycle && (!input.field || m.fieldFire)) {
                if (b.guns[b.activeGun].ammo > 0) {
                    b.fireWithAmmo()
                } else {
                    b.outOfAmmo()
                }
                if (m.holdingTarget) m.drop();
            }
            b.guns[b.activeGun].do();
        }
    },
    fireNotMove() { //added  && player.speed < 0.5 && m.onGround  
        if (b.inventory.length && (b.activeGun !== null && b.activeGun !== undefined)) {
            if (input.fire && m.fireCDcycle < m.cycle && (!input.field || m.fieldFire) && player.speed < 2.5 && m.onGround && Math.abs(m.yOff - m.yOffGoal) < 1) {
                if (b.guns[b.activeGun].ammo > 0) {
                    b.fireWithAmmo()
                } else {
                    b.outOfAmmo()
                }
                if (m.holdingTarget) m.drop();
            }
            b.guns[b.activeGun].do();
        }
    },
    fireAlwaysFire() { //added  && player.speed < 0.5 && m.onGround  //removed input.fire && (!input.field || m.fieldFire)
        if (b.inventory.length && (b.activeGun !== null && b.activeGun !== undefined)) {
            if (m.fireCDcycle < m.cycle && player.speed < 0.5 && m.onGround && Math.abs(m.yOff - m.yOffGoal) < 1) {
                if (b.guns[b.activeGun].ammo > 0) {
                    b.fireWithAmmo()
                }
                if (m.holdingTarget) m.drop();
            }
            b.guns[b.activeGun].do();
        }
    },
    fireFloat() { //added  && player.speed < 0.5 && m.onGround  
        if (b.inventory.length && (b.activeGun !== null && b.activeGun !== undefined)) {
            if (input.fire && (!input.field || m.fieldFire)) {
                if (m.fireCDcycle < m.cycle) {
                    if (b.guns[b.activeGun].ammo > 0) {
                        b.fireWithAmmo()
                    } else {
                        b.outOfAmmo()
                    }
                    if (m.holdingTarget) m.drop();
                }
                Matter.Body.setVelocity(player, {
                    x: 0,
                    y: -55 * player.mass * simulation.g //undo gravity before it is added
                });
                player.force.x = 0
                player.force.y = 0
            }
            b.guns[b.activeGun].do();
        }
    },
    fireWithAmmo() { //triggers after firing when you have ammo
        b.guns[b.activeGun].fire();
        if (tech.crouchAmmoCount && m.crouch) {
            if (tech.crouchAmmoCount % 2) {
                b.guns[b.activeGun].ammo--;
                if (level.is2xAmmo && b.guns[b.activeGun].ammo > 0) b.guns[b.activeGun].ammo--;
                simulation.updateGunHUD();
            }
            tech.crouchAmmoCount++ //makes the no ammo toggle off and on
        } else {
            b.guns[b.activeGun].ammo--;
            if (level.is2xAmmo && b.guns[b.activeGun].ammo > 0) b.guns[b.activeGun].ammo--;
            simulation.updateGunHUD();
        }
    },
    outOfAmmo() { //triggers after firing when you have NO ammo
        simulation.inGameConsole(`${b.guns[b.activeGun].name}.<span class='color-g'>ammo</span><span class='color-symbol'>:</span> 0`);
        m.fireCDcycle = m.cycle + 30; //fire cooldown       
        if (tech.isAmmoFromHealth) {
            const amount = 0.02
            if (tech.isEnergyHealth) {
                if (m.maxEnergy > amount * 2) {
                    tech.healMaxEnergyBonus -= amount * 2
                    m.setMaxEnergy();
                    for (let i = 0; i < 4; i++) powerUps.spawn(m.pos.x + 50 * (Math.random() - 0.5), m.pos.y + 50 * (Math.random() - 0.5), "ammo");
                }
            } else {
                if (m.health > amount) {
                    tech.extraMaxHealth -= amount //decrease max health
                    m.setMaxHealth();
                    for (let i = 0; i < 4; i++) powerUps.spawn(m.pos.x + 50 * (Math.random() - 0.5), m.pos.y + 50 * (Math.random() - 0.5), "ammo");
                }
            }
        }
    },
    refundAmmo() { //triggers after firing when you removed ammo for a gun, but didn't need to
        if (tech.crouchAmmoCount && m.crouch && (b.activeGun !== null && b.activeGun !== undefined)) {
            tech.crouchAmmoCount--
            if ((tech.crouchAmmoCount) % 2) {
                b.guns[b.activeGun].ammo++;
                simulation.updateGunHUD();
            }
        } else {
            b.guns[b.activeGun].ammo++;
            simulation.updateGunHUD();
        }
    },
    // returnGunAmmo(name) {
    //     for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
    //         if (b.guns[i].name === name) return b.guns[i].ammo
    //     }
    // },
    giveGuns(gun = "random", ammoPacks = 22) {
        if (tech.ammoCap) ammoPacks = tech.ammoCap
        if (tech.isOneGun) b.resetAllGuns();
        if (gun === "random") {
            //find what guns player doesn't have
            options = []
            for (let i = 0, len = b.guns.length; i < len; i++) {
                if (!b.guns[i].have) options.push(i)
            }
            if (options.length === 0) return
            //randomly pick from list of possible guns
            gun = options[Math.floor(Math.random() * options.length)]
        }
        if (gun === "all") {
            for (let i = 0; i < b.guns.length; i++) {
                b.inventory[i] = i;
                b.guns[i].have = true;
                if (b.guns[i].ammo !== Infinity) b.guns[i].ammo = Math.ceil(b.guns[i].ammoPack * ammoPacks);
            }
            b.inventoryGun = 0;
            b.activeGun = b.inventory[0];
        } else {
            if (isNaN(gun)) { //find gun by name
                let found = false;
                for (let i = 0; i < b.guns.length; i++) {
                    if (gun === b.guns[i].name) {
                        gun = i
                        found = true;
                        break
                    }
                }
                if (!found) return //if no gun found don't give a gun
            }
            if (!b.guns[gun].have) b.inventory.push(gun);
            b.guns[gun].have = true;
            if (b.guns[gun].ammo !== Infinity) b.guns[gun].ammo = Math.ceil(b.guns[gun].ammoPack * ammoPacks);
            if (b.activeGun === null) {
                b.inventoryGun = 0;
                b.activeGun = b.inventory[0] //if no active gun switch to new gun
                if (b.guns[b.activeGun].charge) b.guns[b.activeGun].charge = 0; //set foam charge to zero if foam is a new gun
            }
        }
        simulation.makeGunHUD();
        simulation.switchGun();
        b.setFireCD();
        if (tech.isOneGun && b.inventory > 0) {
            //count how many gun tech you have and remove them
            let gunTechCount = 0 //2 bonus gun tech
            for (let i = 0, len = tech.tech.length; i < len; i++) {
                if (tech.tech[i].isGunTech && tech.tech[i].count > 0 && !tech.tech[i].isInstant && !tech.tech[i].isRemoveGun) {
                    const remove = tech.removeTech(i)
                    gunTechCount += remove
                }
            }

            //get a random gun tech for your gun
            for (let i = 0; i < gunTechCount; i++) {
                const gunTechPool = []
                for (let j = 0, len = tech.tech.length; j < len; j++) {
                    if (tech.tech[j].isGunTech && tech.tech[j].allowed() && !tech.tech[i].isRemoveGun && !tech.tech[j].isJunk && !tech.tech[j].isBadRandomOption && tech.tech[j].count < tech.tech[j].maxCount) {
                        const regex = tech.tech[j].requires.search(b.guns[b.activeGun].name) //get string index of gun name
                        const not = tech.tech[j].requires.search(' not ') //get string index of ' not '
                        //look for the gun name in the requirements, but the gun name needs to show up before the word ' not '
                        if (regex !== -1 && (not === -1 || not > regex)) gunTechPool.push(j)
                    }
                }
                if (gunTechPool.length) {
                    const index = Math.floor(Math.random() * gunTechPool.length)
                    simulation.inGameConsole(`<span class='color-var'>tech</span>.giveTech("<strong class='color-text'>${tech.tech[gunTechPool[index]].name}</strong>")`)
                    tech.giveTech(gunTechPool[index]) // choose from the gun pool
                } else {
                    tech.giveTech() //get normal tech if you can't find any gun tech
                }
            }

        }
    },
    removeGun(gunName) {
        for (let i = 0; i < b.guns.length; i++) {
            if (b.guns[i].name === gunName && b.guns[i].have) {
                b.guns[i].have = false
                for (let j = 0; j < b.inventory.length; j++) {
                    if (b.inventory[j] === i) {
                        b.inventory.splice(j, 1)
                        break
                    }
                }
                if (b.inventory.length > 0) {
                    b.activeGun = b.inventory[0];
                } else {
                    b.activeGun = null;
                }
                b.inventoryGun = 0;
                simulation.makeGunHUD();
                break
            }
        }
        b.setFireCD();
    },
    resetAllGuns() {
        b.inventory = []; //removes guns and ammo  
        for (let i = 0, len = b.guns.length; i < len; ++i) {
            b.guns[i].count = 0;
            b.guns[i].have = false;
            b.guns[i].ammoPack = b.guns[i].defaultAmmoPack;
            if (b.guns[i].ammo != Infinity) b.guns[i].ammo = 0;
        }
        tech.buffedGun = 0
        b.activeGun = null;
        b.inventoryGun = 0;
        simulation.drawCursor = simulation.drawCursorBasic //set cross hairs
    },
    bulletRemove() { //run in main loop
        //remove bullet if at end cycle for that bullet
        let i = bullet.length;
        while (i--) {
            if (bullet[i].endCycle < simulation.cycle) {
                bullet[i].onEnd(i); //some bullets do stuff on end
                if (bullet[i]) {
                    Matter.Composite.remove(engine.world, bullet[i]);
                    bullet.splice(i, 1);
                } else {
                    break; //if bullet[i] doesn't exist don't complete the for loop, because the game probably reset
                }
            }
        }
    },
    bulletDraw() {
        ctx.beginPath();
        for (let i = 0, len = bullet.length; i < len; i++) {
            let vertices = bullet[i].vertices;
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let j = 1; j < vertices.length; j += 1) {
                ctx.lineTo(vertices[j].x, vertices[j].y);
            }
            ctx.lineTo(vertices[0].x, vertices[0].y);
        }
        ctx.fillStyle = color.bullet;
        ctx.fill();
    },
    bulletDo() {
        for (let i = 0, len = bullet.length; i < len; i++) {
            bullet[i].do();
        }
    },
    fireProps(cd, speed, dir, me) {
        m.fireCDcycle = m.cycle + Math.floor(cd * b.fireCDscale); // cool down
        Matter.Body.setVelocity(bullet[me], {
            x: 0.5 * player.velocity.x + speed * Math.cos(dir),
            y: 0.5 * player.velocity.y + speed * Math.sin(dir)
        });
        Composite.add(engine.world, bullet[me]); //add bullet to world
    },
    fireCDscale: 1,
    setFireCD() {
        b.fireCDscale = tech.fireRate * tech.slowFire * tech.researchHaste * tech.slowFireDamage
        if (m.fieldMode === 6) b.fireCDscale *= 0.8
        if (tech.isFastTime) b.fireCDscale *= 0.666
        if (tech.isFireRateForGuns) b.fireCDscale *= Math.pow(0.76923, Math.max(0, b.inventory.length - 1))
        if (tech.isFireMoveLock) b.fireCDscale *= 0.25
    },
    fireAttributes(dir, rotate = true) {
        if (rotate) {
            return {
                // density: 0.0015,			//frictionAir: 0.01,			//restitution: 0,
                angle: dir,
                friction: 0.5,
                frictionAir: 0,
                dmg: 0, //damage done in addition to the damage from momentum
                classType: "bullet",
                collisionFilter: {
                    category: cat.bullet,
                    mask: cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield
                },
                minDmgSpeed: 10,
                beforeDmg() { }, //this.endCycle = 0  //triggers despawn
                onEnd() { }
            };
        } else {
            return {
                // density: 0.0015,			//frictionAir: 0.01,			//restitution: 0,
                inertia: Infinity, //prevents rotation
                angle: dir,
                friction: 0.5,
                frictionAir: 0,
                dmg: 0, //damage done in addition to the damage from momentum
                classType: "bullet",
                collisionFilter: {
                    category: cat.bullet,
                    mask: cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield
                },
                minDmgSpeed: 10,
                beforeDmg() { }, //this.endCycle = 0  //triggers despawn
                onEnd() { }
            };
        }
    },
    muzzleFlash(radius = 30) {
        // ctx.fillStyle = "#fb0";
        // ctx.beginPath();
        // ctx.arc(m.pos.x + 35 * Math.cos(m.angle), m.pos.y + 35 * Math.sin(m.angle), radius, 0, 2 * Math.PI);
        // ctx.fill();

        simulation.drawList.push({ //add dmg to draw queue
            x: m.pos.x + 20 * Math.cos(m.angle),
            y: m.pos.y + 20 * Math.sin(m.angle),
            radius: radius,
            color: "#fb0",
            time: 1
        });
    },
    removeConsBB(me) {
        for (let i = 0, len = consBB.length; i < len; ++i) {
            if (consBB[i].bodyA === me) {
                consBB[i].bodyA = consBB[i].bodyB;
                consBB.splice(i, 1);
                break;
            } else if (consBB[i].bodyB === me) {
                consBB[i].bodyB = consBB[i].bodyA;
                consBB.splice(i, 1);
                break;
            }
        }
    },
    onCollision(event) {
        const pairs = event.pairs;
        for (let i = 0, j = pairs.length; i != j; i++) {
            //map + bullet collisions
            if (pairs[i].bodyA.collisionFilter.category === cat.map && pairs[i].bodyB.collisionFilter.category === cat.bullet) {
                collideBulletStatic(pairs[i].bodyB)
            } else if (pairs[i].bodyB.collisionFilter.category === cat.map && pairs[i].bodyA.collisionFilter.category === cat.bullet) {
                collideBulletStatic(pairs[i].bodyA)
            }

            function collideBulletStatic(obj) {
                if (obj.onWallHit) obj.onWallHit();
            }
        }
    },
    explosionRange() {
        return tech.explosiveRadius * (tech.isExplosionHarm ? 1.7 : 1) * (tech.isSmallExplosion ? 0.7 : 1) * (tech.isExplodeRadio ? 1.25 : 1)
    },
    explosion(where, radius, color = "rgba(255,25,0,0.6)", reducedKnock = 1) { // typically explode is used for some bullets with .onEnd
        radius *= tech.explosiveRadius

        let knock;
        let dmg = radius * 0.019
        if (tech.isExplosionHarm) radius *= 1.7 //    1/sqrt(2) radius -> area
        if (tech.isSmallExplosion) {
            // color = "rgba(255,0,30,0.7)"
            radius *= 0.7
            dmg *= 1.7
        }
        let sub = Vector.sub(where, player.position);
        let dist = Vector.magnitude(sub);
        if (tech.isSmartRadius && radius > dist - 50) radius = Math.max(dist - 50, 1)

        if (tech.isExplodeRadio) { //radiation explosion
            radius *= 1.25; //alert range
            // if (tech.isSmartRadius) radius = Math.max(Math.min(radius, Vector.magnitude(Vector.sub(where, player.position)) - 25), 1)
            color = "rgba(25,139,170,0.25)"
            simulation.drawList.push({ //add dmg to draw queue
                x: where.x,
                y: where.y,
                radius: radius,
                color: color,
                time: simulation.drawTime * 2
            });

            //player damage
            if (Vector.magnitude(Vector.sub(where, player.position)) < radius) {
                const DRAIN = (tech.isExplosionHarm ? 0.6 : 0.45) * (tech.isRadioactiveResistance ? 0.2 : 1)
                if (m.immuneCycle < m.cycle) m.energy -= DRAIN
                if (m.energy < 0) {
                    m.energy = 0
                    m.takeDamage(tech.radioactiveDamage * 0.03 * (tech.isRadioactiveResistance ? 0.2 : 1) * spawn.dmgToPlayerByLevelsCleared());
                }
            }

            //mob damage and knock back with alert
            let damageScaler = 1.5; // reduce dmg for each new target to limit total AOE damage
            for (let i = 0, len = mob.length; i < len; ++i) {
                if (mob[i].alive && !mob[i].isShielded) {
                    sub = Vector.sub(where, mob[i].position);
                    dist = Vector.magnitude(sub) - mob[i].radius;
                    if (dist < radius) {
                        if (mob[i].shield) dmg *= 2.5 //balancing explosion dmg to shields
                        if (Matter.Query.ray(map, mob[i].position, where).length > 0) dmg *= 0.5 //reduce damage if a wall is in the way
                        mobs.statusDoT(mob[i], dmg * damageScaler * 0.25, 240) //apply radiation damage status effect on direct hits
                        if (tech.isStun) mobs.statusStun(mob[i], 30)
                        mob[i].locatePlayer();
                        damageScaler *= 0.87 //reduced damage for each additional explosion target
                    }
                }
            }
        } else { //normal explosions
            // if (tech.isSmartRadius) radius = Math.max(Math.min(radius, Vector.magnitude(Vector.sub(where, player.position)) - 25), 1)
            simulation.drawList.push({ //add dmg to draw queue
                x: where.x,
                y: where.y,
                radius: radius,
                color: color,
                time: simulation.drawTime
            });
            const alertRange = 100 + radius * 2; //alert range
            simulation.drawList.push({ //add alert to draw queue
                x: where.x,
                y: where.y,
                radius: alertRange,
                color: "rgba(100,20,0,0.03)",
                time: simulation.drawTime
            });

            //player damage and knock back
            if (m.immuneCycle < m.cycle) {
                if (dist < radius) {
                    const harm = tech.isExplosionHarm ? 0.067 : 0.05
                    if (tech.isImmuneExplosion && m.energy > 0.2) {
                        // const mitigate = Math.min(1, Math.max(1 - m.energy * 0.5, 0))
                        m.energy -= 0.2
                        knock = Vector.mult(Vector.normalise(sub), -0.6 * player.mass * Math.max(0, Math.min(0.15 - 0.002 * player.speed, 0.15)));
                        player.force.x = knock.x; // not +=  so crazy forces can't build up with MIRV
                        player.force.y = knock.y - 0.3; //some extra vertical kick 
                    } else {
                        m.takeDamage(harm * spawn.dmgToPlayerByLevelsCleared());
                        knock = Vector.mult(Vector.normalise(sub), -Math.sqrt(dmg) * player.mass * 0.013);
                        player.force.x += knock.x;
                        player.force.y += knock.y;
                    }
                } else if (dist < alertRange) {
                    knock = Vector.mult(Vector.normalise(sub), -Math.sqrt(dmg) * player.mass * 0.005);
                    player.force.x += knock.x;
                    player.force.y += knock.y;
                }
            }

            //body knock backs
            for (let i = body.length - 1; i > -1; i--) {
                if (!body[i].isNotHoldable) {
                    sub = Vector.sub(where, body[i].position);
                    dist = Vector.magnitude(sub);
                    if (dist < radius) {
                        knock = Vector.mult(Vector.normalise(sub), -Math.sqrt(dmg) * body[i].mass * 0.022);
                        body[i].force.x += knock.x;
                        body[i].force.y += knock.y;
                        if (tech.isBlockExplode) {
                            if (body[i] === m.holdingTarget) m.drop()
                            const size = 20 + 300 * Math.pow(body[i].mass, 0.25)
                            const where = body[i].position
                            const onLevel = level.onLevel //prevent explosions in the next level
                            Matter.Composite.remove(engine.world, body[i]);
                            body.splice(i, 1);
                            setTimeout(() => {
                                if (onLevel === level.onLevel) b.explosion(where, size); //makes bullet do explosive damage at end
                            }, 250 + 300 * Math.random());
                        }
                    } else if (dist < alertRange) {
                        knock = Vector.mult(Vector.normalise(sub), -Math.sqrt(dmg) * body[i].mass * 0.011);
                        body[i].force.x += knock.x;
                        body[i].force.y += knock.y;
                    }
                }
            }

            //power up knock backs
            for (let i = 0, len = powerUp.length; i < len; ++i) {
                sub = Vector.sub(where, powerUp[i].position);
                dist = Vector.magnitude(sub);
                if (dist < radius) {
                    knock = Vector.mult(Vector.normalise(sub), -Math.sqrt(dmg) * powerUp[i].mass * 0.013);
                    powerUp[i].force.x += knock.x;
                    powerUp[i].force.y += knock.y;
                } else if (dist < alertRange) {
                    knock = Vector.mult(Vector.normalise(sub), -Math.sqrt(dmg) * powerUp[i].mass * 0.007);
                    powerUp[i].force.x += knock.x;
                    powerUp[i].force.y += knock.y;
                }
            }

            //mob damage and knock back with alert
            let damageScaler = 1.5; // reduce dmg for each new target to limit total AOE damage
            for (let i = 0, len = mob.length; i < len; ++i) {
                if (mob[i].alive && !mob[i].isShielded) {
                    sub = Vector.sub(where, mob[i].position);
                    dist = Vector.magnitude(sub) - mob[i].radius;
                    if (dist < radius) {
                        if (mob[i].shield) dmg *= 1.8 //balancing explosion dmg to shields
                        if (Matter.Query.ray(map, mob[i].position, where).length > 0) dmg *= 0.5 //reduce damage if a wall is in the way
                        mob[i].damage(dmg * damageScaler);
                        mob[i].locatePlayer();
                        knock = Vector.mult(Vector.normalise(sub), -Math.sqrt(dmg * damageScaler) * mob[i].mass * (mob[i].isBoss ? 0.003 : 0.01) * reducedKnock);
                        if (tech.isStun) {
                            mobs.statusStun(mob[i], 30)
                        } else if (!mob[i].isInvulnerable) {
                            mob[i].force.x += knock.x;
                            mob[i].force.y += knock.y;
                        }
                        radius *= 0.95 //reduced range for each additional explosion target
                        damageScaler *= 0.87 //reduced damage for each additional explosion target
                    } else if (!mob[i].seePlayer.recall && dist < alertRange) {
                        mob[i].locatePlayer();
                        knock = Vector.mult(Vector.normalise(sub), -Math.sqrt(dmg * damageScaler) * mob[i].mass * (mob[i].isBoss ? 0 : 0.006 * reducedKnock));
                        if (tech.isStun) {
                            mobs.statusStun(mob[i], 30)
                        } else if (!mob[i].isInvulnerable) {
                            mob[i].force.x += knock.x;
                            mob[i].force.y += knock.y;
                        }
                    }
                }
            }
        }
    },
    pulse(charge, angle = m.angle, where = m.pos) {
        let best;
        let explosionRadius = 5.5 * charge
        let range = 5000
        const path = [{
            x: where.x + 20 * Math.cos(angle),
            y: where.y + 20 * Math.sin(angle)
        },
        {
            x: where.x + range * Math.cos(angle),
            y: where.y + range * Math.sin(angle)
        }
        ];
        //check for collisions
        best = {
            x: null,
            y: null,
            dist2: Infinity,
            who: null,
            v1: null,
            v2: null
        };
        if (!best.who) {
            best = vertexCollision(path[0], path[1], [mob, map, body]);
            if (best.dist2 != Infinity) { //if hitting something
                path[path.length - 1] = {
                    x: best.x,
                    y: best.y
                };
            }
        }
        if (best.who) {
            b.explosion(path[1], explosionRadius)
            const off = explosionRadius * 1.2
            b.explosion({
                x: path[1].x + off * (Math.random() - 0.5),
                y: path[1].y + off * (Math.random() - 0.5)
            }, explosionRadius)
            b.explosion({
                x: path[1].x + off * (Math.random() - 0.5),
                y: path[1].y + off * (Math.random() - 0.5)
            }, explosionRadius)
        }
        //draw laser beam
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        ctx.lineTo(path[1].x, path[1].y);
        if (charge > 50) {
            ctx.strokeStyle = "rgba(255,0,0,0.10)"
            ctx.lineWidth = 70
            ctx.stroke();
        }
        ctx.strokeStyle = "rgba(255,0,0,0.25)"
        ctx.lineWidth = 20
        ctx.stroke();
        ctx.strokeStyle = "#f00";
        ctx.lineWidth = 4
        ctx.stroke();

        //draw little dots along the laser path
        const sub = Vector.sub(path[1], path[0])
        const mag = Vector.magnitude(sub)
        for (let i = 0, len = Math.floor(mag * 0.0005 * charge); i < len; i++) {
            const dist = Math.random()
            simulation.drawList.push({
                x: path[0].x + sub.x * dist + 10 * (Math.random() - 0.5),
                y: path[0].y + sub.y * dist + 10 * (Math.random() - 0.5),
                radius: 1.5 + 5 * Math.random(),
                color: "rgba(255,0,0,0.5)",
                time: Math.floor(9 + 25 * Math.random() * Math.random())
            });
        }
    },
    clusterExplode(where, size) { //can occur after grenades detonate
        const cycle = () => {
            if (m.alive) {
                if (simulation.paused || m.isTimeDilated) {
                    requestAnimationFrame(cycle)
                } else {
                    count++
                    if (count < 84) requestAnimationFrame(cycle);
                    if (!(count % 7)) {
                        const unit = Vector.rotate({ x: 1, y: 0 }, 6.28 * Math.random())
                        b.explosion(Vector.add(where, Vector.mult(unit, size * (count * 0.01 + 0.03 * Math.random()))), size * (0.4 + Math.random() * 0.35), `hsla(${360 * Math.random()},100%,66%,0.6)`, 0.2); //makes bullet do explosive damage at end
                    }
                }
            }
        }
        let count = 7
        requestAnimationFrame(cycle);
    },
    starburst(where, size) { //can occur after grenades detonate
        const color = `hsla(${360 * Math.random()},100%,66%,0.6)`
        const cycle = () => {
            if (m.alive) {
                if (simulation.paused || m.isTimeDilated) {
                    requestAnimationFrame(cycle)
                } else {
                    count++
                    if (count < 21) requestAnimationFrame(cycle);
                    if (count % 2) {
                        const unit = Vector.rotate({
                            x: 1,
                            y: 0
                        }, curl * 6.28 * count / 18 + off)
                        b.explosion(Vector.add(where, Vector.mult(unit, size * 0.75)), size * 0.7, color, 0.5); //makes bullet do explosive damage at end
                    }
                }
            }
        }
        const off = 6 * Math.random()
        const curl = Math.random() < 0.5 ? -1 : 1;
        let count = 0
        requestAnimationFrame(cycle);
    },
    fireFlower(where, size) { //can occur after grenades detonate
        // size *= b.explosionRange()
        const range = size * Math.sqrt(b.explosionRange())
        const cycle = () => {
            if (m.alive) {
                if (simulation.paused || m.isTimeDilated) {
                    requestAnimationFrame(cycle)
                } else {
                    if (count < 30 && m.alive) requestAnimationFrame(cycle);
                    if (count === 0) {
                        const color = `hsla(${360 * Math.random()},100%,66%,0.6)`
                        b.explosion(where, size * 0.8, color, 0.5);
                    }
                    if (count === 8) {
                        const color = `hsla(${360 * Math.random()},100%,66%,0.6)`
                        for (let i = 0, len = 6; i < len; i++) {
                            const unit = Vector.rotate({
                                x: 1,
                                y: 0
                            }, 6.28 * i / len)
                            b.explosion(Vector.add(where, Vector.mult(unit, 1.1 * range)), size * 0.6, color, 0.5); //makes bullet do explosive damage at end
                        }
                    }
                    if (count === 16) {
                        const color = `hsla(${360 * Math.random()},100%,66%,0.6)`
                        for (let i = 0, len = 10; i < len; i++) {
                            const unit = Vector.rotate({
                                x: 1,
                                y: 0
                            }, 6.28 * i / len)
                            b.explosion(Vector.add(where, Vector.mult(unit, 1.4 * range)), size * 0.45, color, 0.5); //makes bullet do explosive damage at end
                        }
                    }
                    count++
                }
            }
        }
        let count = 0
        requestAnimationFrame(cycle);
    },
    grenadeEnd() {
        if (tech.isCircleExplode) {
            b.starburst(this.position, this.explodeRad)
        } else if (tech.isPetalsExplode) {
            b.fireFlower(this.position, this.explodeRad)
        } else if (tech.isClusterExplode) {
            b.clusterExplode(this.position, this.explodeRad)
        } else {
            b.explosion(this.position, this.explodeRad); //makes bullet do explosive damage at end
        }
        if (tech.fragments) b.targetedNail(this.position, tech.fragments * Math.floor(2 + 1.5 * Math.random()))
    },
    grenade() {

    },
    setGrenadeMode() {
        grenadeDefault = function (where = {
            x: m.pos.x + 30 * Math.cos(m.angle),
            y: m.pos.y + 30 * Math.sin(m.angle)
        }, angle = m.angle, size = 1) {
            const me = bullet.length;
            bullet[me] = Bodies.circle(where.x, where.y, 15, b.fireAttributes(angle, false));
            Matter.Body.setDensity(bullet[me], 0.0003);
            bullet[me].explodeRad = 300 * size + 100 * tech.isBlockExplode;
            bullet[me].onEnd = b.grenadeEnd
            bullet[me].minDmgSpeed = 1;
            bullet[me].beforeDmg = function () {
                this.endCycle = 0; //bullet ends cycle after doing damage  //this also triggers explosion
            };
            speed = m.crouch ? 43 : 32
            Matter.Body.setVelocity(bullet[me], {
                x: 0.5 * player.velocity.x + speed * Math.cos(angle),
                y: 0.5 * player.velocity.y + speed * Math.sin(angle)
            });
            bullet[me].endCycle = simulation.cycle + Math.floor(m.crouch ? 120 : 80) * tech.bulletsLastLonger;
            bullet[me].restitution = 0.4;
            bullet[me].do = function () {
                this.force.y += this.mass * 0.0025; //extra gravity for harder arcs
            };
            Composite.add(engine.world, bullet[me]); //add bullet to world
        }
        grenadeRPG = function (where = {
            x: m.pos.x + 30 * Math.cos(m.angle),
            y: m.pos.y + 30 * Math.sin(m.angle)
        }, angle = m.angle, size = 1) {
            const me = bullet.length;
            bullet[me] = Bodies.circle(where.x, where.y, 15, b.fireAttributes(angle, false));
            Matter.Body.setDensity(bullet[me], 0.0003);
            bullet[me].explodeRad = 300 * size + 100 * tech.isBlockExplode;
            bullet[me].onEnd = b.grenadeEnd
            bullet[me].minDmgSpeed = 1;
            bullet[me].beforeDmg = function () {
                this.endCycle = 0; //bullet ends cycle after doing damage  //this also triggers explosion
            };
            speed = m.crouch ? 46 : 32
            Matter.Body.setVelocity(bullet[me], {
                x: 0.8 * player.velocity.x + speed * Math.cos(angle),
                y: 0.5 * player.velocity.y + speed * Math.sin(angle)
            });
            Composite.add(engine.world, bullet[me]); //add bullet to world

            bullet[me].endCycle = simulation.cycle + 70 * tech.bulletsLastLonger;
            bullet[me].frictionAir = 0.07;
            const MAG = 0.015
            bullet[me].thrust = {
                x: bullet[me].mass * MAG * Math.cos(angle),
                y: bullet[me].mass * MAG * Math.sin(angle)
            }
            bullet[me].do = function () {
                this.force.x += this.thrust.x;
                this.force.y += this.thrust.y;
                if (Matter.Query.collides(this, map).length || Matter.Query.collides(this, body).length) {
                    this.endCycle = 0; //explode if touching map or blocks
                }
            };
        }
        grenadeRPGVacuum = function (where = {
            x: m.pos.x + 30 * Math.cos(m.angle),
            y: m.pos.y + 30 * Math.sin(m.angle)
        }, angle = m.angle, size = 1) {
            const me = bullet.length;
            bullet[me] = Bodies.circle(where.x, where.y, 15, b.fireAttributes(angle, false));
            Matter.Body.setDensity(bullet[me], 0.0003);
            bullet[me].explodeRad = 350 * size + Math.floor(Math.random() * 50) + tech.isBlockExplode * 100
            bullet[me].onEnd = b.grenadeEnd
            bullet[me].minDmgSpeed = 1;
            bullet[me].beforeDmg = function () {
                this.endCycle = 0; //bullet ends cycle after doing damage  //this also triggers explosion
            };
            speed = m.crouch ? 46 : 32
            Matter.Body.setVelocity(bullet[me], {
                x: 0.8 * player.velocity.x + speed * Math.cos(angle),
                y: 0.5 * player.velocity.y + speed * Math.sin(angle)
            });
            Composite.add(engine.world, bullet[me]); //add bullet to world
            bullet[me].endCycle = simulation.cycle + 70 * tech.bulletsLastLonger;
            bullet[me].frictionAir = 0.07;
            bullet[me].suckCycles = 40
            const MAG = 0.015
            bullet[me].thrust = {
                x: bullet[me].mass * MAG * Math.cos(angle),
                y: bullet[me].mass * MAG * Math.sin(angle)
            }
            bullet[me].suck = function () {
                const suck = (who, radius = this.explodeRad * 3.2) => {
                    for (i = 0, len = who.length; i < len; i++) {
                        const sub = Vector.sub(this.position, who[i].position);
                        const dist = Vector.magnitude(sub);
                        if (dist < radius && dist > 150 && !who.isInvulnerable && who[i] !== this) {
                            knock = Vector.mult(Vector.normalise(sub), mag * who[i].mass / Math.sqrt(dist));
                            who[i].force.x += knock.x;
                            who[i].force.y += knock.y;
                        }
                    }
                }
                let mag = 0.1
                if (simulation.cycle > this.endCycle - 5) {
                    mag = -0.22
                    suck(mob, this.explodeRad * 3)
                    suck(body, this.explodeRad * 2)
                    suck(powerUp, this.explodeRad * 1.5)
                    suck(bullet, this.explodeRad * 1.5)
                    suck([player], this.explodeRad * 1.3)
                } else {
                    mag = 0.11
                    suck(mob, this.explodeRad * 3)
                    suck(body, this.explodeRad * 2)
                    suck(powerUp, this.explodeRad * 1.5)
                    suck(bullet, this.explodeRad * 1.5)
                    suck([player], this.explodeRad * 1.3)
                }

                Matter.Body.setVelocity(this, { x: 0, y: 0 }); //keep bomb in place
                //draw suck
                const radius = 2.75 * this.explodeRad * (this.endCycle - simulation.cycle) / this.suckCycles
                ctx.fillStyle = "rgba(0,0,0,0.1)";
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, radius, 0, 2 * Math.PI);
                ctx.fill();
            }
            bullet[me].do = function () {
                if (simulation.cycle > this.endCycle - this.suckCycles) { //suck
                    this.do = this.suck
                } else if (Matter.Query.collides(this, map).length || Matter.Query.collides(this, body).length) {
                    Matter.Body.setPosition(this, Vector.sub(this.position, this.velocity)) //undo last movement
                    this.do = this.suck
                } else {
                    this.force.x += this.thrust.x;
                    this.force.y += this.thrust.y;
                }
            };
        }
        grenadeVacuum = function (where = {
            x: m.pos.x + 30 * Math.cos(m.angle),
            y: m.pos.y + 30 * Math.sin(m.angle)
        }, angle = m.angle, size = 1) {
            const me = bullet.length;
            bullet[me] = Bodies.circle(where.x, where.y, 20, b.fireAttributes(angle, false));
            Matter.Body.setDensity(bullet[me], 0.0002);
            bullet[me].explodeRad = 350 * size + Math.floor(Math.random() * 50) + tech.isBlockExplode * 100
            bullet[me].onEnd = b.grenadeEnd
            bullet[me].beforeDmg = function () {
                this.endCycle = 0; //bullet ends cycle after doing damage  //this also triggers explosion
            };
            bullet[me].restitution = 0.4;
            bullet[me].do = function () {
                this.force.y += this.mass * 0.0025; //extra gravity for harder arcs

                const suckCycles = 40
                if (simulation.cycle > this.endCycle - suckCycles) { //suck
                    const that = this

                    function suck(who, radius = that.explodeRad * 3.2) {
                        for (i = 0, len = who.length; i < len; i++) {
                            const sub = Vector.sub(that.position, who[i].position);
                            const dist = Vector.magnitude(sub);
                            if (dist < radius && dist > 150 && !who.isInvulnerable) {
                                knock = Vector.mult(Vector.normalise(sub), mag * who[i].mass / Math.sqrt(dist));
                                who[i].force.x += knock.x;
                                who[i].force.y += knock.y;
                            }
                        }
                    }
                    let mag = 0.1
                    if (simulation.cycle > this.endCycle - 5) {
                        mag = -0.22
                        suck(mob, this.explodeRad * 3)
                        suck(body, this.explodeRad * 2)
                        suck(powerUp, this.explodeRad * 1.5)
                        suck(bullet, this.explodeRad * 1.5)
                        suck([player], this.explodeRad * 1.3)
                    } else {
                        mag = 0.11
                        suck(mob, this.explodeRad * 3)
                        suck(body, this.explodeRad * 2)
                        suck(powerUp, this.explodeRad * 1.5)
                        suck(bullet, this.explodeRad * 1.5)
                        suck([player], this.explodeRad * 1.3)
                    }
                    //keep bomb in place
                    Matter.Body.setVelocity(this, {
                        x: 0,
                        y: 0
                    });
                    //draw suck
                    const radius = 2.75 * this.explodeRad * (this.endCycle - simulation.cycle) / suckCycles
                    ctx.fillStyle = "rgba(0,0,0,0.1)";
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, radius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            };
            speed = 35
            // speed = m.crouch ? 43 : 32

            bullet[me].endCycle = simulation.cycle + 70 * tech.bulletsLastLonger;
            if (m.crouch) {
                speed += 9
                bullet[me].endCycle += 20;
            }
            Matter.Body.setVelocity(bullet[me], {
                x: 0.5 * player.velocity.x + speed * Math.cos(angle),
                y: 0.5 * player.velocity.y + speed * Math.sin(angle)
            });
            Composite.add(engine.world, bullet[me]); //add bullet to world
        }

        grenadeNeutron = function (where = { x: m.pos.x + 30 * Math.cos(m.angle), y: m.pos.y + 30 * Math.sin(m.angle) }, angle = m.angle, size = 1) {
            const me = bullet.length;
            bullet[me] = Bodies.polygon(where.x, where.y, 10, 4, b.fireAttributes(angle, false));
            b.fireProps((m.crouch ? 45 : 25) / Math.pow(0.92, tech.missileCount), m.crouch ? 35 : 20, angle, me); //cd , speed
            Matter.Body.setDensity(bullet[me], 0.000001);
            bullet[me].endCycle = 500 + simulation.cycle;
            bullet[me].frictionAir = 0;
            bullet[me].friction = 1;
            bullet[me].frictionStatic = 1;
            bullet[me].restitution = 0;
            bullet[me].minDmgSpeed = 0;
            bullet[me].damageRadius = 100;
            bullet[me].maxDamageRadius = 450 * size + 130 * tech.isNeutronSlow //+ 150 * Math.random()
            bullet[me].radiusDecay = (0.81 + 0.15 * tech.isNeutronSlow) / tech.bulletsLastLonger
            bullet[me].stuckTo = null;
            bullet[me].stuckToRelativePosition = null;
            if (tech.isRPG) {
                const SCALE = 2
                Matter.Body.scale(bullet[me], SCALE, SCALE);
                speed = m.crouch ? 25 : 15
                // speed = m.crouch ? 43 : 32
                Matter.Body.setVelocity(bullet[me], { x: 0.5 * player.velocity.x + speed * Math.cos(angle), y: 0.5 * player.velocity.y + speed * Math.sin(angle) });
                const MAG = 0.005
                bullet[me].thrust = { x: bullet[me].mass * MAG * Math.cos(angle), y: bullet[me].mass * MAG * Math.sin(angle) }
            }

            bullet[me].beforeDmg = function () { };
            bullet[me].stuck = function () { };
            bullet[me].do = function () {
                const onCollide = () => {
                    this.collisionFilter.mask = 0; //non collide with everything
                    Matter.Body.setVelocity(this, { x: 0, y: 0 });
                    if (tech.isRPG) this.thrust = { x: 0, y: 0 }
                    this.do = this.radiationMode;
                }
                const mobCollisions = Matter.Query.collides(this, mob)
                if (mobCollisions.length) {
                    onCollide()
                    this.stuckTo = mobCollisions[0].bodyA
                    mobs.statusDoT(this.stuckTo, 0.6, 360) //apply radiation damage status effect on direct hits
                    if (this.stuckTo.isVerticesChange) {
                        this.stuckToRelativePosition = { x: 0, y: 0 }
                    } else {
                        //find the relative position for when the mob is at angle zero by undoing the mobs rotation
                        this.stuckToRelativePosition = Vector.rotate(Vector.sub(this.position, this.stuckTo.position), -this.stuckTo.angle)
                    }
                    this.stuck = function () {
                        if (this.stuckTo && this.stuckTo.alive) {
                            const rotate = Vector.rotate(this.stuckToRelativePosition, this.stuckTo.angle) //add in the mob's new angle to the relative position vector
                            Matter.Body.setPosition(this, Vector.add(Vector.add(rotate, this.stuckTo.velocity), this.stuckTo.position))
                            Matter.Body.setVelocity(this, this.stuckTo.velocity); //so that it will move properly if it gets unstuck
                        } else {
                            this.collisionFilter.mask = cat.map | cat.body | cat.player | cat.mob; //non collide with everything but map
                            this.stuck = function () {
                                this.force.y += this.mass * 0.001;
                            }
                        }
                    }
                } else {
                    const bodyCollisions = Matter.Query.collides(this, body)
                    if (bodyCollisions.length) {
                        if (!bodyCollisions[0].bodyA.isNotHoldable) {
                            onCollide()
                            this.stuckTo = bodyCollisions[0].bodyA
                            //find the relative position for when the mob is at angle zero by undoing the mobs rotation
                            this.stuckToRelativePosition = Vector.rotate(Vector.sub(this.position, this.stuckTo.position), -this.stuckTo.angle)
                        } else {
                            this.do = this.radiationMode;
                        }
                        this.stuck = function () {
                            if (this.stuckTo) {
                                const rotate = Vector.rotate(this.stuckToRelativePosition, this.stuckTo.angle) //add in the mob's new angle to the relative position vector
                                Matter.Body.setPosition(this, Vector.add(Vector.add(rotate, this.stuckTo.velocity), this.stuckTo.position))
                                // Matter.Body.setVelocity(this, this.stuckTo.velocity); //so that it will move properly if it gets unstuck
                            } else {
                                this.force.y += this.mass * 0.001;
                            }
                        }
                    } else {
                        if (Matter.Query.collides(this, map).length) {
                            onCollide()
                        } else if (tech.isRPG) { //if colliding with nothing
                            this.force.x += this.thrust.x;
                            this.force.y += this.thrust.y;
                        } else {
                            this.force.y += this.mass * 0.001;
                        }
                    }
                }
            }
            bullet[me].radiationMode = function () { //the do code after the bullet is stuck on something,  projects a damaging radiation field
                this.stuck(); //runs different code based on what the bullet is stuck to
                this.damageRadius = this.damageRadius * 0.85 + 0.15 * this.maxDamageRadius //smooth radius towards max
                this.maxDamageRadius -= this.radiusDecay
                if (this.damageRadius < 15) {
                    this.endCycle = 0;
                } else {
                    //aoe damage to player
                    if (Vector.magnitude(Vector.sub(player.position, this.position)) < this.damageRadius) {
                        const DRAIN = (tech.isRadioactiveResistance ? 0.0025 * 0.2 : 0.0025)
                        if (m.energy > DRAIN) {
                            if (m.immuneCycle < m.cycle) m.energy -= DRAIN
                        } else {
                            m.energy = 0;
                            m.takeDamage((tech.isRadioactiveResistance ? 0.00016 * 0.2 : 0.00016) * tech.radioactiveDamage * spawn.dmgToPlayerByLevelsCleared()) //0.00015
                        }
                    }
                    //aoe damage to mobs
                    let dmg = 0.15 * tech.radioactiveDamage
                    for (let i = 0, len = mob.length; i < len; i++) {
                        if (Vector.magnitude(Vector.sub(mob[i].position, this.position)) < this.damageRadius + mob[i].radius) {
                            if (Matter.Query.ray(map, mob[i].position, this.position).length > 0) dmg *= 0.2 //reduce damage if a wall is in the way
                            mob[i].damage(mob[i].shield ? dmg * 3 : dmg);
                            mob[i].locatePlayer();
                            if (tech.isNeutronSlow && mob[i].speed > 4) {
                                Matter.Body.setVelocity(mob[i], { x: mob[i].velocity.x * 0.97, y: mob[i].velocity.y * 0.97 });
                            }
                        }
                    }
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.damageRadius, 0, 2 * Math.PI);
                    ctx.globalCompositeOperation = "lighter"
                    ctx.fillStyle = `rgba(25,139,170,${0.2 + 0.06 * Math.random()})`;
                    ctx.fill();
                    ctx.globalCompositeOperation = "source-over"
                    if (tech.isNeutronSlow) {
                        let slow = (who, radius = this.explodeRad * 3.2) => {
                            for (i = 0, len = who.length; i < len; i++) {
                                const sub = Vector.sub(this.position, who[i].position);
                                const dist = Vector.magnitude(sub);
                                if (dist < radius) {
                                    Matter.Body.setVelocity(who[i], { x: who[i].velocity.x * 0.975, y: who[i].velocity.y * 0.975 });
                                }
                            }
                        }
                        slow(body, this.damageRadius)
                        slow([player], this.damageRadius)
                    }
                }
            }
        }

        if (tech.isNeutronBomb) {
            b.grenade = grenadeNeutron
            if (tech.isRPG) {
                b.guns[5].do = function () { }
            } else {
                b.guns[5].do = function () {
                    if (!input.field && m.crouch) {
                        const cycles = 80
                        const speed = m.crouch ? 35 : 20 //m.crouch ? 43 : 32
                        const g = m.crouch ? 0.137 : 0.135
                        const v = {
                            x: speed * Math.cos(m.angle),
                            y: speed * Math.sin(m.angle)
                        }
                        ctx.strokeStyle = "rgba(68, 68, 68, 0.2)" //color.map
                        ctx.lineWidth = 2
                        ctx.beginPath()
                        for (let i = 1, len = 19; i < len + 1; i++) {
                            const time = cycles * i / len
                            ctx.lineTo(m.pos.x + time * v.x, m.pos.y + time * v.y + g * time * time)
                        }
                        ctx.stroke()
                    }
                }
            }
        } else if (tech.isRPG) {
            b.guns[5].do = function () { }
            if (tech.isVacuumBomb) {
                b.grenade = grenadeRPGVacuum
            } else {
                b.grenade = grenadeRPG
            }
        } else if (tech.isVacuumBomb) {
            b.grenade = grenadeVacuum
            b.guns[5].do = function () {
                if (!input.field && m.crouch) {
                    const cycles = Math.floor(m.crouch ? 50 : 30) //30
                    const speed = m.crouch ? 44 : 35
                    const v = { x: speed * Math.cos(m.angle), y: speed * Math.sin(m.angle) }
                    ctx.strokeStyle = "rgba(68, 68, 68, 0.2)" //color.map
                    ctx.lineWidth = 2
                    ctx.beginPath()
                    for (let i = 1.6, len = 19; i < len + 1; i++) {
                        const time = cycles * i / len
                        ctx.lineTo(m.pos.x + time * v.x, m.pos.y + time * v.y + 0.34 * time * time)
                    }
                    ctx.stroke()
                }
            }
        } else {
            b.grenade = grenadeDefault
            b.guns[5].do = function () {
                if (!input.field && m.crouch) {
                    const cycles = Math.floor(m.crouch ? 120 : 80) //30
                    const speed = m.crouch ? 43 : 32
                    const v = { x: speed * Math.cos(m.angle), y: speed * Math.sin(m.angle) } //m.Vy / 2 + removed to make the path less jerky
                    ctx.strokeStyle = "rgba(68, 68, 68, 0.2)" //color.map
                    ctx.lineWidth = 2
                    ctx.beginPath()
                    for (let i = 0.5, len = 19; i < len + 1; i++) {
                        const time = cycles * i / len
                        ctx.lineTo(m.pos.x + time * v.x, m.pos.y + time * v.y + 0.34 * time * time)
                    }
                    ctx.stroke()
                }
            }
        }
    },
    grapple(where, angle = m.angle) {
        const me = bullet.length;
        const returnRadius = 100
        bullet[me] = Bodies.fromVertices(where.x, where.y, [{
            x: -40,
            y: 2,
            index: 0,
            isInternal: false
        }, {
            x: -40,
            y: -2,
            index: 1,
            isInternal: false
        }, {
            x: 37,
            y: -2,
            index: 2,
            isInternal: false
        }, {
            x: 40,
            y: -1,
            index: 3,
            isInternal: false
        }, {
            x: 37,
            y: 3,
            index: 4,
            isInternal: false
        }],
            {
                angle: angle,
                friction: 1,
                frictionAir: 0.4,
                thrustMag: 0.17,
                dmg: 7, //damage done in addition to the damage from momentum
                classType: "bullet",
                endCycle: simulation.cycle + 70,
                isSlowPull: false,
                drawStringControlMagnitude: 1000 + 1000 * Math.random(),
                drawStringFlip: (Math.round(Math.random()) ? 1 : -1),
                attached: false,
                glowColor: tech.hookNails ? "rgba(200,0,0,0.07)" : tech.isHarmReduce ? "rgba(50,100,255,0.1)" : "rgba(0,200,255,0.07)",
                collisionFilter: {
                    category: cat.bullet,
                    mask: tech.isShieldPierce ? cat.body | cat.mob | cat.mobBullet : cat.body | cat.mob | cat.mobBullet | cat.mobShield,
                },
                minDmgSpeed: 4,
                // lookFrequency: Math.floor(7 + Math.random() * 3),
                density: 0.004, //0.001 is normal for blocks,  0.004 is normal for harpoon
                drain: 0.001,
                powerUpDamage: tech.isHarpoonPowerUp && simulation.cycle - 480 < tech.harpoonPowerUpCycle,
                draw() {
                    // draw rope
                    const where = { x: m.pos.x + 30 * Math.cos(m.angle), y: m.pos.y + 30 * Math.sin(m.angle) }
                    const sub = Vector.sub(where, this.vertices[0])
                    ctx.strokeStyle = "#000" // "#0ce"
                    ctx.lineWidth = 0.5
                    ctx.beginPath();
                    ctx.moveTo(where.x, where.y);
                    if (this.attached) {
                        const controlPoint = Vector.add(where, Vector.mult(sub, -0.5))
                        ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, this.vertices[0].x, this.vertices[0].y)
                    } else {
                        const long = Math.max(Vector.magnitude(sub), 60)
                        const perpendicular = Vector.mult(Vector.normalise(Vector.perp(sub)), this.drawStringFlip * Math.min(0.7 * long, 10 + this.drawStringControlMagnitude / (10 + Vector.magnitude(sub))))
                        const controlPoint = Vector.add(Vector.add(where, Vector.mult(sub, -0.5)), perpendicular)
                        ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, this.vertices[0].x, this.vertices[0].y)
                    }
                    // ctx.lineTo(this.vertices[0].x, this.vertices[0].y);
                    // ctx.stroke();
                    ctx.strokeStyle = this.glowColor // "#0ce"
                    ctx.lineWidth = 10
                    ctx.stroke();
                    ctx.strokeStyle = "#000" // "#0ce"
                    ctx.lineWidth = 0.5
                    ctx.stroke();

                    if (this.powerUpDamage) {
                        ctx.beginPath();
                        ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
                        ctx.lineTo(this.vertices[1].x, this.vertices[1].y);
                        ctx.lineTo(this.vertices[2].x, this.vertices[2].y);
                        ctx.lineTo(this.vertices[3].x, this.vertices[3].y);
                        ctx.lineTo(this.vertices[4].x, this.vertices[4].y);
                        ctx.lineJoin = "miter"
                        ctx.miterLimit = 30;
                        ctx.lineWidth = 25;
                        ctx.strokeStyle = "rgba(0,255,255,0.4)";
                        ctx.stroke();
                        ctx.lineWidth = 8;
                        ctx.strokeStyle = "rgb(0,255,255)";
                        ctx.stroke();
                        ctx.lineJoin = "round"
                        ctx.miterLimit = 5
                        ctx.fillStyle = "#000"
                        ctx.fill();
                    }
                    //draw hook
                    ctx.beginPath();
                    ctx.lineTo(this.vertices[0].x, this.vertices[0].y);
                    const spike = Vector.add(this.vertices[3], Vector.mult(Vector.sub(this.vertices[3], this.vertices[2]), 2))
                    ctx.moveTo(this.vertices[2].x, this.vertices[2].y);
                    ctx.lineTo(spike.x, spike.y);
                    ctx.lineTo(this.vertices[1].x, this.vertices[1].y);
                    ctx.fillStyle = '#000'
                    ctx.fill();
                },
                beforeDmg(who) {
                    if (tech.isShieldPierce && who.isShielded) { //disable shields
                        who.isShielded = false
                        requestAnimationFrame(() => { who.isShielded = true });
                    }
                    if (m.fieldCDcycle < m.cycle + 30) m.fieldCDcycle = m.cycle + 30  //extra long cooldown on hitting mobs
                    if (tech.hookNails) {
                        // if (m.immuneCycle < m.cycle + m.collisionImmuneCycles) m.immuneCycle = m.cycle + 5; //player is immune to damage for 5 cycles
                        // b.explosion(this.position, 300 + 150 * Math.random()); //makes bullet do explosive damage at end
                        b.targetedNail(this.position, tech.hookNails)
                        const ANGLE = 2 * Math.PI * Math.random() //make a few random ones
                        for (let i = 0; i < 4; i++) b.nail(this.position, { x: 10.5 * Math.cos(ANGLE), y: 10.5 * Math.sin(ANGLE) }, 1.2)
                    }
                    // if (this.powerUpDamage) this.density = 2 * 0.004 //double damage after pick up power up for 8 seconds


                    if (tech.isHarpoonPowerUp && simulation.cycle - 480 < tech.harpoonPowerUpCycle) {
                        Matter.Body.setDensity(this, 1.8 * 0.004); //+90% damage after pick up power up for 8 seconds
                    } else if (tech.isHarpoonFullHealth && who.health === 1) {
                        Matter.Body.setDensity(this, 2.11 * 0.004); //+90% damage if mob has full health do
                        simulation.ephemera.push({
                            name: "grapple outline",
                            count: 3, //cycles before it self removes
                            vertices: this.vertices,
                            do() {
                                this.count--
                                if (this.count < 0) simulation.removeEphemera(this.name)

                                ctx.beginPath();
                                ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
                                for (let j = 1, len = this.vertices.length; j < len; j += 1) ctx.lineTo(this.vertices[j].x, this.vertices[j].y);
                                ctx.lineTo(this.vertices[0].x, this.vertices[0].y);
                                ctx.lineJoin = "miter"
                                ctx.miterLimit = 20;
                                ctx.lineWidth = 40;
                                ctx.strokeStyle = "rgba(255,0,100,0.35)";
                                ctx.stroke();
                                ctx.lineWidth = 10;
                                ctx.strokeStyle = `#f07`;
                                ctx.stroke();
                                ctx.lineJoin = "round"
                                ctx.miterLimit = 5
                                ctx.fillStyle = "#000"
                                ctx.fill();
                            },
                        })
                    }


                    this.retract()
                },
                caughtPowerUp: null,
                dropCaughtPowerUp() {
                    if (this.caughtPowerUp) {
                        this.caughtPowerUp.collisionFilter.category = cat.powerUp
                        this.caughtPowerUp.collisionFilter.mask = cat.map | cat.powerUp
                        this.caughtPowerUp = null
                    }
                },
                onEnd() {
                    if (this.caughtPowerUp && !simulation.isChoosing && (this.caughtPowerUp.name !== "heal" || m.health !== m.maxHealth || tech.isOverHeal)) {
                        let index = null //find index
                        for (let i = 0, len = powerUp.length; i < len; ++i) {
                            if (powerUp[i] === this.caughtPowerUp) index = i
                        }
                        if (index !== null) {
                            powerUps.onPickUp(this.caughtPowerUp);
                            this.caughtPowerUp.effect();
                            Matter.Composite.remove(engine.world, this.caughtPowerUp);
                            powerUp.splice(index, 1);
                            if (tech.isHarpoonPowerUp) tech.harpoonPowerUpCycle = simulation.cycle
                        } else {
                            this.dropCaughtPowerUp()
                        }
                    } else {
                        this.dropCaughtPowerUp()
                    }
                },
                retract() {
                    this.attached = false
                    this.do = this.returnToPlayer
                    this.endCycle = simulation.cycle + 60
                    Matter.Body.setDensity(this, 0.0005); //reduce density on return
                    if (this.angularSpeed < 0.5) this.torque += this.inertia * 0.001 * (Math.random() - 0.5) //(Math.round(Math.random()) ? 1 : -1)
                    this.collisionFilter.mask = 0//cat.map | cat.mob | cat.mobBullet | cat.mobShield // | cat.body
                    //recoil on pulling grapple back
                    // if (this.pickUpTarget.mass) console.log(this.pickUpTarget.mass)
                    const mag = this.pickUpTarget ? Math.min(5, Math.max(this.pickUpTarget.mass, 0.5)) : 0.5
                    const unit = Vector.normalise(Vector.sub(this.position, m.pos))
                    const momentum = Vector.mult(unit, mag * (m.crouch ? 0.1 : 0.2))
                    player.force.x += momentum.x
                    player.force.y += momentum.y
                },
                returnToPlayer() {
                    if (m.fieldCDcycle < m.cycle + 5) m.fieldCDcycle = m.cycle + 5
                    if (Vector.magnitude(Vector.sub(this.position, m.pos)) < returnRadius) { //near player
                        this.endCycle = 0;

                        //recoil on catching grapple
                        // const momentum = Vector.mult(Vector.sub(this.velocity, player.velocity), (m.crouch ? 0.0001 : 0.0002))
                        const unit = Vector.normalise(Vector.sub(this.velocity, player.velocity))
                        const momentum = Vector.mult(unit, (m.crouch ? 0.0001 : 0.0002))
                        player.force.x += momentum.x
                        player.force.y += momentum.y
                        if (this.pickUpTarget) {
                            if (tech.isReel && this.blockDist > 150) {
                                // console.log(0.0003 * Math.min(this.blockDist, 1000))
                                m.energy += 0.00113 * Math.min(this.blockDist, 800) * level.isReducedRegen //max 0.352 energy
                                simulation.drawList.push({ //add dmg to draw queue
                                    x: m.pos.x,
                                    y: m.pos.y,
                                    radius: 10,
                                    color: m.fieldMeterColor,
                                    time: simulation.drawTime
                                });
                            }
                            m.holdingTarget = this.pickUpTarget
                            // give block to player after it returns
                            m.isHolding = true;
                            //conserve momentum when player mass changes
                            const blockMass = Math.min(5, this.pickUpTarget.mass)
                            const grappleMomentum = Vector.mult(Vector.normalise(this.velocity), 15 * blockMass)
                            const playerMomentum = Vector.mult(player.velocity, player.mass)
                            totalMomentum = Vector.add(playerMomentum, grappleMomentum)
                            Matter.Body.setVelocity(player, Vector.mult(totalMomentum, 1 / (m.defaultMass + blockMass)));

                            m.definePlayerMass(m.defaultMass + this.pickUpTarget.mass * m.holdingMassScale)
                            //make block collide with nothing
                            m.holdingTarget.collisionFilter.category = 0;
                            m.holdingTarget.collisionFilter.mask = 0;
                            this.pickUpTarget = null
                        }
                    } else {
                        if (m.energy > this.drain) m.energy -= this.drain
                        const sub = Vector.sub(this.position, m.pos)
                        const rangeScale = 1 + 0.000003 * Vector.magnitude(sub)  //return faster when far from player
                        const returnForce = Vector.mult(Vector.normalise(sub), rangeScale * this.thrustMag * this.mass)
                        this.force.x -= returnForce.x
                        this.force.y -= returnForce.y
                        this.grabPowerUp()
                        this.grabBlocks()
                    }
                    this.draw();
                },
                destroyBlocks() {//not used?
                    const blocks = Matter.Query.collides(this, body)
                    if (blocks.length && !blocks[0].bodyA.isNotHoldable) {
                        if (blocks[0].bodyA.mass > 2.5) this.retract()
                        const block = blocks[0].bodyA.vertices
                        Composite.remove(engine.world, blocks[0].bodyA)
                        body.splice(body.indexOf(blocks[0].bodyA), 1)
                        //animate the block fading away
                        simulation.ephemera.push({
                            name: "blockFadeOut",
                            count: 25, //cycles before it self removes
                            do() {
                                this.count--
                                if (this.count < 0) simulation.removeEphemera(this.name)
                                ctx.beginPath();
                                ctx.moveTo(block[0].x, block[0].y);
                                for (let j = 1; j < block.length; j++) ctx.lineTo(block[j].x, block[j].y);
                                ctx.lineTo(block[0].x, block[0].y);
                                ctx.lineWidth = 2;
                                ctx.strokeStyle = `rgba(0,0,0,${this.count / 25})`
                                ctx.stroke();
                            },
                        })
                    }
                },
                pickUpTarget: null,
                grabBlocks() {
                    if (this.pickUpTarget) { //if always attached to a block
                        //position block on hook
                        Matter.Body.setPosition(this.pickUpTarget, Vector.add(this.vertices[2], this.velocity))
                        Matter.Body.setVelocity(this.pickUpTarget, { x: 0, y: 0 })
                    } else {
                        const blocks = Matter.Query.collides(this, body)
                        if (blocks.length) {
                            for (let i = 0; i < blocks.length; i++) {
                                if (blocks[i].bodyA.classType === "body" && !blocks[i].bodyA.isNotHoldable && blocks[0].bodyA.mass < 40) {
                                    this.retract()
                                    if (tech.hookNails) {
                                        b.targetedNail(this.position, 3 * tech.hookNails)
                                        const ANGLE = 2 * Math.PI * Math.random() //make a few random ones
                                        for (let i = 0; i < 13; i++) b.nail(this.position, { x: 10.5 * Math.cos(ANGLE), y: 10.5 * Math.sin(ANGLE) }, 1.2)

                                        const blockVertices = blocks[i].bodyA.vertices
                                        Composite.remove(engine.world, blocks[i].bodyA)
                                        body.splice(body.indexOf(blocks[i].bodyA), 1)
                                        //animate the block fading away
                                        simulation.ephemera.push({
                                            name: "blockFadeOut",
                                            count: 25, //cycles before it self removes
                                            do() {
                                                this.count--
                                                if (this.count < 0) simulation.removeEphemera(this.name)
                                                ctx.beginPath();
                                                ctx.moveTo(blockVertices[0].x, blockVertices[0].y);
                                                for (let j = 1; j < blockVertices.length; j++) ctx.lineTo(blockVertices[j].x, blockVertices[j].y);
                                                ctx.lineTo(blockVertices[0].x, blockVertices[0].y);
                                                ctx.lineWidth = 2;
                                                ctx.strokeStyle = `rgba(0,0,0,${this.count / 25})`
                                                ctx.stroke();
                                            },
                                        })
                                    } else {
                                        this.pickUpTarget = blocks[i].bodyA
                                        this.blockDist = Vector.magnitude(Vector.sub(this.pickUpTarget.position, m.pos))
                                    }
                                }
                            }
                        }
                    }
                },
                grabPowerUp() { //grab power ups near the tip of the harpoon
                    if (this.caughtPowerUp) {
                        Matter.Body.setPosition(this.caughtPowerUp, Vector.add(this.vertices[2], this.velocity))
                        Matter.Body.setVelocity(this.caughtPowerUp, { x: 0, y: 0 })
                    } else {
                        for (let i = 0, len = powerUp.length; i < len; ++i) {
                            if (tech.isEnergyNoAmmo && powerUp[i].name === "ammo") continue
                            const radius = powerUp[i].circleRadius + 50
                            if (Vector.magnitudeSquared(Vector.sub(this.vertices[2], powerUp[i].position)) < radius * radius) {
                                if (powerUp[i].name !== "heal" || m.health !== m.maxHealth || tech.isOverHeal) {
                                    this.caughtPowerUp = powerUp[i]
                                    Matter.Body.setVelocity(powerUp[i], { x: 0, y: 0 })
                                    Matter.Body.setPosition(powerUp[i], this.vertices[2])
                                    powerUp[i].collisionFilter.category = 0
                                    powerUp[i].collisionFilter.mask = 0
                                    this.thrustMag *= 0.6
                                    this.endCycle += 0.5 //it pulls back slower, so this prevents it from ending early
                                    // this.retract()
                                    break //just pull 1 power up if possible
                                }
                            }
                        }
                    }
                    m.grabPowerUp();
                },
                do() {
                    if (m.fieldCDcycle < m.cycle + 5) m.fieldCDcycle = m.cycle + 5
                    if (input.field) {
                        this.grabBlocks()
                        this.grabPowerUp()
                    } else {
                        this.retract()
                    }
                    //grappling hook
                    if (input.field && Matter.Query.collides(this, map).length) {
                        Matter.Body.setPosition(this, Vector.add(this.position, { x: -20 * Math.cos(this.angle), y: -20 * Math.sin(this.angle) }))
                        if (Matter.Query.collides(this, map).length) {
                            if (tech.hookNails) {
                                b.targetedNail(this.position, tech.hookNails)
                                const ANGLE = 2 * Math.PI * Math.random() //make a few random ones
                                for (let i = 0; i < 4; i++) b.nail(this.position, { x: 10.5 * Math.cos(ANGLE), y: 10.5 * Math.sin(ANGLE) }, 1.2)

                            }
                            this.attached = true
                            Matter.Body.setVelocity(this, { x: 0, y: 0 });
                            Matter.Sleeping.set(this, true)
                            this.endCycle = simulation.cycle + 5
                            this.do = () => {
                                if (m.fieldCDcycle < m.cycle + 5) m.fieldCDcycle = m.cycle + 5
                                this.grabPowerUp()

                                //between player nose and the grapple
                                const sub = Vector.sub(this.vertices[0], { x: m.pos.x + 30 * Math.cos(m.angle), y: m.pos.y + 30 * Math.sin(m.angle) })
                                let dist = Vector.magnitude(sub)
                                if (input.field) {
                                    this.endCycle = simulation.cycle + 10
                                    if (input.down) { //down
                                        this.isSlowPull = true
                                        dist = 0
                                        player.force.y += 3 * player.mass * simulation.g; //adjust this to control fall rate while hooked and pressing down
                                    } else if (input.up) {
                                        this.isSlowPull = false
                                        player.force.y -= player.mass * simulation.g; //adjust this to control fall rate while hooked and pressing down
                                    }
                                    if (m.energy < this.drain) this.isSlowPull = true

                                    // pulling friction that allowed a slight swinging, but has high linear pull at short dist
                                    const drag = 1 - 30 / Math.min(Math.max(100, dist), 700) - 0.1 * (player.speed > 66)
                                    Matter.Body.setVelocity(player, { x: player.velocity.x * drag, y: player.velocity.y * drag });
                                    const pull = Vector.mult(Vector.normalise(sub), 0.0004 * Math.min(Math.max(15, dist), this.isSlowPull ? 70 : 200))
                                    //original pulling force with high friction and very linear pull
                                    // Matter.Body.setVelocity(player, { x: player.velocity.x * 0.85, y: player.velocity.y * 0.85 });
                                    // const pull = Vector.mult(Vector.normalise(sub), 0.0008 * Math.min(Math.max(15, dist), this.isSlowPull ? 100 : 200))

                                    player.force.x += pull.x
                                    player.force.y += pull.y
                                    if (dist > 500) m.energy -= this.drain
                                } else {
                                    Matter.Sleeping.set(this, false)
                                    this.retract()
                                }
                                this.draw();
                            }
                        }
                    }
                    this.force.x += this.thrustMag * this.mass * Math.cos(this.angle);
                    this.force.y += this.thrustMag * this.mass * Math.sin(this.angle);
                    this.draw()
                },
            });
        Composite.add(engine.world, bullet[me]); //add bullet to world
        Matter.Body.setVelocity(bullet[me], player.velocity); //set velocity in direction of player
    },
    harpoon(where, target, angle = m.angle, harpoonSize = 1, isReturn = false, totalCycles = 35, isReturnAmmo = true, thrust = 0.1) {
        const me = bullet.length;
        const returnRadius = 100 * Math.sqrt(harpoonSize)
        let shape
        if (tech.isRebar) {
            const long = tech.isMaul ? 32 : 65
            const tall = tech.isMaul ? 25 : 5
            shape = [{
                x: -long * harpoonSize,
                y: tall * harpoonSize,
                index: 0,
                isInternal: false
            }, {
                x: -long * harpoonSize * 1.05,
                y: 0,
                index: 1,
                isInternal: false
            }, {
                x: -long * harpoonSize,
                y: -tall * harpoonSize,
                index: 2,
                isInternal: false
            }, {
                x: long * harpoonSize,
                y: -tall * harpoonSize,
                index: 3,
                isInternal: false
            }, {
                x: long * harpoonSize * 1.05,
                y: 0,
                index: 4,
                isInternal: false
            }, {
                x: long * harpoonSize,
                y: tall * harpoonSize,
                index: 5,
                isInternal: false
            }]
        } else {
            shape = [{
                x: -40 * harpoonSize,
                y: 2 * harpoonSize,
                index: 0,
                isInternal: false
            }, {
                x: -40 * harpoonSize,
                y: -2 * harpoonSize,
                index: 1,
                isInternal: false
            }, {
                x: 50 * harpoonSize,
                y: -3 * harpoonSize,
                index: 3,
                isInternal: false
            }, {
                x: 30 * harpoonSize,
                y: 2 * harpoonSize,
                index: 4,
                isInternal: false
            }]
        }


        bullet[me] = Bodies.fromVertices(where.x, where.y, shape, {
            cycle: 0,
            angle: angle,
            friction: 1,
            frictionAir: 0.4,
            // thrustMag: 0.1,
            drain: tech.isRailEnergy ? 0.0002 : 0.006,
            turnRate: isReturn ? 0.1 : 0.03, //0.015
            drawStringControlMagnitude: 3000 + 5000 * Math.random(),
            drawStringFlip: (Math.round(Math.random()) ? 1 : -1),
            dmg: 6, //damage done in addition to the damage from momentum
            classType: "bullet",
            endCycle: simulation.cycle + totalCycles * 2.5 + 40,
            collisionFilter: {
                category: cat.bullet,
                mask: tech.isShieldPierce ? cat.map | cat.body | cat.mob | cat.mobBullet : cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield,
            },
            minDmgSpeed: 4,
            lookFrequency: Math.floor(7 + Math.random() * 3),
            density: tech.harpoonDensity * (tech.isRebar ? 0.6 : 1), //0.001 is normal for blocks,  0.004 is normal for harpoon,  0.004*6 when buffed
            foamSpawned: 0,
            beforeDmg(who) {
                if (tech.isShieldPierce && who.isShielded) { //disable shields
                    who.isShielded = false
                    requestAnimationFrame(() => {
                        who.isShielded = true
                    });
                }
                if (tech.fragments) {
                    b.targetedNail(this.vertices[2], tech.fragments * Math.floor(2 + Math.random()))
                    if (!isReturn) this.endCycle = 0;
                }
                if (!who.isBadTarget) {
                    if (isReturn) {
                        this.do = this.returnToPlayer
                    } else {
                        this.frictionAir = 0.01
                        this.do = () => {
                            this.force.y += this.mass * 0.003; //gravity
                            this.draw();
                        }
                    }
                }
                if (tech.isFoamBall && this.foamSpawned < 55) {
                    for (let i = 0, len = Math.min(30, 2 + 3 * Math.sqrt(this.mass)); i < len; i++) {
                        const radius = 5 + 9 * Math.random()
                        const velocity = { x: Math.max(0.5, 2 - radius * 0.1), y: 0 }
                        b.foam(this.position, Vector.rotate(velocity, 6.28 * Math.random()), radius)
                        this.foamSpawned++
                    }
                }
                if (tech.isHarpoonPowerUp && simulation.cycle - 480 < tech.harpoonPowerUpCycle) {
                    Matter.Body.setDensity(this, 1.8 * tech.harpoonDensity); //+90% damage after pick up power up for 8 seconds
                } else if (tech.isHarpoonFullHealth && who.health === 1) {
                    Matter.Body.setDensity(this, 2.2 * tech.harpoonDensity); //+90% damage if mob has full health do
                    simulation.ephemera.push({
                        name: "harpoon outline",
                        count: 2, //cycles before it self removes
                        vertices: this.vertices,
                        do() {
                            this.count--
                            if (this.count < 0) simulation.removeEphemera(this.name)

                            ctx.beginPath();
                            ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
                            for (let j = 1, len = this.vertices.length; j < len; j += 1) ctx.lineTo(this.vertices[j].x, this.vertices[j].y);
                            ctx.lineTo(this.vertices[0].x, this.vertices[0].y);
                            ctx.lineJoin = "miter"
                            ctx.miterLimit = 20;
                            ctx.lineWidth = 40;
                            ctx.strokeStyle = "rgba(255,0,100,0.35)";
                            ctx.stroke();
                            ctx.lineWidth = 10;
                            ctx.strokeStyle = `#f07`;
                            ctx.stroke();
                            ctx.lineJoin = "round"
                            ctx.miterLimit = 5
                            ctx.fillStyle = "#000"
                            ctx.fill();
                        },
                    })
                }
                if (tech.isBreakHarpoon && Math.random() < 0.1) {
                    if (tech.isBreakHarpoonGain) {
                        powerUps.spawn(m.pos.x, m.pos.y - 50, "research");
                        powerUps.spawn(m.pos.x - 20, m.pos.y + 15, "research");
                        powerUps.spawn(m.pos.x + 20, m.pos.y + 15, "boost");
                        b.targetedNail(this.position, Math.floor(1 + 1.5 * Math.random()))
                    }
                    this.endCycle += 60 //so it lasts a bit longer
                    this.frictionAir = 0.01
                    //add spin
                    Matter.Body.setAngularVelocity(this, 0.7 * (Math.random() - 0.5))
                    //cap speed
                    const unit = Vector.normalise(this.velocity)
                    Matter.Body.setVelocity(this, Vector.mult(unit, Math.min(this.speed, 20)));
                    //stop behavior
                    this.do = () => {
                        this.force.y += this.mass * 0.005; //gravity
                    }
                }
            },
            caughtPowerUp: null,
            dropCaughtPowerUp() {
                if (this.caughtPowerUp) {
                    this.caughtPowerUp.collisionFilter.category = cat.powerUp
                    this.caughtPowerUp.collisionFilter.mask = cat.map | cat.powerUp
                    this.caughtPowerUp = null
                }
            },
            onEnd() {
                if (this.caughtPowerUp && !simulation.isChoosing && (this.caughtPowerUp.name !== "heal" || m.health !== m.maxHealth || tech.isOverHeal)) {
                    let index = null //find index
                    for (let i = 0, len = powerUp.length; i < len; ++i) {
                        if (powerUp[i] === this.caughtPowerUp) index = i
                    }
                    if (index !== null) {
                        powerUps.onPickUp(this.caughtPowerUp);
                        this.caughtPowerUp.effect();
                        Matter.Composite.remove(engine.world, this.caughtPowerUp);
                        powerUp.splice(index, 1);
                        if (tech.isHarpoonPowerUp) tech.harpoonPowerUpCycle = simulation.cycle
                    } else {
                        this.dropCaughtPowerUp()
                    }
                } else {
                    this.dropCaughtPowerUp()
                }
            },
            drawDamageAura() {
                ctx.beginPath();
                ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
                for (let j = 1, len = this.vertices.length; j < len; j += 1) ctx.lineTo(this.vertices[j].x, this.vertices[j].y);
                ctx.lineTo(this.vertices[0].x, this.vertices[0].y);
                ctx.lineJoin = "miter"
                ctx.miterLimit = 20;
                ctx.lineWidth = 15;
                ctx.strokeStyle = "rgba(255,0,100,0.25)";
                ctx.stroke();
                ctx.lineWidth = 4;
                ctx.strokeStyle = `#f07`;
                ctx.stroke();
                ctx.lineJoin = "round"
                ctx.miterLimit = 5
                ctx.fillStyle = "#000"
                ctx.fill();
            },
            drawString() {
                ropeIndex = this.vertices.length - 1
                const where = { x: m.pos.x + 30 * Math.cos(m.angle), y: m.pos.y + 30 * Math.sin(m.angle) }
                const sub = Vector.sub(where, this.vertices[ropeIndex])
                const perpendicular = Vector.mult(Vector.normalise(Vector.perp(sub)), this.drawStringFlip * Math.min(80, 10 + this.drawStringControlMagnitude / (10 + Vector.magnitude(sub))))
                const controlPoint = Vector.add(Vector.add(where, Vector.mult(sub, -0.5)), perpendicular)
                ctx.strokeStyle = "#000" // "#0ce"
                ctx.lineWidth = 0.5
                ctx.beginPath();
                ctx.moveTo(where.x, where.y);
                ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, this.vertices[ropeIndex].x, this.vertices[ropeIndex].y)
                // ctx.lineTo(this.vertices[0].x, this.vertices[0].y);
                ctx.stroke();
            },
            draw() { },
            returnToPlayer() {
                if (Vector.magnitude(Vector.sub(this.position, m.pos)) < returnRadius) { //near player
                    this.endCycle = 0;
                    // if (m.energy < 0.05) {
                    //     m.fireCDcycle = m.cycle + 80 * b.fireCDscale; //fire cooldown is much longer when out of energy
                    // } else if (m.cycle + 20 * b.fireCDscale < m.fireCDcycle) {
                    // if (m.energy > 0.05) m.fireCDcycle = m.cycle + 20 * b.fireCDscale //lower cd to 25 if it is above 25
                    // }
                    //recoil on catching
                    const momentum = Vector.mult(Vector.sub(this.velocity, player.velocity), (m.crouch ? 0.0001 : 0.0002))
                    player.force.x += momentum.x
                    player.force.y += momentum.y
                    // refund ammo
                    if (isReturnAmmo) {
                        b.guns[9].ammo++;
                        if (level.is2xAmmo) b.guns[9].ammo++;
                        simulation.updateGunHUD();
                        // for (i = 0, len = b.guns.length; i < len; i++) { //find which gun 
                        //     if (b.guns[i].name === "harpoon") {
                        //         break;
                        //     }
                        // }
                    }
                } else {
                    const sub = Vector.sub(this.position, m.pos)
                    const rangeScale = 1 + 0.000001 * Vector.magnitude(sub) * Vector.magnitude(sub) //return faster when far from player
                    const returnForce = Vector.mult(Vector.normalise(sub), rangeScale * thrust * this.mass)
                    if (m.energy > this.drain) m.energy -= this.drain
                    if (m.energy < 0.05) {
                        this.force.x -= returnForce.x * 0.15
                        this.force.y -= returnForce.y * 0.15
                    } else { //if (m.cycle + 20 * b.fireCDscale < m.fireCDcycle)
                        this.force.x -= returnForce.x
                        this.force.y -= returnForce.y
                    }
                    this.grabPowerUp()
                }
                this.draw();
            },
            grabPowerUp() { //grab power ups near the tip of the harpoon
                const grabPowerUpIndex = 2
                if (this.caughtPowerUp) {
                    Matter.Body.setPosition(this.caughtPowerUp, Vector.add(this.vertices[grabPowerUpIndex], this.velocity))  //this.vertices[2]
                    Matter.Body.setVelocity(this.caughtPowerUp, { x: 0, y: 0 })
                } else { //&& simulation.cycle % 2 
                    for (let i = 0, len = powerUp.length; i < len; ++i) {
                        if (tech.isEnergyNoAmmo && powerUp[i].name === "ammo") continue
                        const radius = powerUp[i].circleRadius + 50
                        if (Vector.magnitudeSquared(Vector.sub(this.vertices[grabPowerUpIndex], powerUp[i].position)) < radius * radius && !powerUp[i].isGrabbed) {  //this.vertices[2]
                            if (powerUp[i].name !== "heal" || m.health !== m.maxHealth || tech.isOverHeal) {
                                powerUp[i].isGrabbed = true
                                this.caughtPowerUp = powerUp[i]
                                Matter.Body.setVelocity(powerUp[i], { x: 0, y: 0 })
                                Matter.Body.setPosition(powerUp[i], this.vertices[grabPowerUpIndex])
                                powerUp[i].collisionFilter.category = 0
                                powerUp[i].collisionFilter.mask = 0
                                thrust *= 0.6
                                this.endCycle += 0.5 //it pulls back slower, so this prevents it from ending early
                                break //just pull 1 power up if possible
                            }
                        }
                    }
                }
            },
            do() {
                this.cycle++
                if (isReturn || target) {
                    if (isReturn) {
                        if (this.cycle > totalCycles) { //return to player  //|| !input.fire
                            this.do = this.returnToPlayer
                            if (this.angularSpeed < 0.5) this.torque += this.inertia * 0.001 * (Math.random() - 0.5) //(Math.round(Math.random()) ? 1 : -1)
                            Matter.Sleeping.set(this, false)
                            this.endCycle = simulation.cycle + 240
                            const momentum = Vector.mult(Vector.sub(this.velocity, player.velocity), (m.crouch ? 0.00015 : 0.0003)) //recoil on jerking line
                            player.force.x += momentum.x
                            player.force.y += momentum.y
                            requestAnimationFrame(() => { //delay this for 1 cycle to get the proper hit graphics
                                this.collisionFilter.category = 0
                                this.collisionFilter.mask = 0
                            });
                        } else {
                            this.grabPowerUp()
                        }
                    }
                    if (target) { //rotate towards the target
                        const face = {
                            x: Math.cos(this.angle),
                            y: Math.sin(this.angle)
                        };
                        const vectorGoal = Vector.normalise(Vector.sub(this.position, target.position));
                        if (Vector.cross(vectorGoal, face) > 0) {
                            Matter.Body.rotate(this, this.turnRate);
                        } else {
                            Matter.Body.rotate(this, -this.turnRate);
                        }
                    }
                    this.force.x += thrust * this.mass * Math.cos(this.angle);
                    this.force.y += thrust * this.mass * Math.sin(this.angle);
                }
                this.draw()
            },
        });
        if (!isReturn && !target) {
            Matter.Body.setVelocity(bullet[me], {
                x: 0.7 * player.velocity.x + 600 * thrust * Math.cos(bullet[me].angle),
                y: 0.5 * player.velocity.x + 600 * thrust * Math.sin(bullet[me].angle)
            });
            bullet[me].frictionAir = 0.002
            bullet[me].do = function () {
                if (this.speed < 20) this.force.y += 0.0005 * this.mass;
                this.draw();
            }
        }
        if (tech.isHarpoonPowerUp && simulation.cycle - 480 < tech.harpoonPowerUpCycle) { //8 seconds
            if (isReturn) {
                bullet[me].draw = function () {
                    this.drawDamageAura()
                    this.drawString()
                }
            } else {
                bullet[me].draw = function () {
                    this.drawDamageAura()
                }
            }
        } else if (isReturn) {
            bullet[me].draw = function () {
                this.drawString()
            }
        }
        Composite.add(engine.world, bullet[me]); //add bullet to world
    },
    missile(where, angle, speed, size = 1) {
        if (tech.isMissileBig) {
            size *= 1.55
            if (tech.isMissileBiggest) size *= 1.55
        }
        const me = bullet.length;
        bullet[me] = Bodies.rectangle(where.x, where.y, 30 * size, 4 * size, {
            angle: angle,
            friction: 0.5,
            frictionAir: 0.045,
            dmg: 0, //damage done in addition to the damage from momentum
            classType: "bullet",
            endCycle: simulation.cycle + Math.floor((230 + 40 * Math.random()) * tech.bulletsLastLonger + 120 * tech.isMissileBiggest + 60 * tech.isMissileBig),
            collisionFilter: {
                category: cat.bullet,
                mask: cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield
            },
            minDmgSpeed: 10,
            lookFrequency: Math.floor(10 + Math.random() * 3),
            explodeRad: (tech.isMissileBig ? 230 : 180) + 60 * Math.random(),
            density: 0.02, //0.001 is normal
            beforeDmg() {
                Matter.Body.setDensity(this, 0.0001); //reduce density to normal
                this.tryToLockOn();
                this.endCycle = 0; //bullet ends cycle after doing damage  // also triggers explosion
            },
            onEnd() {
                b.explosion(this.position, this.explodeRad * size); //makes bullet do explosive damage at end
                if (tech.fragments) b.targetedNail(this.position, tech.fragments * Math.floor(2 + 1.5 * Math.random()))
            },
            lockedOn: null,
            tryToLockOn() {
                let closeDist = Infinity;
                const futurePos = Vector.add(this.position, Vector.mult(this.velocity, 30)) //look for closest target to where the missile will be in 30 cycles
                this.lockedOn = null;
                // const futurePos = this.lockedOn ? :Vector.add(this.position, Vector.mult(this.velocity, 50))
                for (let i = 0, len = mob.length; i < len; ++i) {
                    if (
                        mob[i].alive && !mob[i].isBadTarget &&
                        Matter.Query.ray(map, this.position, mob[i].position).length === 0 &&
                        !mob[i].isInvulnerable
                    ) {
                        const futureDist = Vector.magnitude(Vector.sub(futurePos, mob[i].position));
                        if (futureDist < closeDist) {
                            closeDist = futureDist;
                            this.lockedOn = mob[i];
                            // this.frictionAir = 0.04; //extra friction once a target it locked
                        }
                        if (Vector.magnitude(Vector.sub(this.position, mob[i].position) < this.explodeRad)) {
                            this.endCycle = 0; //bullet ends cycle after doing damage  //also triggers explosion
                            mob[i].lockedOn.damage(2 * size); //does extra damage to target
                        }
                    }
                }
                //explode when bullet is close enough to target
                if (this.lockedOn && Vector.magnitude(Vector.sub(this.position, this.lockedOn.position)) < this.explodeRad) {
                    this.endCycle = 0; //bullet ends cycle after doing damage  //also triggers explosion
                    this.lockedOn.damage(4 * size); //does extra damage to target
                }
            },
            do() {
                if (!(m.cycle % this.lookFrequency)) this.tryToLockOn();
                if (tech.isTargeting && input.down) {
                    const face = {
                        x: Math.cos(this.angle),
                        y: Math.sin(this.angle)
                    };
                    const target = Vector.normalise(Vector.sub(this.position, simulation.mouseInGame));
                    const dot = Vector.dot(target, face)
                    const aim = Math.min(0.08, (1 + dot) * 1)
                    if (Vector.cross(target, face) > 0) {
                        Matter.Body.rotate(this, aim);
                    } else {
                        Matter.Body.rotate(this, -aim);
                    }
                    this.frictionAir = Math.min(0.1, Math.max(0.04, 1 + dot)) //0.08; //extra friction if turning

                    //draw targeting square
                    ctx.strokeStyle = "#000"
                    ctx.lineWidth = 1
                    ctx.strokeRect(simulation.mouseInGame.x - 40, simulation.mouseInGame.y - 40, 80, 80)
                } else if (this.lockedOn) { //rotate missile towards the target
                    const face = {
                        x: Math.cos(this.angle),
                        y: Math.sin(this.angle)
                    };
                    const target = Vector.normalise(Vector.sub(this.position, this.lockedOn.position));
                    const dot = Vector.dot(target, face)
                    const aim = Math.min(0.08, (1 + dot) * 1)
                    if (Vector.cross(target, face) > 0) {
                        Matter.Body.rotate(this, aim);
                    } else {
                        Matter.Body.rotate(this, -aim);
                    }
                    this.frictionAir = Math.min(0.1, Math.max(0.04, 1 + dot)) //0.08; //extra friction if turning
                }
                //accelerate in direction bullet is facing
                const dir = this.angle;
                this.force.x += thrust * Math.cos(dir);
                this.force.y += thrust * Math.sin(dir);

                ctx.beginPath(); //draw rocket
                ctx.arc(this.position.x - Math.cos(this.angle) * (25 * size - 3) + (Math.random() - 0.5) * 4,
                    this.position.y - Math.sin(this.angle) * (25 * size - 3) + (Math.random() - 0.5) * 4,
                    11 * size, 0, 2 * Math.PI);
                ctx.fillStyle = "rgba(255,155,0,0.5)";
                ctx.fill();
            },
        });
        const thrust = 0.0066 * bullet[me].mass * (tech.isMissileBig ? (tech.isMissileBiggest ? 0.3 : 0.7) : 1);
        Matter.Body.setVelocity(bullet[me], {
            x: 0.5 * player.velocity.x + speed * Math.cos(angle),
            y: 0.5 * player.velocity.y + speed * Math.sin(angle)
        });
        Composite.add(engine.world, bullet[me]); //add bullet to world
    },
    lastAngle: 0,
    wasExtruderOn: false,
    isExtruderOn: false,
    didExtruderDrain: false,
    canExtruderFire: true,
    extruder() {
        const DRAIN = 0.0012
        if (m.energy > DRAIN && b.canExtruderFire) {
            m.energy -= DRAIN
            if (m.energy < 0) {
                m.fieldCDcycle = m.cycle + 120;
                m.energy = 0;
            }
            b.isExtruderOn = true
            const SPEED = 8 + 12 * tech.isPlasmaRange
            const me = bullet.length;
            const where = Vector.add(m.pos, player.velocity)
            bullet[me] = Bodies.polygon(where.x + 20 * Math.cos(m.angle), where.y + 20 * Math.sin(m.angle), 4, 0.01, {
                cycle: -0.5,
                isWave: true,
                endCycle: simulation.cycle + 40, // + 30 * tech.isPlasmaRange,
                inertia: Infinity,
                frictionAir: 0,
                isInHole: true, //this keeps the bullet from entering wormholes
                minDmgSpeed: 0,
                dmg: 2.7, //damage also changes when you divide by mob.mass on in .do()
                classType: "bullet",
                isBranch: false,
                restitution: 0,
                collisionFilter: {
                    // category: 0,
                    // mask: 0, //cat.mob | cat.mobBullet | cat.mobShield
                    category: 0, //cat.bullet,
                    mask: 0, //cat.map, //cat.mob | cat.mobBullet | cat.mobShield
                },
                beforeDmg() { },
                onEnd() { },
                do() {
                    if (this.endCycle < simulation.cycle + 1) this.isWave = false
                    if (Matter.Query.point(map, this.position).length) { //check if inside map   //|| Matter.Query.point(body, this.position).length
                        this.isBranch = true;
                        this.do = () => {
                            if (this.endCycle < simulation.cycle + 1) this.isWave = false
                        }
                    } else { //check if inside a mob
                        for (let i = 0, len = mob.length; i < len; i++) {
                            const dist = Vector.magnitudeSquared(Vector.sub(this.position, mob[i].position))
                            const radius = mob[i].radius + tech.extruderRange / 2
                            if (dist < radius * radius) {
                                if (mob[i].speed > 2) {
                                    if (mob[i].isBoss || mob[i].isShielded) {
                                        Matter.Body.setVelocity(mob[i], { x: mob[i].velocity.x * 0.95, y: mob[i].velocity.y * 0.95 });
                                    } else {
                                        Matter.Body.setVelocity(mob[i], { x: mob[i].velocity.x * 0.25, y: mob[i].velocity.y * 0.25 });
                                    }
                                }
                                // Matter.Body.setPosition(this, Vector.add(this.position, mob[i].velocity)) //move with the medium
                                let dmg = this.dmg / Math.min(10, mob[i].mass)
                                mob[i].damage(dmg);
                                if (mob[i].alive) mob[i].foundPlayer();
                            }
                        }
                    }
                    this.cycle++
                    const wiggleMag = (m.crouch ? 6 : 12) * Math.cos(simulation.cycle * 0.09)
                    const wiggle = Vector.mult(transverse, wiggleMag * Math.cos(this.cycle * 0.36)) //+ wiggleMag * Math.cos(simulation.cycle * 0.3))
                    const velocity = Vector.mult(player.velocity, 0.4) //move with player
                    Matter.Body.setPosition(this, Vector.add(velocity, Vector.add(this.position, wiggle)))
                }
            });
            Composite.add(engine.world, bullet[me]); //add bullet to world
            Matter.Body.setVelocity(bullet[me], {
                x: SPEED * Math.cos(m.angle),
                y: SPEED * Math.sin(m.angle)
            });
            const transverse = Vector.normalise(Vector.perp(bullet[me].velocity))
            if (180 - Math.abs(Math.abs(b.lastAngle - m.angle) - 180) > 0.13 || !b.wasExtruderOn) {
                bullet[me].isBranch = true; //don't draw stroke for this bullet
                bullet[me].do = function () {
                    if (this.endCycle < simulation.cycle + 1) this.isWave = false
                }
            }
            b.lastAngle = m.angle //track last angle for the above angle difference calculation
        } else {
            b.canExtruderFire = false;
        }
    },
    plasma() {
        const DRAIN = 0.00075
        if (m.energy > DRAIN) {
            m.energy -= DRAIN;
            if (m.energy < 0) {
                m.fieldCDcycle = m.cycle + 120;
                m.energy = 0;
            }

            //calculate laser collision
            let range = tech.isPlasmaRange * (120 + (m.crouch ? 400 : 300) * Math.sqrt(Math.random())) //+ 100 * Math.sin(m.cycle * 0.3);
            // const dir = m.angle // + 0.04 * (Math.random() - 0.5)
            const path = [
                { x: m.pos.x + 20 * Math.cos(m.angle), y: m.pos.y + 20 * Math.sin(m.angle) },
                { x: m.pos.x + range * Math.cos(m.angle), y: m.pos.y + range * Math.sin(m.angle) }
            ];
            //check for collisions
            let best = {
                x: null,
                y: null,
                dist2: Infinity,
                who: null,
                v1: null,
                v2: null
            };
            best = vertexCollision(path[0], path[1], [mob, map, body]);
            if (best.dist2 != Infinity) { //if hitting something
                path[path.length - 1] = { x: best.x, y: best.y };
                if (best.who.alive) {
                    const dmg = 0.9; //********** SCALE DAMAGE HERE *********************
                    best.who.damage(dmg);
                    best.who.locatePlayer();

                    //push mobs away
                    if (best.who.speed > 3) {
                        const force = Vector.mult(Vector.normalise(Vector.sub(m.pos, path[1])), -0.005 * Math.min(5, best.who.mass))
                        Matter.Body.applyForce(best.who, path[1], force)
                        Matter.Body.setVelocity(best.who, { x: best.who.velocity.x * 0.4, y: best.who.velocity.y * 0.4 });
                    } else {
                        const force = Vector.mult(Vector.normalise(Vector.sub(m.pos, path[1])), -0.01 * Math.min(5, best.who.mass))
                        Matter.Body.applyForce(best.who, path[1], force)
                        Matter.Body.setVelocity(best.who, { x: best.who.velocity.x * 0.7, y: best.who.velocity.y * 0.7 });
                    }
                    //draw mob damage circle
                    simulation.drawList.push({
                        x: path[1].x,
                        y: path[1].y,
                        radius: Math.sqrt(2000 * dmg * best.who.damageReduction),
                        color: "rgba(255,0,255,0.2)",
                        time: simulation.drawTime * 4
                    });
                } else if (!best.who.isStatic) {
                    //push blocks away
                    const force = Vector.mult(Vector.normalise(Vector.sub(m.pos, path[1])), -0.007 * Math.sqrt(Math.sqrt(best.who.mass)))
                    Matter.Body.applyForce(best.who, path[1], force)
                }
            }

            //draw blowtorch laser beam
            ctx.strokeStyle = "rgba(255,0,255,0.1)"
            ctx.lineWidth = 14
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            ctx.lineTo(path[1].x, path[1].y);
            ctx.stroke();
            ctx.strokeStyle = "#f0f";
            ctx.lineWidth = 2
            ctx.stroke();

            //draw electricity
            const Dx = Math.cos(m.angle);
            const Dy = Math.sin(m.angle);
            let x = m.pos.x + 20 * Dx;
            let y = m.pos.y + 20 * Dy;
            ctx.beginPath();
            ctx.moveTo(x, y);
            const step = Vector.magnitude(Vector.sub(path[0], path[1])) / 10
            for (let i = 0; i < 8; i++) {
                x += step * (Dx + 1.5 * (Math.random() - 0.5))
                y += step * (Dy + 1.5 * (Math.random() - 0.5))
                ctx.lineTo(x, y);
            }
            ctx.lineWidth = 2 * Math.random();
            ctx.stroke();
        }
    },
    laser(where = {
        x: m.pos.x + 20 * Math.cos(m.angle),
        y: m.pos.y + 20 * Math.sin(m.angle)
    }, whereEnd = {
        x: where.x + 3000 * Math.cos(m.angle),
        y: where.y + 3000 * Math.sin(m.angle)
    }, damage = tech.laserDamage, reflections = tech.laserReflections, isThickBeam = false, push = 1) {
        const reflectivity = 1 - 1 / (reflections * 3)
        let best = { x: 1, y: 1, dist2: Infinity, who: null, v1: 1, v2: 1 };
        const path = [{ x: where.x, y: where.y }, { x: whereEnd.x, y: whereEnd.y }];

        const checkForCollisions = function () {
            best = vertexCollision(path[path.length - 2], path[path.length - 1], [mob, map, body]);
        };
        const laserHitMob = function () {
            if (best.who.alive) {
                best.who.locatePlayer();
                if (best.who.damageReduction) {
                    if ( //iridescence
                        tech.laserCrit && !best.who.shield &&
                        Vector.dot(Vector.normalise(Vector.sub(best.who.position, path[path.length - 1])), Vector.normalise(Vector.sub(path[path.length - 1], path[path.length - 2]))) > 0.999 - 0.5 / best.who.radius
                    ) {
                        damage *= 1 + tech.laserCrit
                        simulation.drawList.push({ //add dmg to draw queue
                            x: path[path.length - 1].x,
                            y: path[path.length - 1].y,
                            radius: Math.sqrt(2500 * damage * best.who.damageReduction) + 5,
                            color: `hsla(${60 + 283 * Math.random()},100%,70%,0.5)`, // random hue, but not red
                            time: 16
                        });
                    } else {
                        simulation.drawList.push({ //add dmg to draw queue
                            x: path[path.length - 1].x,
                            y: path[path.length - 1].y,
                            radius: Math.sqrt(2000 * damage * best.who.damageReduction) + 2,
                            color: tech.laserColorAlpha,
                            time: simulation.drawTime
                        });
                    }
                    best.who.damage(damage);
                }
                if (tech.isLaserPush) { //push mobs away
                    const index = path.length - 1
                    Matter.Body.setVelocity(best.who, { x: best.who.velocity.x * 0.97, y: best.who.velocity.y * 0.97 });
                    const force = Vector.mult(Vector.normalise(Vector.sub(path[index], path[Math.max(0, index - 1)])), 0.003 * push * Math.min(6, best.who.mass))
                    Matter.Body.applyForce(best.who, path[index], force)
                }
            } else if (tech.isLaserPush && best.who.classType === "body") {
                const index = path.length - 1
                Matter.Body.setVelocity(best.who, { x: best.who.velocity.x * 0.97, y: best.who.velocity.y * 0.97 });
                const force = Vector.mult(Vector.normalise(Vector.sub(path[index], path[Math.max(0, index - 1)])), 0.003 * push * Math.min(6, best.who.mass))
                Matter.Body.applyForce(best.who, path[index], force)
            }
        };
        const reflection = function () { // https://math.stackexchange.com/questions/13261/how-to-get-a-reflection-vector
            const n = Vector.perp(Vector.normalise(Vector.sub(best.v1, best.v2)));
            const d = Vector.sub(path[path.length - 1], path[path.length - 2]);
            const nn = Vector.mult(n, 2 * Vector.dot(d, n));
            const r = Vector.normalise(Vector.sub(d, nn));
            path[path.length] = Vector.add(Vector.mult(r, 5000), path[path.length - 1]);
        };

        checkForCollisions();
        let lastBestOdd
        let lastBestEven = best.who //used in hack below
        if (best.dist2 !== Infinity) { //if hitting something
            path[path.length - 1] = { x: best.x, y: best.y };
            laserHitMob();
            for (let i = 0; i < reflections; i++) {
                reflection();
                checkForCollisions();
                if (best.dist2 !== Infinity) { //if hitting something
                    lastReflection = best
                    path[path.length - 1] = { x: best.x, y: best.y };
                    damage *= reflectivity
                    laserHitMob();
                    //I'm not clear on how this works, but it gets rid of a bug where the laser reflects inside a block, often vertically.
                    //I think it checks to see if the laser is reflecting off a different part of the same block, if it is "inside" a block
                    if (i % 2) {
                        if (lastBestOdd === best.who) break
                    } else {
                        lastBestOdd = best.who
                        if (lastBestEven === best.who) break
                    }
                } else {
                    break
                }
            }
        }
        if (isThickBeam) {
            for (let i = 1, len = path.length; i < len; ++i) {
                ctx.moveTo(path[i - 1].x, path[i - 1].y);
                ctx.lineTo(path[i].x, path[i].y);
            }
        } else if (tech.isLaserLens && b.guns[11].lensDamage !== 1) {
            ctx.strokeStyle = tech.laserColor;
            ctx.lineWidth = 2
            ctx.lineDashOffset = 900 * Math.random()
            ctx.setLineDash([50 + 120 * Math.random(), 50 * Math.random()]);
            for (let i = 1, len = path.length; i < len; ++i) {
                ctx.beginPath();
                ctx.moveTo(path[i - 1].x, path[i - 1].y);
                ctx.lineTo(path[i].x, path[i].y);
                ctx.stroke();
                ctx.globalAlpha *= reflectivity; //reflections are less intense
            }
            ctx.setLineDash([]);
            // ctx.globalAlpha = 1;

            //glow
            ctx.lineWidth = 9 + 2 * b.guns[11].lensDamageOn
            ctx.globalAlpha = 0.13
            ctx.beginPath();
            for (let i = 1, len = path.length; i < len; ++i) {
                ctx.moveTo(path[i - 1].x, path[i - 1].y);
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
        } else {
            ctx.strokeStyle = tech.laserColor;
            ctx.lineWidth = 2
            ctx.lineDashOffset = 900 * Math.random()
            ctx.setLineDash([50 + 120 * Math.random(), 50 * Math.random()]);
            for (let i = 1, len = path.length; i < len; ++i) {
                ctx.beginPath();
                ctx.moveTo(path[i - 1].x, path[i - 1].y);
                ctx.lineTo(path[i].x, path[i].y);
                ctx.stroke();
                ctx.globalAlpha *= reflectivity; //reflections are less intense
            }
            ctx.setLineDash([]);
            ctx.globalAlpha = 1;
        }
    },
    AoEStunEffect(where, range, cycles = 120 + 60 * Math.random()) {
        for (let i = 0, len = mob.length; i < len; ++i) {
            if (mob[i].alive && !mob[i].isShielded && !mob[i].shield && !mob[i].isBadTarget) {
                if (Vector.magnitude(Vector.sub(where, mob[i].position)) - mob[i].radius < range) mobs.statusStun(mob[i], cycles)
            }
        }
        simulation.drawList.push({
            x: where.x,
            y: where.y,
            radius: range,
            color: "rgba(0,0,0,0.1)",
            time: 15
        });
    },
    laserMine(position, velocity = {
        x: 0,
        y: -8
    }) {
        const me = bullet.length;
        bullet[me] = Bodies.polygon(position.x, position.y, 3, 25, {
            bulletType: "laser mine",
            angle: m.angle,
            friction: 0,
            frictionAir: 0.025,
            restitution: 0.5,
            dmg: 0, // 0.14   //damage done in addition to the damage from momentum
            minDmgSpeed: 2,
            lookFrequency: 67 + Math.floor(7 * Math.random()),
            drain: 0.7 * tech.laserDrain,
            isDetonated: false,
            torqueMagnitude: 0.000003 * (Math.round(Math.random()) ? 1 : -1),
            range: 1500,
            endCycle: Infinity,
            classType: "bullet",
            collisionFilter: {
                category: cat.bullet,
                mask: cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield
            },
            beforeDmg() { },
            onEnd() { },
            do() {
                if (!(simulation.cycle % this.lookFrequency) && m.energy > this.drain) { //find mob targets
                    for (let i = 0, len = mob.length; i < len; ++i) {
                        if (
                            Vector.magnitude(Vector.sub(this.position, mob[i].position)) < 1300 &&
                            !mob[i].isBadTarget &&
                            Matter.Query.ray(map, this.position, mob[i].position).length === 0 &&
                            Matter.Query.ray(body, this.position, mob[i].position).length === 0
                        ) {
                            if (tech.isStun) b.AoEStunEffect(this.position, 1300); //AoEStunEffect(where, range, cycles = 90 + 60 * Math.random()) {
                            this.do = this.laserSpin
                            if (this.angularSpeed < 0.5) this.torque += this.inertia * this.torqueMagnitude * 200 //spin
                            this.endCycle = simulation.cycle + 360 + 120
                            // if (this.angularSpeed < 0.01) this.torque += this.inertia * this.torqueMagnitude * 5 //spin
                            this.isDetonated = true
                            break
                        }
                    }
                }
            },
            reflections: Math.max(0, tech.laserReflections - 2),
            laserSpin() {
                //drain energy
                if (m.energy > this.drain) {
                    m.energy -= this.drain
                    if (this.angularSpeed < 0.05) this.torque += this.inertia * this.torqueMagnitude //spin

                    //fire lasers
                    ctx.strokeStyle = tech.laserColor;
                    ctx.lineWidth = 1.5
                    // ctx.globalAlpha = 1;
                    ctx.beginPath();
                    for (let i = 0; i < 3; i++) {
                        const where = this.vertices[i]
                        const endPoint = Vector.add(where, Vector.mult(Vector.normalise(Vector.sub(where, this.position)), 2500))
                        b.laser(where, endPoint, tech.laserDamage * 13, this.reflections, true)
                    }
                    ctx.stroke();
                    // ctx.globalAlpha = 1;
                }
                if (this.endCycle - 60 < simulation.cycle) {
                    this.do = () => { } //no nothing, no laser, no spin
                }
            },
        })
        Matter.Body.setVelocity(bullet[me], velocity);
        Composite.add(engine.world, bullet[me]); //add bullet to world
    },
    mine(where, velocity, angle = 0) {
        const bIndex = bullet.length;
        bullet[bIndex] = Bodies.rectangle(where.x, where.y, 45, 16, {
            angle: angle,
            friction: 1,
            frictionStatic: 1,
            frictionAir: 0,
            restitution: 0,
            dmg: 0, //damage done in addition to the damage from momentum
            classType: "bullet",
            bulletType: "mine",
            collisionFilter: {
                category: cat.bullet,
                mask: cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield //  | cat.bullet   //doesn't collide with other bullets until it lands  (was crashing into bots)
            },
            minDmgSpeed: 5,
            stillCount: 0,
            isArmed: false,
            endCycle: Infinity,
            lookFrequency: 0,
            range: 700 - 300 * tech.isFoamMine,
            beforeDmg() { },
            onEnd() {
                if (this.isArmed && !tech.isMineSentry) {
                    if (tech.isFoamMine) {
                        //send 14 in random directions slowly
                        for (let i = 0; i < 12; i++) {
                            const radius = 13 + 8 * Math.random()
                            const velocity = { x: 0.5 + 5.5 * Math.random(), y: 0 }
                            b.foam(this.position, Vector.rotate(velocity, this.angle + 1.57 + 3 * (Math.random() - 0.5)), radius) //6.28 * Math.random()
                        }
                        //send 40 targeted
                        let count = 0
                        let cycle = () => {
                            if (count < 50) {
                                if (!simulation.paused && !simulation.isChoosing) { //!(simulation.cycle % 1) &&
                                    count++
                                    b.targetedFoam(this.position)
                                }
                                requestAnimationFrame(cycle);
                            }
                        }
                        requestAnimationFrame(cycle)
                    } else if (tech.isSuperMine) {
                        b.targetedBall(this.position, 22 + 2 * tech.extraSuperBalls)
                    } else {
                        b.targetedNail(this.position, 22, 40 + 10 * Math.random(), 1200, 2.2)
                    }
                }
            },
            do() {
                this.force.y += this.mass * 0.002; //extra gravity
                let collide = Matter.Query.collides(this, map) //check if collides with map
                if (collide.length > 0) {
                    for (let i = 0; i < collide.length; i++) {
                        if (collide[i].bodyA.collisionFilter.category === cat.map) { // || collide[i].bodyB.collisionFilter.category === cat.map) {
                            const angle = Vector.angle(collide[i].normal, { x: 1, y: 0 })
                            Matter.Body.setAngle(this, Math.atan2(collide[i].tangent.y, collide[i].tangent.x))
                            for (let j = 0; j < 10; j++) { //move until touching map again after rotation
                                if (Matter.Query.collides(this, map).length > 0) { //touching map
                                    if (angle > -0.2 || angle < -1.5) { //don't stick to level ground
                                        Matter.Body.setVelocity(this, { x: 0, y: 0 });
                                        Matter.Body.setStatic(this, true) //don't set to static if not touching map
                                        this.collisionFilter.category = 0
                                        this.collisionFilter.mask = 0 //cat.map | cat.bullet
                                    } else {
                                        Matter.Body.setVelocity(this, { x: 0, y: 0 });
                                        Matter.Body.setAngularVelocity(this, 0)
                                    }
                                    this.arm();
                                    //sometimes the mine can't attach to map and it just needs to be reset
                                    setTimeout(() => {
                                        if (Matter.Query.collides(this, map).length === 0 || Matter.Query.point(map, this.position).length > 0) {
                                            this.endCycle = 0 // if not touching map explode
                                            this.isArmed = false
                                            b.mine(this.position, this.velocity, this.angle)
                                        }
                                    }, 100);
                                    break
                                }
                                Matter.Body.setPosition(this, Vector.add(this.position, Vector.mult(collide[i].normal, 2))) //move until you are touching the wall
                            }
                            break
                        }
                    }
                } else {
                    if (this.speed < 1 && this.angularSpeed < 0.01) this.stillCount++
                }
                if (this.stillCount > 25) this.arm();
            },
            arm() {
                this.collisionFilter.mask = cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield | cat.bullet //can now collide with other bullets
                this.lookFrequency = simulation.cycle + 60
                this.do = function () { //overwrite the do method for this bullet
                    this.force.y += this.mass * 0.002; //extra gravity
                    if (simulation.cycle > this.lookFrequency) {
                        this.isArmed = true
                        this.lookFrequency = 55 + Math.floor(22 * Math.random())
                        simulation.drawList.push({ x: this.position.x, y: this.position.y, radius: 10, color: "#f00", time: 4 });
                        this.do = function () { //overwrite the do method for this bullet
                            this.force.y += this.mass * 0.002; //extra gravity
                            if (!(simulation.cycle % this.lookFrequency)) { //find mob targets
                                const random = 300 * Math.random()
                                for (let i = 0, len = mob.length; i < len; ++i) {
                                    if (
                                        !mob[i].isBadTarget &&
                                        !mob[i].isInvulnerable &&
                                        Vector.magnitude(Vector.sub(this.position, mob[i].position)) < this.range + mob[i].radius + random &&
                                        Matter.Query.ray(map, this.position, mob[i].position).length === 0 &&
                                        Matter.Query.ray(body, this.position, mob[i].position).length === 0
                                    ) {
                                        if (tech.isStun) b.AoEStunEffect(this.position, this.range + mob[i].radius + random); //AoEStunEffect(where, range, cycles = 90 + 60 * Math.random()) {
                                        if (tech.isMineSentry) {
                                            this.lookFrequency = Math.floor(5 + 7 * b.fireCDscale + 10 * (tech.oneSuperBall && tech.isSuperMine) + Math.floor(2 * Math.random()))
                                            // this.endCycle = Infinity
                                            this.shots = tech.sentryAmmo
                                            this.do = function () { //overwrite the do method for this bullet
                                                this.force.y += this.mass * 0.002; //extra gravity
                                                if (!(simulation.cycle % this.lookFrequency)) { //find mob targets
                                                    if (tech.isFoamMine) {
                                                        this.shots -= 0.6 * b.targetedFoam(this.position, 1, 21 + 7 * Math.random(), 1200, false)
                                                        b.targetedFoam(this.position, 1, 21 + 7 * Math.random(), 1200, false)
                                                    } else if (tech.isSuperMine) {
                                                        const cost = tech.oneSuperBall ? 2 : 0.7
                                                        this.shots -= cost * b.targetedBall(this.position, 1, 42 + 12 * Math.random(), 1200, false)
                                                        for (let i = 0, len = tech.extraSuperBalls / 4; i < len; i++) {
                                                            if (Math.random() < 0.33) b.targetedBall(this.position, 1, 42 + 12 * Math.random(), 1200, false)
                                                        }
                                                    } else {
                                                        this.shots -= b.targetedNail(this.position, 1, 45 + 5 * Math.random(), 1100, 2.3)
                                                    }
                                                    if (this.shots < 0) this.endCycle = 0
                                                    if (!(simulation.cycle % (this.lookFrequency * 6))) {
                                                        simulation.drawList.push({ x: this.position.x, y: this.position.y, radius: 8, color: "#fe0", time: 4 });
                                                    }
                                                }
                                            }
                                            break
                                        } else {
                                            this.endCycle = 0 //end life if mob is near and visible
                                            break
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            },
        });
        bullet[bIndex].torque += bullet[bIndex].inertia * 0.0002 * (0.5 - Math.random())
        Matter.Body.setVelocity(bullet[bIndex], velocity);
        Composite.add(engine.world, bullet[bIndex]); //add bullet to world
    },
    worm(where, isFreeze = tech.isSporeFreeze) { //used with the tech upgrade in mob.death()
        const bIndex = bullet.length;
        const wormSize = 6 + tech.wormSize * 4.2 * Math.random()
        if (bIndex < 500) { //can't make over 500 spores
            bullet[bIndex] = Bodies.polygon(where.x, where.y, 3, 3, {
                inertia: Infinity,
                isFreeze: isFreeze,
                restitution: 0.5,
                // angle: Math.random() * 2 * Math.PI,
                friction: 0,
                frictionAir: 0.025,
                thrust: (tech.isSporeFollow ? 0.0012 : 0.00055) * (1 + 0.5 * (Math.random() - 0.5)),
                wormSize: wormSize,
                wormTail: 1 + Math.max(4, Math.min(wormSize - 2 * tech.wormSize, 30)),
                dmg: (tech.isMutualism ? 9.5 : 3.2) * wormSize,
                lookFrequency: 100 + Math.floor(37 * Math.random()),
                classType: "bullet",
                collisionFilter: {
                    category: cat.bullet,
                    mask: cat.map | cat.mob | cat.mobBullet | cat.mobShield //no collide with body
                },
                endCycle: simulation.cycle + Math.floor((600 + Math.floor(Math.random() * 420)) * tech.bulletsLastLonger),
                minDmgSpeed: 0,
                playerOffPosition: { //used when moving towards player to keep spores separate
                    x: 100 * (Math.random() - 0.5),
                    y: 100 * (Math.random() - 0.5)
                },
                beforeDmg(who) {
                    if (who.isInvulnerable) {
                        Matter.Body.setVelocity(this, Vector.mult(this.velocity, 0.1));
                    } else {
                        if (tech.isSpawnBulletsOnDeath && who.alive && who.isDropPowerUp) {
                            setTimeout(() => {
                                if (!who.alive) {
                                    for (let i = 0; i < 3; i++) { //spawn 3 more
                                        b.worm(this.position)
                                        bullet[bullet.length - 1].endCycle = Math.min(simulation.cycle + Math.floor(420 * tech.bulletsLastLonger), this.endCycle + 180 + Math.floor(60 * Math.random())) //simulation.cycle + Math.floor(420 * tech.bulletsLastLonger)
                                    }
                                }
                                this.endCycle = 0; //bullet ends cycle after doing damage 
                            }, 1);
                        } else {
                            this.endCycle = 0; //bullet ends cycle after doing damage 
                        }
                        if (this.isFreeze) mobs.statusSlow(who, 90)
                    }
                },
                onEnd() {
                    if (tech.isMutualism && this.isMutualismActive && !tech.isEnergyHealth) {
                        m.health += 0.02
                        if (m.health > m.maxHealth) m.health = m.maxHealth;
                        m.displayHealth();
                    }
                },
                tailCycle: 6.28 * Math.random(),
                do() {
                    this.tailCycle += this.speed * 0.025
                    ctx.beginPath(); //draw nematode
                    ctx.moveTo(this.position.x, this.position.y);
                    // const dir = Vector.mult(Vector.normalise(this.velocity), -Math.min(100, this.wormTail * this.speed))
                    const speed = Math.min(7, this.speed)
                    const dir = Vector.mult(Vector.normalise(this.velocity), -0.6 * this.wormTail * speed)
                    const tail = Vector.add(this.position, dir)
                    const wiggle = Vector.add(Vector.add(tail, dir), Vector.rotate(dir, Math.sin(this.tailCycle)))
                    // const wiggle = Vector.add(tail, Vector.rotate(dir, Math.sin((m.cycle - this.endCycle) * 0.03 * this.speed)))
                    ctx.quadraticCurveTo(tail.x, tail.y, wiggle.x, wiggle.y) // ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, this.vertices[0].x, this.vertices[0].y)
                    // ctx.lineTo(tail.x, tail.y);
                    ctx.lineWidth = this.wormSize;
                    ctx.strokeStyle = "#000";
                    ctx.stroke();


                    if (this.lockedOn && this.lockedOn.alive) {
                        this.force = Vector.mult(Vector.normalise(Vector.sub(this.lockedOn.position, this.position)), this.mass * this.thrust)
                    } else {
                        if (!(simulation.cycle % this.lookFrequency)) { //find mob targets
                            this.closestTarget = null;
                            this.lockedOn = null;
                            let closeDist = Infinity;
                            for (let i = 0, len = mob.length; i < len; ++i) {
                                if (!mob[i].isBadTarget && Matter.Query.ray(map, this.position, mob[i].position).length === 0 && !mob[i].isInvulnerable) {
                                    const targetVector = Vector.sub(this.position, mob[i].position)
                                    const dist = Vector.magnitude(targetVector) * (Math.random() + 0.5);
                                    if (dist < closeDist) {
                                        this.closestTarget = mob[i].position;
                                        closeDist = dist;
                                        this.lockedOn = mob[i]
                                        if (0.3 > Math.random()) break //doesn't always target the closest mob
                                    }
                                }
                            }
                        }
                        if (tech.isSporeFollow && this.lockedOn === null) { //move towards player //checking for null means that the spores don't go after the player until it has looked and not found a target
                            const dx = this.position.x - m.pos.x;
                            const dy = this.position.y - m.pos.y;
                            if (dx * dx + dy * dy > 10000) {
                                this.force = Vector.mult(Vector.normalise(Vector.sub(m.pos, Vector.add(this.playerOffPosition, this.position))), this.mass * this.thrust)
                            }
                        } else {
                            const unit = Vector.normalise(this.velocity)
                            const force = Vector.mult(Vector.rotate(unit, 0.005 * this.playerOffPosition.x), 0.000003)
                            this.force.x += force.x
                            this.force.y += force.y
                        }
                    }
                },
            });
            const SPEED = 2 + 1 * Math.random();
            const ANGLE = 2 * Math.PI * Math.random()
            Matter.Body.setVelocity(bullet[bIndex], {
                x: SPEED * Math.cos(ANGLE),
                y: SPEED * Math.sin(ANGLE)
            });
            Composite.add(engine.world, bullet[bIndex]); //add bullet to world
            if (tech.isMutualism && m.health > 0.04) {
                m.health -= 0.02
                m.displayHealth();
                bullet[bIndex].isMutualismActive = true
            }
        }
    },
    spore(where, velocity = null) { //used with the tech upgrade in mob.death()
        const bIndex = bullet.length;
        const size = 4
        if (bIndex < 500) { //can't make over 500 spores
            bullet[bIndex] = Bodies.polygon(where.x, where.y, size, size, {
                // density: 0.0015,			//frictionAir: 0.01,
                inertia: Infinity,
                isFreeze: tech.isSporeFreeze,
                restitution: 0.5,
                angle: Math.random() * 2 * Math.PI,
                friction: 0,
                frictionAir: 0.025,
                thrust: (tech.isSporeFollow ? 0.0011 : 0.0005) * (1 + 0.3 * (Math.random() - 0.5)),
                dmg: (tech.isMutualism ? 20 : 7), //bonus damage from tech.isMutualism
                lookFrequency: 100 + Math.floor(117 * Math.random()),
                classType: "bullet",
                isSpore: true,
                collisionFilter: {
                    category: cat.bullet,
                    mask: cat.map | cat.mob | cat.mobBullet | cat.mobShield //no collide with body
                },
                endCycle: simulation.cycle + Math.floor((540 + Math.floor(Math.random() * 420)) * tech.bulletsLastLonger),
                minDmgSpeed: 0,
                playerOffPosition: { //used when moving towards player to keep spores separate
                    x: 100 * (Math.random() - 0.5),
                    y: 100 * (Math.random() - 0.5)
                },
                beforeDmg(who) {
                    if (!who.isInvulnerable) {
                        this.endCycle = 0; //bullet ends cycle after doing damage 
                        if (this.isFreeze) mobs.statusSlow(who, 90)
                    }
                },
                onEnd() {
                    if (tech.isMutualism && this.isMutualismActive && !tech.isEnergyHealth) {
                        m.health += 0.01
                        if (m.health > m.maxHealth) m.health = m.maxHealth;
                        m.displayHealth();
                    }
                    // console.log(this.dmg)
                },
                do() {
                    if (this.lockedOn && this.lockedOn.alive) {
                        this.force = Vector.mult(Vector.normalise(Vector.sub(this.lockedOn.position, this.position)), this.mass * this.thrust)
                    } else {
                        if (!(simulation.cycle % this.lookFrequency)) { //find mob targets
                            this.closestTarget = null;
                            this.lockedOn = null;
                            let closeDist = Infinity;
                            for (let i = 0, len = mob.length; i < len; ++i) {
                                if (!mob[i].isBadTarget && Matter.Query.ray(map, this.position, mob[i].position).length === 0 && !mob[i].isInvulnerable) {
                                    const targetVector = Vector.sub(this.position, mob[i].position)
                                    const dist = Vector.magnitude(targetVector) * (Math.random() + 0.5);
                                    if (dist < closeDist) {
                                        this.closestTarget = mob[i].position;
                                        closeDist = dist;
                                        this.lockedOn = mob[i]
                                        if (0.3 > Math.random()) break //doesn't always target the closest mob
                                    }
                                }
                            }
                        }
                        if (tech.isSporeFollow && this.lockedOn === null) { //move towards player
                            //checking for null means that the spores don't go after the player until it has looked and not found a target
                            const dx = this.position.x - m.pos.x;
                            const dy = this.position.y - m.pos.y;
                            if (dx * dx + dy * dy > 10000) {
                                this.force = Vector.mult(Vector.normalise(Vector.sub(m.pos, Vector.add(this.playerOffPosition, this.position))), this.mass * this.thrust)
                            }
                        } else {
                            this.force.y += this.mass * 0.0001; //gravity
                        }

                    }
                },
            });
            if (velocity) {
                Matter.Body.setVelocity(bullet[bIndex], velocity);
            } else {
                const SPEED = 4 + 8 * Math.random();
                const ANGLE = 2 * Math.PI * Math.random()
                Matter.Body.setVelocity(bullet[bIndex], {
                    x: SPEED * Math.cos(ANGLE),
                    y: SPEED * Math.sin(ANGLE)
                });
            }

            Composite.add(engine.world, bullet[bIndex]); //add bullet to world

            if (tech.isMutualism && m.health > 0.01) {
                m.health -= 0.01
                m.displayHealth();
                bullet[bIndex].isMutualismActive = true
            }
        }
    },
    iceIX(speed = 0, dir = m.angle + Math.PI * 2 * Math.random(), where = {
        x: m.pos.x + 30 * Math.cos(m.angle),
        y: m.pos.y + 30 * Math.sin(m.angle)
    }) {
        const me = bullet.length;
        const THRUST = 0.0018
        const RADIUS = 18
        const SCALE = 1 - 0.11 / tech.bulletsLastLonger
        bullet[me] = Bodies.polygon(where.x, where.y, 3, RADIUS, {
            angle: dir - Math.PI,
            // inertia: Infinity,
            spin: 0.00004 * (0.1 + Math.random()) * (Math.round(Math.random()) ? 1 : -1),
            friction: 0,
            frictionAir: 0.02,
            restitution: 0.9,
            dmg: 1.3, //damage done in addition to the damage from momentum
            lookFrequency: 14 + Math.floor(8 * Math.random()),
            endCycle: simulation.cycle + 65 * tech.bulletsLastLonger + Math.floor(25 * Math.random()),
            classType: "bullet",
            collisionFilter: {
                category: cat.bullet,
                mask: cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield //self collide
            },
            minDmgSpeed: 0,
            lockedOn: null,
            beforeDmg(who) {
                if (!who.isInvulnerable) {
                    if (tech.iceEnergy && !who.shield && !who.isShielded && who.isDropPowerUp && who.alive && m.immuneCycle < m.cycle) {
                        setTimeout(() => {
                            if (!who.alive) m.energy += tech.iceEnergy * 0.8 * level.isReducedRegen
                        }, 10);
                    }
                    mobs.statusSlow(who, tech.iceIXFreezeTime)
                    this.endCycle = simulation.cycle
                }
                // if (tech.isHeavyWater) mobs.statusDoT(who, 0.15, 300)
            },
            onEnd() { },
            do() {
                // this.force.y += this.mass * 0.0002;
                //find mob targets
                if (!(simulation.cycle % this.lookFrequency)) {
                    Matter.Body.scale(this, SCALE, SCALE);
                    this.lockedOn = null;
                    let closeDist = Infinity;
                    for (let i = 0, len = mob.length; i < len; ++i) {
                        if (
                            !mob[i].isBadTarget &&
                            Matter.Query.ray(map, this.position, mob[i].position).length === 0 &&
                            Matter.Query.ray(body, this.position, mob[i].position).length === 0 &&
                            !mob[i].isInvulnerable
                        ) {
                            const TARGET_VECTOR = Vector.sub(this.position, mob[i].position)
                            const DIST = Vector.magnitude(TARGET_VECTOR);
                            if (DIST < closeDist) {
                                closeDist = DIST;
                                this.lockedOn = mob[i]
                            }
                        }
                    }
                }
                if (this.lockedOn) { //accelerate towards mobs
                    this.force = Vector.mult(Vector.normalise(Vector.sub(this.lockedOn.position, this.position)), this.mass * THRUST)
                } else {
                    this.force = Vector.mult(Vector.normalise(this.velocity), this.mass * THRUST)
                }
                this.torque += this.inertia * this.spin
            }
        })

        Composite.add(engine.world, bullet[me]); //add bullet to world
        // Matter.Body.setAngularVelocity(bullet[me], 2 * (0.5 - Math.random()))  //doesn't work due to high friction
        Matter.Body.setVelocity(bullet[me], {
            x: speed * Math.cos(dir),
            y: speed * Math.sin(dir)
        });
        Matter.Body.setAngularVelocity(bullet[me], 3000 * bullet[me].spin);
    },
    flea(where, velocity, radius = 6 + 3 * Math.random() + 10 * tech.wormSize * Math.random()) {
        const me = bullet.length;
        bullet[me] = Bodies.polygon(where.x, where.y, 5, radius, {
            isFlea: true,
            angle: 0.5 * Math.random(),
            friction: 1,
            frictionStatic: 1,
            frictionAir: 0, //0.01,
            restitution: 0,
            density: 0.0005, //  0.001 is normal density
            lookFrequency: 19 + Math.floor(7 * Math.random()),
            endCycle: simulation.cycle + Math.floor((900 * tech.bulletsLastLonger + 420 * Math.random()) + Math.max(0, 150 - bullet.length)), // 13 - 19s
            classType: "bullet",
            collisionFilter: {
                category: cat.bullet,
                mask: cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield
            },
            minDmgSpeed: 0,
            lockedOn: null,
            delay: 50,
            cd: simulation.cycle + 10,
            dmg: 0,
            setDamage() { //dmg is set to zero after doing damage once, and set back to normal after jumping
                this.dmg = radius * (tech.isMutualism ? 3.3 : 1.1) //damage done in addition to the damage from momentum  //spores do 7 dmg, worms do 18
            },
            beforeDmg(who) {
                Matter.Body.setVelocity(this, Vector.mult(Vector.normalise(Vector.sub(this.position, who.position)), 10 + 10 * Math.random())); //push away from target
                this.cd = simulation.cycle + this.delay;
                if (!who.isInvulnerable && this.dmg !== 0) {
                    this.endCycle -= 110
                    if (tech.isSporeFreeze) mobs.statusSlow(who, 90)
                    if (tech.isSpawnBulletsOnDeath && who.alive && who.isDropPowerUp) {
                        setTimeout(() => {
                            if (!who.alive) {
                                for (let i = 0; i < 2; i++) { //spawn 2 more
                                    const speed = 10 + 5 * Math.random()
                                    const angle = 2 * Math.PI * Math.random()
                                    b.flea(this.position, {
                                        x: speed * Math.cos(angle),
                                        y: speed * Math.sin(angle)
                                    })
                                }
                            }
                            this.endCycle = 0;
                        }, 1);
                    }
                    setTimeout(() => {
                        this.dmg = 0
                    })
                }
            },
            onEnd() {
                if (tech.isMutualism && this.isMutualismActive && !tech.isEnergyHealth) {
                    m.health += 0.02
                    if (m.health > m.maxHealth) m.health = m.maxHealth;
                    m.displayHealth();
                }
            },
            gravity: 0.002 + 0.002 * tech.isSporeFollow,
            do() {
                this.force.y += this.gravity * this.mass
                if (this.cd < simulation.cycle && (Matter.Query.collides(this, map).length || Matter.Query.collides(this, body).length)) { //if on the ground and not on jump cooldown //
                    this.cd = simulation.cycle + this.delay;
                    this.lockedOn = null; //find a target
                    let closeDist = Infinity;
                    for (let i = 0, len = mob.length; i < len; ++i) {
                        if (
                            !mob[i].isBadTarget &&
                            !mob[i].isInvulnerable &&
                            mob[i].alive &&
                            this.position.y - mob[i].position.y < 1500 && //this is about how high fleas can jump with  capMaxY = 0.12 + 0.04 * Math.random()
                            this.position.y - mob[i].position.y > -300 && //not too far below the flea (note that fleas should be on the ground most of the time when doing this check)
                            Matter.Query.ray(map, this.position, mob[i].position).length === 0 &&
                            Matter.Query.ray(body, this.position, mob[i].position).length === 0
                        ) {
                            const TARGET_VECTOR = Vector.sub(this.position, mob[i].position)
                            const DIST = Vector.magnitude(TARGET_VECTOR);
                            if (DIST < closeDist) {
                                closeDist = DIST;
                                this.lockedOn = mob[i]
                            }
                        }
                    }
                    if (tech.isSporeFollow && !this.lockedOn && Matter.Query.ray(map, this.position, m.pos).length === 0) {
                        this.lockedOn = { //make target player if there are no mobs to target
                            position: m.pos,
                            velocity: { x: 0, y: 0 }
                        }
                    }
                    if (this.lockedOn) { //hop towards mob target
                        const where = Vector.add(this.lockedOn.position, Vector.mult(this.lockedOn.velocity, 5)) //estimate where the mob will be in 5 cycles
                        const Dy = Math.max(0, this.position.y - where.y) //can't be negative because you can't hop down
                        const Dx = this.position.x - where.x
                        const Vx = -0.06 * Dx / Math.sqrt(2 * Dy / this.gravity) //calibrated to hit target, don't mess with this
                        const Vy = 0.085 * Math.sqrt(this.gravity * Dy) //calibrated to hit target, don't mess with this
                        const capX = 0.07 + 0.02 * tech.isSporeFollow
                        const capMaxY = 0.12 + 0.04 * Math.random() + 0.05 * tech.isSporeFollow
                        const capMinY = closeDist > 500 ? 0.05 + 0.02 * Math.random() : 0.02 + 0.01 * Math.random() //don't jump super low, unless you are very close to mob target
                        this.force.x = Math.max(-capX, Math.min(capX, Vx)) * this.mass;
                        this.force.y = -Math.max(capMinY, Math.min(capMaxY, Vy)) * this.mass
                    } else { //random hops  
                        if (Math.random() < 0.5) { //chance to continue in the same horizontal direction
                            this.force.x = (0.01 + 0.03 * Math.random()) * this.mass * (this.velocity.x > 0 ? 1 : -1); //random move 
                        } else {
                            this.force.x = (0.01 + 0.03 * Math.random()) * this.mass * (Math.random() < 0.5 ? 1 : -1); //random move 
                        }
                        this.force.y = -(0.03 + 0.08 * Math.random()) * this.mass
                    }
                    Matter.Body.setVelocity(this, { x: 0, y: 0 });
                    this.setDamage() //after jumping damage is no longer zero
                }
            }
        })
        Composite.add(engine.world, bullet[me]); //add bullet to world
        Matter.Body.setVelocity(bullet[me], velocity);
        if (tech.isMutualism && m.health > 0.01) {
            m.health -= 0.01
            m.displayHealth();
            bullet[bullet.length - 1].isMutualismActive = true
        }
    },
    delayDrones(where, droneCount = 1, deliveryCount = 0) {
        let respawnDrones = () => {
            if (droneCount > 0) {
                requestAnimationFrame(respawnDrones);
                if (!simulation.paused && !simulation.isChoosing && m.alive) {
                    droneCount--
                    if (tech.isDroneRadioactive) {
                        b.droneRadioactive({ x: where.x + 50 * (Math.random() - 0.5), y: where.y + 50 * (Math.random() - 0.5) }, 0)
                    } else {
                        b.drone({ x: where.x + 50 * (Math.random() - 0.5), y: where.y + 50 * (Math.random() - 0.5) }, 0)
                        if (tech.isDroneGrab && deliveryCount > 0) { //
                            const who = bullet[bullet.length - 1]
                            who.isImproved = true;
                            const SCALE = 2.25
                            Matter.Body.scale(who, SCALE, SCALE);
                            who.lookFrequency = 30 + Math.floor(11 * Math.random());
                            who.endCycle += 3000 * tech.droneCycleReduction * tech.bulletsLastLonger
                            deliveryCount--
                        }
                    }
                }
            }
        }
        requestAnimationFrame(respawnDrones);
    },
    drone(where = { x: m.pos.x + 30 * Math.cos(m.angle) + 20 * (Math.random() - 0.5), y: m.pos.y + 30 * Math.sin(m.angle) + 20 * (Math.random() - 0.5) }, speed = 1) {
        const me = bullet.length;
        const THRUST = 0.0015
        const dir = m.angle + 0.2 * (Math.random() - 0.5);
        const RADIUS = (4.5 + 3 * Math.random())
        bullet[me] = Bodies.polygon(where.x, where.y, 8, RADIUS, {
            angle: dir,
            inertia: Infinity,
            friction: 0.05,
            frictionAir: 0,
            restitution: 1,
            density: 0.0005, //  0.001 is normal density
            dmg: 0.34 + 0.12 * tech.isDroneTeleport + 0.15 * tech.isDroneFastLook, //damage done in addition to the damage from momentum
            lookFrequency: (tech.isDroneFastLook ? 20 : 70) + Math.floor(17 * Math.random()),
            endCycle: simulation.cycle + Math.floor((950 + 400 * Math.random()) * tech.bulletsLastLonger * tech.droneCycleReduction) + 5 * RADIUS + Math.max(0, 150 - bullet.length),
            classType: "bullet",
            isDrone: true,
            collisionFilter: {
                category: cat.bullet,
                mask: cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet | cat.mobShield //self collide
            },
            minDmgSpeed: 0,
            lockedOn: null,
            deathCycles: 110 + RADIUS * 5,
            isImproved: false,
            beforeDmg(who) {
                if (who.isInvulnerable) {
                    //move away from target after hitting
                    const unit = Vector.mult(Vector.normalise(Vector.sub(this.position, who.position)), -20)
                    Matter.Body.setVelocity(this, { x: unit.x, y: unit.y });
                    this.lockedOn = null
                } else {
                    // if (tech.isIncendiary && simulation.cycle + this.deathCycles < this.endCycle && !tech.isForeverDrones) {
                    //     const max = Math.max(Math.min(this.endCycle - simulation.cycle - this.deathCycles, 1500), 0)
                    //     b.explosion(this.position, max * 0.14 + this.isImproved * 110 + 60 * Math.random()); //makes bullet do explosive damage at end
                    //     if (tech.isForeverDrones) {
                    //         this.endCycle = 0
                    //         b.drone({ x: m.pos.x + 30 * (Math.random() - 0.5), y: m.pos.y + 30 * (Math.random() - 0.5) }, 5)
                    //         bullet[bullet.length - 1].endCycle = Infinity
                    //     } else {
                    //         this.endCycle -= max
                    //     }
                    // } else {
                    //move away from target after hitting
                    const unit = Vector.mult(Vector.normalise(Vector.sub(this.position, who.position)), -20)
                    Matter.Body.setVelocity(this, { x: unit.x, y: unit.y });
                    this.lockedOn = null
                    if (this.endCycle > simulation.cycle + this.deathCycles) {
                        this.endCycle -= 60
                        if (simulation.cycle + this.deathCycles > this.endCycle) this.endCycle = simulation.cycle + this.deathCycles
                    }
                    // }
                }
            },
            onEnd() {
                if (tech.isDroneRespawn) {
                    //are there any nearby bodies nearby that aren't blocked by map?
                    const canSee = body.filter(a => Matter.Query.ray(map, this.position, a.position).length === 0 && !a.isNotHoldable && Vector.magnitude(Vector.sub(this.position, a.position)) < 70 + 30 * a.mass)
                    if (canSee.length) {
                        //find the closest body to the drone from the canSee array
                        const found = canSee.reduce((a, b) => {
                            const distA = Vector.magnitude(Vector.sub(this.position, a.position))
                            const distB = Vector.magnitude(Vector.sub(this.position, b.position))
                            return distA < distB ? a : b
                        })
                        if (found && m.energy > 0.041) {
                            m.energy -= 0.04
                            //remove the body and spawn a new drone
                            Composite.remove(engine.world, found)
                            body.splice(body.indexOf(found), 1)
                            b.delayDrones(found.position, Math.sqrt(found.mass))
                            //draw a line from the drone to the body on the canvas
                            ctx.beginPath();
                            ctx.moveTo(this.position.x, this.position.y);
                            ctx.lineTo(found.position.x, found.position.y);
                            ctx.strokeStyle = "#000";
                            ctx.lineWidth = 2;
                            ctx.stroke();

                            //animate the block fading away
                            simulation.ephemera.push({
                                name: "droneRespawn",
                                count: 60, //cycles before it self removes
                                do() {
                                    this.count--
                                    if (this.count < 0) simulation.removeEphemera(this.name)
                                    ctx.beginPath();
                                    let vertices = found.vertices;
                                    ctx.moveTo(vertices[0].x, vertices[0].y);
                                    for (let j = 1; j < vertices.length; j++) ctx.lineTo(vertices[j].x, vertices[j].y);
                                    ctx.lineTo(vertices[0].x, vertices[0].y);
                                    ctx.lineWidth = 2;
                                    ctx.strokeStyle = `rgba(0,0,0,${this.count / 60})`
                                    ctx.stroke();
                                },
                            })
                        }
                    }
                }
            },
            doRespawning() { //fall shrink and die
                const scale = 0.995;
                Matter.Body.scale(this, scale, scale);
                if (this.bodyTarget) {
                    this.force = Vector.mult(Vector.normalise(Vector.sub(this.position, this.bodyTarget.position)), -this.mass * THRUST)
                } else {
                    this.force.y += this.mass * 0.0012;
                }
            },
            doDieing() { //fall shrink and die
                this.force.y += this.mass * 0.0012;
                const scale = 0.995;
                Matter.Body.scale(this, scale, scale);
            },
            hasExploded: false,
            eatPowerUp(i) {
                simulation.ephemera.push({
                    name: "drone grab",
                    count: 5, //cycles before it self removes
                    pos: this.position,
                    PposX: powerUp[i].position.x,
                    PposY: powerUp[i].position.y,
                    size: powerUp[i].size,
                    color: powerUp[i].color,
                    do() {
                        this.count--
                        if (this.count < 0) simulation.removeEphemera(this.name)
                        ctx.strokeStyle = "#000"
                        ctx.lineWidth = 3
                        ctx.beginPath();
                        ctx.moveTo(this.pos.x, this.pos.y);
                        ctx.lineTo(this.PposX, this.PposY);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(this.PposX, this.PposY, this.size * (this.count + 2) / 7, 0, 2 * Math.PI);
                        ctx.fillStyle = this.color
                        ctx.fill();
                    },
                })
                //pick up nearby power ups
                powerUps.onPickUp(powerUp[i]);
                powerUp[i].effect();
                Matter.Composite.remove(engine.world, powerUp[i]);
                powerUp.splice(i, 1);
                if (tech.isDroneGrab) {
                    this.isImproved = true;
                    const SCALE = 2.25
                    Matter.Body.scale(this, SCALE, SCALE);
                    this.lookFrequency = 30 + Math.floor(11 * Math.random());
                    this.endCycle += 3000 * tech.droneCycleReduction * tech.bulletsLastLonger
                }
            },
            do() {
                if (simulation.cycle + this.deathCycles > this.endCycle) {
                    if (tech.isIncendiary && !this.hasExploded) {
                        this.hasExploded = true
                        // const max = Math.max(Math.min(this.endCycle - simulation.cycle - this.deathCycles, 1500), 0)
                        // this.endCycle -= max
                        b.explosion(this.position, 200 + this.isImproved * 110 + 60 * Math.random()); //makes bullet do explosive damage at end
                    }
                    this.restitution = 0.2;
                    if (tech.isDroneRespawn) {
                        this.do = this.doRespawning
                        //make a list of all elements of array body that a ray can be drawn to from the drone                        
                        const canSee = body.filter(a => Matter.Query.ray(map, this.position, a.position).length === 0 && !a.isNotHoldable)
                        if (canSee.length) {
                            //find the closest body to the drone from the canSee array
                            const found = canSee.reduce((a, b) => {
                                const distA = Vector.magnitude(Vector.sub(this.position, a.position))
                                const distB = Vector.magnitude(Vector.sub(this.position, b.position))
                                return distA < distB ? a : b
                            })
                            if (found) this.bodyTarget = found
                        }
                    } else {
                        this.do = this.doDieing
                    }
                }

                this.force.y += this.mass * 0.0002;
                if (!(simulation.cycle % this.lookFrequency)) {
                    //find mob targets
                    this.lockedOn = null;
                    let closeDist = Infinity;
                    for (let i = 0, len = mob.length; i < len; ++i) {
                        if (
                            !mob[i].isBadTarget &&
                            Matter.Query.ray(map, this.position, mob[i].position).length === 0 &&
                            Matter.Query.ray(body, this.position, mob[i].position).length === 0 &&
                            !mob[i].isInvulnerable
                        ) {
                            const TARGET_VECTOR = Vector.sub(this.position, mob[i].position)
                            const DIST = Vector.magnitude(TARGET_VECTOR)
                            if (DIST < closeDist) {
                                closeDist = DIST;
                                this.lockedOn = mob[i]
                            }
                        }
                    }
                    //blink towards mobs
                    if (tech.isDroneTeleport && this.lockedOn) {
                        const sub = Vector.sub(this.lockedOn.position, this.position);
                        const distMag = Vector.magnitude(sub);
                        const unit = Vector.normalise(sub)
                        Matter.Body.setVelocity(this, Vector.mult(unit, Math.max(20, this.speed * 1.5)));
                        ctx.beginPath();
                        ctx.moveTo(this.position.x, this.position.y);
                        Matter.Body.translate(this, Vector.mult(unit, Math.min(350, distMag - this.lockedOn.radius + 10)));
                        ctx.lineTo(this.position.x, this.position.y);
                        ctx.lineWidth = RADIUS * 2;
                        ctx.strokeStyle = "rgba(0,0,0,0.5)";
                        ctx.stroke();
                    }
                    //power ups
                    if (!this.isImproved && !simulation.isChoosing) {
                        if (this.lockedOn) {
                            for (let i = 0, len = powerUp.length; i < len; ++i) { //grab, but don't lock onto nearby power up
                                if (
                                    Vector.magnitudeSquared(Vector.sub(this.position, powerUp[i].position)) < 20000
                                    && !simulation.isChoosing
                                    && !(
                                        (m.health > 0.94 * m.maxHealth && !tech.isOverHeal && !tech.isDroneGrab && powerUp[i].name === "heal") ||
                                        (tech.isSuperDeterminism && powerUp[i].name === "field") ||
                                        ((tech.isEnergyNoAmmo || b.inventory.length === 0) && powerUp[i].name === "ammo")
                                    )
                                ) {
                                    this.eatPowerUp(i)
                                    break;
                                }
                            }
                        } else {
                            //look for power ups to lock onto
                            let closeDist = Infinity;
                            for (let i = 0, len = powerUp.length; i < len; ++i) {
                                if (!(
                                    (m.health > 0.94 * m.maxHealth && !tech.isOverHeal && !tech.isDroneGrab && powerUp[i].name === "heal") ||
                                    (tech.isSuperDeterminism && powerUp[i].name === "field") ||
                                    ((tech.isEnergyNoAmmo || b.inventory.length === 0) && powerUp[i].name === "ammo")
                                )) {
                                    if (Vector.magnitudeSquared(Vector.sub(this.position, powerUp[i].position)) < 20000 && !simulation.isChoosing) {
                                        this.eatPowerUp(i)
                                        break;
                                    }
                                    //look for power ups to lock onto
                                    if (
                                        Matter.Query.ray(map, this.position, powerUp[i].position).length === 0 //&& Matter.Query.ray(body, this.position, powerUp[i].position).length === 0
                                    ) {
                                        const TARGET_VECTOR = Vector.sub(this.position, powerUp[i].position)
                                        const DIST = Vector.magnitude(TARGET_VECTOR);
                                        if (DIST < closeDist) {
                                            closeDist = DIST;
                                            this.lockedOn = powerUp[i]
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (this.lockedOn) { //accelerate towards mobs
                    this.force = Vector.mult(Vector.normalise(Vector.sub(this.position, this.lockedOn.position)), -this.mass * THRUST)
                } else { //accelerate towards mouse
                    this.force = Vector.mult(Vector.normalise(Vector.sub(this.position, simulation.mouseInGame)), -this.mass * THRUST)
                }
                // speed cap instead of friction to give more agility
                if (this.speed > 6) {
                    Matter.Body.setVelocity(this, { x: this.velocity.x * 0.97, y: this.velocity.y * 0.97 });
                }
            }
        })
        Composite.add(engine.world, bullet[me]); //add bullet to world
        Matter.Body.setVelocity(bullet[me], { x: speed * Math.cos(dir), y: speed * Math.sin(dir) });
    },
    droneRadioactive(where = {
        x: m.pos.x + 30 * Math.cos(m.angle) + 20 * (Math.random() - 0.5),
        y: m.pos.y + 30 * Math.sin(m.angle) + 20 * (Math.random() - 0.5)
    }, speed = 1) {
        const me = bullet.length;
        const THRUST = (tech.isFastDrones ? 0.003 : 0.0012) + 0.0005 * (Math.random() - 0.5)
        const dir = m.angle + 0.4 * (Math.random() - 0.5);
        const RADIUS = 3
        bullet[me] = Bodies.polygon(where.x, where.y, 8, RADIUS, {
            angle: dir,
            inertia: Infinity,
            friction: 0,
            frictionAir: 0,
            restitution: 0.4 + 0.199 * Math.random(),
            dmg: 0, //0.24   damage done in addition to the damage from momentum   and radiation
            lookFrequency: 120 + Math.floor(23 * Math.random()),
            endCycle: simulation.cycle + Math.floor((900 + 110 * Math.random()) * tech.bulletsLastLonger / tech.droneRadioDamage) + 5 * RADIUS + Math.max(0, 150 - 2 * bullet.length),
            classType: "bullet",
            isDrone: true,
            collisionFilter: {
                category: cat.bullet,
                mask: cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet | cat.mobShield //self collide
            },
            minDmgSpeed: 0,
            speedCap: 5 + 2 * Math.random(), //6 is normal
            lockedOn: null,
            deathCycles: 110 + RADIUS * 5,
            isImproved: false,
            radioRadius: 0,
            maxRadioRadius: 270 + Math.floor(90 * Math.random()),
            beforeDmg() { },
            onEnd() {
                if (tech.isDroneRespawn) {
                    //are there any nearby bodies nearby that aren't blocked by map?
                    const canSee = body.filter(a => Matter.Query.ray(map, this.position, a.position).length === 0 && !a.isNotHoldable && Vector.magnitude(Vector.sub(this.position, a.position)) < 70 + 30 * a.mass)
                    if (canSee.length) {
                        //find the closest body to the drone from the canSee array
                        const found = canSee.reduce((a, b) => {
                            const distA = Vector.magnitude(Vector.sub(this.position, a.position))
                            const distB = Vector.magnitude(Vector.sub(this.position, b.position))
                            return distA < distB ? a : b
                        })
                        if (found && m.energy > 0.091) {
                            m.energy -= 0.09
                            //remove the body and spawn a new drone
                            Composite.remove(engine.world, found)
                            body.splice(body.indexOf(found), 1)
                            b.delayDrones(found.position, 0.5 * Math.sqrt(found.mass))
                            //draw a line from the drone to the body on the canvas
                            ctx.beginPath();
                            ctx.moveTo(this.position.x, this.position.y);
                            ctx.lineTo(found.position.x, found.position.y);
                            ctx.strokeStyle = "#000";
                            ctx.lineWidth = 2;
                            ctx.stroke();

                            //animate the block fading away
                            simulation.ephemera.push({
                                name: "droneRespawn",
                                count: 60, //cycles before it self removes
                                do() {
                                    this.count--
                                    if (this.count < 0) simulation.removeEphemera(this.name)
                                    ctx.beginPath();
                                    let vertices = found.vertices;
                                    ctx.moveTo(vertices[0].x, vertices[0].y);
                                    for (let j = 1; j < vertices.length; j++) {
                                        ctx.lineTo(vertices[j].x, vertices[j].y);
                                    }
                                    ctx.lineTo(vertices[0].x, vertices[0].y);
                                    ctx.lineWidth = 2;
                                    ctx.strokeStyle = `rgba(0,0,0,${this.count / 60})`
                                    ctx.stroke();
                                },
                            })
                        }
                    }
                }
            },
            do() {
                //radioactive zone
                this.radioRadius = this.radioRadius * 0.993 + 0.007 * this.maxRadioRadius //smooth radius towards max
                //aoe damage to player
                if (Vector.magnitude(Vector.sub(player.position, this.position)) < this.radioRadius) {
                    const DRAIN = tech.isRadioactiveResistance ? 0.001 : 0.004
                    if (m.energy > DRAIN) {
                        if (m.immuneCycle < m.cycle) m.energy -= DRAIN
                    } else {
                        m.energy = 0;
                        m.takeDamage((tech.isRadioactiveResistance ? 0.00004 : 0.0002) * tech.radioactiveDamage * spawn.dmgToPlayerByLevelsCleared()) //0.00015
                    }
                }
                //aoe damage to mobs
                let dmg = (0.12 + 0.04 * tech.isFastDrones) * tech.droneRadioDamage * tech.radioactiveDamage
                for (let i = 0, len = mob.length; i < len; i++) {
                    if (Vector.magnitude(Vector.sub(mob[i].position, this.position)) < this.radioRadius + mob[i].radius) {
                        if (Matter.Query.ray(map, mob[i].position, this.position).length > 0) dmg *= 0.25 //reduce damage if a wall is in the way
                        mob[i].damage(mob[i].shield ? dmg * 3 : dmg);
                        mob[i].locatePlayer();
                    }
                }
                //draw
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radioRadius, 0, 2 * Math.PI);
                ctx.globalCompositeOperation = "lighter"
                // ctx.fillStyle = `rgba(25,139,170,${0.15+0.05*Math.random()})`;
                // ctx.fillStyle = `rgba(36, 207, 255,${0.1+0.05*Math.random()})`;
                ctx.fillStyle = `rgba(28, 175, 217,${0.13 + 0.07 * Math.random()})`;
                ctx.fill();
                ctx.globalCompositeOperation = "source-over"

                //normal drone actions
                if (simulation.cycle + this.deathCycles > this.endCycle) { //fall shrink and die
                    this.force.y += this.mass * 0.0012;
                    this.restitution = 0.2;
                    const scale = 0.995;
                    Matter.Body.scale(this, scale, scale);
                    this.maxRadioRadius = 0
                    this.radioRadius = this.radioRadius * 0.98 //let radioactivity decrease
                } else {
                    this.force.y += this.mass * 0.0002; //gravity

                    if (!(simulation.cycle % this.lookFrequency)) {
                        //find mob targets
                        this.lockedOn = null;
                        let closeDist = Infinity;
                        for (let i = 0, len = mob.length; i < len; ++i) {
                            if (
                                !mob[i].isBadTarget &&
                                Matter.Query.ray(map, this.position, mob[i].position).length === 0 &&
                                Matter.Query.ray(body, this.position, mob[i].position).length === 0 &&
                                !mob[i].isInvulnerable
                            ) {
                                const TARGET_VECTOR = Vector.sub(this.position, mob[i].position)
                                const DIST = Vector.magnitude(TARGET_VECTOR);
                                if (DIST < closeDist) {
                                    closeDist = DIST;
                                    this.lockedOn = mob[i]
                                }
                            }
                        }
                        //power ups
                        if (!this.isImproved && !simulation.isChoosing) {
                            if (this.lockedOn) {
                                //grab, but don't lock onto nearby power up
                                for (let i = 0, len = powerUp.length; i < len; ++i) {
                                    if (
                                        Vector.magnitudeSquared(Vector.sub(this.position, powerUp[i].position)) < 20000 &&
                                        !(
                                            (m.health > 0.93 * m.maxHealth && !tech.isDroneGrab && powerUp[i].name === "heal") ||
                                            (tech.isSuperDeterminism && powerUp[i].name === "field") ||
                                            ((tech.isEnergyNoAmmo || b.inventory.length === 0) && powerUp[i].name === "ammo")
                                        )
                                    ) {
                                        //draw pickup for a single cycle
                                        ctx.beginPath();
                                        ctx.moveTo(this.position.x, this.position.y);
                                        ctx.lineTo(powerUp[i].position.x, powerUp[i].position.y);
                                        ctx.strokeStyle = "#000"
                                        ctx.lineWidth = 4
                                        ctx.stroke();
                                        //pick up nearby power ups
                                        powerUps.onPickUp(powerUp[i]);
                                        powerUp[i].effect();
                                        Matter.Composite.remove(engine.world, powerUp[i]);
                                        powerUp.splice(i, 1);
                                        if (tech.isDroneGrab) {
                                            this.isImproved = true;
                                            const SCALE = 2.25
                                            Matter.Body.scale(this, SCALE, SCALE);
                                            this.lookFrequency = 30 + Math.floor(11 * Math.random());
                                            this.endCycle += 1000 * tech.bulletsLastLonger
                                            this.maxRadioRadius *= 1.25
                                        }
                                        break;
                                    }
                                }
                            } else {
                                //look for power ups to lock onto
                                let closeDist = Infinity;
                                for (let i = 0, len = powerUp.length; i < len; ++i) {
                                    if (!(
                                        (m.health > 0.93 * m.maxHealth && !tech.isDroneGrab && powerUp[i].name === "heal") ||
                                        (tech.isSuperDeterminism && powerUp[i].name === "field") ||
                                        ((tech.isEnergyNoAmmo || b.inventory.length === 0) && powerUp[i].name === "ammo")
                                    )) {
                                        if (Vector.magnitudeSquared(Vector.sub(this.position, powerUp[i].position)) < 20000 && !simulation.isChoosing) {
                                            //draw pickup for a single cycle
                                            ctx.beginPath();
                                            ctx.moveTo(this.position.x, this.position.y);
                                            ctx.lineTo(powerUp[i].position.x, powerUp[i].position.y);
                                            ctx.strokeStyle = "#000"
                                            ctx.lineWidth = 4
                                            ctx.stroke();
                                            //pick up nearby power ups
                                            powerUps.onPickUp(powerUp[i]);
                                            powerUp[i].effect();
                                            Matter.Composite.remove(engine.world, powerUp[i]);
                                            powerUp.splice(i, 1);
                                            if (tech.isDroneGrab) {
                                                this.isImproved = true;
                                                const SCALE = 2.25
                                                Matter.Body.scale(this, SCALE, SCALE);
                                                this.lookFrequency = 30 + Math.floor(11 * Math.random());
                                                this.endCycle += 1000 * tech.bulletsLastLonger
                                                this.maxRadioRadius *= 1.25
                                            }
                                            break;
                                        }
                                        //look for power ups to lock onto
                                        if (
                                            Matter.Query.ray(map, this.position, powerUp[i].position).length === 0 &&
                                            Matter.Query.ray(body, this.position, powerUp[i].position).length === 0
                                        ) {
                                            const TARGET_VECTOR = Vector.sub(this.position, powerUp[i].position)
                                            const DIST = Vector.magnitude(TARGET_VECTOR);
                                            if (DIST < closeDist) {
                                                closeDist = DIST;
                                                this.lockedOn = powerUp[i]
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (this.lockedOn) { //accelerate towards mobs
                        this.force = Vector.mult(Vector.normalise(Vector.sub(this.position, this.lockedOn.position)), -this.mass * THRUST)
                    } else { //accelerate towards mouse
                        this.force = Vector.mult(Vector.normalise(Vector.sub(this.position, simulation.mouseInGame)), -this.mass * THRUST)
                    }
                    // speed cap instead of friction to give more agility
                    if (this.speed > this.speedCap) {
                        Matter.Body.setVelocity(this, {
                            x: this.velocity.x * 0.97,
                            y: this.velocity.y * 0.97
                        });
                    }
                }
            }
        })
        Composite.add(engine.world, bullet[me]); //add bullet to world
        Matter.Body.setVelocity(bullet[me], {
            x: speed * Math.cos(dir),
            y: speed * Math.sin(dir)
        });
    },
    superBall(where, velocity, radius) {
        let gravity = 0.001
        if (tech.superBallDelay) {
            velocity = Vector.mult(velocity, 1.4)
            gravity *= 6
        }
        let dir = m.angle
        const me = bullet.length;
        bullet[me] = Bodies.polygon(where.x, where.y, 12, radius, b.fireAttributes(dir, false));
        Composite.add(engine.world, bullet[me]); //add bullet to world
        Matter.Body.setVelocity(bullet[me], velocity);
        Matter.Body.setDensity(bullet[me], 0.0007 + 0.0007 * tech.isSuperHarm + 0.0007 * tech.isBulletTeleport);
        bullet[me].endCycle = simulation.cycle + Math.floor(270 + 90 * Math.random());
        bullet[me].minDmgSpeed = 0;
        bullet[me].restitution = 1;
        bullet[me].frictionAir = 0;
        bullet[me].friction = 0;
        bullet[me].frictionStatic = 0;
        if (tech.isSuperHarm) {
            bullet[me].collidePlayerDo = function () {
                this.force.y += this.mass * gravity;;
                if (Matter.Query.collides(this, [player]).length) {
                    this.endCycle = 0
                    // m.energy -= 0.04
                    // if (m.energy < 0) m.energy = 0
                    // simulation.drawList.push({ //add dmg to draw queue
                    //     x: this.position.x,
                    //     y: this.position.y,
                    //     radius: radius,
                    //     color: "#0ad",
                    //     time: 15
                    // });
                }
            }
            bullet[me].cycle = 0
            bullet[me].do = function () {
                this.cycle++
                if (this.cycle > 2) this.do = this.collidePlayerDo
                this.force.y += this.mass * 0.001;
            };
        } else if (tech.isBulletTeleport) {
            bullet[me].portFrequency = 25 + Math.floor(10 * Math.random())
            bullet[me].nextPortCycle = simulation.cycle + bullet[me].portFrequency
            bullet[me].do = function () {
                this.force.y += this.mass * gravity;
                if (this.nextPortCycle < simulation.cycle) { //teleport around if you have tech.isBulletTeleport
                    this.nextPortCycle = simulation.cycle + this.portFrequency
                    const range = 33 * Math.sqrt(radius) * Math.random()
                    Matter.Body.setPosition(this, Vector.add(this.position, Vector.rotate({ x: range, y: 0 }, 2 * Math.PI * Math.random())))
                    Matter.Body.setVelocity(this, Vector.rotate(this.velocity, 2 * (Math.random() * Math.random() - 0.25)))
                }
            };
        } else {
            bullet[me].do = function () {
                this.force.y += this.mass * gravity;
            };
        }
        bullet[me].beforeDmg = function (who) {
            if (!who.isInvulnerable) {
                if (tech.oneSuperBall) mobs.statusStun(who, 120) // (2.3) * 2 / 14 ticks (2x damage over 7 seconds)
                if (tech.isFoamBall) {
                    for (let i = 0, len = 6 * this.mass; i < len; i++) {
                        const radius = 6 + 9 * Math.random()
                        const velocity = { x: Math.max(0.5, 2 - radius * 0.1), y: 0 }
                        b.foam(this.position, Vector.rotate(velocity, 6.28 * Math.random()), radius)
                    }
                    this.endCycle = 0
                }
                if (tech.isIncendiary) {
                    b.explosion(this.position, this.mass * 280); //makes bullet do explosive damage at end
                    this.endCycle = 0
                } else if (tech.isSuperBounce) {
                    const cycle = () => {
                        Matter.Body.setDensity(this, (0.0007 + 0.0007 * tech.isSuperHarm + 0.0007 * tech.isBulletTeleport) * 1.33);//33% more density and damage
                        this.endCycle = simulation.cycle + Math.floor(300 + 90 * Math.random()); //reset to full duration of time
                        Matter.Body.setVelocity(this, Vector.mult(Vector.normalise(this.velocity), 60)); //reset to high velocity
                        let count = 5
                        const wait = () => {
                            count--
                            if (count > 0) requestAnimationFrame(wait);
                            simulation.drawList.push({ //add dmg to draw queue
                                x: this.position.x,
                                y: this.position.y,
                                radius: radius,
                                color: 'rgba(255, 0, 0, 0.33)',
                                time: 8
                            });
                        }
                        requestAnimationFrame(wait);
                        simulation.drawList.push({ //add dmg to draw queue
                            x: this.position.x,
                            y: this.position.y,
                            radius: radius,
                            color: 'rgba(255, 0, 0, 0.33)',
                            time: 8
                        });
                    }
                    requestAnimationFrame(cycle);
                }
            }
        };
    },
    targetedBall(position, num = 1, speed = 42 + 12 * Math.random(), range = 1200, isRandomAim = true) {
        let shotsFired = 0
        const targets = [] //target nearby mobs
        for (let i = 0, len = mob.length; i < len; i++) {
            const dist = Vector.magnitude(Vector.sub(position, mob[i].position));
            if (
                dist < range + mob[i].radius &&
                !mob[i].isBadTarget &&
                Matter.Query.ray(map, position, mob[i].position).length === 0 &&
                Matter.Query.ray(body, position, mob[i].position).length === 0 &&
                !mob[i].isInvulnerable
            ) {
                targets.push(Vector.add(mob[i].position, Vector.mult(mob[i].velocity, dist / 60))) //predict where the mob will be in a few cycles
            }
        }
        const radius = (11 + 9 * tech.oneSuperBall) * tech.bulletSize
        for (let i = 0; i < num; i++) {
            if (targets.length > 0) { // aim near a random target in array
                const index = Math.floor(Math.random() * targets.length)
                const SPREAD = 160 / targets.length
                const WHERE = {
                    x: targets[index].x + SPREAD * (Math.random() - 0.5),
                    y: targets[index].y + SPREAD * (Math.random() - 0.5)
                }
                b.superBall(position, Vector.mult(Vector.normalise(Vector.sub(WHERE, position)), speed), radius)
                shotsFired++
            } else if (isRandomAim) { // aim in random direction
                const ANGLE = 2 * Math.PI * Math.random()
                b.superBall(position, { x: speed * Math.cos(ANGLE), y: speed * Math.sin(ANGLE) }, radius)
            }
        }
        return shotsFired
    },
    targetedFoam(position, num = 1, speed = 21 + 7 * Math.random(), range = 1200, isRandomAim = true) {
        let shotsFired = 0
        const targets = [] //target nearby mobs
        for (let i = 0, len = mob.length; i < len; i++) {
            const dist = Vector.magnitude(Vector.sub(position, mob[i].position));
            if (
                dist < range + mob[i].radius &&
                !mob[i].isBadTarget && //|| mob[i].isMobBullet
                Matter.Query.ray(map, position, mob[i].position).length === 0 &&
                !mob[i].isInvulnerable
            ) {
                targets.push(Vector.add(mob[i].position, Vector.mult(mob[i].velocity, dist / 60))) //predict where the mob will be in a few cycles
            }
        }
        for (let i = 0; i < num; i++) {
            if (targets.length > 0) { // aim near a random target in array
                const SPREAD = 160 / targets.length
                const index = Math.floor(Math.random() * targets.length)
                const radius = 11 + 12 * Math.random()
                const where = {
                    x: targets[index].x + SPREAD * (Math.random() - 0.5),
                    y: targets[index].y + SPREAD * (Math.random() - 0.5)
                }
                b.foam(position, Vector.mult(Vector.normalise(Vector.sub(where, position)), speed - radius * 0.25), radius)
                shotsFired++
            } else if (isRandomAim) { // aim in random direction
                const ANGLE = 2 * Math.PI * Math.random()
                b.foam(position, { x: speed * Math.cos(ANGLE), y: speed * Math.sin(ANGLE) }, 8 + 11 * Math.random())
            }
        }
        return shotsFired
    },
    foam(position, velocity, radius) {
        if (tech.isFoamCavitation && Math.random() < 0.25) {
            velocity = Vector.mult(velocity, 1.35)
            radius = 1.2 * radius + 13
        }
        // radius *= Math.sqrt(tech.bulletSize)
        const me = bullet.length;
        bullet[me] = Bodies.polygon(position.x, position.y, 20, radius, {
            density: 0.000001, //  0.001 is normal density
            inertia: Infinity,
            frictionAir: 0.003,
            dmg: 0, //damage on impact
            damage: tech.foamDamage * (tech.isFastFoam ? 2.8 : 1) * (tech.isBulletTeleport ? 1.53 : 1), //damage done over time
            scale: 1 - 0.006 / tech.bulletsLastLonger * (tech.isFastFoam ? 1.65 : 1),
            classType: "bullet",
            collisionFilter: {
                category: cat.bullet,
                mask: cat.mob | cat.mobBullet // cat.map | cat.body | cat.mob | cat.mobShield
            },
            minDmgSpeed: 0,
            endCycle: Infinity,
            count: 0,
            radius: radius,
            target: null,
            targetVertex: null,
            targetRelativePosition: null,
            portFrequency: 7 + Math.floor(5 * Math.random()),
            nextPortCycle: Infinity, //disabled unless you have the teleport tech
            beforeDmg(who) {
                if (!this.target && who.alive) {
                    this.target = who;
                    if (who.radius < 20) {
                        this.targetRelativePosition = {
                            x: 0,
                            y: 0
                        } //find relative position vector for zero mob rotation
                    } else if (Matter.Query.collides(this, [who]).length > 0) {
                        const normal = Matter.Query.collides(this, [who])[0].normal
                        this.targetRelativePosition = Vector.rotate(Vector.sub(Vector.sub(this.position, who.position), Vector.mult(normal, -this.radius)), -who.angle) //find relative position vector for zero mob rotation
                    } else {
                        this.targetRelativePosition = Vector.rotate(Vector.sub(this.position, who.position), -who.angle) //find relative position vector for zero mob rotation
                    }
                    this.collisionFilter.category = cat.body;
                    this.collisionFilter.mask = null;

                    let bestVertexDistance = Infinity
                    let bestVertex = null
                    for (let i = 0; i < this.target.vertices.length; i++) {
                        const dist = Vector.magnitude(Vector.sub(this.position, this.target.vertices[i]));
                        if (dist < bestVertexDistance) {
                            bestVertex = i
                            bestVertexDistance = dist
                        }
                    }
                    this.targetVertex = bestVertex
                    Matter.Body.setVelocity(this, { x: 0, y: 0 });
                }
            },
            onEnd() { },
            do() {
                if (this.count < 20) {
                    this.count++
                    //grow
                    const SCALE = 1.06
                    Matter.Body.scale(this, SCALE, SCALE);
                    this.radius *= SCALE;
                } else {
                    //shrink
                    Matter.Body.scale(this, this.scale, this.scale);
                    this.radius *= this.scale;
                    if (this.radius < 8) this.endCycle = 0;
                }
                if (this.target && this.target.alive) { //if stuck to a target
                    const rotate = Vector.rotate(this.targetRelativePosition, this.target.angle) //add in the mob's new angle to the relative position vector
                    if (this.target.isVerticesChange) {
                        Matter.Body.setPosition(this, this.target.vertices[this.targetVertex])
                    } else {
                        Matter.Body.setPosition(this, Vector.add(Vector.add(rotate, this.target.velocity), this.target.position))
                    }
                    if (this.target.isBoss) {
                        if (this.target.speed > 6.5) Matter.Body.setVelocity(this.target, Vector.mult(this.target.velocity, 0.975))
                    } else {
                        if (this.target.speed > 2.5) Matter.Body.setVelocity(this.target, Vector.mult(this.target.velocity, 0.94))
                    }

                    Matter.Body.setAngularVelocity(this.target, this.target.angularVelocity * 0.9);
                    // Matter.Body.setAngularVelocity(this.target, this.target.angularVelocity * 0.9)
                    if (this.target.isShielded) {
                        this.target.damage(this.damage, true); //shield damage bypass
                        const SCALE = 1 - 0.004 / tech.bulletsLastLonger //shrink if mob is shielded
                        Matter.Body.scale(this, SCALE, SCALE);
                        this.radius *= SCALE;
                    } else {
                        this.target.damage(this.damage);
                    }
                } else if (this.target !== null) { //look for a new target
                    this.collisionFilter.category = cat.bullet;
                    this.collisionFilter.mask = cat.mob //| cat.mobShield //cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield
                    Matter.Body.setVelocity(this, { x: this.target.velocity.x, y: this.target.velocity.y });
                    if (tech.isSpawnBulletsOnDeath && bullet.length < 180 && !this.target.isMobBullet) {
                        let targets = []
                        for (let i = 0, len = mob.length; i < len; i++) {
                            const dist = Vector.magnitudeSquared(Vector.sub(this.position, mob[i].position));
                            if (dist < 1000000) targets.push(mob[i])
                        }
                        const radius = Math.min(this.radius * 0.5, 9)
                        const len = bullet.length < 80 ? 2 : 1
                        for (let i = 0; i < len; i++) {
                            if (targets.length - i > 0) {
                                const index = Math.floor(Math.random() * targets.length)
                                const speed = 6 + 6 * Math.random()
                                const velocity = Vector.mult(Vector.normalise(Vector.sub(targets[index].position, this.position)), speed)
                                b.foam(this.position, Vector.rotate(velocity, 0.5 * (Math.random() - 0.5)), radius)
                            } else {
                                b.foam(this.position, Vector.rotate({
                                    x: 15 + 10 * Math.random(),
                                    y: 0
                                }, 2 * Math.PI * Math.random()), radius)
                            }
                        }
                    }
                    this.target = null
                } else if (Matter.Query.point(map, this.position).length > 0) { //slow when touching map
                    const slow = 0.87
                    Matter.Body.setVelocity(this, { x: this.velocity.x * slow, y: this.velocity.y * slow });
                    const SCALE = 0.97
                    Matter.Body.scale(this, SCALE, SCALE);
                    this.radius *= SCALE;
                    // } else if (Matter.Query.collides(this, body).length > 0) {
                } else if (Matter.Query.point(body, this.position).length > 0) { //slow when touching blocks
                    const slow = 0.94
                    Matter.Body.setVelocity(this, { x: this.velocity.x * slow, y: this.velocity.y * slow });
                    const SCALE = 0.99
                    Matter.Body.scale(this, SCALE, SCALE);
                    this.radius *= SCALE;
                } else {
                    this.force.y += this.mass * tech.foamGravity; //gravity
                    if (tech.isFoamAttract) {
                        for (let i = 0, len = mob.length; i < len; i++) {
                            const range = Vector.magnitude(Vector.sub(mob[i].position, this.position))
                            if (
                                !mob[i].isBadTarget &&
                                mob[i].alive &&
                                !mob[i].isInvulnerable &&
                                range < 500 &&
                                Matter.Query.ray(map, this.position, mob[i].position).length === 0
                            ) {
                                const mag = 0.001 * Math.min(1, 200 / range)
                                this.force = Vector.mult(Vector.normalise(Vector.sub(mob[i].position, this.position)), this.mass * mag)
                                const slow = 0.98
                                Matter.Body.setVelocity(this, { x: this.velocity.x * slow, y: this.velocity.y * slow });
                                break
                            }
                        }
                    }
                }
                if (this.nextPortCycle < simulation.cycle) { //teleport around if you have tech.isBulletTeleport
                    this.nextPortCycle = simulation.cycle + this.portFrequency
                    const range = 13 * Math.sqrt(this.radius) * Math.random()
                    Matter.Body.setPosition(this, Vector.add(this.position, Vector.rotate({
                        x: range,
                        y: 0
                    }, 2 * Math.PI * Math.random())))
                }
            }
        });
        if (tech.isBulletTeleport) bullet[me].nextPortCycle = simulation.cycle + bullet[me].portFrequency
        Composite.add(engine.world, bullet[me]); //add bullet to world
        Matter.Body.setVelocity(bullet[me], velocity);
    },
    targetedBlock(who, speed = 50 - Math.min(20, who.mass * 2), range = 1600) {
        let closestMob, dist
        for (let i = 0, len = mob.length; i < len; i++) {
            if (who !== mob[i] && !mob[i].isBadTarget && !mob[i].isInvulnerable) {
                dist = Vector.magnitude(Vector.sub(who.position, mob[i].position));
                if (dist < range && Matter.Query.ray(map, who.position, mob[i].position).length === 0) { //&& Matter.Query.ray(body, position, mob[i].position).length === 0
                    closestMob = mob[i]
                    range = dist
                }
            }
        }
        if (closestMob) {
            const where = Vector.add(closestMob.position, Vector.mult(closestMob.velocity, dist / 60))
            const velocity = Vector.mult(Vector.normalise(Vector.sub(where, who.position)), speed)
            velocity.y -= Math.abs(who.position.x - closestMob.position.x) / 150; //gives an arc, but not a good one
            Matter.Body.setVelocity(who, velocity);
        }
    },
    targetedNail(position, num = 1, speed = 40 + 10 * Math.random(), range = 1200, damage = 1.4) {
        let shotsFired = 0
        const targets = [] //target nearby mobs
        for (let i = 0, len = mob.length; i < len; i++) {
            const dist = Vector.magnitude(Vector.sub(position, mob[i].position));
            if (
                dist < range + mob[i].radius &&
                !mob[i].isBadTarget && //|| mob[i].isMobBullet
                Matter.Query.ray(map, position, mob[i].position).length === 0 &&
                Matter.Query.ray(body, position, mob[i].position).length === 0 &&
                !mob[i].isInvulnerable
            ) {
                targets.push(Vector.add(mob[i].position, Vector.mult(mob[i].velocity, dist / 60))) //predict where the mob will be in a few cycles
            }
        }
        for (let i = 0; i < num; i++) {
            if (targets.length > 0) { // aim near a random target in array
                const index = Math.floor(Math.random() * targets.length)
                const SPREAD = 150 / targets.length
                const WHERE = {
                    x: targets[index].x + SPREAD * (Math.random() - 0.5),
                    y: targets[index].y + SPREAD * (Math.random() - 0.5)
                }
                b.nail(position, Vector.mult(Vector.normalise(Vector.sub(WHERE, position)), speed), damage)
                shotsFired++
            } else { // aim in random direction
                const ANGLE = 2 * Math.PI * Math.random()
                b.nail(position, {
                    x: speed * Math.cos(ANGLE),
                    y: speed * Math.sin(ANGLE)
                }, damage)
                shotsFired++
            }
        }
        return shotsFired
    },
    crit(mob, bullet) {
        if (!mob.shield && Vector.dot(Vector.normalise(Vector.sub(mob.position, bullet.position)), Vector.normalise(bullet.velocity)) > 0.999 - 1 / mob.radius) {
            if (mob.isFinalBoss && !(Vector.dot(Vector.normalise(Vector.sub(mob.position, bullet.position)), Vector.normalise(bullet.velocity)) > 0.999999)) return
            let cycle = () => { //makes this run after damage
                if (mob.health < 0.5 && mob.damageReduction > 0 && mob.alive) {
                    // mob.death();
                    // mob.damage(this.health * Math.sqrt(this.mass) / this.damageReduction);
                    mob.damage(Infinity);

                    const color = 'rgb(255,255,255)'
                    simulation.drawList.push({
                        x: mob.position.x,
                        y: mob.position.y,
                        radius: mob.radius * 1.2,
                        color: color, //"rgba(0,0,0,0.6)",
                        time: 8
                    });
                    simulation.drawList.push({
                        x: mob.position.x,
                        y: mob.position.y,
                        radius: mob.radius * 0.75,
                        color: color, //"rgba(0,0,0,0.85)",
                        time: 15
                    });
                    simulation.drawList.push({
                        x: mob.position.x,
                        y: mob.position.y,
                        radius: mob.radius * 0.4,
                        color: color, //"rgb(0,0,0)",
                        time: 20
                    });
                }
            }
            requestAnimationFrame(cycle);
        }
    },
    nail(pos, velocity, dmg = 1) {
        dmg *= tech.bulletSize
        const me = bullet.length;
        bullet[me] = Bodies.rectangle(pos.x, pos.y, 25 * tech.bulletSize, 2 * tech.bulletSize, b.fireAttributes(Math.atan2(velocity.y, velocity.x)));
        Matter.Body.setVelocity(bullet[me], velocity);
        Composite.add(engine.world, bullet[me]); //add bullet to world
        bullet[me].endCycle = simulation.cycle + 80 + 18 * Math.random();
        bullet[me].dmg = tech.isNailRadiation ? 0 : dmg
        bullet[me].beforeDmg = function (who) { //beforeDmg is rewritten with ice crystal tech
            if (tech.isNailRadiation) mobs.statusDoT(who, dmg * (tech.isFastRadiation ? 1.3 : 0.44), tech.isSlowRadiation ? 360 : (tech.isFastRadiation ? 60 : 180)) // one tick every 30 cycles
            if (tech.isNailCrit) { //makes bullet do explosive damage if it hits center
                if (!who.shield && Vector.dot(Vector.normalise(Vector.sub(who.position, this.position)), Vector.normalise(this.velocity)) > 0.97 - 1 / who.radius) {
                    b.explosion(this.position, 80 + 90 * (b.activeGun === 0) + 30 * Math.random()); //larger explosions for human aimed nail gun, smaller for auto aimed sources, like bots, and mine
                }
            }
            this.ricochet(who)
        };
        bullet[me].ricochet = function (who) { //use for normal nails, and ice crystal nails
            if (tech.isRicochet) {
                const targets = [] //target nearby mobs
                for (let i = 0, len = mob.length; i < len; i++) {
                    const dist = Vector.magnitude(Vector.sub(this.position, mob[i].position));
                    if (
                        mob[i] !== who &&
                        dist < 2500 + mob[i].radius &&
                        !mob[i].isBadTarget && //|| mob[i].isMobBullet
                        !mob[i].isInvulnerable &&
                        Matter.Query.ray(body, this.position, mob[i].position).length === 0 &&
                        Matter.Query.ray(map, this.position, mob[i].position).length === 0
                    ) {
                        targets.push(Vector.add(mob[i].position, Vector.mult(mob[i].velocity, dist / 60))) //predict where the mob will be in a few cycles
                    }
                }
                if (targets.length > 0) { // aim near a random target in array
                    const index = Math.floor(Math.random() * targets.length)
                    Matter.Body.setVelocity(this, Vector.mult(Vector.normalise(Vector.sub(targets[index], this.position)), 45));
                    Matter.Body.setAngle(this, Math.atan2(this.velocity.y, this.velocity.x))
                    Matter.Body.setAngularVelocity(this, 0);
                }
                this.dmg += 2
            }
        }
        bullet[me].do = function () { };
    },
    needle(angle = m.angle) {
        const me = bullet.length;
        bullet[me] = Bodies.rectangle(m.pos.x + 40 * Math.cos(m.angle), m.pos.y + 40 * Math.sin(m.angle), 75 * tech.bulletSize, 0.75 * tech.bulletSize, b.fireAttributes(angle));
        Matter.Body.setDensity(bullet[me], 0.00001); //0.001 is normal
        bullet[me].immuneList = []
        bullet[me].dmg = 6
        if (tech.needleTunnel) {
            bullet[me].dmg *= 1.2
            bullet[me].endCycle = simulation.cycle + 300;
            bullet[me].collisionFilter.mask = tech.isShieldPierce ? 0 : cat.mobShield
            // bullet[me].turnRate = 0.005 * (Math.random() - 0.5)
            bullet[me].isInMap = false
            bullet[me].do = function () {
                const whom = Matter.Query.collides(this, mob)
                if (whom.length && this.speed > 20) { //if touching a mob 
                    for (let i = 0, len = whom.length; i < len; i++) {
                        who = whom[i].bodyA
                        if (who && who.mob) {
                            let immune = false
                            for (let i = 0; i < this.immuneList.length; i++) { //check if this needle has hit this mob already
                                if (this.immuneList[i] === who.id) {
                                    immune = true
                                    break
                                }
                            }
                            if (!immune) {
                                if (tech.isNailCrit) {
                                    if (!who.shield && Vector.dot(Vector.normalise(Vector.sub(who.position, this.position)), Vector.normalise(this.velocity)) > 0.97 - 1 / who.radius) {
                                        b.explosion(this.position, 220 + 50 * Math.random()); //makes bullet do explosive damage at end
                                    }
                                } else if (tech.isCritKill) b.crit(who, this)

                                this.immuneList.push(who.id) //remember that this needle has hit this mob once already
                                let dmg = this.dmg * tech.bulletSize
                                if (tech.isNailRadiation) {
                                    mobs.statusDoT(who, (tech.isFastRadiation ? 6 : 2) * tech.bulletSize, tech.isSlowRadiation ? 360 : (tech.isFastRadiation ? 60 : 180)) // one tick every 30 cycles
                                    dmg *= 0.25
                                }
                                if (tech.isCrit && who.isStunned) dmg *= 4
                                who.damage(dmg, tech.isShieldPierce);
                                if (who.alive) who.foundPlayer();
                                if (who.damageReduction) {
                                    simulation.drawList.push({ //add dmg to draw queue
                                        x: this.position.x,
                                        y: this.position.y,
                                        radius: Math.log(dmg + 1.1) * 40 * who.damageReduction + 3,
                                        color: simulation.playerDmgColor,
                                        time: simulation.drawTime
                                    });
                                }
                            }
                        }
                    }
                } else if (Matter.Query.collides(this, map).length) { //penetrate walls
                    if (!this.isInMap) { //turn after entering the map, but only turn once
                        this.isInMap = true
                        Matter.Body.setVelocity(this, Vector.rotate(this.velocity, 0.25 * (Math.random() - 0.5)));
                        Matter.Body.setAngle(this, Math.atan2(this.velocity.y, this.velocity.x))
                    }
                    Matter.Body.setPosition(this, Vector.add(this.position, Vector.mult(this.velocity, -0.98))) //move back 1/2 your velocity = moving at 1/2 speed
                } else if (Matter.Query.collides(this, body).length) { //penetrate blocks
                    Matter.Body.setAngularVelocity(this, 0)
                    Matter.Body.setPosition(this, Vector.add(this.position, Vector.mult(this.velocity, -0.94))) //move back 1/2 your velocity = moving at 1/2 speed
                } else if (this.speed < 30) {
                    this.force.y += this.mass * 0.001; //no gravity until it slows down to improve aiming
                }
            };
        } else {
            bullet[me].endCycle = simulation.cycle + 100;
            bullet[me].collisionFilter.mask = tech.isShieldPierce ? cat.body : cat.body | cat.mobShield
            bullet[me].do = function () {
                const whom = Matter.Query.collides(this, mob)
                if (whom.length && this.speed > 20) { //if touching a mob 
                    for (let i = 0, len = whom.length; i < len; i++) {
                        who = whom[i].bodyA
                        if (who && who.mob) {
                            let immune = false
                            for (let i = 0; i < this.immuneList.length; i++) { //check if this needle has hit this mob already
                                if (this.immuneList[i] === who.id) {
                                    immune = true
                                    break
                                }
                            }
                            if (!immune) {
                                if (tech.isNailCrit) {
                                    if (!who.shield && Vector.dot(Vector.normalise(Vector.sub(who.position, this.position)), Vector.normalise(this.velocity)) > 0.97 - 1 / who.radius) {
                                        b.explosion(this.position, 220 + 50 * Math.random()); //makes bullet do explosive damage at end
                                    }
                                } else if (tech.isCritKill) b.crit(who, this)

                                this.immuneList.push(who.id) //remember that this needle has hit this mob once already
                                let dmg = this.dmg * tech.bulletSize
                                if (tech.isNailRadiation) {
                                    mobs.statusDoT(who, (tech.isFastRadiation ? 6 : 2) * tech.bulletSize, tech.isSlowRadiation ? 360 : (tech.isFastRadiation ? 60 : 180)) // one tick every 30 cycles
                                    dmg *= 0.25
                                }
                                if (tech.isCrit && who.isStunned) dmg *= 4
                                who.damage(dmg, tech.isShieldPierce);
                                if (who.alive) who.foundPlayer();
                                if (who.damageReduction) {
                                    simulation.drawList.push({ //add dmg to draw queue
                                        x: this.position.x,
                                        y: this.position.y,
                                        radius: Math.log(dmg + 1.1) * 40 * who.damageReduction + 3,
                                        color: simulation.playerDmgColor,
                                        time: simulation.drawTime
                                    });
                                }
                            }
                        }
                    }
                } else if (Matter.Query.collides(this, map).length) { //stick in walls
                    this.collisionFilter.mask = 0;
                    Matter.Body.setAngularVelocity(this, 0)
                    Matter.Body.setVelocity(this, {
                        x: 0,
                        y: 0
                    });
                    this.do = function () {
                        if (!Matter.Query.collides(this, map).length) this.force.y += this.mass * 0.001;
                    }
                    if (tech.isNeedleIce) {
                        b.iceIX(5 + 5 * Math.random(), 2 * Math.PI * Math.random(), this.position) // iceIX(speed = 0, dir = m.angle + Math.PI * 2 * Math.random(), where = { x: m.pos.x + 30 * Math.cos(m.angle), y: m.pos.y + 30 * Math.sin(m.angle) }) {
                        if (0.5 < Math.random()) b.iceIX(5 + 5 * Math.random(), 2 * Math.PI * Math.random(), this.position)
                    }
                } else if (this.speed < 30) {
                    this.force.y += this.mass * 0.001; //no gravity until it slows down to improve aiming
                }
            };
        }
        const SPEED = 90
        Matter.Body.setVelocity(bullet[me], {
            x: 0.5 * player.velocity.x + SPEED * Math.cos(angle),
            y: 0.5 * player.velocity.y + SPEED * Math.sin(angle)
        });
        // Matter.Body.setDensity(bullet[me], 0.00001);
        Composite.add(engine.world, bullet[me]); //add bullet to world
    },
    // **************************************************************************************************
    // **************************************************************************************************
    // ********************************         Bots        *********************************************
    // **************************************************************************************************
    // **************************************************************************************************
    totalBots() {
        return tech.dynamoBotCount + tech.foamBotCount + tech.soundBotCount + tech.nailBotCount + tech.laserBotCount + tech.boomBotCount + tech.orbitBotCount + tech.plasmaBotCount + tech.missileBotCount
    },
    hasBotUpgrade() {
        return tech.isNailBotUpgrade + tech.isFoamBotUpgrade + tech.isBoomBotUpgrade + tech.isLaserBotUpgrade + tech.isOrbitBotUpgrade + tech.isDynamoBotUpgrade + tech.isSoundBotUpgrade
    },
    convertBotsTo(type) { //type can be a string like "dynamoBotCount"
        const totalPermanentBots = b.totalBots()
        //remove all bots techs and convert them to the new type so that tech refunds work correctly
        let totalTechToConvert = 0 //count how many tech need to be converted
        for (let i = 0; i < tech.tech.length; i++) {
            if (tech.tech[i].count && tech.tech[i].isBot) {
                totalTechToConvert += tech.tech[i].count
                tech.removeTech(i)
            }
        }
        //remove all bots
        b.zeroBotCount()
        b.clearPermanentBots()
        for (let i = 0; i < totalTechToConvert; i++) tech.giveTech(type) //spawn tech for the correct bot type

        //find index of new bot type tech effect
        let index = null
        for (let i = 0; i < tech.tech.length; i++) {
            if (tech.tech[i].name === type) {
                index = i
                break
            }
        }
        for (let i = 0, len = totalPermanentBots - totalTechToConvert; i < len; i++) tech.tech[index].effect(); //also convert any permanent bots that didn't come from a tech
        //in experiment mode set the unselect color for bot tech that was converted
        // if (build.isExperimentSelection) {        }
    },
    clearPermanentBots() {
        for (let i = 0; i < bullet.length; i++) {
            if (bullet[i].botType && bullet[i].endCycle === Infinity) bullet[i].endCycle = 0 //remove active bots, but don't remove temp bots
        }
    },
    removeBot() {
        if (tech.nailBotCount > 1) {
            tech.nailBotCount--
            return
        }
        if (tech.laserBotCount > 1) {
            tech.laserBotCount--
            return
        }
        if (tech.foamBotCount > 1) {
            tech.foamBotCount--
            return
        }
        if (tech.soundBotCount > 1) {
            tech.soundBotCount--
            return
        }
        if (tech.boomBotCount > 1) {
            tech.boomBotCount--
            return
        }
        if (tech.orbitBotCount > 1) {
            tech.orbitBotCount--
            return
        }
        if (tech.dynamoBotCount > 1) {
            tech.dynamoBotCount--
            return
        }
        if (tech.missileBotCount > 1) {
            tech.missileBotCount--
            return
        }
        if (tech.plasmaBotCount > 1) {
            tech.plasmaBotCount--
            return
        }
    },
    zeroBotCount() { //remove all bots
        tech.dynamoBotCount = 0;
        tech.nailBotCount = 0;
        tech.laserBotCount = 0;
        tech.orbitBotCount = 0;
        tech.foamBotCount = 0;
        tech.soundBotCount = 0;
        tech.boomBotCount = 0;
        tech.plasmaBotCount = 0;
        tech.missileBotCount = 0;
    },
    respawnBots() {
        for (let i = 0; i < tech.dynamoBotCount; i++) b.dynamoBot({
            x: player.position.x + 50 * (Math.random() - 0.5),
            y: player.position.y + 50 * (Math.random() - 0.5)
        }, !level.isSlowBots)
        for (let i = 0; i < tech.laserBotCount; i++) b.laserBot({
            x: player.position.x + 50 * (Math.random() - 0.5),
            y: player.position.y + 50 * (Math.random() - 0.5)
        }, !level.isSlowBots)
        for (let i = 0; i < tech.nailBotCount; i++) b.nailBot({
            x: player.position.x + 50 * (Math.random() - 0.5),
            y: player.position.y + 50 * (Math.random() - 0.5)
        }, !level.isSlowBots)
        for (let i = 0; i < tech.foamBotCount; i++) b.foamBot({
            x: player.position.x + 50 * (Math.random() - 0.5),
            y: player.position.y + 50 * (Math.random() - 0.5)
        }, !level.isSlowBots)
        for (let i = 0; i < tech.soundBotCount; i++) b.soundBot({
            x: player.position.x + 50 * (Math.random() - 0.5),
            y: player.position.y + 50 * (Math.random() - 0.5)
        }, !level.isSlowBots)
        for (let i = 0; i < tech.boomBotCount; i++) b.boomBot({
            x: player.position.x + 50 * (Math.random() - 0.5),
            y: player.position.y + 50 * (Math.random() - 0.5)
        }, !level.isSlowBots)
        for (let i = 0; i < tech.orbitBotCount; i++) b.orbitBot({
            x: player.position.x + 50 * (Math.random() - 0.5),
            y: player.position.y + 50 * (Math.random() - 0.5)
        }, !level.isSlowBots)
        for (let i = 0; i < tech.plasmaBotCount; i++) b.plasmaBot({
            x: player.position.x + 50 * (Math.random() - 0.5),
            y: player.position.y + 50 * (Math.random() - 0.5)
        })
        for (let i = 0; i < tech.missileBotCount; i++) b.missileBot({
            x: player.position.x + 50 * (Math.random() - 0.5),
            y: player.position.y + 50 * (Math.random() - 0.5)
        })
        if (tech.isIntangible && m.isCloak) {
            for (let i = 0; i < bullet.length; i++) {
                if (bullet[i].botType) bullet[i].collisionFilter.mask = cat.map | cat.bullet | cat.mobBullet | cat.mobShield
            }
        }
    },
    randomBot(where = player.position, isKeep = true, isLaser = true) {
        if (Math.random() < 0.5) { //chance to match bot to your upgrade
            if (tech.isNailBotUpgrade) { //check for upgrades first
                b.nailBot(where, isKeep)
                if (isKeep) tech.nailBotCount++;
            } else if (tech.isFoamBotUpgrade) {
                b.foamBot(where, isKeep)
                if (isKeep) tech.foamBotCount++;
            } else if (tech.isSoundBotUpgrade) {
                b.soundBot(where, isKeep)
                if (isKeep) tech.soundBotCount++;
            } else if (tech.isBoomBotUpgrade) {
                b.boomBot(where, isKeep)
                if (isKeep) tech.boomBotCount++;
            } else if (tech.isLaserBotUpgrade) {
                b.laserBot(where, isKeep)
                if (isKeep) tech.laserBotCount++;
            } else if (tech.isOrbitBotUpgrade) {
                b.orbitBot(where, isKeep);
                if (isKeep) tech.orbitBotCount++;
            } else if (tech.isDynamoBotUpgrade) {
                b.dynamoBot(where, isKeep)
                if (isKeep) tech.dynamoBotCount++;
            } else if (Math.random() < 0.143) { //random
                b.soundBot(where, isKeep)
                if (isKeep) tech.soundBotCount++;
            } else if (Math.random() < 0.166 && isLaser) {
                b.laserBot(where, isKeep)
                if (isKeep) tech.laserBotCount++;
            } else if (Math.random() < 0.2) {
                b.dynamoBot(where, isKeep)
                if (isKeep) tech.dynamoBotCount++;
            } else if (Math.random() < 0.25) {
                b.orbitBot(where, isKeep);
                if (isKeep) tech.orbitBotCount++;
            } else if (Math.random() < 0.33) {
                b.nailBot(where, isKeep)
                if (isKeep) tech.nailBotCount++;
            } else if (Math.random() < 0.5) {
                b.foamBot(where, isKeep)
                if (isKeep) tech.foamBotCount++;
            } else {
                b.boomBot(where, isKeep)
                if (isKeep) tech.boomBotCount++;
            }
        } else { //else don't match bot to upgrade
            if (Math.random() < 0.143) { //random
                b.soundBot(where, isKeep)
                if (isKeep) tech.soundBotCount++;
            } else if (Math.random() < 0.166 && isLaser) { //random
                b.laserBot(where, isKeep)
                if (isKeep) tech.laserBotCount++;
            } else if (Math.random() < 0.2) {
                b.dynamoBot(where, isKeep)
                if (isKeep) tech.dynamoBotCount++;
            } else if (Math.random() < 0.25) {
                b.orbitBot(where, isKeep);
                if (isKeep) tech.orbitBotCount++;
            } else if (Math.random() < 0.33) {
                b.nailBot(where, isKeep)
                if (isKeep) tech.nailBotCount++;
            } else if (Math.random() < 0.5) {
                b.foamBot(where, isKeep)
                if (isKeep) tech.foamBotCount++;
            } else {
                b.boomBot(where, isKeep)
                if (isKeep) tech.boomBotCount++;
            }
        }

    },
    setDynamoBotDelay() {
        let total = 0
        for (let i = 0; i < bullet.length; i++) {
            if (bullet[i].botType === 'dynamo') total++
        }
        let count = 0
        for (let i = 0; i < bullet.length; i++) {
            if (bullet[i].botType === 'dynamo') {
                count++
                const step = Math.max(60 - 3 * total, 10)
                if (bullet[i].isKeep) {
                    bullet[i].followDelay = (step * count) % 600
                } else {
                    bullet[i].followDelay = Math.floor(step * bullet.length * Math.random()) % 600
                }
            }
        }
    },
    dynamoBot(position = player.position, isKeep = true) {
        const me = bullet.length;
        bullet[me] = Bodies.polygon(position.x, position.y, 5, 10, {
            isUpgraded: tech.isDynamoBotUpgrade,
            botType: "dynamo",
            friction: 0,
            frictionStatic: 0,
            frictionAir: 0.02,
            spin: 0.07 * (Math.random() < 0.5 ? -1 : 1),
            // isStatic: true,
            isKeep: isKeep,
            isSensor: true,
            restitution: 0,
            dmg: 0, // 0.14   //damage done in addition to the damage from momentum
            minDmgSpeed: 0,
            endCycle: Infinity,
            classType: "bullet",
            collisionFilter: {
                category: cat.bullet,
                mask: 0 //cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet | cat.mobShield
            },
            beforeDmg() { },
            onEnd() {
                b.setDynamoBotDelay()
            },
            followDelay: 0,
            phase: Math.floor(60 * Math.random()),
            do() {
                // if (Vector.magnitude(Vector.sub(this.position, player.position)) < 150) {
                //     ctx.fillStyle = "rgba(0,0,0,0.06)";
                //     ctx.beginPath();
                //     ctx.arc(this.position.x, this.position.y, 150, 0, 2 * Math.PI);
                //     ctx.fill();
                // }

                //check for damage 
                if (m.immuneCycle < m.cycle && !((m.cycle + this.phase) % 30)) { //twice a second
                    if (Vector.magnitude(Vector.sub(this.position, player.position)) < 250 && m.immuneCycle < m.cycle) { //give energy
                        Matter.Body.setAngularVelocity(this, this.spin)
                        if (this.isUpgraded) {
                            m.energy += 0.12 * level.isReducedRegen
                            simulation.drawList.push({ //add dmg to draw queue
                                x: this.position.x,
                                y: this.position.y,
                                radius: 10,
                                color: m.fieldMeterColor,
                                time: simulation.drawTime
                            });
                        } else {
                            m.energy += 0.04 * level.isReducedRegen
                            simulation.drawList.push({ //add dmg to draw queue
                                x: this.position.x,
                                y: this.position.y,
                                radius: 5,
                                color: m.fieldMeterColor,
                                time: simulation.drawTime
                            });
                        }
                    }
                }

                if (!m.isCloak) { //if cloaking field isn't active
                    const size = 33 - 6 * isKeep
                    q = Matter.Query.region(mob, {
                        min: {
                            x: this.position.x - size,
                            y: this.position.y - size
                        },
                        max: {
                            x: this.position.x + size,
                            y: this.position.y + size
                        }
                    })
                    for (let i = 0; i < q.length; i++) {
                        if (!q[i].isShielded) {
                            Matter.Body.setAngularVelocity(this, this.spin)
                            const dmg = 0.5
                            q[i].damage(dmg);
                            if (q[i].alive) q[i].foundPlayer();
                            if (q[i].damageReduction) {
                                simulation.drawList.push({ //add dmg to draw queue
                                    x: this.position.x,
                                    y: this.position.y,
                                    // radius: 600 * dmg * q[i].damageReduction,
                                    radius: Math.sqrt(2000 * dmg * q[i].damageReduction) + 2,
                                    color: 'rgba(0,0,0,0.4)',
                                    time: simulation.drawTime
                                });
                            }
                        }
                    }
                }
                let history = m.history[(m.cycle - this.followDelay) % 600]
                Matter.Body.setPosition(this, { x: history.position.x, y: history.position.y - history.yOff + 24.2859 }) //bullets move with player
            }
        })
        Composite.add(engine.world, bullet[me]); //add bullet to world
        b.setDynamoBotDelay()
    },
    nailBot(position = { x: player.position.x + 50 * (Math.random() - 0.5), y: player.position.y + 50 * (Math.random() - 0.5) }, isKeep = true) {
        const me = bullet.length;
        const dir = m.angle;
        const RADIUS = (12 + 4 * Math.random())
        bullet[me] = Bodies.polygon(position.x, position.y, 4, RADIUS, {
            isUpgraded: tech.isNailBotUpgrade,
            botType: "nail",
            angle: dir,
            friction: 0,
            frictionStatic: 0,
            frictionAir: 0.05,
            restitution: 0.6 * (1 + 0.5 * Math.random()),
            dmg: 0, // 0.14   //damage done in addition to the damage from momentum
            minDmgSpeed: 2,
            // lookFrequency: 56 + Math.floor(17 * Math.random()) - isUpgraded * 20,
            lastLookCycle: simulation.cycle + 60 * Math.random(),
            delay: Math.floor((tech.isNailBotUpgrade ? 22 : 85) + 10 * isKeep),
            acceleration: (isKeep ? 0.005 : 0.001) * (1 + 0.5 * Math.random()),
            range: 60 * (1 + 0.3 * Math.random()) + 3 * b.totalBots() + !isKeep * 100,
            endCycle: Infinity,
            classType: "bullet",
            collisionFilter: {
                category: cat.bullet,
                mask: b.totalBots() < 50 ? cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet | cat.mobShield : cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield //if over 50 bots, they no longer collide with each other
            },
            beforeDmg() { },
            onEnd() { },
            do() {
                const distanceToPlayer = Vector.magnitude(Vector.sub(this.position, m.pos))
                if (distanceToPlayer > this.range) { //if far away move towards player
                    this.force = Vector.mult(Vector.normalise(Vector.sub(m.pos, this.position)), this.mass * this.acceleration)
                } else { //close to player
                    Matter.Body.setVelocity(this, Vector.add(Vector.mult(this.velocity, 0.90), Vector.mult(player.velocity, 0.17))); //add player's velocity
                    if (this.lastLookCycle < simulation.cycle && !m.isCloak) {
                        this.lastLookCycle = simulation.cycle + this.delay
                        for (let i = 0, len = mob.length; i < len; i++) {
                            const dist = Vector.magnitudeSquared(Vector.sub(this.position, mob[i].position));
                            if (
                                !mob[i].isBadTarget &&
                                dist < 3000000 &&
                                Matter.Query.ray(map, this.position, mob[i].position).length === 0 &&
                                Matter.Query.ray(body, this.position, mob[i].position).length === 0 &&
                                !mob[i].isShielded &&
                                !mob[i].isInvulnerable
                            ) {
                                const unit = Vector.normalise(Vector.sub(Vector.add(mob[i].position, Vector.mult(mob[i].velocity, Math.sqrt(dist) / 60)), this.position))
                                if (this.isUpgraded) {
                                    const SPEED = 60
                                    b.nail(this.position, Vector.mult(unit, SPEED))
                                    this.force = Vector.mult(unit, -0.02 * this.mass)
                                } else {
                                    const SPEED = 45
                                    b.nail(this.position, Vector.mult(unit, SPEED))
                                    this.force = Vector.mult(unit, -0.012 * this.mass)
                                }
                                break;
                            }
                        }
                    }
                }
            }
        })
        Composite.add(engine.world, bullet[me]); //add bullet to world
    },
    missileBot(position = { x: player.position.x + 50 * (Math.random() - 0.5), y: player.position.y + 50 * (Math.random() - 0.5) }, isKeep = true) {
        const me = bullet.length;
        bullet[me] = Bodies.rectangle(position.x, position.y, 28, 11, {
            botType: "missile",
            angle: m.angle,
            friction: 0,
            frictionStatic: 0,
            frictionAir: 0.04,
            restitution: 0.7,
            dmg: 0, // 0.14   //damage done in addition to the damage from momentum
            minDmgSpeed: 2,
            lookFrequency: 26 + Math.ceil(6 * Math.random()),
            cd: 0,
            delay: Math.floor(60),
            range: 70 + 3 * b.totalBots(),
            endCycle: Infinity,
            classType: "bullet",
            collisionFilter: {
                category: cat.bullet,
                mask: b.totalBots() < 50 ? (cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet | cat.mobShield) : (cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield) //if over 50 bots, they no longer collide with each other
            },
            beforeDmg() { },
            onEnd() { },
            do() {
                const distanceToPlayer = Vector.magnitude(Vector.sub(this.position, m.pos))
                if (distanceToPlayer > this.range) { //if far away move towards player
                    this.force = Vector.mult(Vector.normalise(Vector.sub(m.pos, this.position)), this.mass * 0.006)
                } else { //close to player
                    Matter.Body.setVelocity(this, Vector.add(Vector.mult(this.velocity, 0.90), Vector.mult(player.velocity, 0.17))); //add player's velocity
                    if (this.cd < simulation.cycle && !(simulation.cycle % this.lookFrequency) && !m.isCloak) {
                        for (let i = 0, len = mob.length; i < len; i++) {
                            const dist2 = Vector.magnitudeSquared(Vector.sub(this.position, mob[i].position));
                            if (
                                mob[i].alive &&
                                !mob[i].isBadTarget &&
                                dist2 > 40000 &&
                                Matter.Query.ray(map, this.position, mob[i].position).length === 0 &&
                                !mob[i].isInvulnerable
                            ) {
                                this.cd = simulation.cycle + this.delay;
                                const angle = Vector.angle(this.position, mob[i].position)
                                Matter.Body.setAngle(this, angle)
                                // Matter.Body.setAngularVelocity(this, 0.025)
                                this.torque += this.inertia * 0.00004 * (Math.round(Math.random()) ? 1 : -1)
                                this.force = Vector.mult(Vector.normalise(Vector.sub(this.position, mob[i].position)), this.mass * 0.02)

                                if (tech.missileCount > 1) {
                                    const countReduction = Math.pow(0.85, tech.missileCount)
                                    const size = Math.sqrt(countReduction)
                                    const direction = { x: Math.cos(angle), y: Math.sin(angle) }
                                    const push = Vector.mult(Vector.perp(direction), 0.015 * countReduction / Math.sqrt(tech.missileCount))
                                    for (let i = 0; i < tech.missileCount; i++) {
                                        setTimeout(() => {
                                            b.missile(this.position, angle, -8, size)
                                            bullet[bullet.length - 1].force.x += push.x * (i - (tech.missileCount - 1) / 2);
                                            bullet[bullet.length - 1].force.y += push.y * (i - (tech.missileCount - 1) / 2);
                                        }, 40 * tech.missileCount * Math.random());
                                    }
                                } else {
                                    b.missile(this.position, angle, -8) //    missile(where, angle, speed, size = 1) {
                                }
                                break;
                            }
                        }
                    }
                }
            }
        })
        Composite.add(engine.world, bullet[me]); //add bullet to world
    },
    foamBot(position = { x: player.position.x + 50 * (Math.random() - 0.5), y: player.position.y + 50 * (Math.random() - 0.5) }, isKeep = true) {
        const me = bullet.length;
        const dir = m.angle;
        const RADIUS = (10 + 5 * Math.random())
        bullet[me] = Bodies.polygon(position.x, position.y, 6, RADIUS, {
            isUpgraded: tech.isFoamBotUpgrade,
            botType: "foam",
            angle: dir,
            friction: 0,
            frictionStatic: 0,
            frictionAir: 0.05,
            restitution: 0.6 * (1 + 0.5 * Math.random()),
            dmg: 0, // 0.14   //damage done in addition to the damage from momentum
            minDmgSpeed: 2,
            lookFrequency: 60 + Math.floor(17 * Math.random()) - 50 * tech.isFoamBotUpgrade,
            cd: 0,
            fireCount: 0,
            fireLimit: 5 + 2 * tech.isFoamBotUpgrade - isKeep,
            delay: Math.floor((200 + (tech.isFoamBotUpgrade ? 0 : 200))),// + 30 - 20 * tech.isFoamBotUpgrade,//20 + Math.floor(85 * b.fireCDscale) - 20 * tech.isFoamBotUpgrade,
            acceleration: (isKeep ? 0.005 : 0.001) * (1 + 0.5 * Math.random()),
            range: 60 * (1 + 0.3 * Math.random()) + 3 * b.totalBots() + !isKeep * 100, //how far from the player the bot will move
            endCycle: Infinity,
            classType: "bullet",
            collisionFilter: {
                category: cat.bullet,
                mask: b.totalBots() < 50 ? cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet | cat.mobShield : cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield //if over 50 bots, they no longer collide with each other
            },
            beforeDmg() { },
            onEnd() { },
            fireTarget: { x: 0, y: 0 },
            fire() {
                this.fireCount++
                if (this.fireCount > this.fireLimit) {
                    this.fireCount = 0
                    this.cd = simulation.cycle + this.delay;
                } // else {this.cd = simulation.cycle + 1;}

                const radius = 5 + 3 * Math.random()
                const SPEED = Math.max(5, 25 - radius * 0.4); //(m.crouch ? 32 : 20) - radius * 0.7;
                const velocity = Vector.mult(Vector.normalise(Vector.sub(this.fireTarget, this.position)), SPEED)
                b.foam(this.position, Vector.rotate(velocity, 0.07 * (Math.random() - 0.5)), radius + 5 * this.isUpgraded)

                //recoil
                // const force = Vector.mult(Vector.normalise(velocity), 0.005 * this.mass * (tech.isFoamCavitation ? 2 : 1))
                const force = Vector.mult(velocity, 0.0001 * this.mass * (tech.isFoamCavitation ? 2 : 1))
                this.force.x -= force.x
                this.force.y -= force.y
            },
            do() {
                if (this.fireCount === 0) { //passive mode: look for targets and following player
                    const distanceToPlayer = Vector.magnitude(Vector.sub(this.position, m.pos))
                    if (distanceToPlayer > this.range) { //if far away move towards player
                        this.force = Vector.mult(Vector.normalise(Vector.sub(m.pos, this.position)), this.mass * this.acceleration)
                    } else { //close to player
                        Matter.Body.setVelocity(this, Vector.add(Vector.mult(this.velocity, 0.90), Vector.mult(player.velocity, 0.17))); //add player's velocity
                    }

                    if (this.cd < simulation.cycle && !m.isCloak && !(simulation.cycle % this.lookFrequency)) {
                        for (let i = 0, len = mob.length; i < len; i++) {
                            const dist2 = Vector.magnitudeSquared(Vector.sub(this.position, mob[i].position));
                            if (dist2 < 1600000 && !mob[i].isBadTarget && Matter.Query.ray(map, this.position, mob[i].position).length === 0 && !mob[i].isInvulnerable) {
                                this.fireTarget = Vector.add(mob[i].position, Vector.mult(mob[i].velocity, Math.sqrt(dist2) / 60)) //set target to where the mob will be in 1 second
                                this.fire()
                                break;
                            }
                        }
                    }
                } else { //fire mode: quickly fire at targets and doesn't follow player
                    this.fire()
                }
            }
        })
        Composite.add(engine.world, bullet[me]); //add bullet to world
    },
    soundBot(position = { x: player.position.x + 50 * (Math.random() - 0.5), y: player.position.y + 50 * (Math.random() - 0.5) }, isKeep = true) {
        const me = bullet.length;
        const dir = m.angle;
        bullet[me] = Bodies.rectangle(position.x, position.y, 12, 30, {
            isUpgraded: tech.isSoundBotUpgrade,
            botType: "sound",
            angle: dir,
            friction: 0,
            frictionStatic: 0,
            frictionAir: 0.05,
            restitution: 0.6 * (1 + 0.5 * Math.random()),
            dmg: 0, // 0.14   //damage done in addition to the damage from momentum
            minDmgSpeed: 2,
            lookFrequency: 17 + Math.floor(7 * Math.random()) - 3 * tech.isSoundBotUpgrade,
            cd: 0,
            fireCount: 0,
            fireLimit: 5 - isKeep,
            delay: Math.floor(140),// + 30 - 20 * tech.isFoamBotUpgrade,//20 + Math.floor(85 * b.fireCDscale) - 20 * tech.isFoamBotUpgrade,
            acceleration: (isKeep ? 0.005 : 0.001) * (1 + 0.5 * Math.random()),
            range: 60 * (1 + 0.3 * Math.random()) + 3 * b.totalBots() + !isKeep * 100, //how far from the player the bot will move
            endCycle: Infinity,
            classType: "bullet",
            collisionFilter: {
                category: cat.bullet,
                mask: b.totalBots() < 50 ? cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet | cat.mobShield : cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield //if over 50 bots, they no longer collide with each other
            },
            beforeDmg() { },
            onEnd() { },
            fireTarget: { x: 0, y: 0 },
            waves: [],
            phononWaveCD: 0,
            addWave(where, angle) {
                const halfArc = 0.2 * (tech.isBulletTeleport ? 0.66 + (Math.random() - 0.5) : 1) + 0.04 * tech.isSoundBotUpgrade //6.28 is a full circle, but these arcs needs to stay small because we are using small angle linear approximation, for collisions
                this.waves.push({
                    position: where,
                    angle: angle - halfArc, //used in drawing ctx.arc
                    unit1: { x: Math.cos(angle - halfArc), y: Math.sin(angle - halfArc) }, //used for collision
                    unit2: { x: Math.cos(angle + halfArc), y: Math.sin(angle + halfArc) }, //used for collision
                    arc: halfArc * 2,
                    radius: 25,
                    resonanceCount: 0,
                    dmg: (tech.isUpgraded ? 9 : 1.5) * tech.wavePacketDamage * tech.waveBeamDamage * (tech.isBulletTeleport ? 1.5 : 1),
                })
            },
            fire() {
                if (!(simulation.cycle % 6)) {
                    this.fireCount++
                    if (this.fireCount > this.fireLimit) {
                        this.fireCount = 0
                        this.cd = simulation.cycle + this.delay;
                    }
                    this.addWave({ x: this.position.x, y: this.position.y }, Math.atan2(this.fireTarget.y - this.position.y, this.fireTarget.x - this.position.x) + tech.isBulletTeleport * 0.3 * (Math.random() - 0.5)) //add wave to waves array
                    //face target
                    Matter.Body.setAngle(this, Vector.angle(this.position, this.fireTarget));
                }
            },
            do() {
                if (this.fireCount === 0) { //passive mode: look for targets and following player
                    const distanceToPlayer = Vector.magnitude(Vector.sub(this.position, m.pos))
                    if (distanceToPlayer > this.range) { //if far away move towards player
                        this.force = Vector.mult(Vector.normalise(Vector.sub(m.pos, this.position)), this.mass * this.acceleration)
                    } else { //close to player
                        Matter.Body.setVelocity(this, Vector.add(Vector.mult(this.velocity, 0.90), Vector.mult(player.velocity, 0.17))); //add player's velocity
                    }
                    if (this.cd < simulation.cycle && !m.isCloak && !(simulation.cycle % this.lookFrequency)) {
                        for (let i = 0, len = mob.length; i < len; i++) {
                            const dist2 = Vector.magnitudeSquared(Vector.sub(this.position, mob[i].position));
                            if (dist2 < 1300000 && !mob[i].isBadTarget && (Matter.Query.ray(map, this.position, mob[i].position).length === 0 || dist2 < 300000) && !mob[i].isInvulnerable) {
                                this.fireTarget = Vector.add(mob[i].position, Vector.mult(mob[i].velocity, Math.sqrt(dist2) / 60)) //set target to where the mob will be in 1 second
                                this.fire()
                                break;
                            }
                        }
                    }
                } else { //fire mode: quickly fire at targets and doesn't follow player
                    this.fire()
                }
                if (!m.isTimeDilated) { //update current waves
                    ctx.strokeStyle = "rgba(0,0,0,0.6)" //"000";
                    ctx.lineWidth = 2 * tech.wavePacketDamage
                    ctx.beginPath();
                    const end = 1200 * Math.sqrt(tech.bulletsLastLonger)
                    //this does less damage than the player phonon waves  2.3 -> 2
                    for (let i = this.waves.length - 1; i > -1; i--) {
                        const v1 = Vector.add(this.waves[i].position, Vector.mult(this.waves[i].unit1, this.waves[i].radius))
                        const v2 = Vector.add(this.waves[i].position, Vector.mult(this.waves[i].unit2, this.waves[i].radius))
                        //draw wave
                        ctx.moveTo(v1.x, v1.y)
                        ctx.arc(this.waves[i].position.x, this.waves[i].position.y, this.waves[i].radius, this.waves[i].angle, this.waves[i].angle + this.waves[i].arc);
                        //using small angle linear approximation of circle arc, this will not work if the arc gets large   // https://stackoverflow.com/questions/13652518/efficiently-find-points-inside-a-circle-sector
                        let hits = Matter.Query.ray(mob, v1, v2, 50)
                        for (let j = 0; j < hits.length; j++) {
                            const who = hits[j].body
                            if (!who.isShielded) {
                                who.force.x += 0.01 * (Math.random() - 0.5) * who.mass
                                who.force.y += 0.01 * (Math.random() - 0.5) * who.mass
                                Matter.Body.setVelocity(who, { x: who.velocity.x * 0.98, y: who.velocity.y * 0.98 });
                                let vertices = who.vertices;
                                const vibe = 50 + who.radius * 0.15
                                ctx.moveTo(vertices[0].x + vibe * (Math.random() - 0.5), vertices[0].y + vibe * (Math.random() - 0.5));
                                for (let j = 1; j < vertices.length; j++) ctx.lineTo(vertices[j].x + vibe * (Math.random() - 0.5), vertices[j].y + vibe * (Math.random() - 0.5));
                                ctx.lineTo(vertices[0].x + vibe * (Math.random() - 0.5), vertices[0].y + vibe * (Math.random() - 0.5));
                                who.locatePlayer();
                                who.damage(this.waves[i].dmg / Math.pow(who.radius, 0.33));


                                if (tech.isPhononWave && this.phononWaveCD < m.cycle) {
                                    this.phononWaveCD = m.cycle + 10 * (1 + this.waves[i].resonanceCount)
                                    let closestMob, dist
                                    let range = end - 30 * this.waves[i].resonanceCount
                                    for (let i = 0, len = mob.length; i < len; i++) {
                                        if (who !== mob[i] && !mob[i].isBadTarget && !mob[i].isInvulnerable) {
                                            dist = Vector.magnitude(Vector.sub(who.position, mob[i].position));
                                            if (dist < range) {
                                                closestMob = mob[i]
                                                range = dist
                                            }
                                        }
                                    }
                                    if (closestMob) { //add wave to waves array
                                        this.addWave(who.position, Math.atan2(closestMob.position.y - who.position.y, closestMob.position.x - who.position.x) + tech.isBulletTeleport * 0.3 * (Math.random() - 0.5))
                                    } else {
                                        this.addWave(who.position, Math.random() * Math.PI)
                                    }
                                    this.waves[this.waves.length - 1].resonanceCount = this.waves[i].resonanceCount + 1
                                    break
                                }
                            }
                        }

                        hits = Matter.Query.ray(body, v1, v2, 50) //Matter.Query.ray(bodies, startPoint, endPoint, [rayWidth])
                        for (let j = 0, len = Math.min(30, hits.length); j < len; j++) {
                            const who = hits[j].body
                            //make them shake around
                            who.force.x += 0.005 * (Math.random() - 0.5) * who.mass
                            who.force.y += (0.005 * (Math.random() - 0.5) - simulation.g * 0.1) * who.mass //remove force of gravity
                            let vertices = who.vertices;
                            const vibe = 25
                            ctx.moveTo(vertices[0].x + vibe * (Math.random() - 0.5), vertices[0].y + vibe * (Math.random() - 0.5));
                            for (let j = 1; j < vertices.length; j++) {
                                ctx.lineTo(vertices[j].x + vibe * (Math.random() - 0.5), vertices[j].y + vibe * (Math.random() - 0.5));
                            }
                            ctx.lineTo(vertices[0].x + vibe * (Math.random() - 0.5), vertices[0].y + vibe * (Math.random() - 0.5));

                            if (tech.isPhononBlock && !who.isNotHoldable && who.speed < 5 && who.angularSpeed < 0.1) {
                                if (Math.random() < 0.5) b.targetedBlock(who, 50 - Math.min(25, who.mass * 3)) //    targetedBlock(who, speed = 50 - Math.min(20, who.mass * 2), range = 1600) {
                                // Matter.Body.setAngularVelocity(who, (0.25 + 0.12 * Math.random()) * (Math.random() < 0.5 ? -1 : 1));
                                who.torque += who.inertia * 0.001 * (Math.random() - 0.5)
                            }
                        }

                        this.waves[i].radius += tech.waveBeamSpeed * 2
                        if (this.waves[i].radius > end - 30 * this.waves[i].resonanceCount) {
                            this.waves.splice(i, 1) //end
                        }
                    }
                    ctx.stroke();
                }



            }
        })
        Composite.add(engine.world, bullet[me]); //add bullet to world
    },
    laserBot(position = { x: player.position.x + 50 * (Math.random() - 0.5), y: player.position.y + 50 * (Math.random() - 0.5) }, isKeep = true) {
        const me = bullet.length;
        const dir = m.angle;
        const RADIUS = (14 + 6 * Math.random())
        bullet[me] = Bodies.polygon(position.x, position.y, 3, RADIUS, {
            botType: "laser",
            angle: dir,
            friction: 0,
            frictionStatic: 0,
            frictionAir: 0.008 * (1 + 0.3 * Math.random()),
            restitution: 0.5 * (1 + 0.5 * Math.random()),
            acceleration: 0.0015 * (1 + 0.3 * Math.random()),
            playerRange: 140 + Math.floor(30 * Math.random()) + 2 * b.totalBots(),
            offPlayer: { x: 0, y: 0, },
            dmg: 0, //damage done in addition to the damage from momentum
            minDmgSpeed: 2,
            lookFrequency: 20 + Math.floor(7 * Math.random()) - 13 * tech.isLaserBotUpgrade,
            range: (600 + 375 * tech.isLaserBotUpgrade) * (1 + 0.12 * Math.random()),
            drainThreshold: 0.15 + 0.5 * Math.random() + (tech.isEnergyHealth ? 0.3 : 0),// laser bot will not attack if the player is below this energy
            drain: (0.57 - 0.43 * tech.isLaserBotUpgrade + isKeep * 0.08) * tech.laserDrain,
            laserDamage: 0.75 + 0.75 * tech.isLaserBotUpgrade,
            endCycle: Infinity,
            classType: "bullet",
            collisionFilter: {
                category: cat.bullet,
                mask: b.totalBots() < 50 ? cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet | cat.mobShield : cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield //if over 50 bots, they no longer collide with each other
            },
            lockedOn: null,
            beforeDmg() {
                this.lockedOn = null
            },
            onEnd() { },
            do() {
                const playerPos = Vector.add(Vector.add(this.offPlayer, m.pos), Vector.mult(player.velocity, 20)) //also include an offset unique to this bot to keep many bots spread out
                const farAway = Math.max(0, (Vector.magnitude(Vector.sub(this.position, playerPos))) / this.playerRange) //linear bounding well 
                const mag = Math.min(farAway, 4) * this.mass * this.acceleration
                this.force = Vector.mult(Vector.normalise(Vector.sub(playerPos, this.position)), mag)
                //manual friction to not lose rotational velocity
                Matter.Body.setVelocity(this, { x: this.velocity.x * 0.95, y: this.velocity.y * 0.95 });
                //find targets
                if (!(simulation.cycle % this.lookFrequency)) {
                    this.lockedOn = null;
                    if (!m.isCloak) {
                        let closeDist = this.range;
                        for (let i = 0, len = mob.length; i < len; ++i) {
                            const DIST = Vector.magnitude(Vector.sub(this.vertices[0], mob[i].position));
                            if (
                                DIST - mob[i].radius < closeDist &&
                                !mob[i].isShielded &&
                                (!mob[i].isBadTarget || mob[i].isMobBullet) &&
                                Matter.Query.ray(map, this.vertices[0], mob[i].position).length === 0 &&
                                Matter.Query.ray(body, this.vertices[0], mob[i].position).length === 0 &&
                                !mob[i].isInvulnerable
                            ) {
                                closeDist = DIST;
                                this.lockedOn = mob[i]
                            }
                        }
                    }
                    //randomize position relative to player
                    if (Math.random() < 0.1) {
                        if (isKeep) {
                            const range = 110 + 4 * b.totalBots()
                            this.offPlayer = { x: range * (Math.random() - 0.5), y: range * (Math.random() - 0.5) - 20, }
                        } else {
                            const range = 110 + 4 * b.totalBots() + 100 * Math.random()
                            this.offPlayer = Vector.mult(Vector.rotate({ x: 1, y: 0 }, 6.28 * Math.random()), range)
                        }
                    }
                }
                //hit target with laser
                if (this.lockedOn && this.lockedOn.alive && m.energy > this.drainThreshold) {
                    m.energy -= this.drain
                    this.laser();
                }
            },
            laser() {
                const push = 0.4
                const reflectivity = 1 - 1 / (tech.laserReflections * 3)
                let damage = this.laserDamage * tech.laserDamage
                //make the laser wiggle as it aims at the target
                let best = { x: 1, y: 1, dist2: Infinity, who: null, v1: 1, v2: 1 };
                const perp2 = Vector.mult(Vector.rotate({ x: 1, y: 0 }, m.angle + Math.PI / 2), 0.6 * this.lockedOn.radius * Math.sin(simulation.cycle / this.lookFrequency))
                const path = [{ x: this.vertices[0].x, y: this.vertices[0].y }, Vector.add(this.lockedOn.position, perp2)];

                const checkForCollisions = function () {
                    best = { x: 1, y: 1, dist2: Infinity, who: null, v1: 1, v2: 1 };
                    best = vertexCollision(path[path.length - 2], path[path.length - 1], [mob, map, body]);
                };
                const laserHitMob = function () {
                    if (best.who.alive) {
                        best.who.locatePlayer();
                        if (best.who.damageReduction) {
                            if ( //iridescence
                                tech.laserCrit && !best.who.shield &&
                                Vector.dot(Vector.normalise(Vector.sub(best.who.position, path[path.length - 1])), Vector.normalise(Vector.sub(path[path.length - 1], path[path.length - 2]))) > 0.999 - 0.5 / best.who.radius
                            ) {
                                damage *= 1 + tech.laserCrit
                                simulation.drawList.push({ //add dmg to draw queue
                                    x: path[path.length - 1].x,
                                    y: path[path.length - 1].y,
                                    radius: Math.sqrt(2500 * damage * best.who.damageReduction) + 5,
                                    color: `hsla(${60 + 283 * Math.random()},100%,70%,0.5)`, // random hue, but not red
                                    time: 16
                                });
                            } else {
                                simulation.drawList.push({ //add dmg to draw queue
                                    x: path[path.length - 1].x,
                                    y: path[path.length - 1].y,
                                    radius: Math.sqrt(2000 * damage * best.who.damageReduction) + 2,
                                    color: tech.laserColorAlpha,
                                    time: simulation.drawTime
                                });
                            }
                            best.who.damage(damage);
                        }
                        if (tech.isLaserPush) { //push mobs away
                            const index = path.length - 1
                            Matter.Body.setVelocity(best.who, { x: best.who.velocity.x * 0.97, y: best.who.velocity.y * 0.97 });
                            const force = Vector.mult(Vector.normalise(Vector.sub(path[index], path[Math.max(0, index - 1)])), 0.003 * push * Math.min(6, best.who.mass))
                            Matter.Body.applyForce(best.who, path[index], force)
                        }
                    } else if (tech.isLaserPush && best.who.classType === "body") {
                        const index = path.length - 1
                        Matter.Body.setVelocity(best.who, { x: best.who.velocity.x * 0.97, y: best.who.velocity.y * 0.97 });
                        const force = Vector.mult(Vector.normalise(Vector.sub(path[index], path[Math.max(0, index - 1)])), 0.003 * push * Math.min(6, best.who.mass))
                        Matter.Body.applyForce(best.who, path[index], force)
                    }
                };
                const reflection = function () { // https://math.stackexchange.com/questions/13261/how-to-get-a-reflection-vector
                    const n = Vector.perp(Vector.normalise(Vector.sub(best.v1, best.v2)));
                    const d = Vector.sub(path[path.length - 1], path[path.length - 2]);
                    const nn = Vector.mult(n, 2 * Vector.dot(d, n));
                    const r = Vector.normalise(Vector.sub(d, nn));
                    path[path.length] = Vector.add(Vector.mult(r, 3000), path[path.length - 1]);
                };

                checkForCollisions();
                let lastBestOdd
                let lastBestEven = best.who //used in hack below
                if (best.dist2 !== Infinity) { //if hitting something
                    path[path.length - 1] = { x: best.x, y: best.y };
                    laserHitMob();
                    for (let i = 0; i < tech.laserReflections; i++) {
                        reflection();
                        checkForCollisions();
                        if (best.dist2 !== Infinity) { //if hitting something
                            lastReflection = best
                            path[path.length - 1] = { x: best.x, y: best.y };
                            damage *= reflectivity
                            laserHitMob();
                            //I'm not clear on how this works, but it gets rid of a bug where the laser reflects inside a block, often vertically.
                            //I think it checks to see if the laser is reflecting off a different part of the same block, if it is "inside" a block
                            if (i % 2) {
                                if (lastBestOdd === best.who) break
                            } else {
                                lastBestOdd = best.who
                                if (lastBestEven === best.who) break
                            }
                        } else {
                            break
                        }
                    }
                }
                ctx.strokeStyle = tech.laserColor;
                ctx.lineWidth = 2
                ctx.lineDashOffset = 900 * Math.random()
                ctx.setLineDash([50 + 120 * Math.random(), 50 * Math.random()]);
                for (let i = 1, len = path.length; i < len; ++i) {
                    ctx.beginPath();
                    ctx.moveTo(path[i - 1].x, path[i - 1].y);
                    ctx.lineTo(path[i].x, path[i].y);
                    ctx.stroke();
                    ctx.globalAlpha *= reflectivity; //reflections are less intense
                }
                ctx.setLineDash([]);
                ctx.globalAlpha = 1;
            }
        })
        Composite.add(engine.world, bullet[me]); //add bullet to world
    },
    boomBot(position = { x: player.position.x + 50 * (Math.random() - 0.5), y: player.position.y + 50 * (Math.random() - 0.5) }, isKeep = true) {
        const me = bullet.length;
        const dir = m.angle;
        const RADIUS = (7 + 2 * Math.random())
        bullet[me] = Bodies.polygon(position.x, position.y, 4, RADIUS, {
            isUpgraded: tech.isBoomBotUpgrade,
            botType: "boom",
            angle: dir,
            friction: 0,
            frictionStatic: 0,
            frictionAir: 0.05,
            restitution: 1,
            dmg: 0,
            minDmgSpeed: 0,
            lookFrequency: 43 + Math.floor(7 * Math.random()) - 15 * tech.isBoomBotUpgrade,
            acceleration: (isKeep ? 0.005 : 0.001) * (1 + 0.5 * Math.random()),
            attackAcceleration: 0.012 + 0.005 * tech.isBoomBotUpgrade,
            range: 500 * (1 + 0.1 * Math.random()) + 250 * tech.isBoomBotUpgrade + !isKeep * 100,
            endCycle: Infinity,
            classType: "bullet",
            collisionFilter: {
                category: cat.bullet,
                mask: b.totalBots() < 50 ? cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet | cat.mobShield : cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield //if over 50 bots, they no longer collide with each other
            },
            lockedOn: null,
            explode: 0,
            beforeDmg() {
                if (this.lockedOn) {
                    const explosionRadius = Math.min(136 + 230 * this.isUpgraded, Vector.magnitude(Vector.sub(this.position, m.pos)) - 30)
                    if (explosionRadius > 60) {
                        this.explode = explosionRadius
                        // 
                        //push away from player, because normal explosion knock doesn't do much
                        // const sub = Vector.sub(this.lockedOn.position, m.pos)
                        // mag = Math.min(35, 20 / Math.sqrt(this.lockedOn.mass))
                        // Matter.Body.setVelocity(this.lockedOn, Vector.mult(Vector.normalise(sub), mag))
                    }
                    this.lockedOn = null //lose target so bot returns to player
                }
            },
            onEnd() { },
            do() {
                const distanceToPlayer = Vector.magnitude(Vector.sub(this.position, player.position))
                if (distanceToPlayer > 100) { //if far away move towards player
                    if (this.explode) {
                        // if (tech.isImmuneExplosion && m.energy > 1.43) {
                        //     b.explosion(this.position, this.explode);
                        // } else {
                        // }
                        b.explosion(this.position, Math.max(0, Math.min(this.explode, (distanceToPlayer - 70) / b.explosionRange())));
                        this.explode = 0;
                    }
                    this.force = Vector.mult(Vector.normalise(Vector.sub(player.position, this.position)), this.mass * this.acceleration)
                } else if (distanceToPlayer < 250) { //close to player
                    Matter.Body.setVelocity(this, Vector.add(Vector.mult(this.velocity, 0.90), Vector.mult(player.velocity, 0.17))); //add player's velocity
                    //find targets
                    if (!(simulation.cycle % this.lookFrequency) && !m.isCloak) {
                        this.lockedOn = null;
                        let closeDist = this.range;
                        for (let i = 0, len = mob.length; i < len; ++i) {
                            const DIST = Vector.magnitude(Vector.sub(this.position, mob[i].position)) - mob[i].radius;
                            if (
                                DIST < closeDist &&
                                !mob[i].isBadTarget &&
                                Matter.Query.ray(map, this.position, mob[i].position).length === 0 &&
                                Matter.Query.ray(body, this.position, mob[i].position).length === 0 &&
                                !mob[i].isInvulnerable
                            ) {
                                closeDist = DIST;
                                this.lockedOn = mob[i]
                            }
                        }
                    }
                }
                //punch target
                if (this.lockedOn && this.lockedOn.alive && !m.isCloak) {
                    const DIST = Vector.magnitude(Vector.sub(this.vertices[0], this.lockedOn.position));
                    if (DIST - this.lockedOn.radius < this.range &&
                        Matter.Query.ray(map, this.position, this.lockedOn.position).length === 0) {
                        //move towards the target
                        this.force = Vector.add(this.force, Vector.mult(Vector.normalise(Vector.sub(this.lockedOn.position, this.position)), this.attackAcceleration * this.mass))
                    }
                }
            }
        })
        Composite.add(engine.world, bullet[me]); //add bullet to world
    },
    plasmaBot(position = { x: player.position.x + 50 * (Math.random() - 0.5), y: player.position.y + 50 * (Math.random() - 0.5) }, isKeep = true) {
        const me = bullet.length;
        const dir = m.angle;
        const RADIUS = 21
        bullet[me] = Bodies.polygon(position.x, position.y, 5, RADIUS, {
            botType: "plasma",
            angle: dir,
            friction: 0,
            frictionStatic: 0,
            frictionAir: 0.05,
            restitution: 1,
            dmg: 0, // 0.14   //damage done in addition to the damage from momentum
            minDmgSpeed: 2,
            lookFrequency: 25,
            cd: 0,
            acceleration: 0.009,
            endCycle: Infinity,
            drainThreshold: tech.isEnergyHealth ? 0.5 : 0.05,
            classType: "bullet",
            collisionFilter: {
                category: cat.bullet,
                mask: b.totalBots() < 50 ? cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet | cat.mobShield : cat.map | cat.body | cat.mob | cat.mobBullet | cat.mobShield //if over 50 bots, they no longer collide with each other
            },
            lockedOn: null,
            beforeDmg() {
                this.lockedOn = null
            },
            onEnd() { },
            do() {
                const distanceToPlayer = Vector.magnitude(Vector.sub(this.position, m.pos))
                if (distanceToPlayer > 150) this.force = Vector.mult(Vector.normalise(Vector.sub(m.pos, this.position)), this.mass * this.acceleration) //if far away move towards player
                Matter.Body.setVelocity(this, Vector.add(Vector.mult(this.velocity, 0.90), Vector.mult(player.velocity, 0.17))); //add player's velocity

                if (!(simulation.cycle % this.lookFrequency)) { //find closest
                    this.lockedOn = null;
                    if (!m.isCloak) {
                        let closeDist = tech.isPlasmaRange * 1000;
                        for (let i = 0, len = mob.length; i < len; ++i) {
                            const DIST = Vector.magnitude(Vector.sub(this.position, mob[i].position)) - mob[i].radius;
                            if (
                                DIST < closeDist && (!mob[i].isBadTarget || mob[i].isMobBullet) &&
                                Matter.Query.ray(map, this.position, mob[i].position).length === 0 &&
                                Matter.Query.ray(body, this.position, mob[i].position).length === 0 &&
                                !mob[i].isInvulnerable
                            ) {
                                closeDist = DIST;
                                this.lockedOn = mob[i]
                            }
                        }
                    }
                }
                //fire plasma at target
                if (this.lockedOn && this.lockedOn.alive && m.fieldCDcycle < m.cycle) {
                    const sub = Vector.sub(this.lockedOn.position, this.position)
                    const DIST = Vector.magnitude(sub);
                    const unit = Vector.normalise(sub)
                    if (DIST < tech.isPlasmaRange * 450 && m.energy > this.drainThreshold) {
                        m.energy -= 0.001
                        //calculate laser collision
                        let best;
                        let range = tech.isPlasmaRange * (120 + 300 * Math.sqrt(Math.random()))
                        const path = [{ x: this.position.x, y: this.position.y }, { x: this.position.x + range * unit.x, y: this.position.y + range * unit.y }];
                        //check for collisions
                        best = { x: null, y: null, dist2: Infinity, who: null, v1: null, v2: null };
                        best = vertexCollision(path[0], path[1], [mob, map, body]);
                        if (best.dist2 != Infinity) { //if hitting something
                            path[path.length - 1] = { x: best.x, y: best.y };
                            if (best.who.alive) {
                                const dmg = 1.4; //********** SCALE DAMAGE HERE *********************
                                best.who.damage(dmg);
                                best.who.locatePlayer();
                                //push mobs away
                                // const force = Vector.mult(Vector.normalise(Vector.sub(m.pos, path[1])), -0.007 * Math.min(5, best.who.mass))
                                // Matter.Body.applyForce(best.who, path[1], force)
                                //push mobs away
                                if (best.who.speed > 3) {
                                    const force = Vector.mult(Vector.normalise(Vector.sub(m.pos, path[1])), -0.004 * Math.min(5, best.who.mass))
                                    Matter.Body.applyForce(best.who, path[1], force)
                                    Matter.Body.setVelocity(best.who, { x: best.who.velocity.x * 0.5, y: best.who.velocity.y * 0.5 });
                                } else {
                                    const force = Vector.mult(Vector.normalise(Vector.sub(m.pos, path[1])), -0.01 * Math.min(5, best.who.mass))
                                    Matter.Body.applyForce(best.who, path[1], force)
                                    Matter.Body.setVelocity(best.who, { x: best.who.velocity.x * 0.7, y: best.who.velocity.y * 0.7 });
                                }

                                if (best.who.speed > 2.5) Matter.Body.setVelocity(best.who, { x: best.who.velocity.x * 0.75, y: best.who.velocity.y * 0.75 });
                                //draw mob damage circle
                                if (best.who.damageReduction) {
                                    simulation.drawList.push({
                                        x: path[1].x,
                                        y: path[1].y,
                                        // radius: Math.sqrt(dmg) * 50 * mob[k].damageReduction,
                                        // radius: 600 * dmg * best.who.damageReduction,
                                        radius: Math.sqrt(2000 * dmg * best.who.damageReduction) + 2,
                                        color: "rgba(255,0,255,0.2)",
                                        time: simulation.drawTime * 4
                                    });
                                }
                            } else if (!best.who.isStatic) {
                                //push blocks away
                                const force = Vector.mult(Vector.normalise(Vector.sub(m.pos, path[1])), -0.007 * Math.sqrt(Math.sqrt(best.who.mass)))
                                Matter.Body.applyForce(best.who, path[1], force)
                            }
                        }
                        //draw blowtorch laser beam
                        ctx.beginPath();
                        ctx.moveTo(path[0].x, path[0].y);
                        ctx.lineTo(path[1].x, path[1].y);
                        ctx.strokeStyle = "rgba(255,0,255,0.1)"
                        ctx.lineWidth = 14
                        ctx.stroke();
                        ctx.strokeStyle = "#f0f";
                        ctx.lineWidth = 2
                        ctx.stroke();
                        //draw electricity
                        let x = this.position.x + 20 * unit.x;
                        let y = this.position.y + 20 * unit.y;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        const step = Vector.magnitude(Vector.sub(path[0], path[1])) / 5
                        for (let i = 0; i < 4; i++) {
                            x += step * (unit.x + 1.5 * (Math.random() - 0.5))
                            y += step * (unit.y + 1.5 * (Math.random() - 0.5))
                            ctx.lineTo(x, y);
                        }
                        ctx.lineWidth = 2 * Math.random();
                        ctx.stroke();
                    }
                }
            }
        })
        Composite.add(engine.world, bullet[me]); //add bullet to world
    },
    orbitBot(position = player.position, isKeep = true) {
        const me = bullet.length;
        bullet[me] = Bodies.polygon(position.x, position.y, 9, 12, {
            isUpgraded: tech.isOrbitBotUpgrade,
            botType: "orbit",
            friction: 0,
            frictionStatic: 0,
            frictionAir: 1,
            isStatic: true,
            isSensor: true,
            isKeep: isKeep,
            restitution: 0,
            dmg: 0, // 0.14   //damage done in addition to the damage from momentum
            minDmgSpeed: 0,
            endCycle: Infinity,
            classType: "bullet",
            collisionFilter: {
                category: cat.bullet,
                mask: 0 //cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet | cat.mobShield
            },
            beforeDmg() { },
            onEnd() {
                //reorder orbital bot positions around a circle
                let totalOrbitalBots = 0
                for (let i = 0; i < bullet.length; i++) {
                    if (bullet[i].botType === 'orbit' && bullet[i] !== this && bullet[i].isKeep) totalOrbitalBots++
                }
                let index = 0
                for (let i = 0; i < bullet.length; i++) {
                    if (bullet[i].botType === 'orbit' && bullet[i] !== this && bullet[i].isKeep) {
                        bullet[i].phase = (index / totalOrbitalBots) * 2 * Math.PI
                        index++
                    }
                }
            },
            range: 160 + 170 * tech.isOrbitBotUpgrade + !isKeep * 100 * (0.5 - Math.random()), //range is set in bot upgrade too!
            orbitalSpeed: 0,
            phase: 2 * Math.PI * Math.random(),
            do() {
                if (!m.isCloak) { //if time dilation isn't active
                    const size = 40
                    q = Matter.Query.region(mob, {
                        min: {
                            x: this.position.x - size,
                            y: this.position.y - size
                        },
                        max: {
                            x: this.position.x + size,
                            y: this.position.y + size
                        }
                    })
                    for (let i = 0; i < q.length; i++) {
                        if (!q[i].isShielded) {
                            mobs.statusStun(q[i], 210 + 90 * this.isUpgraded)
                            const dmg = 0.4 * (this.isUpgraded ? 4.5 : 1) * (tech.isCrit ? 4 : 1)
                            q[i].damage(dmg);
                            if (q[i].alive) q[i].foundPlayer();
                            if (q[i].damageReduction) {
                                simulation.drawList.push({ //add dmg to draw queue
                                    x: this.position.x,
                                    y: this.position.y,
                                    // radius: 600 * dmg * q[i].damageReduction,
                                    radius: Math.sqrt(2000 * dmg * q[i].damageReduction) + 2,
                                    color: 'rgba(0,0,0,0.4)',
                                    time: simulation.drawTime
                                });
                            }
                        }
                    }
                }
                //orbit player
                const time = simulation.cycle * this.orbitalSpeed + this.phase
                const orbit = { x: Math.cos(time), y: Math.sin(time) }
                Matter.Body.setPosition(this, Vector.add(m.pos, Vector.mult(orbit, this.range))) //bullets move with player
            }
        })
        // bullet[me].orbitalSpeed = Math.sqrt(0.7 / bullet[me].range)
        bullet[me].orbitalSpeed = Math.sqrt(0.25 / bullet[me].range) //also set in bot upgrade too!
        // bullet[me].phase = (index / tech.orbitBotCount) * 2 * Math.PI
        Composite.add(engine.world, bullet[me]); //add bullet to world

        //reorder orbital bot positions around a circle
        let totalOrbitalBots = 0
        for (let i = 0; i < bullet.length; i++) {
            if (bullet[i].botType === 'orbit' && bullet[i].isKeep) totalOrbitalBots++
        }
        let index = 0
        for (let i = 0; i < bullet.length; i++) {
            if (bullet[i].botType === 'orbit' && bullet[i].isKeep) {
                bullet[i].phase = (index / totalOrbitalBots) * 2 * Math.PI
                index++
            }
        }
    },
    // **************************************************************************************************
    // **************************************************************************************************
    // ********************************         Guns        *********************************************
    // **************************************************************************************************
    // **************************************************************************************************
    //0 nail gun
    //1 shotgun
    //2 super balls
    //3 wave
    //4 missiles
    //5 grenades
    //6 spores
    //7 drones
    //8 foam
    //9 harpoon
    //10 mine
    //11 laser
    guns: [
        {
            name: "nail gun", // 0
            // description: `use compressed air to shoot a stream of <strong>nails</strong><br><em>fire rate</em> <strong>increases</strong> the longer you fire<br><strong>60</strong> nails per ${powerUps.orb.ammo()}`,
            descriptionFunction() {
                return `use compressed air to rapidly drive <strong>nails</strong><br><em>fire rate</em> <strong>increases</strong> the longer you fire<br><strong>${this.ammoPack.toFixed(0)}</strong> nails per ${powerUps.orb.ammo()}`
            },
            ammo: 0,
            ammoPack: 27,
            defaultAmmoPack: 27,
            recordedAmmo: 0,
            have: false,
            nextFireCycle: 0, //use to remember how longs its been since last fire, used to reset count
            startingHoldCycle: 0,
            chooseFireMethod() { //set in simulation.startGame
                if (tech.nailRecoil) {
                    if (tech.isRivets) {
                        this.fire = this.fireRecoilRivets
                    } else {
                        this.fire = this.fireRecoilNails
                    }
                } else if (tech.isRivets) {
                    this.fire = this.fireRivets
                } else if (tech.isNeedles) {
                    this.fire = this.fireNeedles
                } else if (tech.nailInstantFireRate) {
                    this.fire = this.fireInstantFireRate
                    // } else if (tech.nailFireRate) {
                    // this.fire = this.fireNailFireRate
                } else {
                    this.fire = this.fireNormal
                }
            },
            do() { },
            fire() { },
            fireRecoilNails() {
                if (this.nextFireCycle + 1 < m.cycle) this.startingHoldCycle = m.cycle //reset if not constantly firing
                const CD = Math.max(11 - 0.06 * (m.cycle - this.startingHoldCycle), 0.99) //CD scales with cycles fire is held down
                this.nextFireCycle = m.cycle + CD * b.fireCDscale //predict next fire cycle if the fire button is held down

                m.fireCDcycle = m.cycle + Math.floor(CD * b.fireCDscale); // cool down
                this.baseFire(m.angle + (Math.random() - 0.5) * (m.crouch ? 0.04 : 0.13) / CD, 45 + 6 * Math.random())
                //very complex recoil system
                if (m.onGround) {
                    if (m.crouch) {
                        const KNOCK = 0.006
                        player.force.x -= KNOCK * Math.cos(m.angle)
                        player.force.y -= KNOCK * Math.sin(m.angle) //reduce knock back in vertical direction to stop super jumps
                        Matter.Body.setVelocity(player, {
                            x: player.velocity.x * 0.5,
                            y: player.velocity.y * 0.5
                        });
                    } else {
                        const KNOCK = 0.03
                        player.force.x -= KNOCK * Math.cos(m.angle)
                        player.force.y -= KNOCK * Math.sin(m.angle) //reduce knock back in vertical direction to stop super jumps
                        Matter.Body.setVelocity(player, {
                            x: player.velocity.x * 0.8,
                            y: player.velocity.y * 0.8
                        });
                    }
                } else {
                    player.force.x -= 0.06 * Math.cos(m.angle) * Math.min(1, 3 / (0.1 + Math.abs(player.velocity.x)))
                    player.force.y -= 0.006 * Math.sin(m.angle) //reduce knock back in vertical direction to stop super jumps
                }
            },
            fireNormal() {
                if (this.nextFireCycle + 1 < m.cycle) this.startingHoldCycle = m.cycle //reset if not constantly firing
                const CD = Math.max(11 - 0.06 * (m.cycle - this.startingHoldCycle), 1) //CD scales with cycles fire is held down
                this.nextFireCycle = m.cycle + CD * b.fireCDscale //predict next fire cycle if the fire button is held down

                m.fireCDcycle = m.cycle + Math.floor(CD * b.fireCDscale); // cool down
                this.baseFire(m.angle + (Math.random() - 0.5) * (m.crouch ? 0.05 : 0.3) / CD)
            },
            fireNeedles() {
                if (m.crouch) {
                    m.fireCDcycle = m.cycle + 30 * b.fireCDscale; // cool down
                    b.needle()

                    function cycle() {
                        if (simulation.paused || m.isTimeDilated) {
                            requestAnimationFrame(cycle)
                        } else {
                            count++
                            if (count % 2) b.needle()
                            if (count < 7 && m.alive) requestAnimationFrame(cycle);
                        }
                    }
                    let count = -1
                    requestAnimationFrame(cycle);
                } else {
                    m.fireCDcycle = m.cycle + 22 * b.fireCDscale; // cool down
                    b.needle()

                    function cycle() {
                        if (simulation.paused || m.isTimeDilated) {
                            requestAnimationFrame(cycle)
                        } else {
                            count++
                            if (count % 2) b.needle()
                            if (count < 3 && m.alive) requestAnimationFrame(cycle);
                        }
                    }
                    let count = -1
                    requestAnimationFrame(cycle);
                }
            },
            fireRivets() {
                m.fireCDcycle = m.cycle + Math.floor((m.crouch ? 22 : 14) * b.fireCDscale); // cool down
                const me = bullet.length;
                const size = tech.bulletSize * 8
                bullet[me] = Bodies.rectangle(m.pos.x + 35 * Math.cos(m.angle), m.pos.y + 35 * Math.sin(m.angle), 5 * size, size, b.fireAttributes(m.angle));
                bullet[me].dmg = tech.isNailRadiation ? 0 : 2.75
                Matter.Body.setDensity(bullet[me], 0.002);
                Composite.add(engine.world, bullet[me]); //add bullet to world
                const SPEED = m.crouch ? 60 : 44
                Matter.Body.setVelocity(bullet[me], {
                    x: SPEED * Math.cos(m.angle),
                    y: SPEED * Math.sin(m.angle)
                });
                bullet[me].endCycle = simulation.cycle + 180

                bullet[me].beforeDmg = function (who) { //beforeDmg is rewritten with ice crystal tech
                    if (tech.isIncendiary) {
                        this.endCycle = 0; //bullet ends cycle after hitting a mob and triggers explosion
                        b.explosion(this.position, 100 + (Math.random() - 0.5) * 20); //makes bullet do explosive damage at end
                    }
                    if (tech.isNailCrit) {
                        if (!who.shield && Vector.dot(Vector.normalise(Vector.sub(who.position, this.position)), Vector.normalise(this.velocity)) > 0.97 - 1 / who.radius) {
                            b.explosion(this.position, 300 + 40 * Math.random()); //makes bullet do explosive damage at end
                        }
                    } else if (tech.isCritKill) b.crit(who, this)
                    if (tech.isNailRadiation) mobs.statusDoT(who, 7 * (tech.isFastRadiation ? 0.7 : 0.24), tech.isSlowRadiation ? 360 : (tech.isFastRadiation ? 60 : 180)) // one tick every 30 cycles
                    if (this.speed > 4 && tech.fragments) {
                        b.targetedNail(this.position, 1.25 * tech.fragments * tech.bulletSize)
                        this.endCycle = 0 //triggers despawn
                    }
                };

                bullet[me].minDmgSpeed = 10
                bullet[me].frictionAir = 0.006;
                bullet[me].rotateToVelocity = function () { //rotates bullet to face current velocity?
                    if (this.speed > 7) {
                        const facing = {
                            x: Math.cos(this.angle),
                            y: Math.sin(this.angle)
                        }
                        const mag = 0.002 * this.mass
                        if (Vector.cross(Vector.normalise(this.velocity), facing) < 0) {
                            this.torque += mag
                        } else {
                            this.torque -= mag
                        }
                    }
                };
                if (tech.isIncendiary) {
                    bullet[me].do = function () {
                        this.force.y += this.mass * 0.0008
                        this.rotateToVelocity()
                        //collide with map
                        if (Matter.Query.collides(this, map).length) { //penetrate walls
                            this.endCycle = 0; //bullet ends cycle after hitting a mob and triggers explosion
                            b.explosion(this.position, 300 + 40 * Math.random()); //makes bullet do explosive damage at end
                        }
                    };
                } else {
                    bullet[me].do = function () {
                        this.force.y += this.mass * 0.0008
                        this.rotateToVelocity()
                    };
                }
                b.muzzleFlash();
                //very complex recoil system
                if (m.onGround) {
                    if (m.crouch) {
                        const KNOCK = 0.01
                        player.force.x -= KNOCK * Math.cos(m.angle)
                        player.force.y -= KNOCK * Math.sin(m.angle) //reduce knock back in vertical direction to stop super jumps
                    } else {
                        const KNOCK = 0.02
                        player.force.x -= KNOCK * Math.cos(m.angle)
                        player.force.y -= KNOCK * Math.sin(m.angle) //reduce knock back in vertical direction to stop super jumps
                    }
                } else {
                    const KNOCK = 0.01
                    player.force.x -= KNOCK * Math.cos(m.angle)
                    player.force.y -= KNOCK * Math.sin(m.angle) * 0.5 //reduce knock back in vertical direction to stop super jumps    
                }
            },
            fireRecoilRivets() {
                // m.fireCDcycle = m.cycle + Math.floor((m.crouch ? 25 : 17) * b.fireCDscale); // cool down
                if (this.nextFireCycle + 1 < m.cycle) this.startingHoldCycle = m.cycle //reset if not constantly firing
                const CD = Math.max(25 - 0.14 * (m.cycle - this.startingHoldCycle), 5) //CD scales with cycles fire is held down
                this.nextFireCycle = m.cycle + CD * b.fireCDscale //predict next fire cycle if the fire button is held down
                m.fireCDcycle = m.cycle + Math.floor(CD * b.fireCDscale); // cool down

                const me = bullet.length;
                const size = tech.bulletSize * 8
                bullet[me] = Bodies.rectangle(m.pos.x + 35 * Math.cos(m.angle), m.pos.y + 35 * Math.sin(m.angle), 5 * size, size, b.fireAttributes(m.angle));
                bullet[me].dmg = tech.isNailRadiation ? 0 : 2.75
                Matter.Body.setDensity(bullet[me], 0.002);
                Composite.add(engine.world, bullet[me]); //add bullet to world
                const SPEED = m.crouch ? 62 : 52
                Matter.Body.setVelocity(bullet[me], {
                    x: SPEED * Math.cos(m.angle),
                    y: SPEED * Math.sin(m.angle)
                });
                bullet[me].endCycle = simulation.cycle + 180
                bullet[me].beforeDmg = function (who) { //beforeDmg is rewritten with ice crystal tech
                    if (tech.isIncendiary) {
                        this.endCycle = 0; //bullet ends cycle after hitting a mob and triggers explosion
                        b.explosion(this.position, 100 + (Math.random() - 0.5) * 20); //makes bullet do explosive damage at end
                    }
                    if (tech.isNailCrit) {
                        if (!who.shield && Vector.dot(Vector.normalise(Vector.sub(who.position, this.position)), Vector.normalise(this.velocity)) > 0.97 - 1 / who.radius) {
                            b.explosion(this.position, 300 + 40 * Math.random()); //makes bullet do explosive damage at end
                        }
                    } else if (tech.isCritKill) b.crit(who, this)
                    if (tech.isNailRadiation) mobs.statusDoT(who, 7 * (tech.isFastRadiation ? 0.7 : 0.24), tech.isSlowRadiation ? 360 : (tech.isFastRadiation ? 60 : 180)) // one tick every 30 cycles
                    if (this.speed > 4 && tech.fragments) {
                        b.targetedNail(this.position, 1.25 * tech.fragments * tech.bulletSize)
                        this.endCycle = 0 //triggers despawn
                    }
                };

                bullet[me].minDmgSpeed = 10
                bullet[me].frictionAir = 0.006;
                bullet[me].rotateToVelocity = function () { //rotates bullet to face current velocity?
                    if (this.speed > 7) {
                        const facing = {
                            x: Math.cos(this.angle),
                            y: Math.sin(this.angle)
                        }
                        const mag = 0.002 * this.mass
                        if (Vector.cross(Vector.normalise(this.velocity), facing) < 0) {
                            this.torque += mag
                        } else {
                            this.torque -= mag
                        }
                    }
                };
                if (tech.isIncendiary) {
                    bullet[me].do = function () {
                        this.force.y += this.mass * 0.0008
                        this.rotateToVelocity()
                        //collide with map
                        if (Matter.Query.collides(this, map).length) { //penetrate walls
                            this.endCycle = 0; //bullet ends cycle after hitting a mob and triggers explosion
                            b.explosion(this.position, 100 + (Math.random() - 0.5) * 20); //makes bullet do explosive damage at end
                        }
                    };
                } else {
                    bullet[me].do = function () {
                        this.force.y += this.mass * 0.0008
                        this.rotateToVelocity()
                    };
                }

                b.muzzleFlash();
                //very complex recoil system
                if (m.onGround) {
                    if (m.crouch) {
                        const KNOCK = 0.03
                        player.force.x -= KNOCK * Math.cos(m.angle)
                        player.force.y -= KNOCK * Math.sin(m.angle) //reduce knock back in vertical direction to stop super jumps
                        Matter.Body.setVelocity(player, {
                            x: player.velocity.x * 0.4,
                            y: player.velocity.y * 0.4
                        });
                    } else {
                        const KNOCK = 0.1
                        player.force.x -= KNOCK * Math.cos(m.angle)
                        player.force.y -= KNOCK * Math.sin(m.angle) //reduce knock back in vertical direction to stop super jumps
                        Matter.Body.setVelocity(player, {
                            x: player.velocity.x * 0.7,
                            y: player.velocity.y * 0.7
                        });
                    }
                } else {
                    player.force.x -= 0.2 * Math.cos(m.angle) * Math.min(1, 3 / (0.1 + Math.abs(player.velocity.x)))
                    // player.force.x -= 0.06 * Math.cos(m.angle) * Math.min(1, 3 / (0.1 + Math.abs(player.velocity.x)))

                    player.force.y -= 0.02 * Math.sin(m.angle) //reduce knock back in vertical direction to stop super jumps
                }
            },
            fireInstantFireRate() {
                m.fireCDcycle = m.cycle + Math.floor(1 * b.fireCDscale); // cool down
                this.baseFire(m.angle + (Math.random() - 0.5) * (Math.random() - 0.5) * (m.crouch ? 1.15 : 2) / 2)
            },
            baseFire(angle, speed = 30 + 6 * Math.random()) {
                b.nail({
                    x: m.pos.x + 30 * Math.cos(m.angle),
                    y: m.pos.y + 30 * Math.sin(m.angle)
                }, {
                    x: 0.8 * player.velocity.x + speed * Math.cos(angle),
                    y: 0.5 * player.velocity.y + speed * Math.sin(angle)
                }) //position, velocity, damage
                if (tech.isIceCrystals) {
                    bullet[bullet.length - 1].beforeDmg = function (who) {
                        mobs.statusSlow(who, 60)
                        if (tech.isNailRadiation) mobs.statusDoT(who, 1 * (tech.isFastRadiation ? 1.3 : 0.44), tech.isSlowRadiation ? 360 : (tech.isFastRadiation ? 60 : 180)) // one tick every 30 cycles
                        if (tech.isNailCrit) {
                            if (!who.shield && Vector.dot(Vector.normalise(Vector.sub(who.position, this.position)), Vector.normalise(this.velocity)) > 0.97 - 1 / who.radius) {
                                b.explosion(this.position, 150 + 30 * Math.random()); //makes bullet do explosive damage at end
                            }
                        }
                        this.ricochet(who)
                    };
                    if (m.energy < 0.01) {
                        m.fireCDcycle = m.cycle + 60; // cool down
                    } else {
                        m.energy -= 0.01
                    }
                }
            },
        },
        {
            name: "shotgun", //1
            // description: `fire a wide <strong>burst</strong> of short range <strong> bullets</strong><br>with a low <strong><em>fire rate</em></strong><br><strong>3-4</strong> nails per ${powerUps.orb.ammo()}`,
            descriptionFunction() {
                return `fire a wide <strong>burst</strong> of short range <strong>pellets</strong><br>has a slow <strong><em>fire rate</em></strong><br><strong>${this.ammoPack.toFixed(1)}</strong> shots per ${powerUps.orb.ammo()}`
            },
            ammo: 0,
            ammoPack: 1.6,
            defaultAmmoPack: 1.6,
            have: false,
            do() {
                //fade cross hairs



                // draw loop around player head
                // const left = m.fireCDcycle !== Infinity ? 0.05 * Math.max(m.fireCDcycle - m.cycle, 0) : 0
                // if (left > 0) {
                //     ctx.beginPath();
                //     // ctx.arc(simulation.mouseInGame.x, simulation.mouseInGame.y, 30, 0, left);
                //     ctx.arc(m.pos.x, m.pos.y, 28, m.angle - left, m.angle);
                //     // ctx.fillStyle = "rgba(0,0,0,0.3)" //"#333"
                //     // ctx.fill();
                //     ctx.strokeStyle = "#333";
                //     ctx.lineWidth = 2;
                //     ctx.stroke();
                // }


                //draw hip circle
                // ctx.beginPath();
                // ctx.arc(m.pos.x + m.hip.x, m.pos.y + m.hip.y, 11, 0, 2 * Math.PI);
                // ctx.fillStyle = "rgba(0,0,0,0.3)" //"#333"
                // ctx.fill();
            },
            fire() {
                let knock, spread
                const coolDown = function () {
                    if (m.crouch) {
                        spread = 0.65
                        m.fireCDcycle = m.cycle + Math.floor((73 + 36 * tech.shotgunExtraShots) * b.fireCDscale) // cool down
                        if (tech.isShotgunImmune && m.immuneCycle < m.cycle + Math.floor(60 * b.fireCDscale)) m.immuneCycle = m.cycle + Math.floor(60 * b.fireCDscale); //player is immune to damage for 30 cycles
                        knock = 0.01
                    } else {
                        m.fireCDcycle = m.cycle + Math.floor((56 + 28 * tech.shotgunExtraShots) * b.fireCDscale) // cool down
                        if (tech.isShotgunImmune && m.immuneCycle < m.cycle + Math.floor(47 * b.fireCDscale)) m.immuneCycle = m.cycle + Math.floor(47 * b.fireCDscale); //player is immune to damage for 30 cycles
                        spread = 1.3
                        knock = 0.1
                    }

                    if (tech.isShotgunReversed) {
                        player.force.x += 1.5 * knock * Math.cos(m.angle)
                        player.force.y += 1.5 * knock * Math.sin(m.angle) - 3 * player.mass * simulation.g
                    } else if (tech.isShotgunRecoil) {
                        m.fireCDcycle -= 0.66 * (56 * b.fireCDscale)
                        player.force.x -= 2 * knock * Math.cos(m.angle)
                        player.force.y -= 2 * knock * Math.sin(m.angle)
                    } else {
                        player.force.x -= knock * Math.cos(m.angle)
                        player.force.y -= knock * Math.sin(m.angle) * 0.5 //reduce knock back in vertical direction to stop super jumps
                    }
                }
                const spray = (num) => {
                    const side = 22
                    for (let i = 0; i < num; i++) {
                        const me = bullet.length;
                        const dir = m.angle + (Math.random() - 0.5) * spread
                        bullet[me] = Bodies.rectangle(m.pos.x, m.pos.y, side, side, b.fireAttributes(dir));
                        Composite.add(engine.world, bullet[me]); //add bullet to world
                        const SPEED = 52 + Math.random() * 8
                        Matter.Body.setVelocity(bullet[me], {
                            x: SPEED * Math.cos(dir),
                            y: SPEED * Math.sin(dir)
                        });
                        bullet[me].endCycle = simulation.cycle + 40 * tech.bulletsLastLonger
                        bullet[me].minDmgSpeed = 15
                        if (tech.isShotgunReversed) Matter.Body.setDensity(bullet[me], 0.0015)
                        // bullet[me].restitution = 0.4
                        bullet[me].frictionAir = 0.034;
                        bullet[me].do = function () {
                            const scale = 1 - 0.034 / tech.bulletsLastLonger
                            Matter.Body.scale(this, scale, scale);
                        };
                    }
                }
                const chooseBulletType = function () {
                    if (tech.isRivets) {
                        const me = bullet.length;
                        // const dir = m.angle + 0.02 * (Math.random() - 0.5)
                        bullet[me] = Bodies.rectangle(m.pos.x + 35 * Math.cos(m.angle), m.pos.y + 35 * Math.sin(m.angle), 56 * tech.bulletSize, 25 * tech.bulletSize, b.fireAttributes(m.angle));

                        Matter.Body.setDensity(bullet[me], 0.005 * (tech.isShotgunReversed ? 1.5 : 1));
                        Composite.add(engine.world, bullet[me]); //add bullet to world
                        const SPEED = (m.crouch ? 50 : 43)
                        Matter.Body.setVelocity(bullet[me], {
                            x: SPEED * Math.cos(m.angle),
                            y: SPEED * Math.sin(m.angle)
                        });
                        if (tech.isIncendiary) {
                            bullet[me].endCycle = simulation.cycle + 60
                            bullet[me].onEnd = function () {
                                b.explosion(this.position, 400 + (Math.random() - 0.5) * 60); //makes bullet do explosive damage at end
                            }
                            bullet[me].beforeDmg = function () {
                                this.endCycle = 0; //bullet ends cycle after hitting a mob and triggers explosion
                            };
                        } else {
                            bullet[me].endCycle = simulation.cycle + 180
                        }
                        bullet[me].minDmgSpeed = 7
                        // bullet[me].restitution = 0.4
                        bullet[me].frictionAir = 0.004;
                        bullet[me].turnMag = 0.04 * Math.pow(tech.bulletSize, 3.75)
                        bullet[me].do = function () {
                            this.force.y += this.mass * 0.002
                            if (this.speed > 6) { //rotates bullet to face current velocity?
                                const facing = {
                                    x: Math.cos(this.angle),
                                    y: Math.sin(this.angle)
                                }
                                if (Vector.cross(Vector.normalise(this.velocity), facing) < 0) {
                                    this.torque += this.turnMag
                                } else {
                                    this.torque -= this.turnMag
                                }
                            }
                            if (tech.isIncendiary && Matter.Query.collides(this, map).length) {
                                this.endCycle = 0; //bullet ends cycle after hitting a mob and triggers explosion
                            }
                        };
                        bullet[me].beforeDmg = function (who) {
                            if (this.speed > 4) {
                                if (tech.fragments) {
                                    b.targetedNail(this.position, 6 * tech.fragments * tech.bulletSize)
                                    this.endCycle = 0 //triggers despawn
                                }
                                if (tech.isIncendiary) this.endCycle = 0; //bullet ends cycle after hitting a mob and triggers explosion
                                if (tech.isCritKill) b.crit(who, this)
                            }
                        }
                        spray(12); //fires normal shotgun bullets
                    } else if (tech.isIncendiary) {
                        spread *= 0.15
                        const END = Math.floor(m.crouch ? 8 : 5);
                        const totalBullets = 9
                        const angleStep = (m.crouch ? 0.3 : 0.8) / totalBullets
                        let dir = m.angle - angleStep * totalBullets / 2;
                        for (let i = 0; i < totalBullets; i++) { //5 -> 7
                            dir += angleStep
                            const me = bullet.length;
                            bullet[me] = Bodies.rectangle(m.pos.x + 50 * Math.cos(m.angle), m.pos.y + 50 * Math.sin(m.angle), 17, 4, b.fireAttributes(dir));
                            const end = END + Math.random() * 4
                            bullet[me].endCycle = 2 * end * tech.bulletsLastLonger + simulation.cycle
                            const speed = 25 * end / END
                            const dirOff = dir + (Math.random() - 0.5) * spread
                            Matter.Body.setVelocity(bullet[me], {
                                x: speed * Math.cos(dirOff),
                                y: speed * Math.sin(dirOff)
                            });
                            bullet[me].onEnd = function () {
                                b.explosion(this.position, 180 * (tech.isShotgunReversed ? 1.4 : 1) + (Math.random() - 0.5) * 30); //makes bullet do explosive damage at end
                            }
                            bullet[me].beforeDmg = function () {
                                this.endCycle = 0; //bullet ends cycle after hitting a mob and triggers explosion
                            };
                            bullet[me].do = function () {
                                if (Matter.Query.collides(this, map).length) this.endCycle = 0; //bullet ends cycle after hitting a mob and triggers explosion
                            }
                            Composite.add(engine.world, bullet[me]); //add bullet to world
                        }
                    } else if (tech.isNailShot) {
                        spread *= 0.65
                        const dmg = 2 * (tech.isShotgunReversed ? 1.5 : 1)
                        if (m.crouch) {
                            for (let i = 0; i < 17; i++) {
                                speed = 38 + 15 * Math.random()
                                const dir = m.angle + (Math.random() - 0.5) * spread
                                const pos = {
                                    x: m.pos.x + 35 * Math.cos(m.angle) + 15 * (Math.random() - 0.5),
                                    y: m.pos.y + 35 * Math.sin(m.angle) + 15 * (Math.random() - 0.5)
                                }
                                b.nail(pos, {
                                    x: speed * Math.cos(dir),
                                    y: speed * Math.sin(dir)
                                }, dmg)
                            }
                        } else {
                            for (let i = 0; i < 17; i++) {
                                speed = 38 + 15 * Math.random()
                                const dir = m.angle + (Math.random() - 0.5) * spread
                                const pos = {
                                    x: m.pos.x + 35 * Math.cos(m.angle) + 15 * (Math.random() - 0.5),
                                    y: m.pos.y + 35 * Math.sin(m.angle) + 15 * (Math.random() - 0.5)
                                }
                                b.nail(pos, {
                                    x: speed * Math.cos(dir),
                                    y: speed * Math.sin(dir)
                                }, dmg)
                            }
                        }
                    } else if (tech.isSporeFlea) {
                        const where = {
                            x: m.pos.x + 35 * Math.cos(m.angle),
                            y: m.pos.y + 35 * Math.sin(m.angle)
                        }
                        const number = 2 * (tech.isShotgunReversed ? 1.5 : 1)
                        for (let i = 0; i < number; i++) {
                            const angle = m.angle + 0.2 * (Math.random() - 0.5)
                            const speed = (m.crouch ? 35 * (1 + 0.05 * Math.random()) : 30 * (1 + 0.15 * Math.random()))
                            b.flea(where, {
                                x: speed * Math.cos(angle),
                                y: speed * Math.sin(angle)
                            })
                            bullet[bullet.length - 1].setDamage()
                        }
                        spray(10); //fires normal shotgun bullets
                    } else if (tech.isSporeWorm) {
                        const where = {
                            x: m.pos.x + 35 * Math.cos(m.angle),
                            y: m.pos.y + 35 * Math.sin(m.angle)
                        }
                        const spread = (m.crouch ? 0.02 : 0.07)
                        const number = 3 * (tech.isShotgunReversed ? 1.5 : 1)
                        let angle = m.angle - (number - 1) * spread * 0.5
                        for (let i = 0; i < number; i++) {
                            b.worm(where)
                            const SPEED = (30 + 10 * m.crouch) * (1 + 0.2 * Math.random())
                            Matter.Body.setVelocity(bullet[bullet.length - 1], {
                                x: player.velocity.x * 0.5 + SPEED * Math.cos(angle),
                                y: player.velocity.y * 0.5 + SPEED * Math.sin(angle)
                            });
                            angle += spread
                        }
                        spray(7); //fires normal shotgun bullets
                    } else if (tech.isIceShot) {
                        const spread = (m.crouch ? 0.7 : 1.2)
                        for (let i = 0, len = 10 * (tech.isShotgunReversed ? 1.5 : 1); i < len; i++) {
                            b.iceIX(23 + 10 * Math.random(), m.angle + spread * (Math.random() - 0.5))
                        }
                        spray(10); //fires normal shotgun bullets
                    } else if (tech.isFoamShot) {
                        const spread = (m.crouch ? 0.15 : 0.4)
                        const where = {
                            x: m.pos.x + 25 * Math.cos(m.angle),
                            y: m.pos.y + 25 * Math.sin(m.angle)
                        }
                        const number = 16 * (tech.isShotgunReversed ? 1.5 : 1)
                        for (let i = 0; i < number; i++) {
                            const SPEED = 13 + 4 * Math.random();
                            const angle = m.angle + spread * (Math.random() - 0.5)
                            b.foam(where, {
                                x: 0.6 * player.velocity.x + SPEED * Math.cos(angle),
                                y: 0.5 * player.velocity.y + SPEED * Math.sin(angle)
                            }, 8 + 7 * Math.random())
                        }
                    } else if (tech.isNeedles) {
                        const number = 9 * (tech.isShotgunReversed ? 1.5 : 1)
                        const spread = (m.crouch ? 0.03 : 0.05)
                        let angle = m.angle - (number - 1) * spread * 0.5
                        for (let i = 0; i < number; i++) {
                            b.needle(angle)
                            angle += spread
                        }
                    } else {
                        spray(16); //fires normal shotgun bullets
                    }
                }


                coolDown();
                b.muzzleFlash(35);
                chooseBulletType();

                if (tech.shotgunExtraShots) {
                    const delay = 7
                    let count = tech.shotgunExtraShots * delay

                    function cycle() {
                        count--
                        if (!(count % delay)) {
                            coolDown();
                            b.muzzleFlash(35);
                            chooseBulletType();
                        }
                        if (count > 0) {
                            requestAnimationFrame(cycle);
                        }
                    }
                    requestAnimationFrame(cycle);
                }
            }
        }, {
            name: "super balls", //2
            descriptionFunction() {
                return `fire <strong>3</strong> balls that retain<br><strong>momentum</strong> and <strong>kinetic energy</strong> after <strong>collisions</strong><br><strong>${this.ammoPack.toFixed(0)}</strong> balls per ${powerUps.orb.ammo()}`
            },
            ammo: 0,
            ammoPack: 4.05,
            defaultAmmoPack: 4.05,
            have: false,
            // num: 5,
            do() { },
            foamBall() { },
            fireOne() {
                m.fireCDcycle = m.cycle + Math.floor((m.crouch ? 27 : 19) * b.fireCDscale); // cool down
                const speed = m.crouch ? 43 : 36
                b.superBall({
                    x: m.pos.x + 30 * Math.cos(m.angle),
                    y: m.pos.y + 30 * Math.sin(m.angle)
                }, {
                    x: speed * Math.cos(m.angle),
                    y: speed * Math.sin(m.angle)
                }, 21 * tech.bulletSize)
            },
            fireMulti() {
                m.fireCDcycle = m.cycle + Math.floor((m.crouch ? 23 : 15) * b.fireCDscale); // cool down
                const SPREAD = m.crouch ? 0.08 : 0.13
                const num = 3 + Math.floor(tech.extraSuperBalls * Math.random())
                const speed = m.crouch ? 43 : 36
                if (tech.isBulletTeleport) {
                    for (let i = 0; i < num; i++) {
                        b.superBall({
                            x: m.pos.x + 30 * Math.cos(m.angle),
                            y: m.pos.y + 30 * Math.sin(m.angle)
                        }, {
                            x: speed * Math.cos(m.angle),
                            y: speed * Math.sin(m.angle)
                        }, 11 * tech.bulletSize)
                    }
                } else {
                    let dir = m.angle - SPREAD * (num - 1) / 2;
                    for (let i = 0; i < num; i++) {
                        b.superBall({
                            x: m.pos.x + 30 * Math.cos(dir),
                            y: m.pos.y + 30 * Math.sin(dir)
                        }, {
                            x: speed * Math.cos(dir),
                            y: speed * Math.sin(dir)
                        }, 11 * tech.bulletSize)
                        dir += SPREAD;
                    }
                }
            },
            fireQueue() {
                m.fireCDcycle = m.cycle + Math.floor((m.crouch ? 23 : 15) * b.fireCDscale); // cool down
                const num = 2 + 3 + Math.floor(tech.extraSuperBalls * Math.random()) //2 extra 
                const speed = m.crouch ? 43 : 36

                const delay = Math.floor((m.crouch ? 18 : 12) * b.fireCDscale)
                m.fireCDcycle = m.cycle + delay; // cool down
                function cycle() {
                    count++
                    b.superBall({
                        x: m.pos.x + 30 * Math.cos(m.angle),
                        y: m.pos.y + 30 * Math.sin(m.angle)
                    }, {
                        x: speed * Math.cos(m.angle),
                        y: speed * Math.sin(m.angle)
                    }, 11 * tech.bulletSize)
                    if (count < num && m.alive) requestAnimationFrame(cycle);
                    m.fireCDcycle = m.cycle + delay; // cool down                  
                }
                let count = 0
                requestAnimationFrame(cycle);
            },
            chooseFireMethod() { //set in simulation.startGame
                if (tech.oneSuperBall) {
                    this.fire = this.fireOne
                } else if (tech.superBallDelay) {
                    this.fire = this.fireQueue
                } else {
                    this.fire = this.fireMulti
                }
            },
            fire() { }
        },
        {
            name: "wave", //3
            // description: `emit <strong>wave packets</strong> that propagate through <strong>solids</strong><br>waves <strong class='color-s'>slow</strong> mobs<br><strong>115</strong> packets per ${powerUps.orb.ammo()}`,
            descriptionFunction() {
                return `emit <strong>wave packets</strong> that propagate through <strong>solids</strong><br>waves <strong class='color-s'>slow</strong> mobs<br><strong>${this.ammoPack.toFixed(0)}</strong> wave packets per ${powerUps.orb.ammo()}`
            },
            ammo: 0,
            ammoPack: 60,
            defaultAmmoPack: 60,
            have: false,
            wavePacketCycle: 0,
            delay: 40,
            phononWaveCD: 0,
            waves: [], //used in longitudinal mode
            chooseFireMethod() { //set in simulation.startGame
                this.waves = [];
                if (tech.isLongitudinal) {
                    if (tech.is360Longitudinal) {
                        this.fire = this.fire360Longitudinal
                        this.do = this.do360Longitudinal
                    } else {
                        this.fire = this.fireLongitudinal
                        this.do = this.doLongitudinal
                    }
                } else {
                    this.fire = this.fireTransverse
                    this.do = this.doTransverse
                }
            },
            do() { },
            do360Longitudinal() {
                if (!m.isTimeDilated) {
                    ctx.strokeStyle = "rgba(0,0,0,0.6)" //"000";
                    ctx.lineWidth = 2 * tech.wavePacketDamage
                    ctx.beginPath();
                    const end = 700 * Math.sqrt(tech.bulletsLastLonger)
                    const damage = 2.3 * tech.wavePacketDamage * tech.waveBeamDamage * (tech.isBulletTeleport ? 1.43 : 1) * (tech.isInfiniteWaveAmmo ? 0.75 : 1) //damage is lower for large radius mobs, since they feel the waves longer

                    for (let i = this.waves.length - 1; i > -1; i--) {
                        //draw wave
                        ctx.moveTo(this.waves[i].position.x + this.waves[i].radius, this.waves[i].position.y)
                        ctx.arc(this.waves[i].position.x, this.waves[i].position.y, this.waves[i].radius, 0, 2 * Math.PI);
                        // collisions
                        // if (tech.isBulletTeleport && Math.random() < 0.04) {
                        //     const scale = 400 * Math.random()
                        //     this.waves[i].position = Vector.add(this.waves[i].position, { x: scale * (Math.random() - 0.5), y: scale * (Math.random() - 0.5) })
                        // }
                        for (let j = 0, len = mob.length; j < len; j++) {
                            if (!mob[j].isShielded) {
                                const dist = Vector.magnitude(Vector.sub(this.waves[i].position, mob[j].position))
                                const r = mob[j].radius + 30
                                if (dist + r > this.waves[i].radius && dist - r < this.waves[i].radius) {
                                    //make them shake around
                                    if (!mob[j].isBadTarget) {
                                        mob[j].force.x += 0.01 * (Math.random() - 0.5) * mob[j].mass
                                        mob[j].force.y += 0.01 * (Math.random() - 0.5) * mob[j].mass
                                    }
                                    // if (!mob[j].isShielded) {
                                    Matter.Body.setVelocity(mob[j], { //friction
                                        x: mob[j].velocity.x * 0.95,
                                        y: mob[j].velocity.y * 0.95
                                    });
                                    //draw vibes
                                    let vertices = mob[j].vertices;
                                    const vibe = 50 + mob[j].radius * 0.15
                                    ctx.moveTo(vertices[0].x + vibe * (Math.random() - 0.5), vertices[0].y + vibe * (Math.random() - 0.5));
                                    for (let k = 1; k < vertices.length; k++) {
                                        ctx.lineTo(vertices[k].x + vibe * (Math.random() - 0.5), vertices[k].y + vibe * (Math.random() - 0.5));
                                    }
                                    ctx.lineTo(vertices[0].x + vibe * (Math.random() - 0.5), vertices[0].y + vibe * (Math.random() - 0.5));
                                    //damage
                                    mob[j].locatePlayer();
                                    mob[j].damage(damage / Math.sqrt(mob[j].radius));
                                    // }
                                    if (tech.isPhononWave && this.phononWaveCD < m.cycle) {
                                        this.phononWaveCD = m.cycle + 8 * (1 + this.waves[i].resonanceCount)
                                        this.waves.push({
                                            position: mob[j].position,
                                            radius: 25,
                                            resonanceCount: this.waves[i].resonanceCount + 1,
                                        })
                                    }
                                }
                            }
                        }
                        // for (let j = 0, len = body.length; j < len; j++) {
                        for (let j = 0, len = Math.min(30, body.length); j < len; j++) {
                            const dist = Vector.magnitude(Vector.sub(this.waves[i].position, body[j].position))
                            const r = 20
                            if (dist + r > this.waves[i].radius && dist - r < this.waves[i].radius) {
                                const who = body[j]
                                //make them shake around
                                who.force.x += 0.01 * (Math.random() - 0.5) * who.mass
                                who.force.y += (0.01 * (Math.random() - 0.5) - simulation.g * 0.25) * who.mass //remove force of gravity
                                //draw vibes
                                let vertices = who.vertices;
                                const vibe = 25
                                ctx.moveTo(vertices[0].x + vibe * (Math.random() - 0.5), vertices[0].y + vibe * (Math.random() - 0.5));
                                for (let k = 1; k < vertices.length; k++) {
                                    ctx.lineTo(vertices[k].x + vibe * (Math.random() - 0.5), vertices[k].y + vibe * (Math.random() - 0.5));
                                }
                                ctx.lineTo(vertices[0].x + vibe * (Math.random() - 0.5), vertices[0].y + vibe * (Math.random() - 0.5));

                                if (tech.isPhononBlock && !who.isNotHoldable && who.speed < 5 && who.angularSpeed < 0.1) {
                                    if (Math.random() < 0.5) b.targetedBlock(who, 50 - Math.min(25, who.mass * 3)) //    targetedBlock(who, speed = 50 - Math.min(20, who.mass * 2), range = 1600) {
                                    // Matter.Body.setAngularVelocity(who, (0.25 + 0.1 * Math.random()) * (Math.random() < 0.5 ? -1 : 1));
                                    who.torque += who.inertia * 0.001 * (Math.random() - 0.5)
                                }
                            }
                        }
                        this.waves[i].radius += 0.9 * tech.waveBeamSpeed //expand / move
                        // if (this.waves[i].radius > end) this.waves.splice(i, 1) //end
                        if (this.waves[i].radius > end - 30 * this.waves[i].resonanceCount) { //* Math.pow(0.9, this.waves[i].resonanceCount)
                            this.waves.splice(i, 1) //end
                        }
                    }
                    ctx.stroke();
                }
            },
            fire360Longitudinal() {
                m.fireCDcycle = m.cycle + Math.floor((m.crouch ? 4 : 8) * b.fireCDscale); // cool down
                this.waves.push({
                    position: { x: m.pos.x, y: m.pos.y, },
                    radius: 25,
                    resonanceCount: 0 //used with tech.isPhononWave
                })
            },
            doLongitudinal() {
                if (!m.isTimeDilated) {
                    ctx.strokeStyle = "rgba(0,0,0,0.6)" //"000";
                    ctx.lineWidth = 2 * tech.wavePacketDamage
                    ctx.beginPath();
                    const end = 1100 * tech.bulletsLastLonger
                    const damage = 2.3 * tech.wavePacketDamage * tech.waveBeamDamage * (tech.isBulletTeleport ? 1.4 : 1) * (tech.isInfiniteWaveAmmo ? 0.75 : 1) //damage is lower for large radius mobs, since they feel the waves longer
                    for (let i = this.waves.length - 1; i > -1; i--) {
                        const v1 = Vector.add(this.waves[i].position, Vector.mult(this.waves[i].unit1, this.waves[i].radius))
                        const v2 = Vector.add(this.waves[i].position, Vector.mult(this.waves[i].unit2, this.waves[i].radius))
                        //draw wave
                        ctx.moveTo(v1.x, v1.y)
                        ctx.arc(this.waves[i].position.x, this.waves[i].position.y, this.waves[i].radius, this.waves[i].angle, this.waves[i].angle + this.waves[i].arc);
                        //using small angle linear approximation of circle arc, this will not work if the arc gets large   // https://stackoverflow.com/questions/13652518/efficiently-find-points-inside-a-circle-sector
                        let hits = Matter.Query.ray(mob, v1, v2, 50) //Matter.Query.ray(bodies, startPoint, endPoint, [rayWidth])
                        for (let j = 0; j < hits.length; j++) {
                            const who = hits[j].body
                            if (!who.isShielded) {
                                who.force.x += 0.01 * (Math.random() - 0.5) * who.mass
                                who.force.y += 0.01 * (Math.random() - 0.5) * who.mass
                                Matter.Body.setVelocity(who, { x: who.velocity.x * 0.95, y: who.velocity.y * 0.95 });
                                let vertices = who.vertices;
                                const vibe = 50 + who.radius * 0.15
                                ctx.moveTo(vertices[0].x + vibe * (Math.random() - 0.5), vertices[0].y + vibe * (Math.random() - 0.5));
                                for (let j = 1; j < vertices.length; j++) ctx.lineTo(vertices[j].x + vibe * (Math.random() - 0.5), vertices[j].y + vibe * (Math.random() - 0.5));
                                ctx.lineTo(vertices[0].x + vibe * (Math.random() - 0.5), vertices[0].y + vibe * (Math.random() - 0.5));
                                who.locatePlayer();
                                who.damage(damage / Math.sqrt(who.radius));

                                if (tech.isPhononWave && this.phononWaveCD < m.cycle) {
                                    this.phononWaveCD = m.cycle + 8 * (1 + this.waves[i].resonanceCount)
                                    const halfArc = 0.27 //6.28 is a full circle, but these arcs needs to stay small because we are using small angle linear approximation, for collisions
                                    let closestMob, dist
                                    let range = end - 30 * this.waves[i].resonanceCount
                                    for (let i = 0, len = mob.length; i < len; i++) {
                                        if (who !== mob[i] && !mob[i].isBadTarget && !mob[i].isInvulnerable) {
                                            dist = Vector.magnitude(Vector.sub(who.position, mob[i].position));
                                            if (dist < range) {
                                                closestMob = mob[i]
                                                range = dist
                                            }
                                        }
                                    }
                                    if (closestMob) {
                                        const dir = Vector.normalise(Vector.sub(closestMob.position, who.position))
                                        var angle = Math.atan2(dir.y, dir.x)
                                    } else {
                                        var angle = 2 * Math.PI * Math.random()
                                    }
                                    this.waves.push({
                                        position: who.position,
                                        angle: angle - halfArc, //used in drawing ctx.arc
                                        unit1: { x: Math.cos(angle - halfArc), y: Math.sin(angle - halfArc) }, //used for collision
                                        unit2: { x: Math.cos(angle + halfArc), y: Math.sin(angle + halfArc) }, //used for collision
                                        arc: halfArc * 2,
                                        radius: 25,
                                        resonanceCount: this.waves[i].resonanceCount + 1
                                    })
                                }
                            }
                        }

                        hits = Matter.Query.ray(body, v1, v2, 50) //Matter.Query.ray(bodies, startPoint, endPoint, [rayWidth])
                        for (let j = 0, len = Math.min(30, hits.length); j < len; j++) {
                            const who = hits[j].body
                            //make them shake around
                            who.force.x += 0.01 * (Math.random() - 0.5) * who.mass
                            who.force.y += (0.01 * (Math.random() - 0.5) - simulation.g * 0.25) * who.mass //remove force of gravity
                            let vertices = who.vertices;
                            const vibe = 25
                            ctx.moveTo(vertices[0].x + vibe * (Math.random() - 0.5), vertices[0].y + vibe * (Math.random() - 0.5));
                            for (let j = 1; j < vertices.length; j++) {
                                ctx.lineTo(vertices[j].x + vibe * (Math.random() - 0.5), vertices[j].y + vibe * (Math.random() - 0.5));
                            }
                            ctx.lineTo(vertices[0].x + vibe * (Math.random() - 0.5), vertices[0].y + vibe * (Math.random() - 0.5));

                            if (tech.isPhononBlock && !who.isNotHoldable && who.speed < 5 && who.angularSpeed < 0.1) {
                                if (Math.random() < 0.5) b.targetedBlock(who, 50 - Math.min(25, who.mass * 3)) //    targetedBlock(who, speed = 50 - Math.min(20, who.mass * 2), range = 1600) {
                                // Matter.Body.setAngularVelocity(who, (0.25 + 0.12 * Math.random()) * (Math.random() < 0.5 ? -1 : 1));
                                who.torque += who.inertia * 0.001 * (Math.random() - 0.5)
                            }
                        }

                        this.waves[i].radius += tech.waveBeamSpeed * 1.8 //expand / move
                        if (this.waves[i].radius > end - 30 * this.waves[i].resonanceCount) {
                            this.waves.splice(i, 1) //end
                        }
                    }
                    ctx.stroke();
                }
            },
            fireLongitudinal() {
                m.fireCDcycle = m.cycle + Math.floor((m.crouch ? 4 : 8) * b.fireCDscale); // cool down
                const halfArc = (m.crouch ? 0.0785 : 0.275) * (tech.isBulletTeleport ? 0.66 + (Math.random() - 0.5) : 1) //6.28 is a full circle, but these arcs needs to stay small because we are using small angle linear approximation, for collisions
                const angle = m.angle + tech.isBulletTeleport * 0.3 * (Math.random() - 0.5)
                this.waves.push({
                    position: { x: m.pos.x + 25 * Math.cos(m.angle), y: m.pos.y + 25 * Math.sin(m.angle), },
                    angle: angle - halfArc, //used in drawing ctx.arc
                    unit1: { x: Math.cos(angle - halfArc), y: Math.sin(angle - halfArc) }, //used for collision
                    unit2: { x: Math.cos(angle + halfArc), y: Math.sin(angle + halfArc) }, //used for collision
                    arc: halfArc * 2,
                    radius: 25,
                    resonanceCount: 0
                })
            },
            doTransverse() {
                // if (this.wavePacketCycle && !input.fire) {
                //     this.wavePacketCycle = 0;
                //     m.fireCDcycle = m.cycle + Math.floor(this.delay * b.fireCDscale); // cool down
                // }
            },
            fireTransverse() {
                totalCycles = Math.floor((3.5) * 35 * tech.waveReflections * tech.bulletsLastLonger / Math.sqrt(tech.waveReflections * 0.5))
                const me = bullet.length;
                bullet[me] = Bodies.polygon(m.pos.x + 25 * Math.cos(m.angle), m.pos.y + 25 * Math.sin(m.angle), 5, 4, {
                    angle: m.angle,
                    cycle: -0.5,
                    endCycle: simulation.cycle + totalCycles,
                    inertia: Infinity,
                    frictionAir: 0,
                    slow: 0,
                    // amplitude: (m.crouch ? 5 : 10) * ((this.wavePacketCycle % 2) ? -1 : 1) * Math.sin((this.wavePacketCycle + 1) * 0.088), //0.0968 //0.1012 //0.11 //0.088 //shorten wave packet
                    amplitude: (m.crouch ? 6 : 12) * ((this.wavePacketCycle % 2) ? -1 : 1) * Math.sin(this.wavePacketCycle * 0.088) * Math.sin(this.wavePacketCycle * 0.04), //0.0968 //0.1012 //0.11 //0.088 //shorten wave packet
                    minDmgSpeed: 0,
                    dmg: tech.waveBeamDamage * tech.wavePacketDamage * (tech.isBulletTeleport ? 1.43 : 1) * (tech.isInfiniteWaveAmmo ? 0.75 : 1), //also control damage when you divide by mob.mass 
                    dmgCoolDown: 0,
                    classType: "bullet",
                    collisionFilter: {
                        category: 0,
                        mask: 0, //cat.mob | cat.mobBullet | cat.mobShield
                    },
                    beforeDmg() { },
                    onEnd() { },
                    do() { },
                    query() {
                        let slowCheck = 1
                        if (Matter.Query.point(map, this.position).length) { //check if inside map                                    
                            slowCheck = waveSpeedMap
                        } else { //check if inside a body
                            let q = Matter.Query.point(body, this.position)
                            if (q.length) {
                                slowCheck = waveSpeedBody
                                Matter.Body.setPosition(this, Vector.add(this.position, q[0].velocity)) //move with the medium
                            }
                        }
                        if (slowCheck !== this.slow) { //toggle velocity based on inside and outside status change
                            this.slow = slowCheck
                            Matter.Body.setVelocity(this, Vector.mult(Vector.normalise(this.velocity), tech.waveBeamSpeed * slowCheck));
                        }

                        if (this.dmgCoolDown < 1) {
                            q = Matter.Query.point(mob, this.position) // check if inside a mob
                            for (let i = 0; i < q.length; i++) {
                                this.dmgCoolDown = 5 + Math.floor(8 * Math.random() * b.fireCDscale);
                                let dmg = this.dmg
                                q[i].damage(dmg);
                                if (q[i].alive) {
                                    q[i].foundPlayer();
                                    Matter.Body.setVelocity(q[i], Vector.mult(q[i].velocity, 0.9))
                                }
                                // this.endCycle = 0; //bullet ends cycle after doing damage
                                if (q[i].damageReduction) {
                                    simulation.drawList.push({ //add dmg to draw queue
                                        x: this.position.x,
                                        y: this.position.y,
                                        radius: Math.log(dmg + 1.1) * 40 * q[i].damageReduction + 3,
                                        color: 'rgba(0,0,0,0.4)',
                                        time: simulation.drawTime
                                    });
                                }
                            }
                        } else {
                            this.dmgCoolDown--
                        }
                    },
                    wiggle() {
                        this.cycle++
                        const where = Vector.mult(transverse, this.amplitude * Math.cos(this.cycle * tech.waveFrequency))
                        Matter.Body.setPosition(this, Vector.add(this.position, where))
                    }
                });
                if (tech.isBulletTeleport) {
                    bullet[me].wiggle = function () {
                        this.cycle++
                        const where = Vector.mult(transverse, this.amplitude * Math.cos(this.cycle * tech.waveFrequency))
                        if (Math.random() < 0.005) {
                            if (Math.random() < 0.33) { //randomize position
                                const scale = 500 * Math.random()
                                Matter.Body.setPosition(this, Vector.add({
                                    x: scale * (Math.random() - 0.5),
                                    y: scale * (Math.random() - 0.5)
                                }, Vector.add(this.position, where)))
                            } else { //randomize position in velocity direction
                                const velocityScale = Vector.mult(this.velocity, 50 * (Math.random() - 0.5))
                                Matter.Body.setPosition(this, Vector.add(velocityScale, Vector.add(this.position, where)))
                            }

                        } else {
                            Matter.Body.setPosition(this, Vector.add(this.position, where))
                        }
                    }
                }
                let waveSpeedMap = 0.13
                let waveSpeedBody = 0.3
                if (tech.isPhaseVelocity) {
                    waveSpeedMap = 3.5
                    waveSpeedBody = 2
                    bullet[me].dmg *= 1.5
                }
                if (tech.waveReflections) {
                    bullet[me].reflectCycle = totalCycles / tech.waveReflections //tech.waveLengthRange
                    bullet[me].do = function () {
                        this.query()
                        if (this.cycle > this.reflectCycle) {
                            this.reflectCycle += totalCycles / tech.waveReflections
                            Matter.Body.setVelocity(this, Vector.mult(this.velocity, -1));
                            // if (this.reflectCycle > tech.waveLengthRange * (1 + tech.waveReflections)) this.endCycle = 0;
                        }
                        this.wiggle()
                    }
                } else {
                    bullet[me].do = function () {
                        this.query()
                        this.wiggle();
                    }
                }
                Composite.add(engine.world, bullet[me]); //add bullet to world
                Matter.Body.setVelocity(bullet[me], {
                    x: tech.waveBeamSpeed * Math.cos(m.angle),
                    y: tech.waveBeamSpeed * Math.sin(m.angle)
                });
                const transverse = Vector.normalise(Vector.perp(bullet[me].velocity))
                this.wavePacketCycle++
            },
            fire() { }
        },
        {
            name: "missiles", //6
            // description: `launch <strong>homing</strong> missiles that target mobs<br>missiles <strong class='color-e'>explode</strong> on contact with mobs<br><strong>5</strong> missiles per ${powerUps.orb.ammo()}`,
            descriptionFunction() {
                return `launch <strong>homing</strong> missiles that target mobs<br>missiles <strong class='color-e'>explode</strong> on contact with mobs<br><strong>${this.ammoPack.toFixed(1)}</strong> missiles per ${powerUps.orb.ammo()}`
            },
            ammo: 0,
            ammoPack: 2.3,
            defaultAmmoPack: 2.3,
            have: false,
            fireCycle: 0,
            do() { },
            fire() {
                const countReduction = Math.pow(0.86, tech.missileCount)
                // if (m.crouch) {
                //     m.fireCDcycle = m.cycle + tech.missileFireCD * b.fireCDscale / countReduction; // cool down
                //     // for (let i = 0; i < tech.missileCount; i++) {
                //     //     b.missile(where, -Math.PI / 2 + 0.2 * (Math.random() - 0.5) * Math.sqrt(tech.missileCount), -2, Math.sqrt(countReduction))
                //     //     bullet[bullet.length - 1].force.x += 0.004 * countReduction * (i - (tech.missileCount - 1) / 2);
                //     // }

                //     if (tech.missileCount > 1) {
                //         for (let i = 0; i < tech.missileCount; i++) {
                //             setTimeout(() => {
                //                 const where = { x: m.pos.x, y: m.pos.y - 40 }
                //                 b.missile(where, -Math.PI / 2 + 0.2 * (Math.random() - 0.5) * Math.sqrt(tech.missileCount), -2, Math.sqrt(countReduction))
                //                 bullet[bullet.length - 1].force.x += 0.025 * countReduction * (i - (tech.missileCount - 1) / 2);
                //             }, 20 * tech.missileCount * Math.random());
                //         }
                //     } else {
                //         const where = {
                //             x: m.pos.x,
                //             y: m.pos.y - 40
                //         }
                //         b.missile(where, -Math.PI / 2 + 0.2 * (Math.random() - 0.5), -2)
                //     }
                // } else {
                m.fireCDcycle = m.cycle + tech.missileFireCD * b.fireCDscale / countReduction; // cool down
                const direction = { x: Math.cos(m.angle), y: Math.sin(m.angle) }
                // const where = {
                //     x: m.pos.x + 30 * direction.x,
                //     y: m.pos.y + 30 * direction.y
                // }
                if (tech.missileCount > 1) {
                    const push = Vector.mult(Vector.perp(direction), 0.2 * countReduction / Math.sqrt(tech.missileCount))
                    const sqrtCountReduction = Math.sqrt(countReduction)
                    // for (let i = 0; i < tech.missileCount; i++) {
                    //     setTimeout(() => {
                    //         if (m.crouch) {
                    //             b.missile(where, m.angle, 20, sqrtCountReduction)
                    //             // bullet[bullet.length - 1].force.x += 0.7 * push.x * (i - (tech.missileCount - 1) / 2);
                    //             // bullet[bullet.length - 1].force.y += 0.7 * push.y * (i - (tech.missileCount - 1) / 2);
                    //         } else {
                    //             b.missile(where, m.angle, -10, sqrtCountReduction)
                    //             bullet[bullet.length - 1].force.x += push.x * (i - (tech.missileCount - 1) / 2);
                    //             bullet[bullet.length - 1].force.y += 0.005 + push.y * (i - (tech.missileCount - 1) / 2);
                    //         }

                    //     }, 1 + i * 10 * tech.missileCount);
                    // }
                    const launchDelay = 4
                    let count = 0
                    const fireMissile = () => {
                        if (m.crouch) {
                            b.missile({ x: m.pos.x + 30 * direction.x, y: m.pos.y + 30 * direction.y }, m.angle, 20, sqrtCountReduction)
                            bullet[bullet.length - 1].force.x += 0.5 * push.x * (Math.random() - 0.5)
                            bullet[bullet.length - 1].force.y += 0.004 + 0.5 * push.y * (Math.random() - 0.5)
                        } else {
                            b.missile({ x: m.pos.x + 30 * direction.x, y: m.pos.y + 30 * direction.y }, m.angle, -15, sqrtCountReduction)
                            bullet[bullet.length - 1].force.x += push.x * (Math.random() - 0.5)
                            bullet[bullet.length - 1].force.y += 0.005 + push.y * (Math.random() - 0.5)
                        }
                    }
                    const cycle = () => {
                        if ((simulation.paused) && m.alive) {
                            requestAnimationFrame(cycle)
                        } else {
                            count++
                            if (!(count % launchDelay)) {
                                fireMissile()
                            }
                            if (count < tech.missileCount * launchDelay && m.alive) requestAnimationFrame(cycle);
                        }
                    }
                    requestAnimationFrame(cycle);
                } else {
                    if (m.crouch) {
                        b.missile({ x: m.pos.x + 40 * direction.x, y: m.pos.y + 40 * direction.y }, m.angle, 25)
                    } else {
                        b.missile({ x: m.pos.x + 40 * direction.x, y: m.pos.y + 40 * direction.y }, m.angle, -12)
                        bullet[bullet.length - 1].force.y += 0.04 * (Math.random() - 0.2)
                    }
                }
            }
        }, {
            name: "grenades", //5
            // description: `lob a single <strong>bouncy</strong> projectile<br><strong class='color-e'>explodes</strong> on <strong>contact</strong> or after one second<br><strong>7</strong> grenades per ${powerUps.orb.ammo()}`,
            descriptionFunction() {
                return `lob a single <strong>bouncy</strong> projectile<br><strong class='color-e'>explodes</strong> on <strong>contact</strong> or after <strong>1.5</strong> seconds<br><strong>${this.ammoPack.toFixed(0)}</strong> grenades per ${powerUps.orb.ammo()}`
            },
            ammo: 0,
            ammoPack: 3.2,
            defaultAmmoPack: 3.2,
            have: false,
            do() { }, //do is set in b.setGrenadeMode()
            fire() {
                const countReduction = Math.pow(0.93, tech.missileCount)
                m.fireCDcycle = m.cycle + Math.floor((m.crouch ? 35 : 27) * b.fireCDscale / countReduction); // cool down
                const where = {
                    x: m.pos.x + 30 * Math.cos(m.angle),
                    y: m.pos.y + 30 * Math.sin(m.angle)
                }
                const SPREAD = m.crouch ? 0.12 : 0.2
                let angle = m.angle - SPREAD * (tech.missileCount - 1) / 2;
                for (let i = 0; i < tech.missileCount; i++) {
                    b.grenade(where, angle, countReduction) //function(where = { x: m.pos.x + 30 * Math.cos(m.angle), y: m.pos.y + 30 * Math.sin(m.angle) }, angle = m.angle, size = 1)
                    angle += SPREAD
                }
            },
        }, {
            name: "spores", //6
            // description: `toss a <strong class='color-p' style='letter-spacing: 2px;'>sporangium</strong> that discharges <strong class='color-p' style='letter-spacing: 2px;'>spores</strong><br><strong class='color-p' style='letter-spacing: 2px;'>spores</strong> seek out nearby mobs<br><strong>2-3</strong> sporangium per ${powerUps.orb.ammo()}`,
            descriptionFunction() {
                return `toss a <strong class='color-p' style='letter-spacing: 2px;'>sporangium</strong> that discharges ${b.guns[6].nameString("s")}<br>${b.guns[6].nameString("s")} seek out nearby mobs<br><strong>${this.ammoPack.toFixed(1)}</strong> sporangium per ${powerUps.orb.ammo()}`
            },
            ammo: 0,
            ammoPack: 1.22,
            defaultAmmoPack: 1.22,
            have: false,
            nameString(suffix = "") {
                if (tech.isSporeFlea) {
                    return `<strong class='color-p' style='letter-spacing: -0.8px;'>flea${suffix}</strong>`
                } else if (tech.isSporeWorm) {
                    return `<strong class='color-p' style='letter-spacing: -0.8px;'>worm${suffix}</strong>`
                } else {
                    return `<strong class='color-p' style='letter-spacing: 2px;'>spore${suffix}</strong>`
                }
            },
            do() {
                if (!input.field && m.crouch) {
                    const cycles = 110
                    const speed = 24
                    const g = 0.0955 //get this from just testing
                    const v = {
                        x: speed * Math.cos(m.angle),
                        y: speed * Math.sin(m.angle)
                    }
                    ctx.strokeStyle = "rgba(68, 68, 68, 0.2)" //color.map
                    ctx.lineWidth = 2
                    ctx.beginPath()
                    for (let i = 0.5, len = 15; i < len + 1; i++) {
                        const time = cycles * i / len
                        ctx.lineTo(m.pos.x + time * v.x, m.pos.y + time * v.y + g * time * time)
                    }
                    ctx.stroke()
                }
            },
            fire() {
                const me = bullet.length;
                const dir = m.angle;
                bullet[me] = Bodies.polygon(m.pos.x + 30 * Math.cos(m.angle), m.pos.y + 30 * Math.sin(m.angle), 20, 4.5, b.fireAttributes(dir, false));
                b.fireProps(m.crouch ? 40 : 20, m.crouch ? 24 : 18, dir, me); //cd , speed
                Matter.Body.setDensity(bullet[me], 0.000001);
                bullet[me].endCycle = simulation.cycle + 480 + Math.max(0, 120 - 2 * bullet.length);
                bullet[me].frictionAir = 0;
                bullet[me].friction = 0.5;
                bullet[me].radius = 4.5;
                bullet[me].maxRadius = 30;
                bullet[me].restitution = 0.3;
                bullet[me].minDmgSpeed = 0;
                bullet[me].totalSpores = 8 + 2 * tech.isSporeFreeze + 5 * tech.isSporeColony
                bullet[me].stuck = function () { };
                bullet[me].beforeDmg = function () { };
                bullet[me].do = function () {
                    function onCollide(that) {
                        that.collisionFilter.mask = 0; //non collide with everything
                        Matter.Body.setVelocity(that, { x: 0, y: 0 });
                        that.do = that.grow;
                    }
                    const mobCollisions = Matter.Query.collides(this, mob)
                    if (mobCollisions.length) {
                        onCollide(this)
                        this.stuckTo = mobCollisions[0].bodyA
                        if (tech.isZombieMobs) this.stuckTo.isSoonZombie = true
                        if (this.stuckTo.isVerticesChange) {
                            this.stuckToRelativePosition = { x: 0, y: 0 }
                        } else {
                            //find the relative position for when the mob is at angle zero by undoing the mobs rotation
                            this.stuckToRelativePosition = Vector.rotate(Vector.sub(this.position, this.stuckTo.position), -this.stuckTo.angle)
                        }
                        this.stuck = function () {
                            if (this.stuckTo && this.stuckTo.alive) {
                                const rotate = Vector.rotate(this.stuckToRelativePosition, this.stuckTo.angle) //add in the mob's new angle to the relative position vector
                                Matter.Body.setPosition(this, Vector.add(Vector.add(rotate, this.stuckTo.velocity), this.stuckTo.position))
                                Matter.Body.setVelocity(this, this.stuckTo.velocity); //so that it will move properly if it gets unstuck
                            } else {
                                this.collisionFilter.mask = cat.map; //non collide with everything but map
                                this.stuck = function () {
                                    this.force.y += this.mass * 0.0006;
                                }
                            }
                        }
                    } else {
                        const bodyCollisions = Matter.Query.collides(this, body)
                        if (bodyCollisions.length) {
                            if (!bodyCollisions[0].bodyA.isNonStick) {
                                onCollide(this)
                                this.stuckTo = bodyCollisions[0].bodyA
                                //find the relative position for when the mob is at angle zero by undoing the mobs rotation
                                this.stuckToRelativePosition = Vector.rotate(Vector.sub(this.position, this.stuckTo.position), -this.stuckTo.angle)
                            } else {
                                this.do = this.grow;
                            }
                            this.stuck = function () {
                                if (this.stuckTo) {
                                    const rotate = Vector.rotate(this.stuckToRelativePosition, this.stuckTo.angle) //add in the mob's new angle to the relative position vector
                                    Matter.Body.setPosition(this, Vector.add(Vector.add(rotate, this.stuckTo.velocity), this.stuckTo.position))
                                    // Matter.Body.setVelocity(this, this.stuckTo.velocity); //so that it will move properly if it gets unstuck
                                } else {
                                    this.force.y += this.mass * 0.0007;
                                }
                            }
                        } else {
                            if (Matter.Query.collides(this, map).length) {
                                onCollide(this)
                            } else { //if colliding with nothing just fall
                                this.force.y += this.mass * 0.0007;
                                simulation.mouseInGame.x
                            }
                        }
                    }
                    //draw green glow
                    ctx.fillStyle = "rgba(0,200,125,0.16)";
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.maxRadius, 0, 2 * Math.PI);
                    ctx.fill();
                }
                bullet[me].grow = function () {
                    this.stuck(); //runs different code based on what the bullet is stuck to
                    let scale = 1.01
                    if (tech.isSporeGrowth && !(simulation.cycle % 40)) { //release a spore
                        if (tech.isSporeFlea) {
                            if (!(simulation.cycle % 80)) {
                                const speed = 10 + 5 * Math.random()
                                const angle = 2 * Math.PI * Math.random()
                                b.flea(this.position, {
                                    x: speed * Math.cos(angle),
                                    y: speed * Math.sin(angle)
                                })
                            }
                        } else if (tech.isSporeWorm) {
                            if (!(simulation.cycle % 80)) b.worm(this.position)
                        } else {
                            b.spore(this.position)
                        }
                        scale = 0.96
                        if (this.stuckTo && this.stuckTo.alive) scale = 0.9
                        Matter.Body.scale(this, scale, scale);
                        this.radius *= scale
                    } else {
                        if (this.stuckTo && this.stuckTo.alive) scale = 1.03
                        Matter.Body.scale(this, scale, scale);
                        this.radius *= scale
                        if (this.radius > this.maxRadius) this.endCycle = 0;
                    }
                    //draw green glow
                    ctx.fillStyle = "rgba(0,200,125,0.16)";
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.maxRadius, 0, 2 * Math.PI);
                    ctx.fill();
                };
                //spawn bullets on end
                bullet[me].onEnd = function () {
                    let count = 0 //used in for loop below
                    const things = [
                        () => { //spore
                            b.spore(this.position)
                        },
                        () => { //worm
                            count++ //count as 2 things
                            b.worm(this.position)
                        },
                        () => { //flea
                            count++ //count as 2 things
                            const speed = 10 + 5 * Math.random()
                            const angle = 2 * Math.PI * Math.random()
                            b.flea(this.position, {
                                x: speed * Math.cos(angle),
                                y: speed * Math.sin(angle)
                            })
                        },
                        () => { // drones
                            b.drone(this.position)
                        },
                        () => { // ice IX
                            b.iceIX(1, Math.random() * 2 * Math.PI, this.position)
                        },
                        () => { //missile
                            count++ //count as 2 things
                            b.missile(this.position, -Math.PI / 2 + 0.5 * (Math.random() - 0.5), 0, 1)
                        },
                        () => { //nail
                            b.targetedNail(this.position, 1, 39 + 6 * Math.random())
                        },
                        () => { //super ball
                            const speed = 36
                            const angle = 2 * Math.PI * Math.random()
                            b.superBall(this.position, {
                                x: speed * Math.cos(angle),
                                y: speed * Math.sin(angle)
                            }, 11 * tech.bulletSize)
                        },
                    ]

                    for (len = this.totalSpores; count < len; count++) {
                        if (tech.isSporeColony && Math.random() < 0.33) {
                            things[Math.floor(Math.random() * things.length)]()
                        } else if (tech.isSporeFlea) {
                            things[2]()
                        } else if (tech.isSporeWorm) {
                            things[1]()
                        } else {
                            things[0]() //spores
                        }
                    }
                    // } else if (tech.isSporeFlea) {
                    //     for (let i = 0, len = this.totalSpores; i < len; i++) things[2]()
                    // } else if (tech.isSporeWorm) {
                    //     for (let i = 0, len = this.totalSpores; i < len; i++) things[1]()
                    // } else {
                    //     for (let i = 0; i < this.totalSpores; i++) things[0]()
                    // }
                    if (tech.isStun) b.AoEStunEffect(this.position, 600, 270 + 120 * Math.random()); //AoEStunEffect(where, range, cycles = 120 + 60 * Math.random()) {
                }
            }
        }, {
            name: "drones", //7
            descriptionFunction() {
                return `deploy <strong>autonomous</strong> <strong>drones</strong> that smash into mobs<br>drones <strong>collect</strong> nearby power ups<br><strong>${this.ammoPack.toFixed(0)}</strong> drones per ${powerUps.orb.ammo()}`
            },
            ammo: 0,
            ammoPack: 7.8,
            defaultAmmoPack: 7.8,
            have: false,
            do() { },
            fire() {
                if (tech.isDroneRadioactive) {
                    if (m.crouch) {
                        b.droneRadioactive({
                            x: m.pos.x + 30 * Math.cos(m.angle) + 10 * (Math.random() - 0.5),
                            y: m.pos.y + 30 * Math.sin(m.angle) + 10 * (Math.random() - 0.5)
                        }, 45)
                        m.fireCDcycle = m.cycle + Math.floor(45 * b.fireCDscale); // cool down
                    } else {
                        b.droneRadioactive({
                            x: m.pos.x + 30 * Math.cos(m.angle) + 10 * (Math.random() - 0.5),
                            y: m.pos.y + 30 * Math.sin(m.angle) + 10 * (Math.random() - 0.5)
                        }, 10)
                        m.fireCDcycle = m.cycle + Math.floor(25 * b.fireCDscale); // cool down
                    }
                } else {
                    if (m.crouch) {
                        b.drone({
                            x: m.pos.x + 30 * Math.cos(m.angle) + 5 * (Math.random() - 0.5),
                            y: m.pos.y + 30 * Math.sin(m.angle) + 5 * (Math.random() - 0.5)
                        }, 50)
                        m.fireCDcycle = m.cycle + Math.floor(4 * b.fireCDscale); // cool down
                    } else {
                        b.drone({
                            x: m.pos.x + 30 * Math.cos(m.angle) + 10 * (Math.random() - 0.5),
                            y: m.pos.y + 30 * Math.sin(m.angle) + 10 * (Math.random() - 0.5)
                        }, 15)
                        m.fireCDcycle = m.cycle + Math.floor(3 * b.fireCDscale); // cool down
                    }
                }
            }
        },
        {
            name: "foam", //8
            descriptionFunction() {
                return `spray bubbly <strong>foam</strong> that <strong>sticks</strong> to mobs<br><strong class='color-s'>slows</strong> mobs and does <strong class='color-d'>damage</strong> over time<br><strong>${this.ammoPack.toFixed(0)}</strong> bubbles per ${powerUps.orb.ammo()}`
            },
            ammo: 0,
            ammoPack: 12.6,
            defaultAmmoPack: 12.6,
            have: false,
            charge: 0,
            isDischarge: false,
            knockBack: 0.0005, //set in tech: cavitation
            applyKnock(velocity) {
                player.force.x -= 0.7 * this.knockBack * velocity.x
                if (velocity.y > 0) {
                    player.force.y -= 4.3 * this.knockBack * velocity.y
                } else {
                    player.force.y -= this.knockBack * velocity.y
                }
            },
            chooseFireMethod() {
                if (tech.isFoamPressure) {
                    this.do = this.doCharges
                    this.fire = this.fireCharges
                } else {
                    this.do = this.doStream
                    this.fire = this.fireStream
                }
            },
            doStream() { },
            fireStream() {
                const spread = (m.crouch ?
                    0.04 * (Math.random() - 0.5) + 0.09 * Math.sin(m.cycle * 0.12) :
                    0.23 * (Math.random() - 0.5) + 0.15 * Math.sin(m.cycle * 0.12)
                )
                const radius = 5 + 8 * Math.random() + (tech.isAmmoFoamSize && this.ammo < 300) * 12
                const SPEED = (m.crouch ? 1.2 : 1) * Math.max(2, 14 - radius * 0.25)
                const dir = m.angle + 0.15 * (Math.random() - 0.5)
                const velocity = {
                    x: 0.7 * player.velocity.x + SPEED * Math.cos(dir),
                    y: 0.5 * player.velocity.y + SPEED * Math.sin(dir)
                }
                const position = { x: m.pos.x + 30 * Math.cos(m.angle), y: m.pos.y + 30 * Math.sin(m.angle) }
                b.foam(position, Vector.rotate(velocity, spread), radius)
                this.applyKnock(velocity)
                m.fireCDcycle = m.cycle + Math.floor(1.5 * b.fireCDscale);
            },
            doCharges() {
                if (this.charge > 0) {
                    //draw charge level
                    ctx.fillStyle = "rgba(0,50,50,0.3)";
                    ctx.beginPath();
                    const radius = 5 * Math.sqrt(this.charge)
                    const mag = 11 + radius
                    ctx.arc(m.pos.x + mag * Math.cos(m.angle), m.pos.y + mag * Math.sin(m.angle), radius, 0, 2 * Math.PI);
                    ctx.fill();

                    if (this.isDischarge && m.cycle % 2) {
                        const spread = (m.crouch ? 0.04 : 0.5) * (Math.random() - 0.5)
                        const radius = 5 + 8 * Math.random() + (tech.isAmmoFoamSize && this.ammo < 300) * 12
                        const SPEED = (m.crouch ? 1.2 : 1) * 10 - radius * 0.4 + Math.min(5, Math.sqrt(this.charge));
                        const dir = m.angle + 0.15 * (Math.random() - 0.5)
                        const velocity = {
                            x: 0.7 * player.velocity.x + SPEED * Math.cos(dir),
                            y: 0.5 * player.velocity.y + SPEED * Math.sin(dir)
                        }
                        const position = {
                            x: m.pos.x + 30 * Math.cos(m.angle),
                            y: m.pos.y + 30 * Math.sin(m.angle)
                        }
                        b.foam(position, Vector.rotate(velocity, spread), radius)
                        this.applyKnock(velocity)
                        this.charge -= 0.75
                        m.fireCDcycle = m.cycle + 2; //disable firing and adding more charge until empty
                    } else if (!input.fire) {
                        this.isDischarge = true;
                    }
                } else {
                    if (this.isDischarge) {
                        m.fireCDcycle = m.cycle + Math.floor(25 * b.fireCDscale);
                    }
                    this.isDischarge = false
                }
            },
            fireCharges() {
                const spread = (m.crouch ?
                    0.04 * (Math.random() - 0.5) + 0.09 * Math.sin(m.cycle * 0.12) :
                    0.23 * (Math.random() - 0.5) + 0.15 * Math.sin(m.cycle * 0.12)
                )
                const radius = 5 + 8 * Math.random() + (tech.isAmmoFoamSize && this.ammo < 300) * 12
                const SPEED = (m.crouch ? 1.2 : 1) * Math.max(2, 14 - radius * 0.25)
                const dir = m.angle + 0.15 * (Math.random() - 0.5)
                const velocity = {
                    x: 0.7 * player.velocity.x + SPEED * Math.cos(dir),
                    y: 0.5 * player.velocity.y + SPEED * Math.sin(dir)
                }
                const position = { x: m.pos.x + 30 * Math.cos(m.angle), y: m.pos.y + 30 * Math.sin(m.angle) }

                b.foam(position, Vector.rotate(velocity, spread), radius)
                this.applyKnock(velocity)
                m.fireCDcycle = m.cycle + Math.floor(1.5 * b.fireCDscale);
                this.charge += 1 + tech.isCapacitor
            },
            fire() { },
            do() { },
        },
        {
            name: "harpoon", //9
            // description: `throw a <strong>self-steering</strong> harpoon that uses <strong class='color-f'>energy</strong><br>to <strong>retract</strong> and refund its <strong class='color-ammo'>ammo</strong> cost<br><strong>1-2</strong> harpoons per ${powerUps.orb.ammo()}`,
            descriptionFunction() {
                return `throw a <strong>harpoon</strong> that uses <strong class='color-f'>energy</strong> to <strong>retract</strong><br><strong>harpoons</strong> refund <strong class='color-ammo'>ammo</strong><br><strong>${this.ammoPack.toFixed(1)}</strong> harpoons per ${powerUps.orb.ammo()}`
            },
            harpoonName() {
                return "<strong>" + (tech.isMaul ? "maul" : (tech.isRebar ? "rebar" : "harpoon")) + "</strong>"
            },
            ammo: 0,
            ammoPack: 0.77, //update this in railgun tech
            defaultAmmoPack: 0.77,
            have: false,
            fire() { },
            do() { },
            chooseFireMethod() {
                if (tech.isRailGun) {
                    this.do = this.railDo
                    this.fire = this.railFire
                    // } else if (tech.isGrapple) {
                    //     this.do = () => { }
                    //     this.fire = this.grappleFire
                } else {
                    this.do = () => { }
                    this.fire = this.harpoonFire
                }
            },
            charge: 0,
            railDo() {
                if (this.charge > 0) {
                    const DRAIN = (tech.isRailEnergy ? 0 : 0.002)
                    //exit railgun charging without firing
                    if (m.energy < DRAIN) {
                        m.fireCDcycle = m.cycle + 120; // cool down if out of energy
                        this.endCycle = 0;
                        this.charge = 0
                        b.refundAmmo()
                        return
                    }
                    //fire
                    if ((!input.fire && this.charge > 0.6)) {
                        const where = {
                            x: m.pos.x + 30 * Math.cos(m.angle),
                            y: m.pos.y + 30 * Math.sin(m.angle)
                        }
                        const closest = {
                            distance: 10000,
                            target: null
                        }
                        //push away blocks and mobs
                        const range = 600 + 500 * this.charge
                        for (let i = 0, len = mob.length; i < len; ++i) { //push away mobs when firing
                            if (!mob[i].isUnblockable) {
                                const SUB = Vector.sub(mob[i].position, m.pos)
                                const DISTANCE = Vector.magnitude(SUB)
                                if (DISTANCE < range + mob[i].radius) {
                                    const DEPTH = 100 + Math.min(range - DISTANCE + mob[i].radius, 1500)
                                    const FORCE = Vector.mult(Vector.normalise(SUB), 0.0015 * Math.sqrt(DEPTH) * mob[i].mass)
                                    mob[i].force.x += FORCE.x;
                                    mob[i].force.y += FORCE.y;

                                    let dmg = (mob[i].isDropPowerUp ? 350 : 1100) * tech.harpoonDensity * this.charge
                                    simulation.drawList.push({ //add dmg to draw queue
                                        x: mob[i].position.x,
                                        y: mob[i].position.y,
                                        radius: Math.log(dmg + 1.1) * 40 * mob[i].damageReduction + 3,
                                        color: 'rgba(100, 0, 200, 0.4)',
                                        time: 15
                                    });
                                    mob[i].damage(dmg);
                                }
                            }
                        }
                        for (let i = 0, len = body.length; i < len; ++i) { //push away blocks when firing
                            const SUB = Vector.sub(body[i].position, m.pos)
                            const DISTANCE = Vector.magnitude(SUB)
                            if (DISTANCE < range) {
                                const DEPTH = Math.min(range - DISTANCE, 500)
                                const FORCE = Vector.mult(Vector.normalise(SUB), 0.003 * Math.sqrt(DEPTH) * body[i].mass)
                                body[i].force.x += FORCE.x;
                                body[i].force.y += FORCE.y - body[i].mass * simulation.g * 1.5; //kick up a bit to give them some arc
                            }
                        }
                        for (let i = 0, len = powerUp.length; i < len; ++i) { //push away blocks when firing
                            const SUB = Vector.sub(powerUp[i].position, m.pos)
                            const DISTANCE = Vector.magnitude(SUB)
                            if (DISTANCE < range) {
                                const DEPTH = Math.min(range - DISTANCE, 500)
                                const FORCE = Vector.mult(Vector.normalise(SUB), 0.002 * Math.sqrt(DEPTH) * powerUp[i].mass)
                                powerUp[i].force.x += FORCE.x;
                                powerUp[i].force.y += FORCE.y - powerUp[i].mass * simulation.g * 1.5; //kick up a bit to give them some arc
                            }
                        }
                        //draw little dots near the edge of range
                        for (let i = 0, len = 10 + 25 * this.charge; i < len; i++) {
                            const unit = Vector.rotate({
                                x: 1,
                                y: 0
                            }, 6.28 * Math.random())
                            const where = Vector.add(m.pos, Vector.mult(unit, range * (0.6 + 0.3 * Math.random())))
                            simulation.drawList.push({
                                x: where.x,
                                y: where.y,
                                radius: 5 + 12 * Math.random(),
                                color: "rgba(100, 0, 200, 0.1)",
                                time: Math.floor(5 + 35 * Math.random())
                            });
                        }

                        const recoil = Vector.mult(Vector.normalise(Vector.sub(where, m.pos)), m.crouch ? 0.03 : 0.06)
                        player.force.x -= recoil.x
                        player.force.y -= recoil.y
                        const harpoonSize = tech.isLargeHarpoon ? 1 + 0.07 * Math.sqrt(this.ammo) : 1
                        const thrust = 0.15 * (this.charge)
                        if (tech.extraHarpoons) {
                            let targetCount = 0
                            const SPREAD = 0.06 + 0.05 * (!m.crouch)
                            let angle = m.angle - SPREAD * tech.extraHarpoons / 2;
                            const dir = {
                                x: Math.cos(angle),
                                y: Math.sin(angle)
                            }; //make a vector for the player's direction of length 1; used in dot product

                            for (let i = 0, len = mob.length; i < len; ++i) {
                                if (mob[i].alive && !mob[i].isBadTarget && !mob[i].shield && Matter.Query.ray(map, m.pos, mob[i].position).length === 0 && !mob[i].isInvulnerable) {
                                    const dot = Vector.dot(dir, Vector.normalise(Vector.sub(mob[i].position, m.pos))) //the dot product of diff and dir will return how much over lap between the vectors
                                    const dist = Vector.magnitude(Vector.sub(where, mob[i].position))
                                    if (dot > 0.95 - Math.min(dist * 0.00015, 0.3)) { //lower dot product threshold for targeting then if you only have one harpoon //target closest mob that player is looking at and isn't too close to target
                                        // if (this.ammo > -1) {
                                        //     this.ammo--
                                        b.harpoon(where, m.crouch ? null : mob[i], angle, harpoonSize, false, 35, false, thrust) //harpoon(where, target, angle = m.angle, harpoonSize = 1, isReturn = false, totalCycles = 35, isReturnAmmo = true, thrust = 0.1) {
                                        angle += SPREAD
                                        targetCount++
                                        if (targetCount > tech.extraHarpoons) break
                                        // }
                                    }
                                }
                            }
                            //if more harpoons and no targets left
                            if (targetCount < tech.extraHarpoons + 1) {
                                const num = tech.extraHarpoons + 1 - targetCount
                                for (let i = 0; i < num; i++) {
                                    b.harpoon(where, null, angle, harpoonSize, false, 35, false, thrust)
                                    angle += SPREAD
                                }
                            }
                            simulation.updateGunHUD();
                        } else {
                            //look for closest mob in player's LoS
                            const dir = {
                                x: Math.cos(m.angle),
                                y: Math.sin(m.angle)
                            }; //make a vector for the player's direction of length 1; used in dot product
                            for (let i = 0, len = mob.length; i < len; ++i) {
                                if (mob[i].alive && !mob[i].isBadTarget && Matter.Query.ray(map, m.pos, mob[i].position).length === 0 && !mob[i].isInvulnerable) {
                                    const dot = Vector.dot(dir, Vector.normalise(Vector.sub(mob[i].position, m.pos))) //the dot product of diff and dir will return how much over lap between the vectors
                                    const dist = Vector.magnitude(Vector.sub(where, mob[i].position))
                                    if (dist < closest.distance && dot > 0.98 - Math.min(dist * 0.00014, 0.3)) { //target closest mob that player is looking at and isn't too close to target
                                        closest.distance = dist
                                        closest.target = mob[i]
                                    }
                                }
                            }
                            b.harpoon(where, closest.target, m.angle, harpoonSize, false, 35, false, thrust)
                        }

                        this.charge = 0;
                    } else { //charging
                        if (tech.isFireMoveLock) {
                            Matter.Body.setVelocity(player, {
                                x: 0,
                                y: -55 * player.mass * simulation.g //undo gravity before it is added
                            });
                            player.force.x = 0
                            player.force.y = 0
                        }
                        m.fireCDcycle = m.cycle + 10 //can't fire until mouse is released
                        // const previousCharge = this.charge

                        //small b.fireCDscale = faster shots, b.fireCDscale=1 = normal shot,  big b.fireCDscale = slower chot
                        // let smoothRate = tech.isCapacitor ? 0.85 : Math.min(0.998, 0.985 * (0.98 + 0.02 * b.fireCDscale))
                        const rate = Math.sqrt(b.fireCDscale) * tech.railChargeRate * (tech.isCapacitor ? 0.6 : 1) * (m.crouch ? 0.8 : 1)
                        let smoothRate = Math.min(0.998, 0.94 + 0.05 * rate)


                        this.charge = 1 - smoothRate + this.charge * smoothRate
                        if (m.energy > DRAIN) m.energy -= DRAIN

                        //draw magnetic field
                        const X = m.pos.x
                        const Y = m.pos.y
                        const unitVector = {
                            x: Math.cos(m.angle),
                            y: Math.sin(m.angle)
                        }
                        const unitVectorPerp = Vector.perp(unitVector)

                        function magField(mag, arc) {
                            ctx.moveTo(X, Y);
                            ctx.bezierCurveTo(
                                X + unitVector.x * mag, Y + unitVector.y * mag,
                                X + unitVector.x * mag + unitVectorPerp.x * arc, Y + unitVector.y * mag + unitVectorPerp.y * arc,
                                X + unitVectorPerp.x * arc, Y + unitVectorPerp.y * arc)
                            ctx.bezierCurveTo(
                                X - unitVector.x * mag + unitVectorPerp.x * arc, Y - unitVector.y * mag + unitVectorPerp.y * arc,
                                X - unitVector.x * mag, Y - unitVector.y * mag,
                                X, Y)
                        }
                        ctx.fillStyle = `rgba(50,0,100,0.05)`;
                        const magSize = 8 * this.charge * tech.railChargeRate ** 3
                        const arcSize = 6 * this.charge * tech.railChargeRate ** 3
                        for (let i = 3; i < 7; i++) {
                            const MAG = magSize * i * i * (0.93 + 0.07 * Math.random())
                            const ARC = arcSize * i * i * (0.93 + 0.07 * Math.random())
                            ctx.beginPath();
                            magField(MAG, ARC)
                            magField(MAG, -ARC)
                            ctx.fill();
                        }
                    }
                }
            },
            railFire() {
                m.fireCDcycle = m.cycle + 10 //can't fire until mouse is released
                this.charge += 0.00001
            },
            harpoonFire() {
                const where = {
                    x: m.pos.x + 30 * Math.cos(m.angle),
                    y: m.pos.y + 30 * Math.sin(m.angle)
                }
                const closest = {
                    distance: 10000,
                    target: null
                }
                //look for closest mob in player's LoS
                const harpoonSize = (tech.isLargeHarpoon ? 1 + 0.1 * Math.sqrt(this.ammo) : 1) //* (m.crouch ? 0.7 : 1)
                const totalCycles = 6.5 * (tech.isFilament ? 1 + 0.013 * Math.min(110, this.ammo) : 1) * Math.sqrt(harpoonSize)

                if (tech.extraHarpoons && !m.crouch) { //multiple harpoons
                    const SPREAD = 0.2
                    let angle = m.angle - SPREAD * tech.extraHarpoons / 2;
                    const dir = { x: Math.cos(angle), y: Math.sin(angle) }; //make a vector for the player's direction of length 1; used in dot product
                    const range = 450 * (tech.isFilament ? 1 + 0.012 * Math.min(110, this.ammo) : 1)
                    let targetCount = 0
                    for (let i = 0, len = mob.length; i < len; ++i) {
                        if (mob[i].alive && !mob[i].isBadTarget && !mob[i].shield && Matter.Query.ray(map, m.pos, mob[i].position).length === 0 && !mob[i].isInvulnerable) {
                            const dot = Vector.dot(dir, Vector.normalise(Vector.sub(mob[i].position, m.pos))) //the dot product of diff and dir will return how much over lap between the vectors
                            const dist = Vector.magnitude(Vector.sub(where, mob[i].position))
                            if (dist < range && dot > 0.9) { //lower dot product threshold for targeting then if you only have one harpoon //target closest mob that player is looking at and isn't too close to target
                                if (this.ammo > 0) {
                                    this.ammo--
                                    b.harpoon(where, mob[i], angle, harpoonSize, true, totalCycles) //Vector.angle(Vector.sub(where, mob[i].position), { x: 0, y: 0 })
                                    angle += SPREAD
                                    targetCount++
                                    if (targetCount > tech.extraHarpoons) break
                                }
                            }
                        }
                    }
                    //if more harpoons and no targets left
                    if (targetCount < tech.extraHarpoons + 1) {
                        const num = tech.extraHarpoons - targetCount
                        const delay = 1 //Math.floor(Math.max(4, 8 - 0.5 * tech.extraHarpoons))
                        let angle = m.angle - SPREAD * tech.extraHarpoons / 2;
                        let count = -1
                        let harpoonDelay = () => {
                            if (simulation.paused) {
                                requestAnimationFrame(harpoonDelay)
                            } else {
                                count++
                                if (!(count % delay) && this.ammo > 0) {
                                    this.ammo--
                                    b.harpoon({ x: m.pos.x + 30 * Math.cos(m.angle), y: m.pos.y + 30 * Math.sin(m.angle) }, null, angle, harpoonSize, true, totalCycles)
                                    angle += SPREAD
                                }
                                if (count < num * delay && m.alive) requestAnimationFrame(harpoonDelay);
                            }
                        }
                        requestAnimationFrame(harpoonDelay)
                    }
                    this.ammo++ //make up for the ammo used up in fire()
                    simulation.updateGunHUD();

                } else { //m.crouch makes a single harpoon with longer range
                    const dir = {
                        x: Math.cos(m.angle),
                        y: Math.sin(m.angle)
                    }; //make a vector for the player's direction of length 1; used in dot product
                    for (let i = 0, len = mob.length; i < len; ++i) {
                        if (mob[i].alive && !mob[i].isBadTarget && Matter.Query.ray(map, m.pos, mob[i].position).length === 0 && !mob[i].isInvulnerable) {
                            const dot = Vector.dot(dir, Vector.normalise(Vector.sub(mob[i].position, m.pos))) //the dot product of diff and dir will return how much over lap between the vectors
                            const dist = Vector.magnitude(Vector.sub(where, mob[i].position))
                            if (dist < closest.distance && dot > 0.98 - Math.min(dist * 0.00014, 0.3)) { //target closest mob that player is looking at and isn't too close to target
                                closest.distance = dist
                                closest.target = mob[i]
                            }
                        }
                    }
                    if (m.crouch && m.onGround) {
                        b.harpoon(where, null, m.angle, harpoonSize, true, 1.6 * totalCycles, (m.crouch && tech.crouchAmmoCount && (tech.crouchAmmoCount - 1) % 2) ? false : true) //    harpoon(where, target, angle = m.angle, harpoonSize = 1, isReturn = false, totalCycles = 35, isReturnAmmo = true) {
                    } else {
                        b.harpoon(where, closest.target, m.angle, harpoonSize, true, totalCycles)
                    }
                }
                m.fireCDcycle = m.cycle + 5 + 35 * b.fireCDscale * (tech.isBreakHarpoon ? 0.5 : 1) + 60 * (m.energy < 0.05) + tech.extraHarpoons // cool down is set when harpoon bullet returns to player
                const recoil = Vector.mult(Vector.normalise(Vector.sub(where, m.pos)), m.crouch ? 0.015 : 0.035)
                player.force.x -= recoil.x
                player.force.y -= recoil.y
            },
        }, {
            name: "mine", //10
            // description: `toss a <strong>proximity</strong> mine that <strong>sticks</strong> to walls<br>refund <strong>undetonated</strong> mines on <strong>exiting</strong> a level<br><strong>1-2</strong> mines per ${powerUps.orb.ammo()}`,
            descriptionFunction() {
                return `toss a <strong>proximity</strong> mine that <strong>sticks</strong> to walls<br>refund <strong>undetonated</strong> mines on <strong>exiting</strong> a level<br><strong>${this.ammoPack.toFixed(1)}</strong> mines per ${powerUps.orb.ammo()}`
            },
            ammo: 0,
            ammoPack: 0.77,
            defaultAmmoPack: 0.77,
            have: false,
            nameString(suffix = "") {
                if (tech.isFoamMine) {
                    return `<strong>foam</strong>`
                } else if (tech.isSuperMine) {
                    return `<strong>super ball${suffix}</strong>`
                } else {
                    return `<strong>nail${suffix}</strong>`
                }
            },
            do() {
                if (!input.field && m.crouch && !tech.isLaserMine) {
                    const cycles = 80 //30
                    const speed = 40
                    const v = {
                        x: speed * Math.cos(m.angle),
                        y: speed * Math.sin(m.angle)
                    } //m.Vy / 2 + removed to make the path less jerky
                    ctx.strokeStyle = "rgba(68, 68, 68, 0.2)" //color.map
                    ctx.lineWidth = 2
                    ctx.beginPath()
                    for (let i = 1.5, len = 19; i < len + 1; i++) {
                        const time = cycles * i / len
                        ctx.lineTo(m.pos.x + time * v.x, m.pos.y + time * v.y + 0.34 * time * time)
                    }
                    ctx.stroke()
                }
            },
            fire() {
                if (m.crouch) {
                    if (tech.isLaserMine) {
                        const speed = 30
                        const velocity = {
                            x: speed * Math.cos(m.angle),
                            y: speed * Math.sin(m.angle)
                        }
                        b.laserMine(m.pos, velocity)
                        m.fireCDcycle = m.cycle + Math.floor(65 * b.fireCDscale); // cool down
                    } else {
                        const pos = {
                            x: m.pos.x + 30 * Math.cos(m.angle),
                            y: m.pos.y + 30 * Math.sin(m.angle)
                        }
                        let speed = 36
                        if (Matter.Query.point(map, pos).length > 0) speed = -2 //don't launch if mine will spawn inside map
                        b.mine(pos, { x: speed * Math.cos(m.angle), y: speed * Math.sin(m.angle) }, 0)
                        m.fireCDcycle = m.cycle + Math.floor(55 * b.fireCDscale); // cool down
                    }
                } else {
                    const pos = {
                        x: m.pos.x + 30 * Math.cos(m.angle),
                        y: m.pos.y + 30 * Math.sin(m.angle)
                    }
                    let speed = 23
                    if (Matter.Query.point(map, pos).length > 0) speed = -2 //don't launch if mine will spawn inside map
                    b.mine(pos, { x: speed * Math.cos(m.angle), y: speed * Math.sin(m.angle) }, 0)
                    m.fireCDcycle = m.cycle + Math.floor(35 * b.fireCDscale); // cool down
                }
            }
        },
        {
            name: "laser", //11
            descriptionFunction() {
                return `emit a <strong>beam</strong> of collimated coherent <strong class='color-laser'>light</strong><br>reflects off map, <strong class='color-block'>blocks</strong>, and mobs <strong>${(tech.isWideLaser || tech.isPulseLaser) ? 0 : tech.laserReflections}</strong> times<br>costs <strong>${(tech.laserDrain * 6000).toFixed(1)}</strong> <strong class='color-f'>energy</strong> per second and 0 <strong>ammo</strong>`
            },
            ammo: 0,
            ammoPack: Infinity,
            defaultAmmoPack: Infinity,
            have: false,
            charge: 0,
            isStuckOn: false,
            angle: 0,
            isInsideArc(angle) {
                const mod = (a, n) => {
                    return a - Math.floor(a / n) * n
                }
                let diff = mod(angle - this.angle + Math.PI, 2 * Math.PI) - Math.PI
                return Math.abs(diff) < this.arcRange
            },
            arcRange: 0.78, //1.57,
            lensDamage: 1,
            lensDamageOn: 0, //set in tech
            lens() {
                this.stuckOn();
                this.angle += 0.03
                if (this.isInsideArc(m.angle)) {
                    this.lensDamage = this.lensDamageOn
                    ctx.lineWidth = 6 + this.lensDamageOn
                } else {
                    this.lensDamage = 1
                    ctx.lineWidth = 2
                }
                ctx.beginPath();
                ctx.arc(m.pos.x, m.pos.y, 60, this.angle - this.arcRange, this.angle + this.arcRange);
                ctx.strokeStyle = '#fff' //'rgba(255,255,255,0.9)' //'hsl(189, 100%, 95%)'
                ctx.stroke();
            },
            stuckOn() {
                if (tech.isStuckOn) {
                    if (this.isStuckOn) {
                        if (!input.fire) this.fire();
                        if (m.energy < tech.laserDrain + 0.06) this.isStuckOn = false
                    } else if (input.fire) {
                        this.isStuckOn = true
                    }
                    // console.log(this.isStuckOn)
                }
            },
            do() { },
            fire() { },
            chooseFireMethod() {
                this.lensDamage = 1
                if (tech.isLaserLens) {
                    this.do = this.lens
                } else {
                    this.do = this.stuckOn
                }
                if (tech.isPulseLaser) {
                    this.fire = () => {
                        const drain = Math.min(0.9 * m.maxEnergy, 0.01 * (tech.isCapacitor ? 10 : 1) / b.fireCDscale)
                        if (m.energy > drain && this.charge < 50 * m.maxEnergy) {
                            m.energy -= drain
                            this.charge += drain * 100
                        }
                    }
                    if (tech.historyLaser) {
                        const len = 1 + tech.historyLaser
                        const spacing = Math.ceil(30 - 2 * tech.historyLaser)
                        this.do = () => {
                            if (tech.isLaserLens) this.lens()
                            if (this.charge > 0) {
                                //draw charge level
                                const mag = 4.1 * Math.sqrt(this.charge)
                                ctx.beginPath();
                                for (let i = 0; i < len; i++) {
                                    const history = m.history[(m.cycle - i * spacing) % 600]
                                    const off = history.yOff - 24.2859
                                    ctx.moveTo(history.position.x, history.position.y - off);
                                    ctx.ellipse(history.position.x, history.position.y - off, mag, mag * 0.65, history.angle, 0, 2 * Math.PI)
                                }
                                ctx.fillStyle = `rgba(255,0,0,${0.09 * Math.sqrt(this.charge)})`;
                                ctx.fill();
                                //fire
                                if (!input.fire) {
                                    if (this.charge > 5) {
                                        m.fireCDcycle = m.cycle + Math.floor(35 * b.fireCDscale); // cool down
                                        for (let i = 0; i < len; i++) {
                                            const history = m.history[(m.cycle - i * spacing) % 600]
                                            const off = history.yOff - 24.2859
                                            b.pulse(1.65 * this.charge * this.lensDamage, history.angle, {
                                                x: history.position.x,
                                                y: history.position.y - off
                                            })
                                        }
                                    }
                                    this.charge = 0;
                                }
                            }
                        };
                    } else {
                        this.do = () => {
                            if (tech.isLaserLens) this.lens()
                            if (this.charge > 0) {
                                //draw charge level
                                ctx.beginPath();
                                ctx.arc(m.pos.x, m.pos.y, 4.2 * Math.sqrt(this.charge), 0, 2 * Math.PI);
                                // ctx.fillStyle = `rgba(255,0,0,${0.09 * Math.sqrt(this.charge)})`;
                                ctx.fillStyle = `rgba(255,0,0,${0.09 * Math.sqrt(this.charge)})`;
                                ctx.fill();
                                //fire  
                                if (!input.fire) {
                                    if (this.charge > 5) {
                                        m.fireCDcycle = m.cycle + Math.floor(35 * b.fireCDscale); // cool down
                                        if (tech.beamSplitter) {
                                            const divergence = m.crouch ? 0.15 : 0.35
                                            const angle = m.angle - tech.beamSplitter * divergence / 2
                                            for (let i = 0; i < 1 + tech.beamSplitter; i++) b.pulse(this.charge, angle + i * divergence)
                                        } else {
                                            b.pulse(1.8 * this.charge * this.lensDamage, m.angle)
                                        }
                                    }
                                    this.charge = 0;
                                }
                            }
                        };
                    }

                } else if (tech.beamCollimator) {
                    this.fire = this.fireSplitCollimator
                } else if (tech.beamSplitter) {
                    this.fire = this.fireSplit
                } else if (tech.historyLaser) {
                    this.fire = this.fireHistory
                } else if (tech.isWideLaser) {
                    this.fire = this.fireWideBeam
                } else {
                    this.fire = this.fireLaser
                }
                // this.fire = this.firePhoton
            },
            fireLaser() {
                const drain = tech.laserDrain / b.fireCDscale
                if (m.energy < drain) {
                    m.fireCDcycle = m.cycle + 100; // cool down if out of energy
                } else {
                    m.fireCDcycle = m.cycle
                    m.energy -= drain
                    const where = { x: m.pos.x + 20 * Math.cos(m.angle), y: m.pos.y + 20 * Math.sin(m.angle) }
                    b.laser(where, {
                        x: where.x + 5000 * Math.cos(m.angle),
                        y: where.y + 5000 * Math.sin(m.angle)
                    }, tech.laserDamage / b.fireCDscale * this.lensDamage);
                }
            },

            firePulse() { },
            fireSplit() {
                const drain = tech.laserDrain / b.fireCDscale
                if (m.energy < drain) {
                    m.fireCDcycle = m.cycle + 100; // cool down if out of energy
                } else {
                    m.fireCDcycle = m.cycle
                    m.energy -= drain
                    // const divergence = m.crouch ? 0.15 : 0.2
                    // const scale = Math.pow(0.9, tech.beamSplitter)
                    // const pushScale = scale * scale
                    let dmg = tech.laserDamage / b.fireCDscale * this.lensDamage // * scale //Math.pow(0.9, tech.laserDamage)
                    const where = { x: m.pos.x + 20 * Math.cos(m.angle), y: m.pos.y + 20 * Math.sin(m.angle) }
                    const divergence = m.crouch ? 0.15 : 0.35
                    const angle = m.angle - tech.beamSplitter * divergence / 2
                    for (let i = 0; i < 1 + tech.beamSplitter; i++) {
                        b.laser(where, {
                            x: where.x + 3000 * Math.cos(angle + i * divergence),
                            y: where.y + 3000 * Math.sin(angle + i * divergence)
                        }, dmg, tech.laserReflections, false)
                    }
                }
            },
            fireSplitCollimator() {
                const drain = tech.laserDrain / b.fireCDscale
                if (m.energy < drain) {
                    m.fireCDcycle = m.cycle + 100; // cool down if out of energy
                } else {
                    m.fireCDcycle = m.cycle
                    m.energy -= drain
                    const freq = 0.037
                    const len = tech.beamSplitter + 1
                    const phase = 2 * Math.PI / len
                    for (let i = 0; i < len; i++) {
                        if (Math.sin(m.cycle * freq + phase * (i) + Math.PI / 2) > 0 || !(m.cycle % 3)) ctx.globalAlpha = 0.35

                        const whereSweep = m.angle + (m.crouch ? 0.4 : 1) * (Math.sin(m.cycle * freq + phase * (i)))
                        const where = { x: m.pos.x + 30 * Math.cos(whereSweep), y: m.pos.y + 30 * Math.sin(whereSweep) }
                        b.laser(where, {
                            x: where.x + 5000 * Math.cos(m.angle),
                            y: where.y + 5000 * Math.sin(m.angle)
                        }, tech.laserDamage / b.fireCDscale * this.lensDamage);
                        ctx.globalAlpha = 1
                    }
                }
            },
            fireWideBeam() {
                const drain = tech.laserDrain / b.fireCDscale
                if (m.energy < drain) {
                    m.fireCDcycle = m.cycle + 100; // cool down if out of energy
                } else {
                    m.fireCDcycle = m.cycle
                    m.energy -= drain
                    const range = {
                        x: 5000 * Math.cos(m.angle),
                        y: 5000 * Math.sin(m.angle)
                    }
                    const rangeOffPlus = {
                        x: 7.5 * Math.cos(m.angle + Math.PI / 2),
                        y: 7.5 * Math.sin(m.angle + Math.PI / 2)
                    }
                    const rangeOffMinus = {
                        x: 7.5 * Math.cos(m.angle - Math.PI / 2),
                        y: 7.5 * Math.sin(m.angle - Math.PI / 2)
                    }
                    const dmg = 0.70 * tech.laserDamage / b.fireCDscale * this.lensDamage //  3.5 * 0.55 = 200% more damage
                    const where = {
                        x: m.pos.x + 30 * Math.cos(m.angle),
                        y: m.pos.y + 30 * Math.sin(m.angle)
                    }
                    const eye = {
                        x: m.pos.x + 15 * Math.cos(m.angle),
                        y: m.pos.y + 15 * Math.sin(m.angle)
                    }
                    ctx.strokeStyle = tech.laserColor;
                    ctx.lineWidth = 8
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    if (Matter.Query.ray(map, eye, where).length === 0 && Matter.Query.ray(body, eye, where).length === 0) {
                        b.laser(eye, {
                            x: eye.x + range.x,
                            y: eye.y + range.y
                        }, dmg, 0, true, 0.3)
                    }
                    for (let i = 1; i < tech.wideLaser; i++) {
                        let whereOff = Vector.add(where, {
                            x: i * rangeOffPlus.x,
                            y: i * rangeOffPlus.y
                        })
                        if (Matter.Query.ray(map, eye, whereOff).length === 0 && Matter.Query.ray(body, eye, whereOff).length === 0) {
                            ctx.moveTo(eye.x, eye.y)
                            ctx.lineTo(whereOff.x, whereOff.y)
                            b.laser(whereOff, {
                                x: whereOff.x + range.x,
                                y: whereOff.y + range.y
                            }, dmg, 0, true, 0.3)
                        }
                        whereOff = Vector.add(where, {
                            x: i * rangeOffMinus.x,
                            y: i * rangeOffMinus.y
                        })
                        if (Matter.Query.ray(map, eye, whereOff).length === 0 && Matter.Query.ray(body, eye, whereOff).length === 0) {
                            ctx.moveTo(eye.x, eye.y)
                            ctx.lineTo(whereOff.x, whereOff.y)
                            b.laser(whereOff, {
                                x: whereOff.x + range.x,
                                y: whereOff.y + range.y
                            }, dmg, 0, true, 0.3)
                        }
                    }
                    ctx.stroke();
                    if (tech.isLaserLens && b.guns[11].lensDamage !== 1) {
                        ctx.lineWidth = 20 + 3 * b.guns[11].lensDamageOn
                        ctx.globalAlpha = 0.3
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }
            },
            fireHistory() {
                drain = tech.laserDrain / b.fireCDscale
                if (m.energy < drain) {
                    m.fireCDcycle = m.cycle + 100; // cool down if out of energy
                } else {
                    m.fireCDcycle = m.cycle
                    m.energy -= drain
                    const dmg = tech.laserDamage / b.fireCDscale * this.lensDamage
                    const spacing = Math.ceil(23 - tech.historyLaser)
                    ctx.beginPath();
                    b.laser({
                        x: m.pos.x + 20 * Math.cos(m.angle),
                        y: m.pos.y + 20 * Math.sin(m.angle)
                    }, {
                        x: m.pos.x + 3000 * Math.cos(m.angle),
                        y: m.pos.y + 3000 * Math.sin(m.angle)
                    }, dmg);

                    for (let i = 1, len = 1 + tech.historyLaser; i < len; i++) {
                        const history = m.history[(m.cycle - i * spacing) % 600]
                        const off = history.yOff - 24.2859 + 2 * i
                        // ctx.globalAlpha = 0.13
                        b.laser({
                            x: history.position.x + 20 * Math.cos(history.angle),
                            y: history.position.y + 20 * Math.sin(history.angle) - off
                        }, {
                            x: history.position.x + 3000 * Math.cos(history.angle),
                            y: history.position.y + 3000 * Math.sin(history.angle) - off
                        }, 0.7 * dmg, tech.laserReflections, true);
                    }
                    // ctx.globalAlpha = 1
                    ctx.strokeStyle = tech.laserColor;
                    ctx.lineWidth = 1
                    ctx.stroke();
                    if (tech.isLaserLens && b.guns[11].lensDamage !== 1) {
                        ctx.strokeStyle = tech.laserColor;
                        ctx.lineWidth = 10 + 2 * b.guns[11].lensDamageOn
                        ctx.globalAlpha = 0.2
                        ctx.stroke(); //glow
                        ctx.globalAlpha = 1;
                    }
                }
            },
        },
    ],
};
    </script>
    <script>
        //create array of mobs
let mob = [];
//method to populate the array above
const mobs = {
    loop() {
        let i = mob.length;
        while (i--) {
            if (mob[i].alive) {
                mob[i].do();
            } else {
                mob[i].replace(i); //removing mob and replace with body, this is done here to avoid an array index bug with drawing I think
            }
        }
    },
    draw() { },
    drawDefault() {
        ctx.lineWidth = 2;
        let i = mob.length;
        while (i--) {
            // if (Matter.Query.ray(map, mob[i].position, m.pos).length === 0) { //check if there is a ray between the mob and the player
            ctx.beginPath();
            const vertices = mob[i].vertices;
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let j = 1, len = vertices.length; j < len; ++j) ctx.lineTo(vertices[j].x, vertices[j].y);
            ctx.lineTo(vertices[0].x, vertices[0].y);
            ctx.fillStyle = mob[i].fill;
            ctx.strokeStyle = mob[i].stroke;
            ctx.fill();
            ctx.stroke();
            // }
        }
    },
    defaultHealthBar() {
        for (let i = 0, len = mob.length; i < len; i++) {
            if (mob[i].seePlayer.recall && mob[i].showHealthBar) {
                const h = mob[i].radius * 0.3;
                const w = mob[i].radius * 2;
                const x = mob[i].position.x - w / 2;
                const y = mob[i].position.y - w * 0.7;
                ctx.fillStyle = "rgba(100, 100, 100, 0.3)";
                ctx.fillRect(x, y, w, h);
                ctx.fillStyle = "rgba(255,0,0,0.7)";
                ctx.fillRect(x, y, w * mob[i].health, h);
                // if (mob[i].isInvulnerable) {
                //     ctx.strokeStyle = "rgba(255,255,255,1)";
                //     ctx.lineWidth = 5
                //     ctx.strokeRect(x, y, w, h);
                // }
            }
        }
    },
    healthBar() { },
    statusSlow(who, cycles = 60) {
        applySlow(who)
        //look for mobs near the target
        if (tech.isAoESlow) {
            const range2 = (200 + 170 * Math.random()) ** 2
            for (let i = 0, len = mob.length; i < len; i++) {
                if (who !== mob[i] && Vector.magnitudeSquared(Vector.sub(who.position, mob[i].position)) < range2 + mob[i].radius) applySlow(mob[i])
            }
            simulation.drawList.push({
                x: who.position.x,
                y: who.position.y,
                radius: Math.sqrt(range2),
                color: "rgba(0,100,255,0.05)",
                time: simulation.drawTime
            });
        }

        function applySlow(whom) {
            if (!whom.shield && !whom.isShielded && whom.alive) {
                if (tech.isIceMaxHealthLoss && whom.health > 0.66 && whom.damageReduction > 0) whom.health = 0.66
                if (tech.isIceKill && whom.health < 0.34 && whom.damageReduction > 0 && whom.alive) {
                    whom.damage(Infinity)
                    simulation.drawList.push({
                        x: whom.position.x,
                        y: whom.position.y,
                        radius: whom.radius * 1.2,
                        color: "rgb(0,100,255)",
                        time: 8
                    });
                    simulation.drawList.push({
                        x: whom.position.x,
                        y: whom.position.y,
                        radius: whom.radius * 0.7,
                        color: "rgb(0,100,255)",
                        time: 12
                    });
                    simulation.drawList.push({
                        x: whom.position.x,
                        y: whom.position.y,
                        radius: whom.radius * 0.4,
                        color: "rgb(0,100,255)",
                        time: 16
                    });
                }
                if (whom.isBoss) cycles = Math.floor(cycles * 0.25)
                let i = whom.status.length
                while (i--) {
                    if (whom.status[i].type === "slow") whom.status.splice(i, 1); //remove other "slow" effects on this mob
                }
                whom.isSlowed = true;
                whom.status.push({
                    effect() {
                        if (whom.speed > 1) {
                            const drag = 0.94
                            Matter.Body.setVelocity(whom, {
                                x: whom.velocity.x * drag,
                                y: whom.velocity.y * drag
                            });
                        }
                        Matter.Body.setAngularVelocity(whom, 0);
                        ctx.beginPath();
                        ctx.moveTo(whom.vertices[0].x, whom.vertices[0].y);
                        for (let j = 1, len = whom.vertices.length; j < len; ++j) {
                            ctx.lineTo(whom.vertices[j].x, whom.vertices[j].y);
                        }
                        ctx.lineTo(whom.vertices[0].x, whom.vertices[0].y);
                        ctx.strokeStyle = "rgba(0,100,255,0.8)";
                        ctx.lineWidth = 15;
                        ctx.stroke();
                        ctx.fillStyle = whom.fill
                        ctx.fill();
                    },
                    endEffect() {
                        //check to see if there are not other freeze effects?
                        whom.isSlowed = false;
                    },
                    type: "slow",
                    endCycle: simulation.cycle + cycles,
                })
            }
        }
    },
    statusStun(who, cycles = 180) {
        if (!who.shield && !who.isShielded) {
            if (who.speed > 3) {
                Matter.Body.setVelocity(who, {
                    x: who.velocity.x * 0.8,
                    y: who.velocity.y * 0.8
                });
            }
            Matter.Body.setAngularVelocity(who, who.angularVelocity * 0.8);
            //remove other "stun" effects on this mob
            let i = who.status.length
            while (i--) {
                if (who.status[i].type === "stun") who.status.splice(i, 1);
            }
            who.isStunned = true;
            who.status.push({
                effect() {
                    if (who.memory !== Infinity) {
                        who.seePlayer.yes = false;
                        who.seePlayer.recall = 0;
                        who.seePlayer.position = {
                            x: who.position.x + 100 * (Math.random() - 0.5),
                            y: who.position.y + 100 * (Math.random() - 0.5)
                        }
                    } else {
                        Matter.Body.setVelocity(who, {
                            x: who.velocity.x * 0.6,
                            y: who.velocity.y * 0.6
                        });
                    }
                    if (who.velocity.y < 2) who.force.y += who.mass * 0.0004 //extra gravity

                    //draw health bar
                    const h = who.radius * 0.3;
                    const w = who.radius * 2;
                    const x = who.position.x - w / 2;
                    const y = who.position.y - w * 0.7;
                    ctx.fillStyle = "rgba(100, 100, 100, 0.3)";
                    ctx.fillRect(x, y, w, h);
                    ctx.fillStyle = `rgba(${Math.floor(255 * Math.random())},${Math.floor(255 * Math.random())},${Math.floor(255 * Math.random())},0.5)`
                    ctx.fillRect(x, y, w * who.health, h);

                    //draw fill inside mob
                    ctx.beginPath();
                    ctx.moveTo(who.vertices[0].x, who.vertices[0].y);
                    for (let j = 1, len = who.vertices.length; j < len; ++j) {
                        ctx.lineTo(who.vertices[j].x, who.vertices[j].y);
                    }
                    ctx.lineTo(who.vertices[0].x, who.vertices[0].y);
                    ctx.fill();
                },
                endEffect() {
                    who.isStunned = false
                },
                type: "stun",
                endCycle: simulation.cycle + cycles * (who.isBoss ? 0.2 : 1),
            })
        }
    },
    statusDoT(who, tickDamage, cycles = 180) {
        if (!who.isShielded && who.alive && who.damageReduction > 0) {
            who.status.push({
                effect() {
                    if ((simulation.cycle - this.startCycle) % 30 === 0) {
                        let dmg = tech.radioactiveDamage * this.dmg
                        who.damage(dmg);
                        if (who.damageReduction) {
                            simulation.drawList.push({ //add dmg to draw queue
                                x: who.position.x + (Math.random() - 0.5) * who.radius * 0.5,
                                y: who.position.y + (Math.random() - 0.5) * who.radius * 0.5,
                                radius: Math.log(dmg + 1.1) * 40 * who.damageReduction + 3,
                                color: "rgba(0,80,80,0.9)",
                                time: simulation.drawTime
                            });
                        }
                    }
                },
                endEffect() { },
                dmg: tickDamage,
                type: "dot",
                endCycle: simulation.cycle + cycles,
                startCycle: simulation.cycle + 29 //makes sure it doesn't tick on first application
            })
        }
    },
    deathCount: 0,
    mobSpawnWithHealth: 1,
    setMobSpawnHealth() {
        mobs.mobSpawnWithHealth = 0.88 ** (tech.mobSpawnWithHealth)
    },
    //**********************************************************************************************
    //**********************************************************************************************
    spawn(xPos, yPos, sides, radius, color) {
        let i = mob.length;
        mob[i] = Matter.Bodies.polygon(xPos, yPos, sides, radius, {
            //inertia: Infinity, //prevents rotation
            mob: true,
            density: 0.001,
            //friction: 0,
            frictionAir: 0.005,
            //frictionStatic: 0,
            restitution: 0.5,
            collisionFilter: {
                group: 0,
                category: cat.mob,
                mask: cat.player | cat.map | cat.body | cat.bullet | cat.mob
            },
            onHit: undefined,
            alive: true,
            index: i,
            health: mobs.mobSpawnWithHealth,
            showHealthBar: true,
            accelMag: 0.001 * simulation.accelScale,
            cd: 0, //game cycle when cooldown will be over
            delay: 60, //static: time between cooldowns
            fill: color,
            stroke: "#000",
            seePlayer: {
                yes: false,
                recall: 0,
                position: {
                    x: xPos,
                    y: yPos
                }
            },
            radius: radius,
            spawnPos: {
                x: xPos,
                y: yPos
            },
            status: [], // [ { effect(), endCycle } ]
            checkStatus() {
                let j = this.status.length;
                while (j--) {
                    this.status[j].effect();
                    if (this.status[j].endCycle < simulation.cycle) {
                        this.status[j].endEffect();
                        this.status.splice(j, 1);
                    }
                }
            },
            isSlowed: false,
            isStunned: false,
            seeAtDistance2: Infinity, //sqrt(4000000) = 2000 = max seeing range
            distanceToPlayer() {
                const dx = this.position.x - player.position.x;
                const dy = this.position.y - player.position.y;
                return Math.sqrt(dx * dx + dy * dy);
            },
            distanceToPlayer2() {
                const dx = this.position.x - player.position.x;
                const dy = this.position.y - player.position.y;
                return dx * dx + dy * dy;
            },
            gravity() {
                this.force.y += this.mass * this.g;
            },
            seePlayerFreq: Math.floor(30 + 30 * Math.random()), //how often NPC checks to see where player is, lower numbers have better vision
            foundPlayer() {
                this.locatePlayer();
                if (!this.seePlayer.yes) {
                    this.alertNearByMobs();
                    this.seePlayer.yes = true;
                }
            },
            lostPlayer() {
                this.seePlayer.yes = false;
                this.seePlayer.recall -= this.seePlayerFreq;
                if (this.seePlayer.recall < 0) this.seePlayer.recall = 0;
            },
            memory: 120, //default time to remember player's location
            locatePlayer() { // updates mob's memory of player location
                this.seePlayer.recall = this.memory + Math.round(this.memory * Math.random()); //cycles before mob falls a sleep
                this.seePlayer.position.x = player.position.x;
                this.seePlayer.position.y = player.position.y;
            },
            alertNearByMobs() {
                //this.alertRange2 is set at the very bottom of this mobs, after mob is made
                for (let i = 0; i < mob.length; i++) {
                    if (!mob[i].seePlayer.recall && Vector.magnitudeSquared(Vector.sub(this.position, mob[i].position)) < this.alertRange2) {
                        mob[i].locatePlayer();
                    }
                }
            },
            alwaysSeePlayer() {
                if (!m.isCloak) {
                    this.seePlayer.recall = 1;
                    this.seePlayer.position.x = player.position.x;
                    this.seePlayer.position.y = player.position.y;
                }
            },
            seePlayerByHistory(depth = 30) { //depth max 60?  limit of history
                if (!(simulation.cycle % this.seePlayerFreq)) {
                    if (Matter.Query.ray(map, this.position, this.playerPosRandomY()).length === 0 && !m.isCloak) {
                        this.foundPlayer();
                    } else if (this.seePlayer.recall) {
                        this.lostPlayer();
                        if (!m.isCloak) {
                            for (let i = 0; i < depth; i++) { //if lost player lock onto a player location in history
                                let history = m.history[(m.cycle - 10 * i) % 600]
                                if (Matter.Query.ray(map, this.position, history.position).length === 0) {
                                    this.seePlayer.recall = this.memory + Math.round(this.memory * Math.random()); //cycles before mob falls a sleep
                                    this.seePlayer.position.x = history.position.x;
                                    this.seePlayer.position.y = history.position.y;
                                    this.seePlayer.yes = true;
                                    //draw the history location found for testing purposes
                                    // ctx.beginPath();
                                    // ctx.moveTo(this.position.x, this.position.y);
                                    // ctx.lineTo(history.position.x, history.position.y);
                                    // ctx.lineWidth = 5;
                                    // ctx.strokeStyle = "#000";
                                    // ctx.stroke();
                                    break
                                }
                            }
                        }
                    }
                }
            },
            seePlayerCheck() {
                if (!(simulation.cycle % this.seePlayerFreq)) {
                    if (
                        this.distanceToPlayer2() < this.seeAtDistance2 &&
                        Matter.Query.ray(map, this.position, this.playerPosRandomY()).length === 0 &&
                        // Matter.Query.ray(body, this.position, this.playerPosRandomY()).length === 0 &&
                        !m.isCloak
                    ) {
                        this.foundPlayer();
                    } else if (this.seePlayer.recall) {
                        this.lostPlayer();
                    }
                }
            },
            seePlayerCheckByDistance() {
                if (!(simulation.cycle % this.seePlayerFreq)) {
                    if (this.distanceToPlayer2() < this.seeAtDistance2 && !m.isCloak) {
                        this.foundPlayer();
                    } else if (this.seePlayer.recall) {
                        this.lostPlayer();
                    }
                }
            },
            seePlayerByDistOrLOS() {
                if (!(simulation.cycle % this.seePlayerFreq)) {
                    if (
                        (this.distanceToPlayer2() < this.seeAtDistance2 || (Matter.Query.ray(map, this.position, this.playerPosRandomY()).length === 0)) && //&& Matter.Query.ray(body, this.position, this.playerPosRandomY()).length === 0
                        !m.isCloak
                    ) {
                        this.foundPlayer();
                    } else if (this.seePlayer.recall) {
                        this.lostPlayer();
                    }
                }
            },
            isLookingAtPlayer(threshold) {
                const diff = Vector.normalise(Vector.sub(player.position, this.position));
                //make a vector for the mob's direction of length 1
                const dir = { x: Math.cos(this.angle), y: Math.sin(this.angle) };
                //the dot product of diff and dir will return how much over lap between the vectors
                const dot = Vector.dot(dir, diff);
                // console.log(Math.cos(dot)*180/Math.PI)
                if (dot > threshold) {
                    return true;
                } else {
                    return false;
                }
            },
            lookRange: 0.2 + Math.random() * 0.2,
            lookTorque: 0.0000004 * (Math.random() > 0.5 ? -1 : 1),
            seePlayerByLookingAt() {
                if (!(simulation.cycle % this.seePlayerFreq) && (this.seePlayer.recall || this.isLookingAtPlayer(this.lookRange))) {
                    if (
                        this.distanceToPlayer2() < this.seeAtDistance2 &&
                        Matter.Query.ray(map, this.position, this.playerPosRandomY()).length === 0 &&
                        // Matter.Query.ray(body, this.position, this.playerPosRandomY()).length === 0 &&
                        !m.isCloak
                    ) {
                        this.foundPlayer();
                    } else if (this.seePlayer.recall) {
                        this.lostPlayer();
                    }
                }
                //if you don't recall player location rotate and draw to show where you are looking
                if (!this.seePlayer.recall) {
                    this.torque = this.lookTorque * this.inertia;
                    //draw
                    const range = Math.PI * this.lookRange;
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.radius * 2.5, this.angle - range, this.angle + range);
                    ctx.arc(this.position.x, this.position.y, this.radius * 1.4, this.angle + range, this.angle - range, true);
                    ctx.fillStyle = "rgba(0,0,0,0.07)";
                    ctx.fill();
                }
            },
            playerPosRandomY() {
                return {
                    x: player.position.x, // + (Math.random() - 0.5) * 50,
                    y: player.position.y + (Math.random() - 0.5) * 110
                };
            },
            // hacked() { //set this.hackedTarget variable before running this method
            //   //find a new target
            //   if (!(simulation.cycle % this.seePlayerFreq)) {
            //     this.hackedTarget = null
            //     for (let i = 0, len = mob.length; i < len; i++) {
            //       if (mob[i] !== this) {
            //         // const DIST = Vector.magnitude(Vector.sub(this.position, mob[j]));
            //         if (Matter.Query.ray(map, this.position, mob[i].position).length === 0 &&
            //           Matter.Query.ray(body, this.position, mob[i].position).length === 0) {
            //           this.hackedTarget = mob[i]
            //         }
            //       }
            //     }
            //   }
            //   //acceleration towards targets
            //   if (this.hackedTarget) {
            //     this.force = Vector.mult(Vector.normalise(Vector.sub(this.hackedTarget.position, this.position)), this.mass * 0.0015)
            //   }
            // },
            harmZone() {
                if (this.seePlayer.yes) {
                    ctx.setLineDash([125 * Math.random(), 125 * Math.random()]);
                    // ctx.lineDashOffset = 6*(simulation.cycle % 215);
                    if (this.distanceToPlayer() < this.laserRange) {
                        if (m.immuneCycle < m.cycle) {
                            m.takeDamage(0.0003 * this.damageScale());
                            if (m.energy > 0.1) m.energy -= 0.003
                        }
                        ctx.beginPath();
                        ctx.moveTo(this.position.x, this.position.y);
                        ctx.lineTo(m.pos.x, m.pos.y);
                        ctx.lineTo(m.pos.x + (Math.random() - 0.5) * 3000, m.pos.y + (Math.random() - 0.5) * 3000);
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = "rgb(255,0,170)";
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.arc(m.pos.x, m.pos.y, 40, 0, 2 * Math.PI);
                        ctx.fillStyle = "rgba(255,0,170,0.15)";
                        ctx.fill();
                    }
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.laserRange * 0.9, 0, 2 * Math.PI);
                    ctx.strokeStyle = "rgba(255,0,170,0.5)";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillStyle = "rgba(255,0,170,0.03)";
                    ctx.fill();
                }
            },
            wing(a, radius = 250, ellipticity = 0.4, dmg = 0.0006) {
                const minorRadius = radius * ellipticity
                const perp = { x: Math.cos(a), y: Math.sin(a) } //
                const where = Vector.add(this.position, Vector.mult(perp, radius + 0.8 * this.radius))

                ctx.beginPath();
                ctx.ellipse(where.x, where.y, radius, minorRadius, a, 0, 2 * Math.PI)
                ctx.fill();

                //check for wing -> player damage
                const hitPlayer = Matter.Query.ray([player], this.position, Vector.add(this.position, Vector.mult(perp, radius * 2.05)), minorRadius)
                if (hitPlayer.length && m.immuneCycle < m.cycle) {
                    m.takeDamage(dmg * this.damageScale());
                }
            },
            searchSpring() {
                //draw the two dots on the end of the springs
                ctx.beginPath();
                ctx.arc(this.cons.pointA.x, this.cons.pointA.y, 6, 0, 2 * Math.PI);
                ctx.arc(this.cons2.pointA.x, this.cons2.pointA.y, 6, 0, 2 * Math.PI);
                ctx.fillStyle = "#222";
                ctx.fill();

                if (!(simulation.cycle % this.seePlayerFreq)) {
                    if (
                        (this.seePlayer.recall || this.isLookingAtPlayer(this.lookRange)) &&
                        this.distanceToPlayer2() < this.seeAtDistance2 &&
                        Matter.Query.ray(map, this.position, player.position).length === 0 &&
                        Matter.Query.ray(body, this.position, player.position).length === 0 &&
                        !m.isCloak
                    ) {
                        this.foundPlayer();
                    } else if (this.seePlayer.recall) {
                        this.lostPlayer();
                    }
                }
            },
            springAttack() {
                // set new values of the ends of the spring constraints
                const stepRange = 600
                if (this.seePlayer.recall && Matter.Query.ray(map, this.position, this.seePlayer.position).length === 0) {
                    if (!(simulation.cycle % (this.seePlayerFreq * 2))) {
                        const unit = Vector.normalise(Vector.sub(this.seePlayer.position, this.position))
                        const goal = Vector.add(this.position, Vector.mult(unit, stepRange))
                        this.springTarget.x = goal.x;
                        this.springTarget.y = goal.y;
                        // this.springTarget.x = this.seePlayer.position.x;
                        // this.springTarget.y = this.seePlayer.position.y;
                        this.cons.length = -200;
                        this.cons2.length = 100 + 1.5 * this.radius;
                    } else if (!(simulation.cycle % this.seePlayerFreq)) {
                        const unit = Vector.normalise(Vector.sub(this.seePlayer.position, this.position))
                        const goal = Vector.add(this.position, Vector.mult(unit, stepRange))
                        this.springTarget2.x = goal.x;
                        this.springTarget2.y = goal.y;
                        // this.springTarget2.x = this.seePlayer.position.x;
                        // this.springTarget2.y = this.seePlayer.position.y;
                        this.cons.length = 100 + 1.5 * this.radius;
                        this.cons2.length = -200;
                    }
                } else {
                    this.torque = this.lookTorque * this.inertia;
                    //draw looking around arcs
                    const range = Math.PI * this.lookRange;
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.radius * 2.5, this.angle - range, this.angle + range);
                    ctx.arc(this.position.x, this.position.y, this.radius * 1.4, this.angle + range, this.angle - range, true);
                    ctx.fillStyle = "rgba(0,0,0,0.07)";
                    ctx.fill();
                    //spring to random place on map
                    if (!(simulation.cycle % (this.seePlayerFreq * 4))) {
                        best = {
                            x: null,
                            y: null,
                            dist2: Infinity,
                            who: null,
                            v1: null,
                            v2: null
                        };
                        const seeRange = 3000;
                        const look = {
                            x: this.position.x + seeRange * Math.cos(this.angle),
                            y: this.position.y + seeRange * Math.sin(this.angle)
                        };
                        best = vertexCollision(this.position, look, [map, body]);
                        if (best.dist2 != Infinity) {
                            if (Math.random() > 0.5) {
                                this.springTarget.x = best.x;
                                this.springTarget.y = best.y;
                                this.cons.length = 100 + 1.5 * this.radius;
                                this.cons2.length = 100 + 1.5 * this.radius;
                            } else {
                                this.springTarget2.x = best.x;
                                this.springTarget2.y = best.y;
                                this.cons.length = 100 + 1.5 * this.radius;
                                this.cons2.length = 100 + 1.5 * this.radius;
                            }
                        }
                    }
                }
            },
            curl(range = 1000, mag = -10) {
                //cause all mobs, and bodies to rotate in a circle
                applyCurl = function (center, array, isAntiGravity = true) {
                    for (let i = 0; i < array.length; ++i) {
                        if (!array[i].isNotHoldable) {
                            const sub = Vector.sub(center, array[i].position)
                            const radius2 = Vector.magnitudeSquared(sub);

                            //if too close, like center mob or shield, don't curl   // if too far don't curl
                            if (radius2 < range * range && radius2 > 10000) {
                                const curlVector = Vector.mult(Vector.perp(Vector.normalise(sub)), mag)
                                //apply curl force
                                if (array[i].isMobBullet) {
                                    Matter.Body.setVelocity(array[i], {
                                        x: array[i].velocity.x * 0.97 + curlVector.x * 0.06,
                                        y: array[i].velocity.y * 0.97 + curlVector.y * 0.06
                                    })
                                } else {
                                    Matter.Body.setVelocity(array[i], {
                                        x: array[i].velocity.x * 0.95 + curlVector.x * 0.06,
                                        y: array[i].velocity.y * 0.95 + curlVector.y * 0.06
                                    })
                                }
                                if (isAntiGravity) array[i].force.y -= 0.8 * simulation.g * array[i].mass
                                // //draw curl, for debugging
                                // ctx.beginPath();
                                // ctx.moveTo(array[i].position.x, array[i].position.y);
                                // ctx.lineTo(array[i].position.x + curlVector.x * 10, array[i].position.y + curlVector.y * 10);
                                // ctx.lineWidth = 2;
                                // ctx.strokeStyle = "#000";
                                // ctx.stroke();
                            }
                        }
                    }
                }
                applyCurl(this.position, mob, false);
                applyCurl(this.position, body);
                applyCurl(this.position, powerUp);
                // applyCurl(this.position, bullet);  // too powerful, just stops all bullets need to write a curl function just for bullets
                // applyCurl(this.position, [player]);

                //draw limit
                // ctx.beginPath();
                // ctx.arc(this.position.x, this.position.y, range, 0, 2 * Math.PI);
                // ctx.fillStyle = "rgba(55,255,255, 0.1)";
                // ctx.fill();
            },
            pullPlayer() {
                if (this.seePlayer.yes && Vector.magnitudeSquared(Vector.sub(this.position, player.position)) < 1000000) {
                    const angle = Math.atan2(player.position.y - this.position.y, player.position.x - this.position.x);
                    player.force.x -= simulation.accelScale * 0.00113 * player.mass * Math.cos(angle) * (m.onGround ? 2 : 1);
                    player.force.y -= simulation.accelScale * 0.00084 * player.mass * Math.sin(angle);

                    ctx.beginPath();
                    ctx.moveTo(this.position.x, this.position.y);
                    ctx.lineTo(m.pos.x, m.pos.y);
                    ctx.lineWidth = Math.min(60, this.radius * 2);
                    ctx.strokeStyle = "rgba(0,0,0,0.5)";
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(m.pos.x, m.pos.y, 40, 0, 2 * Math.PI);
                    ctx.fillStyle = "rgba(0,0,0,0.3)";
                    ctx.fill();
                }
            },
            repelBullets() {
                // if (this.seePlayer.yes) {
                // ctx.lineWidth = "8";
                // ctx.strokeStyle = this.fill;
                // ctx.beginPath();
                for (let i = 0, len = bullet.length; i < len; ++i) {
                    const dx = bullet[i].position.x - this.position.x;
                    const dy = bullet[i].position.y - this.position.y;
                    const dist = Math.max(300, Math.sqrt(dx * dx + dy * dy))
                    if (dist < 700) {
                        ctx.moveTo(this.position.x, this.position.y);
                        ctx.lineTo(bullet[i].position.x, bullet[i].position.y);
                        const angle = Math.atan2(dy, dx);
                        const mag = (500 * bullet[i].mass * simulation.g) / dist;
                        bullet[i].force.x += mag * Math.cos(angle);
                        bullet[i].force.y += mag * Math.sin(angle);
                    }
                }
                // ctx.stroke();
                // }
            },
            attraction() {
                //accelerate towards the player
                if (this.seePlayer.recall) {
                    const force = Vector.mult(Vector.normalise(Vector.sub(this.seePlayer.position, this.position)), this.accelMag * this.mass)
                    this.force.x += force.x;
                    this.force.y += force.y;
                }
            },
            repulsionRange: 500000, //squared
            repulsion() {
                //accelerate towards the player
                if (this.seePlayer.recall && this.distanceToPlayer2() < this.repulsionRange) {
                    // && dx * dx + dy * dy < 2000000) {
                    const forceMag = this.accelMag * this.mass;
                    const angle = Math.atan2(this.seePlayer.position.y - this.position.y, this.seePlayer.position.x - this.position.x);
                    this.force.x -= 2 * forceMag * Math.cos(angle);
                    this.force.y -= 2 * forceMag * Math.sin(angle); // - 0.0007 * this.mass; //antigravity
                }
            },
            hoverOverPlayer() {
                if (this.seePlayer.recall) {
                    // vertical positioning
                    const rangeY = 250;
                    if (this.position.y > this.seePlayer.position.y - this.hoverElevation + rangeY) {
                        this.force.y -= this.accelMag * this.mass;
                    } else if (this.position.y < this.seePlayer.position.y - this.hoverElevation - rangeY) {
                        this.force.y += this.accelMag * this.mass;
                    }
                    // horizontal positioning
                    const rangeX = 150;
                    if (this.position.x > this.seePlayer.position.x + this.hoverXOff + rangeX) {
                        this.force.x -= this.accelMag * this.mass;
                    } else if (this.position.x < this.seePlayer.position.x + this.hoverXOff - rangeX) {
                        this.force.x += this.accelMag * this.mass;
                    }
                }
            },
            grow() {
                if (this.seePlayer.recall) {
                    if (this.radius < 80) {
                        const scale = 1.01;
                        Matter.Body.scale(this, scale, scale);
                        this.radius *= scale;
                        // this.torque = -0.00002 * this.inertia;
                        this.fill = `hsl(144, ${this.radius}%, 50%)`;
                        if (this.isShielded) { //remove shield if shielded when growing
                            this.isShielded = false;
                            this.removeConsBB();
                        }
                    }
                } else {
                    if (this.radius > 15) {
                        const scale = 0.99;
                        Matter.Body.scale(this, scale, scale);
                        this.radius *= scale;
                        this.fill = `hsl(144, ${this.radius}%, 50%)`;
                    }
                }
            },
            search() {
                //be sure to declare searchTarget in mob spawn
                //accelerate towards the searchTarget
                if (!this.seePlayer.recall) {
                    const newTarget = function (that) {
                        if (Math.random() < 0.0007) {
                            that.searchTarget = player.position; //chance to target player
                        } else {
                            //target random body
                            that.searchTarget = map[Math.floor(Math.random() * (map.length - 1))].position;
                        }
                    };

                    const sub = Vector.sub(this.searchTarget, this.position);
                    if (Vector.magnitude(sub) > this.radius * 2) {
                        // ctx.beginPath();
                        // ctx.strokeStyle = "#aaa";
                        // ctx.moveTo(this.position.x, this.position.y);
                        // ctx.lineTo(this.searchTarget.x,this.searchTarget.y);
                        // ctx.stroke();
                        //accelerate at 0.1 of normal acceleration
                        this.force = Vector.mult(Vector.normalise(sub), this.accelMag * this.mass * 0.2);
                    } else {
                        //after reaching random target switch to new target
                        newTarget(this);
                    }
                    //switch to a new target after a while
                    if (!(simulation.cycle % (this.seePlayerFreq * 15))) {
                        newTarget(this);
                    }
                }
            },
            blink() {
                //teleport towards player as a way to move
                if (this.seePlayer.recall && !(simulation.cycle % this.blinkRate)) {
                    ctx.beginPath();
                    ctx.moveTo(this.position.x, this.position.y);
                    const dist = Vector.sub(this.seePlayer.position, this.position);
                    const distMag = Vector.magnitude(dist);
                    const unitVector = Vector.normalise(dist);
                    const rando = (Math.random() - 0.5) * 50;
                    if (distMag < this.blinkLength) {
                        Matter.Body.translate(this, Vector.mult(unitVector, distMag + rando));
                    } else {
                        Matter.Body.translate(this, Vector.mult(unitVector, this.blinkLength + rando));
                    }
                    ctx.lineTo(this.position.x, this.position.y);
                    ctx.lineWidth = radius * 2;
                    ctx.strokeStyle = this.stroke; //"rgba(0,0,0,0.5)"; //'#000'
                    ctx.stroke();
                }
            },
            drift() {
                //teleport towards player as a way to move
                if (this.seePlayer.recall && !(simulation.cycle % this.blinkRate)) {
                    // && !m.lookingAtMob(this,0.5)){
                    ctx.beginPath();
                    ctx.moveTo(this.position.x, this.position.y);
                    const dist = Vector.sub(this.seePlayer.position, this.position);
                    const distMag = Vector.magnitude(dist);
                    const vector = Vector.mult(Vector.normalise(dist), this.blinkLength);
                    if (distMag < this.blinkLength) {
                        Matter.Body.setPosition(this, this.seePlayer.position);
                        Matter.Body.translate(this, {
                            x: (Math.random() - 0.5) * 50,
                            y: (Math.random() - 0.5) * 50
                        });
                    } else {
                        vector.x += (Math.random() - 0.5) * 200;
                        vector.y += (Math.random() - 0.5) * 200;
                        Matter.Body.translate(this, vector);
                    }
                    ctx.lineTo(this.position.x, this.position.y);
                    ctx.lineWidth = radius * 2;
                    ctx.strokeStyle = this.stroke;
                    ctx.stroke();
                }
            },
            // pushAway(range = 700, force = 0.2) {
            //     if (m.immuneCycle < m.cycle) {
            //         let sub = Vector.sub(player.position, this.position);
            //         if (Vector.magnitude(sub) < range) {
            //             knock = Vector.mult(Vector.normalise(sub), player.mass * force);
            //             player.force.x += knock.x;
            //             player.force.y += knock.y - (m.onGround && !m.crouch) ? 0.1 * player.mass : 0;
            //         }
            //     }
            // },
            bomb() {
                //throw a mob/bullet at player
                if (
                    !(simulation.cycle % this.fireFreq) &&
                    Math.abs(this.position.x - this.seePlayer.position.x) < 400 && //above player
                    Matter.Query.ray(map, this.position, this.playerPosRandomY()).length === 0 && //see player
                    Matter.Query.ray(body, this.position, this.playerPosRandomY()).length === 0
                ) {
                    spawn.bomb(this.position.x, this.position.y + this.radius * 0.7, 9 + Math.ceil(this.radius / 15), 5);
                    //add spin and speed
                    Matter.Body.setAngularVelocity(mob[mob.length - 1], (Math.random() - 0.5) * 0.5);
                    Matter.Body.setVelocity(mob[mob.length - 1], { x: this.velocity.x, y: this.velocity.y });
                    //spin for mob as well
                    Matter.Body.setAngularVelocity(this, (Math.random() - 0.5) * 0.25);
                }
            },
            fire() {
                const setNoseShape = () => {
                    const mag = this.radius + this.radius * this.noseLength;
                    this.vertices[1].x = this.position.x + Math.cos(this.angle) * mag;
                    this.vertices[1].y = this.position.y + Math.sin(this.angle) * mag;
                };
                //throw a mob/bullet at player
                if (this.seePlayer.recall) {
                    //set direction to turn to fire
                    if (!(simulation.cycle % this.seePlayerFreq)) {
                        this.fireDir = Vector.normalise(Vector.sub(this.seePlayer.position, this.position));
                        this.fireDir.y -= Math.abs(this.seePlayer.position.x - this.position.x) / 2500; //gives the bullet an arc  //was    / 1600
                    }
                    //rotate towards fireAngle
                    const angle = this.angle + Math.PI / 2;
                    const dot = Vector.dot({
                        x: Math.cos(angle),
                        y: Math.sin(angle)
                    }, this.fireDir)
                    const threshold = 0.1;
                    if (dot > threshold) {
                        this.torque += 0.000004 * this.inertia;
                    } else if (dot < -threshold) {
                        this.torque -= 0.000004 * this.inertia;
                    } else if (this.noseLength > 1.5 && dot > -0.2 && dot < 0.2) {
                        //fire
                        spawn.bullet(this.vertices[1].x, this.vertices[1].y, this.tier, 9 + Math.ceil(this.radius / 15));

                        const v = 15;
                        Matter.Body.setVelocity(mob[mob.length - 1], {
                            x: this.velocity.x + this.fireDir.x * v + 3 * Math.random(),
                            y: this.velocity.y + this.fireDir.y * v + 3 * Math.random()
                        });
                        this.noseLength = 0;
                        // recoil
                        this.force.x -= 0.005 * this.fireDir.x * this.mass;
                        this.force.y -= 0.005 * this.fireDir.y * this.mass;
                    }
                    if (this.noseLength < 1.5) this.noseLength += this.fireFreq;
                    setNoseShape();
                } else if (this.noseLength > 0.1) {
                    this.noseLength -= this.fireFreq / 2;
                    setNoseShape();
                }
            },
            turnToFacePlayer() {
                //turn to face player
                const dx = player.position.x - this.position.x;
                const dy = -player.position.y + this.position.y;
                const dist = this.distanceToPlayer();
                const angle = this.angle + Math.PI / 2;
                c = Math.cos(angle) * dx - Math.sin(angle) * dy;
                if (c > 0.04 * dist) {
                    this.torque += 0.002 * this.mass;
                } else if (c < 0.04) {
                    this.torque -= 0.002 * this.mass;
                }
            },
            facePlayer() {
                const unitVector = Vector.normalise(Vector.sub(this.seePlayer.position, this.position));
                const angle = Math.atan2(unitVector.y, unitVector.x);
                Matter.Body.setAngle(this, angle - Math.PI);
            },
            explode(mass = this.mass) {
                if (m.immuneCycle < m.cycle) {
                    m.takeDamage(Math.min(Math.max(0.03 * Math.sqrt(mass), 0.01), 0.4) * this.damageScale());
                    this.isDropPowerUp = false;
                    this.death(); //death with no power up or body
                }
            },
            timeLimit() {
                this.timeLeft--;
                if (this.timeLeft < 0) {
                    this.isDropPowerUp = false;
                    this.death(); //death with no power up
                }
            },
            //draw health by mob //most health bars are drawn in mobs.healthBar(); , not this
            healthBar() {
                if (this.seePlayer.recall && !level.isHideHealth) {
                    const h = this.radius * 0.3;
                    const w = this.radius * 2;
                    const x = this.position.x - w / 2;
                    const y = this.position.y - w * 0.7;
                    ctx.fillStyle = "rgba(100, 100, 100, 0.3)";
                    ctx.fillRect(x, y, w, h);
                    ctx.fillStyle = "rgba(255,0,0,0.7)";
                    ctx.fillRect(x, y, w * this.health, h);
                }
            },
            damageScale() {
                return ((spawn.mobDmgDoneByTier[this.tier] && level.levelsCleared < 14) ? spawn.mobDmgDoneByTier[this.tier] : spawn.dmgToPlayerByLevelsCleared())
            },
            damage(dmg, isBypassShield = false) { //damage taken by this mob 
                if ((!this.isShielded || isBypassShield) && this.alive) {
                    if (dmg !== Infinity) {
                        dmg *= tech.damageAdjustments()
                        if (this.isDropPowerUp) {
                            if (this.health === 1) {
                                if (tech.isMobFullHealthCloak) {
                                    dmg *= 2.11
                                    simulation.ephemera.push({
                                        name: "damage outline",
                                        count: 7, //cycles before it self removes
                                        vertices: this.vertices,
                                        do() {
                                            this.count--
                                            if (this.count < 0) simulation.removeEphemera(this.name)
                                            //draw body
                                            ctx.beginPath();
                                            const vertices = this.vertices;
                                            ctx.moveTo(vertices[0].x, vertices[0].y);
                                            for (let j = 1, len = vertices.length; j < len; ++j) {
                                                ctx.lineTo(vertices[j].x, vertices[j].y);
                                            }
                                            ctx.lineTo(vertices[0].x, vertices[0].y);
                                            ctx.fillStyle = `rgba(255,0,100,0.15)` //"rgba(150,150,225,0.5)";
                                            ctx.fill()
                                            ctx.lineWidth = 3 //60 * (0.25 - this.damageReductionGoal)
                                            ctx.strokeStyle = `#f08` //"rgba(150,150,225,0.5)";
                                            ctx.stroke();
                                        },
                                    })
                                }
                            } else if (tech.isMobLowHealth && this.health < 0.25) {
                                dmg *= 3
                                simulation.ephemera.push({
                                    name: "damage outline",
                                    count: 2, //cycles before it self removes
                                    vertices: this.vertices,
                                    do() {
                                        this.count--
                                        if (this.count < 0) simulation.removeEphemera(this.name)
                                        //draw body
                                        ctx.beginPath();
                                        const vertices = this.vertices;
                                        ctx.moveTo(vertices[0].x, vertices[0].y);
                                        for (let j = 1, len = vertices.length; j < len; ++j) {
                                            ctx.lineTo(vertices[j].x, vertices[j].y);
                                        }
                                        ctx.lineTo(vertices[0].x, vertices[0].y);
                                        ctx.fillStyle = `rgba(255,50,100,0.2)` //"rgba(150,150,225,0.5)";
                                        ctx.fill()
                                        ctx.lineWidth = 3 //60 * (0.25 - this.damageReductionGoal)
                                        ctx.strokeStyle = `#f38` //"rgba(150,150,225,0.5)";
                                        ctx.stroke();
                                    },
                                })
                            }
                        }

                        //mobs specific damage changes
                        if (this.tier && level.levelsCleared < 14) {
                            dmg *= spawn.mobDmgTakenByTier[this.tier] //scale by tier
                        } else {
                            dmg *= spawn.mobDmgTakenByLevelsCleared() //scale by level.levelsCleared if no tier
                        }
                        dmg *= this.damageReduction //damage reduction specific to this mob (not based on tier)

                        if (tech.isFarAwayDmg) dmg *= 1 + Math.sqrt(Math.max(500, Math.min(3000, this.distanceToPlayer())) - 500) * 0.0067 //up to 33% dmg at max range of 3000
                        //energy and heal drain should be calculated after damage boosts and before mass reduction
                        if (tech.energySiphon && this.isDropPowerUp && m.immuneCycle < m.cycle) {
                            //dmg !== Infinity &&
                            const regen = Math.min(this.health, dmg) * tech.energySiphon * level.isReducedRegen
                            if (!isNaN(regen) && regen !== Infinity) m.energy += regen
                        }
                        dmg /= Math.sqrt(this.mass)
                    }

                    this.health -= dmg
                    //this.fill = this.color + this.health + ')';
                    this.onDamage(dmg); //custom damage effects
                    if ((this.health < 0.01 || isNaN(this.health)) && this.alive) this.death();
                }
            },
            onDamage() {
                // a placeholder for custom effects on mob damage
                //to use declare custom method in mob spawn
            },
            onDeath() {
                // a placeholder for custom effects on mob death
                // to use declare custom method in mob spawn
            },
            damageReduction: 1,
            // damageReductionGoal: 0.001, //must add this to boss set up:   me.damageReduction = 0.25
            // damageReductionScale: 0.004, //for bosses in this.onDamage  determines the impact of dmg on damageReductionGoal
            // armor() { //slowly reduce damage reduction, for bosses
            //     if (this.seePlayer.recall) {
            //         if (this.damageReductionGoal > 0.24) {
            //             this.damageReductionGoal = 0.25
            //         } else {
            //             this.damageReductionGoal = this.damageReductionGoal * 0.999 + 0.001 * 0.25 //smooth the goal towards 0.25 damage reduction
            //         }
            //         this.damageReduction = this.damageReduction * 0.995 + 0.005 * this.damageReductionGoal //smooth damage reduction towards the goal
            //         // console.log(`damageReduction = ${this.damageReduction.toFixed(4)}`, `damageReductionGoal = ${this.damageReductionGoal.toFixed(4)}`)
            //     }
            //     //draw armor
            //     //draw body
            //     ctx.beginPath();
            //     const vertices = this.vertices;
            //     ctx.moveTo(vertices[0].x, vertices[0].y);
            //     for (let j = 1, len = vertices.length; j < len; ++j) {
            //         ctx.lineTo(vertices[j].x, vertices[j].y);
            //     }
            //     ctx.lineTo(vertices[0].x, vertices[0].y);
            //     console.log(this.damageReduction, this.damageReductionGoal)
            //     ctx.lineWidth = 3 //60 * (0.25 - this.damageReductionGoal)
            //     ctx.strokeStyle = `rgba(255,255,255,${4.1*(0.25 - this.damageReductionGoal)})` //"rgba(150,150,225,0.5)";
            //     ctx.stroke();
            // },
            leaveBody: true,
            maxMobBody: 40,
            isDropPowerUp: true,
            death() {
                if (tech.collidePowerUps && this.isDropPowerUp) powerUps.randomize(this.position) //needs to run before onDeath spawns power ups
                this.onDeath(this); //custom death effects
                this.removeConsBB();
                this.alive = false; //triggers mob removal in mob[i].replace(i)
                // console.log(this.shieldCount)

                if (this.isDropPowerUp) {
                    if (level.isMobDeathHeal) {
                        for (let i = 0; i < mob.length; i++) {
                            if (Vector.magnitudeSquared(Vector.sub(this.position, mob[i].position)) < 500000 && mob[i].alive) { //700
                                if (mob[i].health < 1) {
                                    mob[i].health += 0.33
                                    if (mob[i].health > 1) mob[i].health = 1
                                    simulation.drawList.push({
                                        x: mob[i].position.x,
                                        y: mob[i].position.y,
                                        radius: mob[i].radius + 20,
                                        color: "rgba(0,255,100,0.5)",
                                        time: 10
                                    });
                                }
                            }
                        }
                    }
                    if (this.isSoonZombie) { //spawn zombie on death
                        this.leaveBody = false;
                        let count = 5 //delay spawn cycles
                        let cycle = () => {
                            if (count > 0) {
                                if (m.alive) requestAnimationFrame(cycle);
                                if (!simulation.paused && !simulation.isChoosing) {
                                    count--
                                }
                            } else {
                                spawn.zombie(this.position.x, this.position.y, this.radius, this.vertices.length, this.fill) // zombie(x, y, radius, sides, color)
                            }
                        }
                        requestAnimationFrame(cycle);
                    }
                    if (tech.iceIXOnDeath && this.isSlowed) {
                        for (let i = 0, len = 2 * Math.sqrt(Math.min(this.mass, 25)) * tech.iceIXOnDeath; i < len; i++) b.iceIX(3, Math.random() * 2 * Math.PI, this.position)
                    }
                    if (tech.deathSpawnsFromBoss || tech.deathSpawns) {
                        const spawns = tech.deathSpawns + tech.deathSpawnsFromBoss
                        const len = Math.min(12, spawns * Math.ceil(Math.random() * simulation.difficulty * spawns))
                        for (let i = 0; i < len; i++) {
                            spawn.spawns(this.position.x + (Math.random() - 0.5) * radius * 2.5, this.position.y + (Math.random() - 0.5) * radius * 2.5, 2);
                            Matter.Body.setVelocity(mob[mob.length - 1], {
                                x: this.velocity.x + (Math.random() - 0.5) * 10,
                                y: this.velocity.x + (Math.random() - 0.5) * 10
                            });
                        }
                    }
                    if (level.isMobRespawn && !this.isBoss && 0.33 > Math.random()) {
                        simulation.drawList.push({
                            x: this.position.x,
                            y: this.position.y,
                            radius: 30,
                            color: `#fff`,
                            time: 20
                        });
                        simulation.drawList.push({
                            x: this.position.x,
                            y: this.position.y,
                            radius: 20,
                            color: `#fff`,
                            time: 40
                        });
                        simulation.drawList.push({
                            x: this.position.x,
                            y: this.position.y,
                            radius: 10,
                            color: `#fff`,
                            time: 60
                        });
                        setTimeout(() => {
                            const pick = spawn.pickList[Math.floor(Math.random() * spawn.pickList.length)];
                            const size = 16 + Math.ceil(Math.random() * 15)
                            spawn[pick](this.position.x, this.position.y, size);
                        }, 1000);
                    }
                    if (tech.healSpawn && Math.random() < tech.healSpawn) {
                        powerUps.spawn(this.position.x + 20 * (Math.random() - 0.5), this.position.y + 20 * (Math.random() - 0.5), "heal");
                        simulation.drawList.push({
                            x: this.position.x,
                            y: this.position.y,
                            radius: 50,
                            color: "#0eb",
                            time: 12
                        });
                        simulation.drawList.push({
                            x: this.position.x,
                            y: this.position.y,
                            radius: 100,
                            color: "#0eb",
                            time: 6
                        });
                        simulation.drawList.push({
                            x: this.position.x,
                            y: this.position.y,
                            radius: 200,
                            color: "#0eb",
                            time: 3
                        });
                    }

                    if (tech.isVerlet && !m.isTimeDilated) {
                        requestAnimationFrame(() => {
                            simulation.timePlayerSkip(this.isBoss ? 60 : 30)
                            simulation.loop(); //ending with a wipe and normal loop fixes some very minor graphical issues where things are draw in the wrong locations
                        }); //wrapping in animation frame prevents errors, probably
                    }
                    if (tech.isEnergyLoss) {
                        m.energy -= 0.05;
                        if (m.energy < 0) m.energy = 0
                    }



                    if (tech.isRemineralize) {
                        //reduce mineral percent based on time since last check
                        const seconds = (simulation.cycle - tech.mineralLastCheck) / 60
                        tech.mineralLastCheck = simulation.cycle
                        tech.mineralDamageReduction = 1 - (1 - tech.mineralDamageReduction) * Math.pow(0.9, seconds);
                        tech.mineralDamage = 1 + (tech.mineralDamage - 1) * Math.pow(0.9, seconds);
                        //apply mineral damage reduction
                        tech.mineralDamageReduction *= 0.85
                    }
                    if (tech.isDemineralize) {
                        //reduce mineral percent based on time since last check
                        const seconds = (simulation.cycle - tech.mineralLastCheck) / 60
                        tech.mineralLastCheck = simulation.cycle
                        tech.mineralDamageReduction = 1 - (1 - tech.mineralDamageReduction) * Math.pow(0.9, seconds);
                        tech.mineralDamage = 1 + (tech.mineralDamage - 1) * Math.pow(0.9, seconds);
                        //apply mineral damage
                        tech.mineralDamage *= 1.08
                    }



                    powerUps.spawnRandomPowerUp(this.position.x, this.position.y);
                    m.lastKillCycle = m.cycle; //tracks the last time a kill was made, mostly used in simulation.checks()
                    mobs.mobDeaths++

                    if (Math.random() < tech.sporesOnDeath) {
                        const amount = Math.min(25, Math.floor(2 + this.mass * (0.5 + 0.5 * Math.random())))
                        if (tech.isSporeFlea) {
                            const len = amount / 2
                            for (let i = 0; i < len; i++) {
                                const speed = 10 + 5 * Math.random()
                                const angle = 2 * Math.PI * Math.random()
                                b.flea(this.position, { x: speed * Math.cos(angle), y: speed * Math.sin(angle) })
                            }
                        } else if (tech.isSporeWorm) {
                            const len = amount / 2
                            for (let i = 0; i < len; i++) b.worm(this.position)
                        } else {
                            for (let i = 0; i < amount; i++) b.spore(this.position)
                        }
                    }
                    if (tech.isExplodeMob) {
                        b.explosion(this.position, Math.min(700, Math.sqrt(this.mass + 6) * (30 + 60 * Math.random())))
                    }
                    if (tech.nailsDeathMob) {
                        b.targetedNail(this.position, tech.nailsDeathMob, 39 + 6 * Math.random())
                    }
                    if (tech.isBotSpawnerReset) {
                        for (let i = 0, len = bullet.length; i < len; i++) {
                            if (bullet[i].botType && bullet[i].endCycle !== Infinity) bullet[i].endCycle = simulation.cycle + 900 //15 seconds
                        }
                    }
                    if (Math.random() < tech.botSpawner) {
                        b.randomBot(this.position, false)
                        bullet[bullet.length - 1].endCycle = simulation.cycle + 900 //15 seconds
                        this.leaveBody = false; // no body since it turned into the bot
                    }
                    if (tech.isMobDeathImmunity) {
                        const immuneTime = 300
                        if (m.immuneCycle < m.cycle + immuneTime) m.immuneCycle = m.cycle + immuneTime; //player is immune to damage
                    }
                    if (tech.isAddRemoveMaxHealth) {
                        if (!this.isBoss) {
                            const amount = 0.0025
                            if (tech.isEnergyHealth) {
                                if (m.maxEnergy > amount) {
                                    tech.healMaxEnergyBonus -= amount
                                    m.setMaxEnergy();
                                }
                            } else if (m.maxHealth > amount) {
                                tech.extraMaxHealth -= amount //decrease max health
                                m.setMaxHealth();
                            }
                        }
                    }
                    if (tech.cloakDuplication && !this.isBoss) {
                        tech.cloakDuplication -= 0.01
                        powerUps.setPowerUpMode(); //needed after adjusting duplication chance
                    }
                } else if (tech.isShieldAmmo && this.shield && this.shieldCount === 1) {
                    let type = "ammo"
                    if (Math.random() < 0.4) {
                        type = "heal"
                    } else if (Math.random() < 0.3 && !tech.isSuperDeterminism) {
                        type = "research"
                    }
                    for (let i = 0, len = Math.ceil(2 * Math.random()); i < len; i++) {
                        powerUps.spawn(this.position.x, this.position.y, type);
                    }
                }
                if (tech.isRadioactive) {
                    //look for dots and spread them
                    let dmgTotal = 0
                    for (let i = 0, len = this.status.length; i < len; i++) {
                        if (this.status[i].type === "dot") dmgTotal += this.status[i].dmg * (this.status[i].endCycle - simulation.cycle)
                    }
                    if (dmgTotal > 0) { //look for closest mob
                        let closestRadius = 500;
                        let closestIndex = null;
                        for (let i = 0, len = mob.length; i < len; ++i) {
                            const radius = Vector.magnitude(Vector.sub(this.position, mob[i].position))
                            if (mob[i].alive && !mob[i].isShielded && radius < closestRadius) {
                                closestRadius = radius
                                closestIndex = i
                            }
                        }
                        if (closestIndex) {
                            mobs.statusDoT(mob[closestIndex], dmgTotal / 180, 180)
                            ctx.beginPath();
                            ctx.moveTo(this.position.x, this.position.y);
                            ctx.lineTo(mob[closestIndex].position.x, mob[closestIndex].position.y);
                            ctx.lineWidth = this.radius;
                            ctx.strokeStyle = "rgba(0,80,80,1)";
                            ctx.stroke();
                        }
                        //draw AOE
                        // simulation.drawList.push({ //add dmg to draw queue
                        //     x: this.position.x,
                        //     y: this.position.y,
                        //     radius: radius,
                        //     color: "rgba(0,80,80,0.03)",
                        //     time: 15
                        // });
                    }
                }
            },
            removeConsBB() {
                for (let i = 0, len = consBB.length; i < len; ++i) {
                    if (consBB[i].bodyA === this) {
                        if (consBB[i].bodyB.shield) { //&& !this.shield
                            consBB[i].bodyB.do = function () { this.death() }
                        }
                        consBB[i].bodyA = consBB[i].bodyB;
                        consBB.splice(i, 1);
                        this.removeConsBB();
                        break;
                    } else if (consBB[i].bodyB === this) {
                        if (consBB[i].bodyA.shield) {
                            consBB[i].bodyA.do = function () { this.death() }
                        }
                        consBB[i].bodyB = consBB[i].bodyA;
                        consBB.splice(i, 1);
                        this.removeConsBB();
                        break;
                    }
                }
            },
            removeCons() {
                for (let i = 0, len = cons.length; i < len; ++i) {
                    if (cons[i].bodyA === this) {
                        cons[i].bodyA = cons[i].bodyB;
                        cons.splice(i, 1);
                        this.removeCons();
                        break;
                    } else if (cons[i].bodyB === this) {
                        cons[i].bodyB = cons[i].bodyA;
                        cons.splice(i, 1);
                        this.removeCons();
                        break;
                    }
                }
            },
            //replace dead mob with a regular body
            replace(i) {
                //if there are too many bodies don't turn into blocks to help performance
                // if (this.leaveBody && body.length < mobs.maxMobBody && this.mass < 200 && this.radius > 18) {
                if (this.leaveBody && body.length < mobs.maxMobBody && this.mass < 200 && this.mass > 1 && this.radius > 18) {

                    let v = Matter.Vertices.hull(Matter.Vertices.clockwiseSort(this.vertices)) //might help with vertex collision issue, not sure
                    if (v.length > 5 && body.length < 35 && Math.random() < 0.25) {
                        const cutPoint = 3 + Math.floor((v.length - 6) * Math.random()) //Math.floor(v.length / 2)
                        const v2 = v.slice(0, cutPoint + 1)
                        v = v.slice(cutPoint - 1)
                        const len = body.length;
                        body[len] = Matter.Bodies.fromVertices(this.position.x, this.position.y, v2);
                        Matter.Body.setVelocity(body[len], Vector.mult(this.velocity, 0.5));
                        Matter.Body.setAngularVelocity(body[len], this.angularVelocity);
                        body[len].collisionFilter.category = cat.body;
                        body[len].collisionFilter.mask = cat.player | cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet;
                        body[len].classType = "body";
                        body[len].frictionAir = 0.001
                        body[len].friction = 0.05
                        Composite.add(engine.world, body[len]); //add to world

                        const len2 = body.length;
                        body[len2] = Matter.Bodies.fromVertices(this.position.x, this.position.y, v);
                        Matter.Body.setVelocity(body[len2], Vector.mult(this.velocity, 0.5));
                        Matter.Body.setAngularVelocity(body[len2], this.angularVelocity);
                        body[len2].collisionFilter.category = cat.body;
                        body[len2].collisionFilter.mask = cat.player | cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet;
                        body[len2].classType = "body";
                        body[len2].frictionAir = 0.001
                        body[len2].friction = 0.05
                        Composite.add(engine.world, body[len2]); //add to world

                        //large mobs shrink so they don't block paths
                        if (body[len].mass + body[len2].mass > 16) {
                            const massLimit = 8 + 6 * Math.random()
                            const shrink = function (that1, that2) {
                                if (that1.mass + that2.mass > massLimit) {
                                    const scale = 0.95;
                                    Matter.Body.scale(that1, scale, scale);
                                    Matter.Body.scale(that2, scale, scale);
                                    setTimeout(shrink, 20, that1, that2);
                                }
                            };
                            shrink(body[len], body[len2])
                        }
                    } else {
                        const len = body.length;
                        body[len] = Matter.Bodies.fromVertices(this.position.x, this.position.y, v);
                        Matter.Body.setVelocity(body[len], Vector.mult(this.velocity, 0.5));
                        Matter.Body.setAngularVelocity(body[len], this.angularVelocity);
                        body[len].collisionFilter.category = cat.body;
                        body[len].collisionFilter.mask = cat.player | cat.map | cat.body | cat.bullet | cat.mob | cat.mobBullet;
                        body[len].classType = "body";
                        body[len].frictionAir = 0.001
                        body[len].friction = 0.05
                        Composite.add(engine.world, body[len]); //add to world
                        //large mobs shrink so they don't block paths
                        if (body[len].mass > 9) {
                            const massLimit = 7 + 4 * Math.random()
                            const shrink = function (that) {
                                if (that.mass > massLimit) {
                                    const scale = 0.95;
                                    Matter.Body.scale(that, scale, scale);
                                    setTimeout(shrink, 20, that);
                                }
                            };
                            shrink(body[len])
                        }
                    }
                    Matter.Composite.remove(engine.world, this);
                    mob.splice(i, 1);
                    if (tech.isMobBlockFling) {
                        const who = body[body.length - 1]
                        if (!who.isNotHoldable) {
                            b.targetedBlock(who)
                            Matter.Body.setAngularVelocity(who, (0.5 + 0.2 * Math.random()) * (Math.random() < 0.5 ? -1 : 1));
                            // who.torque += who.inertia * 0.002 * (Math.random() - 0.5)
                        }
                    }
                } else {
                    Matter.Composite.remove(engine.world, this);
                    mob.splice(i, 1);
                }
            }
        });
        mob[i].alertRange2 = Math.pow(mob[i].radius * 3 + 550, 2);
        Composite.add(engine.world, mob[i]); //add to world
    }
};
    </script>
    <script src="js/spawn.js"></script>
    <script src="js/level.js"></script>
    <script src="js/lore.js"></script>
    <script src="js/engine.js"></script>
    <script src="js/index.js"></script>
    <!-- <script>javascript: (async () => { const scriptText = await (await fetch('https://raw.githubusercontent.com/kgurchiek/n-gon-controller/main/main.js')).text(); var script = document.createElement('script'); script.type = 'text/javascript'; script.textContent = scriptText; document.head.appendChild(script); })();</script> -->
</body>

</html>
